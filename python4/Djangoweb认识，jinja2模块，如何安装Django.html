<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修Djangoweb认识，jinja2模块，如何安装Django' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>Djangoweb认识，jinja2模块，如何安装Django</center></div><div class='banquan'>原文出处:本文由博客园博主是阿凯啊提供。<br/>
原文连接:https://www.cnblogs.com/xujunkai/p/11229514.html</div><br>
    <h2 id="一内容概要">一内容概要</h2>
<h3 id="http协议">1.HTTP协议</h3>
<h4 id="简介">1.1简介</h4>
<p>​ 超文本传输协议（英文：Hyper Text Transfer Protocol，HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP是万维网的数据通信的基础。HTTP有很多应用，但最著名的是用于web浏览器和web服务器之间的双工通信。</p>
<p>​ HTTP的发展是由蒂姆·伯纳斯-李于1989年在欧洲核子研究组织（CERN）所发起。HTTP的标准制定由万维网协会（World Wide Web Consortium，W3C）和互联网工程任务组（Internet Engineering Task Force，IETF）进行协调，最终发布了一系列的RFC，其中最著名的是1999年6月公布的 RFC 2616，定义了HTTP协议中现今广泛使用的一个版本——HTTP 1.1。</p>
<ul>
<li>想详细了解HTTP协议推荐书籍：</li>
</ul>
<p><img src="./images/Djangoweb认识，jinja2模块，如何安装Django0.png" /></p>
<h4 id="http协议概述">1.2HTTP协议概述</h4>
<p>​ 通常，由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，比如&quot;HTTP/1.1 200 OK&quot;，以及返回的内容，如请求的文件、错误消息、或者其它信息。</p>
<h4 id="http工作原理">1.3 HTTP工作原理</h4>
<p>​ HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。</p>
<h4 id="http请求方法">1.4 HTTP请求方法</h4>
<ul>
<li><p>GET</p>
<p>向指定资源发出“显示”请求，使用GET方法应该只用在读取数据。（通俗讲获取一个页面，资源）</p></li>
<li><p>POST</p>
<p>向指定资源提交数据，请求服务器进行处理(例如提交表单或者上传文件)（通俗讲向页面提交数据）</p></li>
<li><p>HEAD</p>
<p>与GET方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文部分。它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该资源的信息”（元信息或称元数据）。</p></li>
<li><p>PUT</p>
<p>向指定资源位置上传其最新内容。</p></li>
<li><p>DELETE</p>
<p>请求服务器删除Request-URI所标识的资源。</p></li>
<li><p>TRACE</p>
<p>回显服务器收到的请求，主要用于测试或诊断。</p></li>
<li><p>OPTIONS</p>
<p>这个方法可使服务器传回该资源所支持的所有HTTP请求方法。用'*'来代替资源名称，向Web服务器发送OPTIONS请求，可以测试服务器功能是否正常运作。</p></li>
<li><p>CONNECT</p>
<p>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接（经由非加密的HTTP代理服务器）。</p></li>
</ul>
<h4 id="http状态码">1.5 HTTP状态码</h4>
<p>​ 所有HTTP响应的第一行都是状态行，依次是当前HTTP版本号，3位数字组成的状态代码，以及描述状态的短语，彼此由空格分隔。</p>
<ul>
<li>状态码分类</li>
</ul>
<table>
<thead>
<tr class="header">
<th>分类</th>
<th>分类描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1**</td>
<td>信息，服务器收到请求，需要请求者继续执行操作</td>
</tr>
<tr class="even">
<td>2**</td>
<td>成功，操作被成功接收并处理</td>
</tr>
<tr class="odd">
<td>3**</td>
<td>重定向，需要进一步的操作以完成请求</td>
</tr>
<tr class="even">
<td>4**</td>
<td>客户端错误，请求包含语法错误或无法完成请求</td>
</tr>
<tr class="odd">
<td>5**</td>
<td>服务器错误，服务器在处理请求的过程中发生了错误</td>
</tr>
</tbody>
</table>
<ul>
<li>状态码列表</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">状态码</th>
<th style="text-align: left;">状态码英文名称</th>
<th style="text-align: left;">中文描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">100</td>
<td style="text-align: left;">Continue</td>
<td style="text-align: left;">继续。<a href="http://www.dreamdu.com/webbuild/client_vs_server/">客户端</a>应继续其请求</td>
</tr>
<tr class="even">
<td style="text-align: left;">101</td>
<td style="text-align: left;">Switching Protocols</td>
<td style="text-align: left;">切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">200</td>
<td style="text-align: left;">OK</td>
<td style="text-align: left;">请求成功。一般用于GET与POST请求</td>
</tr>
<tr class="odd">
<td style="text-align: left;">201</td>
<td style="text-align: left;">Created</td>
<td style="text-align: left;">已创建。成功请求并创建了新的资源</td>
</tr>
<tr class="even">
<td style="text-align: left;">202</td>
<td style="text-align: left;">Accepted</td>
<td style="text-align: left;">已接受。已经接受请求，但未处理完成</td>
</tr>
<tr class="odd">
<td style="text-align: left;">203</td>
<td style="text-align: left;">Non-Authoritative Information</td>
<td style="text-align: left;">非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td>
</tr>
<tr class="even">
<td style="text-align: left;">204</td>
<td style="text-align: left;">No Content</td>
<td style="text-align: left;">无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td>
</tr>
<tr class="odd">
<td style="text-align: left;">205</td>
<td style="text-align: left;">Reset Content</td>
<td style="text-align: left;">重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td>
</tr>
<tr class="even">
<td style="text-align: left;">206</td>
<td style="text-align: left;">Partial Content</td>
<td style="text-align: left;">部分内容。服务器成功处理了部分GET请求</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">300</td>
<td style="text-align: left;">Multiple Choices</td>
<td style="text-align: left;">多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td>
</tr>
<tr class="odd">
<td style="text-align: left;">301</td>
<td style="text-align: left;">Moved Permanently</td>
<td style="text-align: left;">永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td>
</tr>
<tr class="even">
<td style="text-align: left;">302</td>
<td style="text-align: left;">Found</td>
<td style="text-align: left;">临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td>
</tr>
<tr class="odd">
<td style="text-align: left;">303</td>
<td style="text-align: left;">See Other</td>
<td style="text-align: left;">查看其它地址。与301类似。使用GET和POST请求查看</td>
</tr>
<tr class="even">
<td style="text-align: left;">304</td>
<td style="text-align: left;">Not Modified</td>
<td style="text-align: left;">未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td>
</tr>
<tr class="odd">
<td style="text-align: left;">305</td>
<td style="text-align: left;">Use Proxy</td>
<td style="text-align: left;">使用代理。所请求的资源必须通过代理访问</td>
</tr>
<tr class="even">
<td style="text-align: left;">306</td>
<td style="text-align: left;">Unused</td>
<td style="text-align: left;">已经被废弃的HTTP状态码</td>
</tr>
<tr class="odd">
<td style="text-align: left;">307</td>
<td style="text-align: left;">Temporary Redirect</td>
<td style="text-align: left;">临时重定向。与302类似。使用GET请求重定向</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">400</td>
<td style="text-align: left;">Bad Request</td>
<td style="text-align: left;">客户端请求的语法错误，服务器无法理解</td>
</tr>
<tr class="even">
<td style="text-align: left;">401</td>
<td style="text-align: left;">Unauthorized</td>
<td style="text-align: left;">请求要求用户的身份认证</td>
</tr>
<tr class="odd">
<td style="text-align: left;">402</td>
<td style="text-align: left;">Payment Required</td>
<td style="text-align: left;">保留，将来使用</td>
</tr>
<tr class="even">
<td style="text-align: left;">403</td>
<td style="text-align: left;">Forbidden</td>
<td style="text-align: left;">服务器理解请求客户端的请求，但是拒绝执行此请求</td>
</tr>
<tr class="odd">
<td style="text-align: left;">404</td>
<td style="text-align: left;">Not Found</td>
<td style="text-align: left;">服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置&quot;您所请求的资源无法找到&quot;的个性页面</td>
</tr>
<tr class="even">
<td style="text-align: left;">405</td>
<td style="text-align: left;">Method Not Allowed</td>
<td style="text-align: left;">客户端请求中的方法被禁止</td>
</tr>
<tr class="odd">
<td style="text-align: left;">406</td>
<td style="text-align: left;">Not Acceptable</td>
<td style="text-align: left;">服务器无法根据客户端请求的内容特性完成请求</td>
</tr>
<tr class="even">
<td style="text-align: left;">407</td>
<td style="text-align: left;">Proxy Authentication Required</td>
<td style="text-align: left;">请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td>
</tr>
<tr class="odd">
<td style="text-align: left;">408</td>
<td style="text-align: left;">Request Time-out</td>
<td style="text-align: left;">服务器等待客户端发送的请求时间过长，超时</td>
</tr>
<tr class="even">
<td style="text-align: left;">409</td>
<td style="text-align: left;">Conflict</td>
<td style="text-align: left;">服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突</td>
</tr>
<tr class="odd">
<td style="text-align: left;">410</td>
<td style="text-align: left;">Gone</td>
<td style="text-align: left;">客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td>
</tr>
<tr class="even">
<td style="text-align: left;">411</td>
<td style="text-align: left;">Length Required</td>
<td style="text-align: left;">服务器无法处理客户端发送的不带Content-Length的请求信息</td>
</tr>
<tr class="odd">
<td style="text-align: left;">412</td>
<td style="text-align: left;">Precondition Failed</td>
<td style="text-align: left;">客户端请求信息的先决条件错误</td>
</tr>
<tr class="even">
<td style="text-align: left;">413</td>
<td style="text-align: left;">Request Entity Too Large</td>
<td style="text-align: left;">由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td>
</tr>
<tr class="odd">
<td style="text-align: left;">414</td>
<td style="text-align: left;">Request-URI Too Large</td>
<td style="text-align: left;">请求的URI过长（URI通常为网址），服务器无法处理</td>
</tr>
<tr class="even">
<td style="text-align: left;">415</td>
<td style="text-align: left;">Unsupported Media Type</td>
<td style="text-align: left;">服务器无法处理请求附带的媒体格式</td>
</tr>
<tr class="odd">
<td style="text-align: left;">416</td>
<td style="text-align: left;">Requested range not satisfiable</td>
<td style="text-align: left;">客户端请求的范围无效</td>
</tr>
<tr class="even">
<td style="text-align: left;">417</td>
<td style="text-align: left;">Expectation Failed</td>
<td style="text-align: left;">服务器无法满足Expect的请求头信息</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">500</td>
<td style="text-align: left;">Internal Server Error</td>
<td style="text-align: left;">服务器内部错误，无法完成请求</td>
</tr>
<tr class="odd">
<td style="text-align: left;">501</td>
<td style="text-align: left;">Not Implemented</td>
<td style="text-align: left;">服务器不支持请求的功能，无法完成请求</td>
</tr>
<tr class="even">
<td style="text-align: left;">502</td>
<td style="text-align: left;">Bad Gateway</td>
<td style="text-align: left;">作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td>
</tr>
<tr class="odd">
<td style="text-align: left;">503</td>
<td style="text-align: left;">Service Unavailable</td>
<td style="text-align: left;">由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td>
</tr>
<tr class="even">
<td style="text-align: left;">504</td>
<td style="text-align: left;">Gateway Time-out</td>
<td style="text-align: left;">充当网关或代理的服务器，未及时从远端服务器获取请求</td>
</tr>
<tr class="odd">
<td style="text-align: left;">505</td>
<td style="text-align: left;">HTTP Version not supported</td>
<td style="text-align: left;">服务器不支持请求的HTTP协议的版本，无法完成处理</td>
</tr>
</tbody>
</table>
<h4 id="url">1.6 URL</h4>
<p>​ 超文本传输协议（HTTP）的统一资源定位符，从因特网获取信息的五个基本元素包括在一个简单的地址中。</p>
<p><img src="./images/Djangoweb认识，jinja2模块，如何安装Django1.png" /></p>
<ol>
<li>传送协议</li>
<li>层级URL标记符号【//】</li>
<li>服务器（通常域名，有时为IP地址）</li>
<li>端口号（以数字方式表示，HTTPS 是443 HTTP 是80。可省略）</li>
<li>路径（以“/”字符区别路径中的每一个目录名称）</li>
<li>查询（GET模式下窗口参数，以&quot;?&quot;字符为起点，每个参数哦以&quot;&amp;&quot;隔开）</li>
<li>片段，以“#”字符为起点</li>
</ol>
<h4 id="http请求格式浏览器-发出请求-----服务器">1.7HTTP请求格式(浏览器 发出请求-----&gt;服务器)</h4>
<ul>
<li>请求格式：</li>
</ul>
<p><img src="./images/Djangoweb认识，jinja2模块，如何安装Django2.png" /></p>
<ul>
<li>示例：</li>
</ul>
<p><img src="./images/Djangoweb认识，jinja2模块，如何安装Django3.png" /></p>
<pre><code><code>#请求方式
请求行：请求“get”方法 url路经 协议版本
请求头：&quot;key1&quot;:&quot;value1&quot;\r\n(类似键值对)
       &quot;key2&quot;:&quot;value2&quot;\r\n
        ...
响应体：          数据</code></pre>
<h4 id="http响应格式服务器响应response-----浏览器">1.8 HTTP响应格式(服务器响应(response)-----&gt;浏览器)</h4>
<ul>
<li>响应格式：</li>
</ul>
<p><img src="./images/Djangoweb认识，jinja2模块，如何安装Django4.png" /></p>
<ul>
<li>示例：</li>
</ul>
<p><img src="./images/Djangoweb认识，jinja2模块，如何安装Django5.png" /></p>
<pre><code><code>#响应方式
响应行：协议版本 状态码 状态描述\r\n
响应头：&quot;key1&quot;:&quot;value1&quot;\r\n(类似键值对)
       &quot;key2&quot;:&quot;value2&quot;\r\n
        ...
响应体：          数据</code></pre>
<h3 id="web框架">2. web框架</h3>
<h4 id="一个简单的web框架">2.1.一个简单的web框架</h4>
<pre class="python"><code>import socket
# 创建一个socket套接字
sk = socket.socket()
# 绑定IP和端口
sk.bind((&quot;127.0.0.1&quot;,8888))
# 设为监听对象
sk.listen(5)
while True:
    conn,_ = sk.accept()
    #接收数据
    data = conn.recv(1024)
    print(data)
    # 返回数据
    conn.send(b&quot;HTTP/1.1 200 OK\r\n\r\n&lt;h1&gt;hello world&lt;/h1&gt;&quot;)
    #断开连接
    conn.close()
# 浏览器访问127.0.0.1:8888 会打印hello world</code></pre>
<h4 id="函数实现一个简单web框架">2.2 函数实现一个简单web框架</h4>
<pre class="python"><code>import socket

# 创建一个socket对象
sk = socket.socket()
# 绑定IP和端口
sk.bind((&#39;127.0.0.1&#39;, 8000))
# 监听
sk.listen(5)

# 等待连接

def index(url):
    ret = &quot;&lt;h1&gt;index!&lt;/h1&gt;({})&quot;.format(url)
    return ret.encode(&quot;utf-8&quot;)
def home(url):
    ret = &#39;&lt;h1&gt;home!&lt;/h1&gt;({})&#39;.format(url)
    return ret.encode(&#39;utf-8&#39;)

list1 = [(&quot;/index&quot;,index),(&quot;/home&quot;,home)]
while True:
    conn,addr = sk.accept()
    data = conn.recv(1024)
    data = data.decode(&quot;utf-8&quot;)
    url = data.split(&#39; &#39;)[1]
    conn.send(b&#39;HTTP/1.1 200 OK\r\n\r\n&#39;)
    func = None
    for i in list1:
        if url == i[0]:
            func = i[1]
            break
    if func:
        ret = func(url)
    else:
        ret = b&quot;&lt;h1&gt;404 not found!&lt;/h1&gt;&quot;

    conn.send(ret)
    #断开连接
    conn.close()</code></pre>
<ul>
<li>通过网页访问 <a href="http://127.0.0.1:8000/home" class="uri">http://127.0.0.1:8000/home</a>，可得到如下效果：</li>
</ul>
<p><img src="./images/Djangoweb认识，jinja2模块，如何安装Django6.png" /></p>
<h4 id="通过返回html页面">2.3 通过返回HTML页面</h4>
<pre class="python"><code>import socket

# 创建一个socket对象
sk = socket.socket()
# 绑定IP和端口
sk.bind((&#39;127.0.0.1&#39;, 8080))
# 监听
sk.listen(5)
# 等待连接
def index(url):
    with open(r&#39;G:\homework\day52Djongo\index.html&#39;,&#39;rb&#39;) as f:
        ret = f.read()
    return ret

def home(url):#打开.html文件,读取出来返回读取内容
    with open(r&#39;G:\homework\day52Djongo\home.html&#39;,&#39;rb&#39;) as f:
        ret = f.read()
    return ret
list1 = [
    (&quot;/index&quot;,index),
    (&quot;/home&quot;,home)
]




while True:
    conn,addr = sk.accept()
    data = conn.recv(1024)
    data = data.decode(&#39;utf-8&#39;)
    url = data.split(&#39; &#39;)[1]
    conn.send(b&#39;HTTP/1.1 200 OK\r\n\r\n&#39;)
    print(url)
    func = None
    for i in list1:
        if url == i[0]:
            func = i[1]
            print(func)
            break
    if func:
        res = func(url)
    else:
        res = b&quot;&lt;h1&gt;404 not found!&lt;/h1&gt;&quot;

    conn.send(res)
    conn.close()
</code></pre>
<h4 id="一个简单的返回动态网页">2.4 一个简单的返回动态网页</h4>
<pre class="python"><code>#!/usr/bin/env python
# -*- coding:utf-8 -*-
&quot;&quot;&quot;
Xu Junkai
&quot;&quot;&quot;
import socket
import time
# 创建一个socket对象
sk = socket.socket()
# 绑定IP和端口
sk.bind((&#39;127.0.0.1&#39;, 8080))
# 监听
sk.listen(5)
# 等待连接
def index(url):
    with open(r&#39;G:\homework\day52Djongo\index.html&#39;,&#39;rb&#39;) as f:
        ret = f.read()
    return ret

def home(url):
    with open(r&#39;G:\homework\day52Djongo\home.html&#39;,&#39;rb&#39;) as f:
        ret = f.read()
    return ret
def timer(url):#返回当前时间
    with open(r&#39;G:\homework\day52Djongo\timer.html&#39;,&#39;r&#39;,encoding=&#39;utf-8&#39;) as f:
        ret = f.read()
        now = time.strftime(&#39;%H:%M:%S&#39;)
        data = ret.replace(&quot;xxtimexx&quot;,now)
    return data.encode(&#39;utf-8&#39;)
list1 = [
    (&quot;/index&quot;,index),
    (&quot;/home&quot;,home),
    (&quot;/timer&quot;,timer)
]




while True:
    conn,addr = sk.accept()
    data = conn.recv(1024)
    data = data.decode(&#39;utf-8&#39;)
    url = data.split(&#39; &#39;)[1]
    conn.send(b&#39;HTTP/1.1 200 OK\r\n\r\n&#39;)
    print(url)
    func = None
    for i in list1:
        if url == i[0]:
            func = i[1]
            print(func)
            break
    if func:
        res = func(url)
    else:
        res = b&quot;&lt;h1&gt;404 not found!&lt;/h1&gt;&quot;

    conn.send(res)
    conn.close()
</code></pre>
<h4 id="wsgiref模块应用">2.5 wsgiref模块应用</h4>
<p>​ WSGI就是一种规范，它定义了使用Python编写的web应用程序与web服务器程序之间的接口格式，实现web应用程序与web服务器程序间解耦。</p>
<p>​ 常用的WSGI服务器有uwsgi、Gunicorn。而Python标准库提供的独立WSGI服务器叫wsgiref，Django开发环境用的就是这个模块来做服务器。wsgiref(测试用) uwsgi(线上用)。</p>
<pre class="python"><code>import time
from wsgiref.simple_server import make_server


def index(url):
    with open(r&#39;G:\homework\day52Djongo\index.html&#39;, &#39;rb&#39;) as f:
        ret = f.read()
    return ret


def home(url):
    with open(r&#39;G:\homework\day52Djongo\home.html&#39;, &#39;rb&#39;) as f:
        ret = f.read()
    return ret


def timer(url):
    with open(r&#39;G:\homework\day52Djongo\timer.html&#39;, &#39;r&#39;, encoding=&#39;utf-8&#39;) as f:
        ret = f.read()
        now = time.strftime(&#39;%H:%M:%S&#39;)
        data = ret.replace(&quot;xxtimexx&quot;, now)
    return data.encode(&#39;utf-8&#39;)


list1 = [
    (&quot;/index/&quot;, index),
    (&quot;/home/&quot;, home),
    (&quot;/timer/&quot;, timer)
]


def run_server(environ,start_response):
    start_response(&quot;200 OK&quot;,[(&quot;Content-Type&quot;,&quot;text/html;charset=utf8&quot;),])
    url = environ[&quot;PATH_INFO&quot;]#获取用户输入URL
    print(url)
    func = None
    for i in list1:
        if i[0] == url:
            func = i[1]
            break
    if func:
        response = func(url)
    else:
        response = b&quot;404 not found!&quot;
    return [response,]

if __name__ == &quot;__main__&quot;:
    httpd = make_server(&quot;127.0.0.1&quot;,8080,run_server)
    print(&quot;waitting...&quot;)
    httpd.serve_forever()#执行函数</code></pre>
<h4 id="jinjia2模块">2.6jinjia2模块</h4>
<p>​ 上面的代码实现了一个简单的动态，我完全可以从数据库中查询数据，然后去替换我html中的对应内容，然后再发送给浏览器完成渲染。 这个过程就相当于HTML模板渲染数据。 本质上就是HTML内容中利用一些特殊的符号来替换要展示的数据。 我这里用的特殊符号是我定义的，其实模板渲染有个现成的工具。</p>
<ul>
<li>示例：</li>
</ul>
<pre class="html"><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;zh-CN&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;
  &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;姓名：{{name}}&lt;/h1&gt;
    &lt;h1&gt;爱好：&lt;/h1&gt;
    &lt;ul&gt;
        {% for hobby in hobby_list %}
        &lt;li&gt;{{hobby}}&lt;/li&gt;
        {% endfor %}
    &lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<pre class="python"><code>from wsgiref.simple_server import make_server
from jinja2 import Template


def index(url):
    # 读取HTML文件内容  
    with open(&quot;index2.html&quot;, &quot;r&quot;, encoding=&quot;utf8&quot;) as f:
        data = f.read()
        template = Template(data)  # 生成模板文件
        ret = template.render({&#39;name&#39;: &#39;xjk&#39;, &#39;hobby_list&#39;: [&#39;唱&#39;, &#39;跳&#39;, &#39;rap&#39;]})  # 把数据填充到模板中
    return bytes(ret, encoding=&quot;utf8&quot;)


def home(url):
    with open(&quot;home.html&quot;, &quot;r&quot;, encoding=&quot;utf8&quot;) as f:
        s = f.read()
    return bytes(s, encoding=&quot;utf8&quot;)


# 定义一个url和实际要执行的函数的对应关系  
list1 = [
    (&quot;/index/&quot;, index),
    (&quot;/home/&quot;, home),
]


def run_server(environ, start_response):
    start_response(&#39;200 OK&#39;, [(&#39;Content-Type&#39;, &#39;text/html;charset=utf8&#39;), ])  # 设置HTTP响应的状态码和头信息  
    url = environ[&#39;PATH_INFO&#39;]  # 取到用户输入的url  
    func = None
    for i in list1:
        if i[0] == url:
            func = i[1]
            break
    if func:
        response = func(url)
    else:
        response = b&quot;404 not found!&quot;
    return [response, ]


if __name__ == &#39;__main__&#39;:
    httpd = make_server(&#39;127.0.0.1&#39;, 8090, run_server)
    print(&quot;我在8090等你哦...&quot;)
    httpd.serve_forever()  
</code></pre>
<h4 id="小结">2.7小结：</h4>
<ul>
<li>自己实现一个简单web框架功能具备以下条件：
<ul>
<li>1.socket收发消息 -wsgiref(测试用) uwsgi(线上用)</li>
<li>2.根据不同路径返回不同内容</li>
<li>3.返回动态页面（字符串的替换） 可以用jinja2</li>
</ul></li>
<li>我们熟知的框架django有2和3功能。flask:有2功能，tornado:1,2,3功能都有，并且是异步非阻塞。</li>
</ul>
<h3 id="django">3.django</h3>
<h4 id="django的下载">3.1 django的下载</h4>
<ul>
<li>方法一：利用终端输入:pip install Django ==1.11.21 -i <a href="https://pypi.tuna.tsinghua.edu.cn/simple" class="uri">https://pypi.tuna.tsinghua.edu.cn/simple</a></li>
<li>方法二：pycharm下载 <a href="https://www.djangoproject.com/" class="uri">https://www.djangoproject.com/</a> 下载</li>
</ul>
<p><img src="./images/Djangoweb认识，jinja2模块，如何安装Django7.png" /></p>
<p>推荐使用1.11版本，因为1.11版本是最后支持python2.7</p>
<p>创建项目1：</p>
<p><strong>预先看Django必须在默认环境变量里。</strong></p>
<p>第一步：先创建空文件夹</p>
<p>第二步：右键点击：Git Bash Here</p>
<p><img src="./images/Djangoweb认识，jinja2模块，如何安装Django8.png" /></p>
<p>第三步：输入django-admin</p>
<p><img src="./images/Djangoweb认识，jinja2模块，如何安装Django9.png" /></p>
<p>第四步：django-admin startproject mysite 创建项目</p>
<p><img src="./images/Djangoweb认识，jinja2模块，如何安装Django10.png" /></p>
<p>manage.py:管理文件，执行与项目相关文件，通过manage操作</p>
<p>第五步：在manager.py文件夹路径上 shift+鼠标右键 点击在此处打开powershell</p>
<p>终端输入python manage.py runserver</p>
<p>也可自定义IP端口：</p>
<p>​ 法1：python36 manage.py runserver 80</p>
<p>​ 法2：python36 manage.py runserver 0.0.0.0:80 （在settings文件内设置ALLOWED_HOSTS=[&quot;*&quot;] 别人访问你的IP加端口可以直接访问的网页）</p>
<p>在网页输入127.0.0.1:8000(默认IP端口)</p>
<p><img src="./images/Djangoweb认识，jinja2模块，如何安装Django11.png" /></p>
<p>1.命令行</p>
<p>找一个文件夹存放项目文件：</p>
<p>打开终端（或git）</p>
<p>django-admin startproject 项目名称</p>
<p>表示连接接成功。</p>
<p>2.pycharm创建项目：</p>
<p>第一步：点击New Project</p>
<p><img src="./images/Djangoweb认识，jinja2模块，如何安装Django12.png" /></p>
<p>第二步：</p>
<p><img src="./images/Djangoweb认识，jinja2模块，如何安装Django13.png" /></p>
<p>第三步：</p>
<p><img src="./images/Djangoweb认识，jinja2模块，如何安装Django14.png" /></p>
<p>第四步：设置端口</p>
<p><img src="./images/Djangoweb认识，jinja2模块，如何安装Django15.png" /></p>
<p>（在pycharm中会自动生成.idea文件，如果是别人的项目先删除.idea再打开项目）从pycharm打开项目要从项目根目录打开。</p>
<p>在pycharm创建项目比git或终端创建项目多template文件夹。</p>
<p>第五步：启动项目</p>
<p><img src="./images/Djangoweb认识，jinja2模块，如何安装Django16.png" /></p>
<h4 id="在django创建一个字符串">3.2 在Django创建一个字符串</h4>
<pre class="python"><code>#urls.py
from django.conf.urls import url
from django.contrib import admin
from django.shortcuts import HttpResponse,render
def index(request):
    return HttpResponse(&quot;index&quot;)

urlpatterns = [
    url(r&#39;^admin/&#39;, admin.site.urls),
    url(r&#39;^index/&#39;, index),#第二个index为函数，第一个index为网页显示路径默认127.0.0.1:8000/index/

]
</code></pre>
<h4 id="在django创建一页面">3.3在Django创建一页面</h4>
<pre class="python"><code>from django.conf.urls import url
from django.contrib import admin
from django.shortcuts import HttpResponse,render
def index(request):
    return render(request,&#39;index.html&#39;)#html文件都放在templates

urlpatterns = [
    url(r&#39;^admin/&#39;, admin.site.urls),
    url(r&#39;^index/&#39;, index),

]
</code></pre>
<pre class="python"><code>pycharm已经给设置好了路径
settings.py 
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))#当前项目根目录

TEMPLATES = [
    {
        &#39;BACKEND&#39;: &#39;django.template.backends.django.DjangoTemplates&#39;,
        &#39;DIRS&#39;: [os.path.join(BASE_DIR, &#39;templates&#39;)]
        ,
        &#39;APP_DIRS&#39;: True,
        &#39;OPTIONS&#39;: {
            &#39;context_processors&#39;: [
                &#39;django.template.context_processors.debug&#39;,
                &#39;django.template.context_processors.request&#39;,
                &#39;django.contrib.auth.context_processors.auth&#39;,
                &#39;django.contrib.messages.context_processors.messages&#39;,
            ],
        },
    },
</code></pre>

</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>