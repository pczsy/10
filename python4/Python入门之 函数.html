<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修Python入门之 函数' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>Python入门之 函数</center></div><div class='banquan'>原文出处:本文由博客园博主永亮提供。<br/>
原文连接:https://www.cnblogs.com/caiyongliang/p/11433658.html</div><br>
    <h1 id="python入门之-函数">Python入门之 函数</h1>
<h2 id="初识函数">1、初识函数</h2>
<h3 id="什么是函数">1.1 什么是函数？</h3>
<h4 id="将某个功能封装到一个空间中就是一个函数">&lt;1&gt; 将某个功能封装到一个空间中就是一个函数</h4>
<h4 id="减少重复代码">&lt;2&gt; 减少重复代码</h4>
<h3 id="定义函数">1.2 定义函数</h3>
<h3 id="def----python中的关键字">def -- python中的关键字</h3>
<h3 id="必须要写-格式规定">（）-- 必须要写 格式规定</h3>
<h3 id="语句结束">： -- 语句结束</h3>
<pre><code><code>def len():    
    函数体</code></pre>
<pre><code><code>def my_len():    
    n = 0    
    for i in dic:        
    n += 1    
    print(n)</code></pre>
<h3 id="函数的调用">1.3 函数的调用</h3>
<h4 id="函数名-就是在调用函数">函数名 + （） 就是在调用函数</h4>
<pre><code><code>def yue():    
    print(&quot;掏出手机&quot;)    
    print(&quot;打开微信&quot;)    
    rint(&quot;摇一摇&quot;)    
    print(&quot;聊一聊&quot;)    
    print(&quot;约吗?&quot;)    
    print(&quot;....&quot;)
yue()
yue()</code></pre>
<p>面向过程：</p>
<pre><code><code>print(&quot;掏出手机&quot;)
print(&quot;打开微信&quot;)
print(&quot;摇一摇&quot;)
print(&quot;聊一聊&quot;)
print(&quot;约吗?&quot;)
print(&quot;....&quot;)
print(&quot;上班&quot;)
print(&quot;掏出手机&quot;)
print(&quot;打开微信&quot;)
print(&quot;摇一摇&quot;)
print(&quot;聊一聊&quot;)
print(&quot;约吗?&quot;)
print(&quot;....&quot;)
print(&quot;检查一下&quot;)</code></pre>
<p>面向函数编程：</p>
<pre><code><code>def work():    
    print(&quot;打开电脑&quot;)    
    print(&quot;查看邮件&quot;)    
    print(&quot;打开找到微信&quot;)    
    print(&quot;进行群聊&quot;)    
    print(&quot;开始撸代码&quot;)    
    print(&quot;撸完&quot;)    
    print(&quot;下班&quot;)
def yue():    
    print(&quot;掏出手机&quot;)    
    print(&quot;打开微信&quot;)    
    print(&quot;摇一摇&quot;)    
    print(&quot;聊一聊&quot;)    
    print(&quot;约吗?&quot;)    
    print(&quot;....&quot;)
yue()
work()
yue()
print(&quot;检查一下&quot;)
yue()
print(&quot;6块钱的麻辣烫&quot;)
yue()
print(&quot;歇会,上个班&quot;)</code></pre>
<h3 id="函数的返回值">1.4 函数的返回值</h3>
<pre><code><code>def yue():   
    print(&quot;打开手机&quot;)    
    print(&quot;打开微信&quot;)   
    print(&quot;打开附近的人&quot;)    
    print(&quot;聊一聊&quot;)    
    print(&quot;见一见&quot;)    
    print(&quot;......&quot;)    
    return 1,2,3,4,5    
    print(1111)
girl = yue()
print(girl)</code></pre>
<h4 id="函数的返回值返回给函数的调用者">（1）函数的返回值，返回给函数的调用者</h4>
<h4 id="return-值-返回值">return 值 （返回值）</h4>
<h4 id="return">（2）return：</h4>
<h5 id="可以返回任意类型数据">&lt;1&gt; 可以返回任意类型数据</h5>
<h5 id="return返回多个内容时是元组的形式">&lt;2&gt; return返回多个内容时是元组的形式</h5>
<h5 id="return下方不执行并且会终止当前这个函数">&lt;3&gt; return下方不执行，并且会终止当前这个函数</h5>
<h5 id="return不写或者写了return后面不写值都返回none">&lt;4&gt; return不写或者写了return后面不写值都返回None</h5>
<p>函数名+（）</p>
<p>启动函数</p>
<p>接受返回值</p>
<h3 id="函数的参数">1.5 函数的参数</h3>
<pre><code><code>def yue(app1,app2,app3,app4):      # 形参       
    print(&quot;打开手机&quot;)    
    print(f&quot;打开{app1} {app2}&quot;)    
    print(&quot;聊一聊&quot;)    
    print(&quot;见一见&quot;)    
    print(&quot;......&quot;)
yue(&quot;微信&quot;,&quot;探探&quot;,&quot;陌陌&quot;,&quot;soul&quot;)        # 实参</code></pre>
<pre><code><code>def yue(a,b,c,app1=&quot;微信&quot;):     # 形参      
    print(&quot;打开手机&quot;)    
    print(f&quot;打开{a} {app1}&quot;)    
    print(&quot;聊一聊&quot;)    
    print(&quot;见一见&quot;)    
    print(&quot;......&quot;)
yue(&quot;探探&quot;,&quot;陌陌&quot;,&quot;微信&quot;)      # 实参</code></pre>
<pre><code><code>def yue(a,b,c,a1=&quot;微信&quot;):     # 形参       
    print(&quot;打开手机&quot;)    
    print(f&quot;打开{a} {b} {c} {a1}&quot;)    
    print(&quot;聊一聊&quot;)    
    print(&quot;见一见&quot;)    
    print(&quot;......&quot;)
yue(11,c=5,b=1)       # 实参

</code></pre>
<p>三元运算符*（三目运算符）：（只支持if else）</p>
<p>条件成立的结果 条件 条件不成立的结果</p>
<pre><code><code>def func(a,b):    
    return a if a &gt; b else b
print(func(6,9))

</code></pre>
<pre><code><code>def info(name,age,job,moeny,sex=&quot;男&quot;):    
    print(f&quot;姓名:{name} 年龄:{age} 性别:{sex} 岗位:{job} 薪资:{moeny}&quot;)
while True:    
    name = input(&quot;name:&quot;)     # rimo    
    age = input(&quot;age:&quot;)       # 89    
    sex = input(&quot;sex(男性回车):&quot;) # 女    
    job = input(&quot;job:&quot;)          #  wc    
    money = input(&quot;moeny:&quot;)      # 10    
    if sex == &quot;女&quot;:        
        info(name,age,job,money,sex)    
    else:        
        info(name, age, job, money)

</code></pre>
<h4 id="形参">（1）形参:</h4>
<h5 id="位置参数">&lt;1&gt; 位置参数:</h5>
<p>​ 一一对应</p>
<h5 id="默认参数-函数定义的时括号中写好的就是默认参数">&lt;2&gt; 默认参数: 函数定义的时括号中写好的就是默认参数</h5>
<p>​ 不进行传参使用默认参数,进行传参时使用传递的参数</p>
<h4 id="实参">（2）实参:</h4>
<h5 id="位置参数-1">&lt;1&gt;位置参数:</h5>
<p>​ 一一对应</p>
<h5 id="关键字参数">&lt;2&gt; 关键字参数:</h5>
<p>​ 按照名字进行传参</p>
<h5 id="混合参数">（3）混合参数:</h5>
<p>​ 位置参数和关键字参数一起使用</p>
<p>​ 位置参数 &gt; 默认参数(关键字参数)</p>
<h4 id="形参-函数定义阶段括号中的参数叫做形参">形参: 函数定义阶段括号中的参数叫做形参</h4>
<h4 id="实参-函数调用阶段括号中的参数叫做实参">实参: 函数调用阶段括号中的参数叫做实参</h4>
<h4 id="传参-将实参传递给形参的过程叫传参">传参: 将实参传递给形参的过程叫传参</h4>
<h2 id="section"></h2>
<h2 id="函数进阶">2、函数进阶：</h2>
<pre><code><code>def eat(a,b,c,d,e,f):    
    print(a,b,c,d,e,f)
eat(&quot;麻辣烫&quot;,&quot;大烧饼&quot;,&quot;大煎饼&quot;,&quot;大腰子&quot;,&quot;韭菜&quot;,&quot;羊蝎子&quot;)
</code></pre>
<p>如何解决参数数量太多？</p>
<h3 id="动态位置参数">2.1 动态位置参数：</h3>
<pre><code><code>def eat(*args):    # 函数的定义阶段 *聚合(打包)    
    print(args)    # tuple    
    print(*args)   # 函数体中的 *    打散(解包)
eat(&quot;麻辣烫&quot;,&quot;大烧饼&quot;,&quot;大煎饼&quot;,&quot;大腰子&quot;,&quot;韭菜&quot;,&quot;羊蝎子&quot;)
</code></pre>
<pre><code><code>def eat(a,b,*c):       #位置参数 &gt; 动态位置参数
    print(a)    
    print(b)    
    print(c)     # tuple
eat(&quot;面条&quot;,&quot;米饭&quot;,&quot;馒头&quot;,&quot;大饼&quot;)
</code></pre>
<pre><code><code>def eat(a,b,*args,d=2,**c):  # 位置参数 &gt; 动态位置参数 &gt; 默认参数 &gt; 动态默认参数
    print(a)
    print(b)
    print(d)
    print(args)     # tuple
    print(c)        # dict
eat(&quot;面条&quot;,&quot;米饭&quot;,&quot;大烧饼&quot;,&quot;大煎饼&quot;,a1=1,b1=2)        # 位置 &gt; 关键字
</code></pre>
<pre><code><code>def eat(*args,**kwargs):  # (万能传参)
    print(args) # tulpe
    print(kwargs) #
lst = [1,23,4,6,7]
dic = {&quot;key1&quot;:1,&quot;key2&quot;:3}
应用场景
eat(lst,dic)

eat(*lst,**dic) # eat(1,23,4,6,7,&quot;key1&quot;=1,&quot;key2&quot;=2)
</code></pre>
<p>总结：</p>
<h3 id="args-聚合位置参数-大家伙都用的名字可以进行修改但是不建议修改">&lt;1&gt; *args (聚合位置参数) 大家伙都用的名字，可以进行修改但是不建议修改</h3>
<h3 id="kwargs-聚合关键字参数-大家伙都用的名字可以进行修改但是不建议修改">&lt;2&gt; **kwargs (聚合关键字参数) 大家伙都用的名字，可以进行修改但是不建议修改</h3>
<p>函数的定义阶段 * 和 ** 都是聚合</p>
<p>函数体中 * 就是打散，* args将元组中的元素进行打散，* kwargs将字典的键获取</p>
<h3 id="形参-1">2.2 形参：</h3>
<h4 id="位置参数-2">&lt;1&gt; 位置参数</h4>
<p>动态位置参数：先执行位置参数，位置参数接受后额外的参数由动态位置参数进行接受 ，获取的是一个元组</p>
<h4 id="默认参数">&lt;2&gt; 默认参数</h4>
<p>动态关键字参数（默认）：先执行默认参数，默认参数接受后额外的由默认参数进行接受，获取的是一个字典</p>
<p>实参和函数体：</p>
<ul>
<li>*打撒</li>
<li>**实参时能够使用</li>
</ul>
<h3 id="函数的注释">2.3 函数的注释：</h3>
<pre><code><code>def a(a:int,b:int):
    &quot;&quot;&quot;
    求和
    :param a: int
    :param b: int
    :return:  int
    &quot;&quot;&quot;
    return a + b

def b(a:int,b:int):
    &quot;&quot;&quot;
    求差
    :param a: int
    :param b: int
    :return:  int
    &quot;&quot;&quot;
    return a - b
</code></pre>
<h4 id="函数名._-doc-_-查看函数的注释">（1）函数名._ doc _ #查看函数的注释</h4>
<h4 id="函数名._-name-_-查看函数的名字">（2）函数名._ name _ #查看函数的名字</h4>
<h3 id="名称空间">2.4 名称空间</h3>
<h4 id="内置空间python解释器自带的空间">（1）内置空间：Python解释器自带的空间</h4>
<h4 id="全局空间py文件中顶格写的就是全局空间">（2）全局空间：py文件中顶格写的就是全局空间</h4>
<h4 id="局部空间函数体中就是局部空间">（3）局部空间：函数体中就是局部空间</h4>
<h5 id="加载顺序">&lt;1&gt; 加载顺序：</h5>
<p>​ 内置空间</p>
<p>​ 全局空间</p>
<p>​ 局部空间</p>
<pre><code><code>def func():
    a = 1
    print(a)
func()
</code></pre>
<h5 id="取值顺序">&lt;2&gt; 取值顺序：</h5>
<p>​ 局部空间</p>
<p>​ 全局空间</p>
<p>​ 内置空间</p>
<pre><code><code>a = 10
def func():
    print(a)
func()
</code></pre>
<h4 id="作用域">（4）作用域:</h4>
<p>全局作用域：全局 + 内置</p>
<p>局部作用域： 局部</p>
<p>作用域的作用就是保护数据的安全性</p>
<h3 id="函数的嵌套">2.5 函数的嵌套：</h3>
<h4 id="不管在什么位置只要是函数名-就是在调用一个函数">不管在什么位置，只要是函数名() 就是在调用一个函数</h4>
<p>混合嵌套：</p>
<pre><code><code>def f1():
    print(11)
def f2():
    print(22)
    f1()
def f3():
    print(33)
    f1()
def run():
    f3()
    f2()
    f1()
run()

</code></pre>
<pre><code><code>def foo(a):
    a = 10
    def f1(b):
        c = b
        def foo(c):
            print(c)
            print(foo.__doc__)
        foo(c)
        print(b)
    f1(a)
    print(a)
foo(25)

</code></pre>
<h3 id="global-只修改全局没有时就创建一个">2.6 global :只修改全局，没有时就创建一个</h3>
<pre><code><code>a = 10
def func():
    global a
    a = a - 6
    print(a)
print(a)
func()
print(a)

</code></pre>
<h3 id="nonlocal-只修改局部修改离nonlocal最近的一层上一层没有继续向上上层查找只限在局部没有就报错">2.7 nonlocal :只修改局部，修改离nonlocal最近的一层，上一层没有继续向上上层查找，只限在局部，没有就报错</h3>
<pre><code><code>a = 100
def func():
    b = 10
    def foo():
        b = a
        def f1():
            nonlocal b
            b = b + 5
            print(b)  # 105
        f1()
        print(b)  # 105
    foo()
    print(b) # 10
func()
print(a)         # 100
</code></pre>
<p>​ enumerate() #枚举 默认从0开始数 第一个参数是可迭代对象 第二个对象是起始值</p>
<h2 id="函数的第一类对象及使用">3 、 函数的第一类对象及使用</h2>
<h3 id="函数名可以当做值赋值给变量">（1）函数名可以当做值，赋值给变量 ：</h3>
<pre><code><code>def func():
    print(1)
print(func)          # 函数的内存地址
a = func
print(a)
a()</code></pre>
<h3 id="函数名可以当做容器中的元素">（2）函数名可以当做容器中的元素：</h3>
<pre><code><code>def login():
    print(&quot;这是登录&quot;)
def register():
    print(&quot;这是注册&quot;)
def index():
    print(&quot;这是博客园的主页&quot;)
msg = &quot;&quot;&quot;
1 登录
2 注册
3 主页
&quot;&quot;&quot;
choose = input(msg)   # 1
if choose.isdecimal():
    if choose == &quot;1&quot;:
        login()
    elif choose == &quot;2&quot;:
        register()
    elif choose == &quot;3&quot;:
        index()
</code></pre>
<p>​ 改良：</p>
<pre><code><code>def login():
    print(&quot;这是登录&quot;)
def register():
    print(&quot;这是注册&quot;)
def index():
    print(&quot;这是博客园的主页&quot;)
dic = {&quot;1&quot;:login,&quot;2&quot;:register,&quot;3&quot;:index}
msg = &quot;&quot;&quot;
1 登录
2 注册
3 主页
&quot;&quot;&quot;
choose = input(msg)   # 1
if choose.isdecimal():
    if dic.get(choose):
        dic[choose]()
    else:
        print(&quot;请正确输入!&quot;)
</code></pre>
<h3 id="函数名可以当做函数的参数">（3）函数名可以当做函数的参数：</h3>
<pre><code><code>def func(a):
    print(111)
    a()
def foo():
    print(222)
func(foo)
</code></pre>
<h3 id="函数名可以当做函数的返回值">（4）函数名可以当做函数的返回值：</h3>
<pre><code><code>def func():
    def foo():
        print(111)
    return foo
a = func()
a()
func()()  # foo()
</code></pre>
<p>练习：</p>
<pre><code><code>def f1(c):
    def a():
        def f3():
            print(3333)
            return [f3,a,f1]
        print(11)
        return f3()
    ret = a()
    return c(ret)

def aa(b):
    print(111)
    return b
print(f1(aa))
</code></pre>
<h2 id="匿名函数-一句话函数一行函数">4、匿名函数 == 一句话函数（一行函数）</h2>
<p>匿名函数是有名字的 叫做 lambda</p>
<h3 id="lambda-xx">（1）lambda x:x</h3>
<h4 id="lambda-关键字">&lt;1&gt; lambda 关键字</h4>
<h4 id="x-是普通函数的形参位置关键字可以不接收参数可以不写">&lt;2&gt; x 是普通函数的形参（位置，关键字·····）可以不接收参数，可以不写</h4>
<h4 id="x-冒号后边的x是普通函数的函数值-只能返回一个数据类型必须要有返回值">&lt;3&gt; :x 冒号后边的x是普通函数的函数值 （只能返回一个数据类型），必须要有返回值</h4>
<pre><code><code>print((lambda x:x+6)(5))

f = lambda x:x+6
print(f.__name__)

f = lambda x,y,z,b=1:x,y,z,b
print(f(1,2,3))

print([lambda :5][0]())
print((lambda :5)())
a = lambda :5
a()

lst = [lambda :i for i in range(5)]
print(lst[0]())
</code></pre>
<pre><code><code>lst = [lambda :i for i in range(5)]
print(lst[0]())

面试题拆解:
lst = []
for i in range(5):
    def func():
        return i
    lst.append(func)
</code></pre>
<pre><code><code>lst = [] # [lambda x:x+1,lambda x:x+1]
for i in range(2):
    lst.append(lambda x:x+1)
print(lst[-1](5))

lst = [lambda x:x+1 for i in range(5)]
print(lst[0](5))

tu = (lambda :i for i in range(3))
print(next(tu)())
print(next(tu)())
print(next(tu)())

def func():
    for i in range(3):  # i = 0 1 2
        def foo():      # foo1  foo2  foo3
            return i
        yield foo       # foo1  foo2  foo3
g = func()
print(next(g)())  # foo1
print(next(g))  # foo2
print(next(g))  # foo3

lst = [lambda :i for i in range(3)]
print(lst[0]())

tu = (lambda :i for i in range(3))
print(next(tu)())
</code></pre>
<pre><code><code>lst = [lambda x:x+5 for i in range(2)]
print([i(2) for i in lst])

lst = [] # [lambda x:x+5,lambda x:x+5]
for i in range(2):
    lst.append(lambda x:x+5)
new_lst = []
for i in lst:
    new_lst.append(i(2))
print(new_lst)
</code></pre>
<pre><code><code>lst = (lambda x:x+5 for i in range(2))
print([i(2) for i in lst])

def func():
    for i in range(2):
        f = lambda x: x + 5
        yield f
g = func()
lst = []
for i in g:
    lst.append(i(2))
print(lst)
</code></pre>
<pre><code><code>lst = [lambda x:x*i for i in range(2)]
print([i(2) for i in lst])  #[2,2]

lst = [] # [lambda x:x*i,lambda x:x*i]
for i in range(2):
    lst.append(lambda x:x*i)
# print(i)
new_lst = []
for em in lst:
    new_lst.append(em(2))
print(new_lst)
</code></pre>
<pre><code><code>lst = (lambda x:x*i for i in range(2))
print([i(2) for i in lst])  #[0,2]

def func():
    for i in range(2):
        f = lambda x:x*i
        yield f
g = func()
lst = []
for i in g:
    lst.append(i(2))
print(lst)</code></pre>

</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>