<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修python网络进程' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>python网络进程</center></div><div class='banquan'>原文出处:本文由博客园博主凌逆战提供。<br/>
原文连接:https://www.cnblogs.com/LXP-Never/p/9448064.html</div><br>
    <h1><span style="font-family: 宋体;">多任务编程</span></h1>
<p><span style="font-family: 宋体;"><strong>意义</strong>：充分利用计算机的资源提高程序的运行效率</span></p>
<p><span style="font-family: 宋体;"><strong>定义</strong>：通过应用程序利用计算机多个核心，达到同时执行多个任务的目的</span></p>
<p><span style="font-family: 宋体;"><strong>实施方案</strong>： <span style="color: #ff0000;">多进程</span>、<span style="color: #ff0000;">多线程</span><br /></span></p>
<p><span style="font-family: 宋体;"><strong>并行</strong>：多个计算机核心<span style="text-decoration: underline;">并行的</span><span style="text-decoration: underline;">同时处理</span>多个任务</span></p>
<p><span style="font-family: 宋体;"><strong>并发</strong>：内核在<span style="text-decoration: underline;">多个任务间</span>不断<span style="text-decoration: underline;">切换</span>，达到好像内核在同时处理多个任务的运行效果</span></p>
<p><span style="font-family: 宋体;"><strong>进程</strong>：程序在计算机中运行一次的过程</span></p>
<p><span style="font-family: 宋体;"><strong>程序</strong>：是一个可执行文件，是静态的，占有磁盘，不占有计算机运行资源</span></p>
<p><span style="font-family: 宋体;"><strong>进程</strong>：进程是一个动态的过程描述，占有CPU内存等计算机资源的，有一定的生命周期</span></p>
<p><span style="font-family: 宋体; color: #888888;">* 同一个程序的不同执行过程是不同的进程，因为分配的计算机资源等均不同</span></p>
<p><span style="font-family: 宋体;">父子进程 : 系统中每一个进程(除了系统初始化进程)都有唯一的父进程,可以有0个或多个子进</span><br /><span style="font-family: 宋体;">程。父子进程关系便于进程管理。</span></p>
<h1><span style="font-family: 宋体;">进程</span></h1>
<p><span style="font-family: 宋体;"><strong>CPU时间片：</strong>如果一个进程在某个时间点被计算机分配了内核，我们称为该进程在CPU时间片上。</span></p>
<p><span style="font-family: 宋体;"><strong>PCB(</strong>进程控制块)：存放进程消息的空间</span></p>
<p><span style="font-family: 宋体;">进程ID(PID)：进程在操作系统中的唯一编号，由系统自动分配</span></p>
<p><span style="font-family: 宋体;">进程信息包括：进程PID，进程占有的内存位置，创建时间，创建用户. . . . . . . .&nbsp;&nbsp;</span></p>
<p><strong><span style="font-family: 宋体;">进程特征：</span></strong></p>
<ol>
<li><span style="font-family: 宋体;">进程是操作系统分配计算机资源的最小单位</span></li>
<li><span style="font-family: 宋体;">每一个进程都有自己单独的<strong>虚拟</strong>内存空间</span></li>
<li><span style="font-family: 宋体;">进程间的执行相互独立，互不影响</span></li>








</ol>
<p><strong><span style="font-family: 宋体;">进程的状态</span></strong></p>
<p><span style="font-family: 宋体;">1、<strong>三态</strong></span></p>
<ul>
<li><span style="font-family: 宋体;"><strong>就绪态：</strong>进程具备执行条件，<span style="text-decoration: underline;">等待系统分配CPU</span></span></li>
<li><span style="font-family: 宋体;"><strong>运行态：</strong>进程<span style="text-decoration: underline;">占有CPU处理器</span>，处于运行状态</span></li>
<li><span style="font-family: 宋体;"><strong>等待态：</strong>进程<span style="text-decoration: underline;">暂时不具备运行条件</span>，需要<span style="text-decoration: underline;">阻塞</span>等待，让出CPU</span></li>


























































</ul>
<p><span style="font-family: 宋体;"><img src="./images/python网络进程0.png" alt="" width="417" height="213" /></span></p>
<p><span style="font-family: 宋体;">2、<strong>五态（增加新建态和终止态）</strong></span></p>
<ul>
<li><span style="font-family: 宋体;"><strong>新建态：</strong>创建一个<span style="text-decoration: underline;">新的进程</span>，获取资源的过程</span></li>
<li><span style="font-family: 宋体;"><strong>终止态：</strong>进程结束<span style="text-decoration: underline;">释放资源的过程</span></span></li>


























































</ul>
<p><span style="font-family: 宋体;"><span style="text-decoration: underline;"><img src="./images/python网络进程1.png" alt="" width="412" height="194" /></span></span></p>
<p><span style="font-family: 宋体;">查看进程树：　　　<span style="color: #888888;">pstree</span></span></p>
<p><span style="font-family: 宋体;">查看父进程PID：　&nbsp;<span style="color: #888888;">ps -ajx</span></span></p>
<p><span style="font-family: 宋体;">linux查看进程命令：　　<span style="color: #808080;">ps -aux</span></span></p>
<p>有一列为STAT为进程的状态</p>
<p><span style="font-family: 宋体;"> 　　D 等待态 （不可中断等待）（<strong>阻塞</strong>）</span><br /><span style="font-family: 宋体;">	 　　S  等待态   （可中断等待）（<strong>睡眠</strong>）</span><br /><span style="font-family: 宋体;">	 　　T  等待态   （<strong>暂停</strong>状态）</span><br /><span style="font-family: 宋体;">	 　　R  运行态   （就绪态运行态）</span><br /><span style="font-family: 宋体;">	 　　Z  僵尸态</span></p>
<p><span style="font-family: 宋体;">	 　　+  前台进程（能在终端显示出现象的）</span><br /><span style="font-family: 宋体;">	 　　&lt;  高优先级</span><br /><span style="font-family: 宋体;">	 　　N  低优先级</span><br /><span style="font-family: 宋体;">	 　　l  有多线程的</span><br /><span style="font-family: 宋体;">	 　　s  会话组组长</span></p>
<p>&nbsp;</p>
<h1>os.fork创建进程</h1>
<p><span style="font-size: 15px;"><strong><span style="font-family: 宋体;">pid = os.fork()　</span></strong></span></p>
<p><span style="font-family: 宋体;">功能：创建一个子进程</span></p>
<p><span style="font-family: 宋体;">返回值：创建成功在原有的进程中返回子进程的PID，在子进程中返回0；创建失败返回一个负数</span></p>
<p><span style="font-family: 宋体;">父子进程通常会根据fork返回值的差异选择执行不同的代码（使用if结构）</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">import</span><span style="color: #000000;">  os 
</span><span style="color: #0000ff;">from</span> time <span style="color: #0000ff;">import</span><span style="color: #000000;"> sleep

pid </span>=<span style="color: #000000;"> os.fork()

</span><span style="color: #0000ff;">if</span> pid &lt;<span style="color: #000000;"> 0:
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">"</span><span style="color: #800000;">创建进程失败</span><span style="color: #800000;">"</span><span style="color: #000000;">)

</span><span style="color: #008000;">#</span><span style="color: #008000;">子进程执行部分</span>
<span style="color: #0000ff;">elif</span> pid ==<span style="color: #000000;"> 0:
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">"</span><span style="color: #800000;">新进程创建成功</span><span style="color: #800000;">"</span><span style="color: #000000;">)

</span><span style="color: #008000;">#</span><span style="color: #008000;">父进程执行部分</span>
<span style="color: #0000ff;">else</span><span style="color: #000000;">:
    sleep(</span>1<span style="color: #000000;">)
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">"</span><span style="color: #800000;">原来的进程</span><span style="color: #800000;">"</span><span style="color: #000000;">)

</span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">"</span><span style="color: #800000;">程序执行完毕</span><span style="color: #800000;">"</span><span style="color: #000000;">)

</span><span style="color: #008000;">#</span><span style="color: #008000;"> 新进程创建成功</span><span style="color: #008000;">
#</span><span style="color: #008000;"> 原来的进程</span><span style="color: #008000;">
#</span><span style="color: #008000;"> 程序执行完毕</span></pre>
</div>
<ul>
<li><span style="font-family: 宋体;"><span style="text-decoration: underline;">子进程会复制父进程全部代码段</span><span style="color: #888888;">(包括fork前的代码)</span>但是子进程仅从fork的下一句开始执行</span></li>
<li><span style="font-family: 宋体;">父进程不一定先执行<span style="color: #888888;">(进程之间相互独立，互不影响)</span></span></li>
<li><span style="font-family: 宋体;">父子进程各有自己的属性特征，比如：PID号PCB内存空间</span></li>
<li><span style="font-family: 宋体;">父进程fork之前开辟的空间子进程同样拥有，但是进程之间相互独立，互不影响．</span></li>
</ul>
<p><span style="font-family: 宋体;">父子进程的变量域</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">import</span><span style="color: #000000;"> os 
</span><span style="color: #0000ff;">from</span> time <span style="color: #0000ff;">import</span><span style="color: #000000;"> sleep 

a </span>= 1<span style="color: #000000;">
pid </span>=<span style="color: #000000;"> os.fork()
</span><span style="color: #0000ff;">if</span> pid &lt;<span style="color: #000000;"> 0:
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">"</span><span style="color: #800000;">创建进程失败</span><span style="color: #800000;">"</span><span style="color: #000000;">)
</span><span style="color: #0000ff;">elif</span> pid ==<span style="color: #000000;"> 0:
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">"</span><span style="color: #800000;">子进程</span><span style="color: #800000;">"</span><span style="color: #000000;">)
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">"</span><span style="color: #800000;">a = </span><span style="color: #800000;">"</span><span style="color: #000000;">,a)
    a </span>= 10000
    <span style="color: #0000ff;">print</span>(<span style="color: #800000;">"</span><span style="color: #800000;">a = </span><span style="color: #800000;">"</span><span style="color: #000000;">,a)
</span><span style="color: #0000ff;">else</span><span style="color: #000000;">:
    sleep(</span>1<span style="color: #000000;">)
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">"</span><span style="color: #800000;">父进程</span><span style="color: #800000;">"</span><span style="color: #000000;">)
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">"</span><span style="color: #800000;">parent a :</span><span style="color: #800000;">"</span>,a)    <span style="color: #008000;">#</span><span style="color: #008000;"> a = 1</span>

<span style="color: #008000;">#</span><span style="color: #008000;"> 子进程</span><span style="color: #008000;">
#</span><span style="color: #008000;"> a =  1</span><span style="color: #008000;">
#</span><span style="color: #008000;"> a =  10000</span><span style="color: #008000;">
#</span><span style="color: #008000;"> 父进程</span><span style="color: #008000;">
#</span><span style="color: #008000;"> parent a : 1</span></pre>
</div>
<h2><span style="font-family: 宋体;">进程ID和退出函数</span></h2>
<p><strong><span style="font-family: 宋体;"><span style="font-size: 15px;">os.getpid()</span>&nbsp;</span></strong><span style="font-family: 宋体;"><span>获取当前进程的PID号</span></span></p>
<p><span style="font-family: 宋体;">　　返回值：返回PID号</span></p>
<p><span style="font-size: 15px;"><strong><span style="font-family: 宋体;">os.getppid()&nbsp;</span></strong></span><span style="font-family: 宋体;">获取父类进程的进程号</span></p>
<p><span style="font-family: 宋体;">　　返回值：返回PID号</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">import</span><span style="color: #000000;"> os

pid </span>=<span style="color: #000000;"> os.fork()

</span><span style="color: #0000ff;">if</span> pid &lt;<span style="color: #000000;"> 0:
  </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">"</span><span style="color: #800000;">Error</span><span style="color: #800000;">"</span><span style="color: #000000;">)
</span><span style="color: #0000ff;">elif</span> pid ==<span style="color: #000000;"> 0:
  </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">"</span><span style="color: #800000;">Child PID:</span><span style="color: #800000;">"</span>, os.getpid())       <span style="color: #008000;">#</span><span style="color: #008000;"> 26537</span>
  <span style="color: #0000ff;">print</span>(<span style="color: #800000;">"</span><span style="color: #800000;">Get parent PID:</span><span style="color: #800000;">"</span>, os.getppid()) <span style="color: #008000;">#</span><span style="color: #008000;"> 26536</span>
<span style="color: #0000ff;">else</span><span style="color: #000000;">:
  </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">"</span><span style="color: #800000;">Get child PID:</span><span style="color: #800000;">"</span>, pid)           <span style="color: #008000;">#</span><span style="color: #008000;"> 26537</span>
  <span style="color: #0000ff;">print</span>(<span style="color: #800000;">"</span><span style="color: #800000;">Parent PID:</span><span style="color: #800000;">"</span>, os.getpid())      <span style="color: #008000;">#</span><span style="color: #008000;"> 26536</span></pre>
</div>
<p><strong><span style="font-family: 宋体;"><span style="font-size: 15px;">os._exit(status)</span>&nbsp;&nbsp;</span></strong><span style="font-family: 宋体;">退出进程</span></p>
<p><span style="font-family: 宋体;">　　参数：进程的退出状态　　整数</span></p>
<p><strong><span style="font-family: 宋体;"><span style="font-size: 15px;">sys.exit([status])</span>&nbsp;&nbsp;</span></strong><span style="font-family: 宋体;">退出进程</span></p>
<p><span style="font-family: 宋体;">　　参数：默认为0　　整数则表示退出状态；符串则表示退出时打印内容</span></p>
<p><span style="font-family: 宋体;">　　sys.exit([status])可以通过<strong>捕获</strong>SystemExit<strong>异常</strong>阻止退出</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">import</span><span style="color: #000000;"> os,sys

</span><span style="color: #008000;">#</span><span style="color: #008000;"> os._exit(0)                 # 退出进程</span>
<span style="color: #0000ff;">try</span><span style="color: #000000;">:
    sys.exit(</span><span style="color: #800000;">"</span><span style="color: #800000;">退出</span><span style="color: #800000;">"</span><span style="color: #000000;">)
</span><span style="color: #0000ff;">except</span><span style="color: #000000;"> SystemExit as e:
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">"</span><span style="color: #800000;">退出原因：</span><span style="color: #800000;">"</span>,e)    <span style="color: #008000;">#</span><span style="color: #008000;"> 退出原因： 退出</span></pre>
</div>
<h1><span style="font-family: 宋体;"><strong>孤儿和僵尸</strong></span></h1>
<h2><span style="font-family: 宋体;">孤儿进程</span></h2>
<p><span style="font-family: 宋体;">父进程先于子进程退出，此时子进程就会变成孤儿进程</span></p>
<p><span style="font-family: 宋体;">　　孤儿进程会被系统指定的进程收养，即系统进程会成为该孤儿进程新的父进程。孤儿进程退出时该父进程会处理退出状态</span></p>
<h2><span style="font-family: 宋体;"><strong>僵尸进程</strong></span></h2>
<p><span style="font-family: 宋体;">子进程先与父进程退出，父进程没有处理子进程退出状态，此时子进程成为僵尸进程</span></p>
<p><span style="font-family: 宋体;">　　僵尸进程已经结束，但是会滞留部分PCB信息在内存，大量的僵尸会消耗系统资源，应该尽量避免</span></p>
<h2><span style="font-family: 宋体;">如何避免僵尸进程的产生</span></h2>
<h3><span style="font-family: 宋体;">父进程处理子进程退出状态</span></h3>
<p><span style="font-family: 宋体;"><span style="font-size: 15px;">pid, status = os.wait()</span><br /></span></p>
<p><span style="font-family: 宋体;">功能：在父进程中<span style="text-decoration: underline;">阻塞等待</span>处理子进程的退出</span></p>
<p><span style="font-family: 宋体;">返回值：　pid&nbsp; &nbsp; &nbsp;退出的子进程的PID号</span></p>
<p><span style="font-family: 宋体;">　　　　　status 　　子进程的退出状态</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">import</span><span style="color: #000000;"> os, sys

pid </span>=<span style="color: #000000;"> os.fork()

</span><span style="color: #0000ff;">if</span> pid &lt;<span style="color: #000000;"> 0:
  </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">"</span><span style="color: #800000;">Error</span><span style="color: #800000;">"</span><span style="color: #000000;">)
</span><span style="color: #0000ff;">elif</span> pid ==<span style="color: #000000;"> 0:
  </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">"</span><span style="color: #800000;">Child process</span><span style="color: #800000;">"</span>, os.getpid())   <span style="color: #008000;">#</span><span style="color: #008000;"> Child process 27248</span>
  sys.exit(1<span style="color: #000000;">)
</span><span style="color: #0000ff;">else</span><span style="color: #000000;">:
  pid, status </span>= os.wait()     <span style="color: #008000;">#</span><span style="color: #008000;"> 阻塞等待子进程退出</span>
  <span style="color: #0000ff;">print</span>(<span style="color: #800000;">"</span><span style="color: #800000;">pid : </span><span style="color: #800000;">"</span>, pid)        <span style="color: #008000;">#</span><span style="color: #008000;"> pid :  27248</span>
  <span style="color: #008000;">#</span><span style="color: #008000;"> 还原退出状态</span>
  <span style="color: #0000ff;">print</span>(<span style="color: #800000;">"</span><span style="color: #800000;">status:</span><span style="color: #800000;">"</span>, os.WEXITSTATUS(status))      <span style="color: #008000;">#</span><span style="color: #008000;"> status: 1</span>
  <span style="color: #0000ff;">while</span><span style="color: #000000;"> True:
    </span><span style="color: #0000ff;">pass</span></pre>
</div>
<h3><span style="font-family: 宋体;">创建二级子进程</span></h3>
<ol>
<li><span style="font-family: 宋体;">父进程创建子进程等待子进程退出</span></li>
<li><span style="font-family: 宋体;">子进程创建二级子进程，然后马上退出</span></li>
<li><span style="font-family: 宋体;">二级子进程成为孤儿，处理具体事件</span></li>
</ol>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">import</span><span style="color: #000000;"> os
</span><span style="color: #0000ff;">from</span> time <span style="color: #0000ff;">import</span><span style="color: #000000;"> sleep

</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> fun1():
    sleep(</span>3<span style="color: #000000;">)
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">"</span><span style="color: #800000;">第一件事情</span><span style="color: #800000;">"</span><span style="color: #000000;">)

</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> fun2():
    sleep(</span>4<span style="color: #000000;">)
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">"</span><span style="color: #800000;">第二件事情</span><span style="color: #800000;">"</span><span style="color: #000000;">)

pid </span>=<span style="color: #000000;"> os.fork()

</span><span style="color: #0000ff;">if</span> pid &lt;<span style="color: #000000;"> 0:
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">"</span><span style="color: #800000;">Create process error</span><span style="color: #800000;">"</span><span style="color: #000000;">)
</span><span style="color: #0000ff;">elif</span> pid == 0:          <span style="color: #008000;">#</span><span style="color: #008000;"> 子进程</span>
    pid0 = os.fork()    <span style="color: #008000;">#</span><span style="color: #008000;"> 创建二级进程</span>
    <span style="color: #0000ff;">if</span> pid0 &lt;<span style="color: #000000;"> 0:
        </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">"</span><span style="color: #800000;">创建二级进程失败</span><span style="color: #800000;">"</span><span style="color: #000000;">)
    </span><span style="color: #0000ff;">elif</span> pid0 == 0:     <span style="color: #008000;">#</span><span style="color: #008000;"> 二级子进程</span>
        fun2()          <span style="color: #008000;">#</span><span style="color: #008000;"> 做第二件事</span>
    <span style="color: #0000ff;">else</span>:               <span style="color: #008000;">#</span><span style="color: #008000;"> 二级进程</span>
        os._exit(0)     <span style="color: #008000;">#</span><span style="color: #008000;"> 二级进程退出</span>
<span style="color: #0000ff;">else</span><span style="color: #000000;">:
    os.wait()
    fun1()              </span><span style="color: #008000;">#</span><span style="color: #008000;"> 做第一件事</span>

<span style="color: #008000;">#</span><span style="color: #008000;"> 第一件事情</span><span style="color: #008000;">
#</span><span style="color: #008000;"> 第二件事情</span></pre>
</div>
<h3><span style="font-family: 宋体;">通过信号处理子进程退出</span></h3>
<p><span style="font-family: 宋体;">原理: 子进程退出时会发送信号给父进程,如果父进程忽略子进程信号, 则系统就会自动处</span><span style="font-family: 宋体;">理子进程退出。</span></p>
<p><span style="font-family: 宋体;">方法: 使用signal模块在父进程创建子进程前写如下语句 :</span><br /><span style="font-family: 宋体; background-color: #333333; color: #ffffff;">import signal</span><br /><span style="font-family: 宋体; background-color: #333333; color: #ffffff;">signal.signal(signal.SIGCHLD,signal.SIG_IGN)</span><br /><span style="font-family: 宋体;">特点 : 非阻塞,不会影响父进程运行。可以处理所有子进程退出</span></p>
<h1><span style="font-family: 宋体;">Multiprocessing创建进程</span></h1>
<p><span style="font-family: 宋体;">步骤：</span></p>
<ol>
<li><span style="font-family: 宋体;">需要将要做的事情封装成函数</span></li>
<li><span style="font-family: 宋体;">multiprocessing.Process创建进程，并绑定函数</span></li>
<li><span style="font-family: 宋体;">start启动进程</span></li>
<li><span style="font-family: 宋体;">join回收进程</span>&nbsp;</li>



</ol>
<p><span style="font-family: 宋体;"><strong>p = multiprocessing.Process(target, [name], [args], [kwargs])</strong></span>&nbsp;</p>
<p><span style="font-family: 宋体;">创建进程对象</span><br /><span style="font-family: 宋体;">参数：</span></p>
<ul>
<li><span style="font-family: 宋体;">target ： 要绑定的函数名</span></li>
<li><span style="font-family: 宋体;">name ： 给进程起的名称 （默认Process-1）</span></li>
<li><span style="font-family: 宋体;">args：&nbsp;元组&nbsp;用来给target函数传参</span></li>
<li><span style="font-family: 宋体;">kwargs :&nbsp;字典&nbsp;用来给target函数键值传参</span></li>



</ul>
<p><span style="font-family: 宋体;"><strong>p.start()</strong></span><br /><span style="font-family: 宋体;"><strong>功能</strong>&nbsp;： 启动进程 自动运行terget绑定函数。此时进程被创建</span></p>
<p><span style="font-family: 宋体;"><strong>p.join([timeout])</strong></span><br /><span style="font-family: 宋体;"><strong>功能</strong>： 阻塞等待子进程退出，最后回收进程</span><br /><span style="font-family: 宋体;"><strong>参数</strong>： 超时时间</span></p>
<p><span style="font-family: 宋体;">multiprocessing的注意事项：</span></p>
<ul>
<ul>
<li><span style="font-family: 宋体;">使用multiprocessing创建进程子进程同样复制父进程的全部内存空间，之后有自己独立的空间，执行上互不干扰</span></li>
<li><span style="font-family: 宋体;">如果不使用join回收可能会产生僵尸进程</span></li>
<li><span style="color: #ff0000; font-family: 宋体;">一般父进程功能就是创建子进程回收子进程，所有事件交给子进程完成</span></li>
<li><span style="font-family: 宋体;">multiprocessing创建的子进程无法使用ptint</span></li>



</ul>



</ul>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">import</span><span style="color: #000000;"> multiprocessing as mp 
</span><span style="color: #0000ff;">from</span> time <span style="color: #0000ff;">import</span><span style="color: #000000;"> sleep 
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> os

a </span>= 1

<span style="color: #0000ff;">def</span><span style="color: #000000;"> fun():
    sleep(</span>2<span style="color: #000000;">)
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">"</span><span style="color: #800000;">子进程事件</span><span style="color: #800000;">"</span><span style="color: #000000;">,os.getpid())
    </span><span style="color: #0000ff;">global</span><span style="color: #000000;"> a
    a </span>= 10000
    <span style="color: #0000ff;">print</span>(<span style="color: #800000;">"</span><span style="color: #800000;">a = </span><span style="color: #800000;">"</span><span style="color: #000000;">,a)

p </span>= mp.Process(target = fun)    <span style="color: #008000;">#</span><span style="color: #008000;"> 创建进程对象</span>
p.start()   <span style="color: #008000;">#</span><span style="color: #008000;"> 启动进程</span>
sleep(3<span style="color: #000000;">)
</span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">"</span><span style="color: #800000;">这是父进程</span><span style="color: #800000;">"</span><span style="color: #000000;">)
p.join()    </span><span style="color: #008000;">#</span><span style="color: #008000;"> 回收进程</span>
<span style="color: #0000ff;">print</span>(<span style="color: #800000;">"</span><span style="color: #800000;">parent a:</span><span style="color: #800000;">"</span><span style="color: #000000;">,a)

</span><span style="color: #008000;">#</span><span style="color: #008000;"> 子进程事件 5434</span><span style="color: #008000;">
#</span><span style="color: #008000;"> a =  10000</span><span style="color: #008000;">
#</span><span style="color: #008000;"> 这是父进程</span><span style="color: #008000;">
#</span><span style="color: #008000;"> parent a: 1</span>
<span style="color: #000000;">
Process(target)</span></pre>
</div>
<h2><span style="font-family: 宋体;">multiprocessing进程属性</span></h2>
<p><span style="font-family: 宋体;">p.name 　　&nbsp; &nbsp; 进程名称</span></p>
<p><span style="font-family: 宋体;">p.pid 　　　　对应子进程的PID号</span></p>
<p><span style="font-family: 宋体;">p.is_alive() 　&nbsp; 查看子进程是否在生命周期</span></p>
<p><span style="font-family: 宋体;">p.daemon&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;设置父子进程的退出关系</span></p>
<p><span style="font-family: 宋体;">　　如果等于True则子进程会随父进程的退出而结束，就不用使用 join()，必须要求在start()前设置</span></p>
<h1><span style="font-family: 宋体;">进程池</span></h1>
<p><span style="font-family: 宋体;">引言：如果有大量的任务需要多进程完成，而任务周期又比较短且需要频繁创建。此时可能产生大量进程频繁创建销毁的情况，消耗计算机资源较大，这个时候就需要进程池技术</span></p>
<p><span style="font-family: 宋体;">进程池的原理：创建一定数量的进程来处理事件,事件处理完进程不退出而是继续处理其他事件,直到所有事件全都处理完毕统一销毁。增加进程的重复利用,降低资源消耗。</span>&nbsp;</p>
<p><span style="font-family: 宋体;"><strong>１．创建进程池，在池内放入适当数量的进程</strong></span></p>
<p><span style="font-family: 宋体;">from multiprocessing import Pool</span></p>
<p><span style="font-family: 宋体;">Pool(processes)　　创建进程池对象</span></p>
<ul>
<li><span style="font-family: 宋体;">参数：进程数量</span></li>
<li><span style="font-family: 宋体;">返回 ：&nbsp;指定进程数量，默认根据系统自动判定</span>&nbsp;</li>
</ul>
<p><span style="font-family: 宋体;"><strong>２．将事件封装函数，放入到进程池</strong></span></p>
<p><span style="font-family: 宋体;">pool.apply_async(fun,args,kwds)　　将事件放入进程池执行</span><br /><span style="font-family: 宋体;">参数：</span></p>
<ul>
<li><span style="font-family: 宋体;">fun 要执行的事件函数</span></li>
<li><span style="font-family: 宋体;">args 以元组为fun传参</span></li>
<li><span style="font-family: 宋体;">kwds 以字典为fun传参</span></li>



</ul>
<p><span style="font-family: 宋体;">返回值 ：</span>&nbsp;</p>
<ul>
<li><span style="font-family: 宋体;">返回一个事件对象 通过get()属性函数可以获取fun的返回值&nbsp;</span></li>



</ul>
<p><span style="font-family: 宋体;"><strong>３．关闭进程池</strong></span></p>
<p><span style="font-family: 宋体;">&nbsp;pool.close()　　关闭进程池，无法再加入事件</span></p>
<p><span style="font-family: 宋体;"><strong>４．回收进程</strong></span></p>
<p><span style="font-family: 宋体;">pool.join()　　回收进程池</span>&nbsp;</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">from</span> multiprocessing <span style="color: #0000ff;">import</span><span style="color: #000000;"> Pool
</span><span style="color: #0000ff;">from</span> time <span style="color: #0000ff;">import</span><span style="color: #000000;"> sleep,ctime

pool </span>= Pool(4)    <span style="color: #008000;">#</span><span style="color: #008000;"> 创建进程池</span><span style="color: #008000;">
#</span><span style="color: #008000;"> 进程池事件</span>
<span style="color: #0000ff;">def</span><span style="color: #000000;"> worker(msg):
  sleep(</span>2<span style="color: #000000;">)
  </span><span style="color: #0000ff;">print</span><span style="color: #000000;">(msg)
  </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> ctime()

</span><span style="color: #008000;">#</span><span style="color: #008000;"> 向进程池添加执行事件</span>
<span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span> range(4<span style="color: #000000;">):
  msg </span>= <span style="color: #800000;">"</span><span style="color: #800000;">Hello %d</span><span style="color: #800000;">"</span>%<span style="color: #000000;">i

  </span><span style="color: #008000;">#</span><span style="color: #008000;"> r 代表func事件的一个对象</span>
  r = pool.apply_async(func=worker,args=<span style="color: #000000;">(msg,))

pool.close()    </span><span style="color: #008000;">#</span><span style="color: #008000;"> 关闭进程池</span>
pool.join()     <span style="color: #008000;">#</span><span style="color: #008000;"> 回收进程池</span>

<span style="color: #008000;">#</span><span style="color: #008000;"> Hello 3</span><span style="color: #008000;">
#</span><span style="color: #008000;"> Hello 2</span><span style="color: #008000;">
#</span><span style="color: #008000;"> Hello 0</span><span style="color: #008000;">
#</span><span style="color: #008000;"> Hello 1</span></pre>
</div>
<h1><span style="font-family: 宋体;">进程间通信(IPC)</span></h1>
<p><span style="font-family: 宋体;">由于进程间空间独立，资源无法共享，此时在进程间通信就需要专门的通信方法。</span></p>
<p><span style="font-family: 宋体;">进程间通信方法 ： 管道 消息队列 共享内存 信号信号量 套接字</span></p>
<h2><span style="font-family: 宋体;">管道通信(Pipe)</span></h2>
<p><span style="font-family: 宋体;">通信原理：在内存中开辟管道空间，生成管道操作对象，多个进程使用同一个管道对象进行读写即可实现通信　</span></p>
<p><span style="font-family: 宋体;">from　multiprocessing import Pipe</span></p>
<p><span style="font-family: 宋体;"><strong>fd1, fd2 = Pipe(duplex = True)</strong></span></p>
<ul>
<li><span style="font-family: 宋体;">功能：创建管道</span></li>
<li><span style="font-family: 宋体;">参数：默认表示双向管道，如果为False 表示单向管道</span></li>
<li><span style="font-family: 宋体;">返回值：表示管道两端的读写对象；如果是双向管道均可读写；如果是单向管道fd1只读 fd2只写</span></li>
</ul>
<p><span style="font-family: 宋体;"><strong>fd.recv()</strong></span></p>
<ul>
<li><span style="font-family: 宋体;">功能 : 从管道获取内容</span></li>
<li><span style="font-family: 宋体;">返回值:获取到的数据，当管道为空则阻塞</span></li>
</ul>
<p><span style="font-family: 宋体;"><strong>fd.send(data)</strong></span></p>
<ul>
<li><span style="font-family: 宋体;">功能: 向管道写入内容</span></li>
<li><span style="font-family: 宋体;">参数: 要写入的数据&nbsp;</span></li>
</ul>
<p><span style="font-family: 宋体;">注意：</span></p>
<ol>
<li><span style="font-family: 宋体;">multiprocessing中管道通信只能用于父子关系进程中&nbsp;</span></li>
<li><span style="font-family: 宋体;">管道对象在父进程中创建，子进程通过父进程获取</span>&nbsp;</li>
</ol>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">from</span> multiprocessing <span style="color: #0000ff;">import</span><span style="color: #000000;"> Pipe, Process

fd1, fd2 </span>= Pipe()   <span style="color: #008000;">#</span><span style="color: #008000;"> 创建管道，默认双向管道</span>
<span style="color: #0000ff;">def</span><span style="color: #000000;"> fun1():
  data </span>= fd1.recv()     <span style="color: #008000;">#</span><span style="color: #008000;"> 从管道获取消息</span>
  <span style="color: #0000ff;">print</span>(<span style="color: #800000;">"</span><span style="color: #800000;">管道２传给管道１的数据</span><span style="color: #800000;">"</span><span style="color: #000000;">, data)
  inpu </span>= <span style="color: #800000;">"</span><span style="color: #800000;">跟你说句悄悄话</span><span style="color: #800000;">"</span><span style="color: #000000;">
  fd1.send(inpu)

</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> fun2():
  fd2.send(</span><span style="color: #800000;">"</span><span style="color: #800000;">肥水不流外人天</span><span style="color: #800000;">"</span><span style="color: #000000;">)
  data </span>=<span style="color: #000000;"> fd2.recv()
  </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">"</span><span style="color: #800000;">管道１传给管道２的数据</span><span style="color: #800000;">"</span><span style="color: #000000;">, data)

p1 </span>= Process(target=<span style="color: #000000;">fun1)
P2 </span>= Process(target=<span style="color: #000000;">fun2)

p1.start()
P2.start()

p1.join()
P2.join()
</span><span style="color: #008000;">#</span><span style="color: #008000;"> 管道２传给管道１的数据 肥水不流外人天</span><span style="color: #008000;">
#</span><span style="color: #008000;"> 管道１传给管道２的数据 跟你说句悄悄话</span></pre>
</div>
<h2><span style="font-family: 宋体;">消息队列</span></h2>
<p><span style="font-family: 宋体;">从内存中开辟队列结构空间，多个进程可以向队列投放消息，在取出来的时候按照<strong><span style="color: #ff0000;">先进先出</span>顺序取出</strong>&nbsp;</span></p>
<p><span style="font-family: 宋体;"><strong>q = Queue(maxsize = 0)</strong>　　</span></p>
<p><span style="font-family: 宋体;">创建队列对象</span></p>
<ul>
<li><span style="font-family: 宋体;">maxsize ：默认表示系统自动分配队列空间；如果传入正整数则表示最多存放多少条消息</span></li>
<li><span style="font-family: 宋体;">返回值 ： 队列对象</span></li>
</ul>
<p><span style="font-family: 宋体;"><strong>q.put(data,[block,timeout])　　</strong></span></p>
<p><span style="font-family: 宋体;">向队列中存入消息</span></p>
<ul>
<li><span style="font-family: 宋体;"><strong>data：</strong>存放消息（<strong>python</strong>数据类型）</span></li>
<li><span style="font-family: 宋体;"><strong>block：</strong>默认为<strong>True</strong>表示当前队列满的时候阻塞，设置为<strong>False</strong>则表示非阻塞</span></li>
<li><span style="font-family: 宋体;"><strong>timeout：</strong>当<strong>block</strong>为<strong>True</strong>表示超时时间</span></li>
</ul>
<p><span style="font-family: 宋体;">　　返回值：返回获取的消息</span></p>
<p><span style="font-family: 宋体;"><strong>q.get([block,timeout])</strong></span></p>
<p><span style="font-family: 宋体;">从队列取出消息</span></p>
<ul>
<li><span style="font-family: 宋体;">参数:block 设置是否阻塞 False为非阻塞；timeout 超时检测</span></li>
<li><span style="font-family: 宋体;">返回值: 返回获取到的内容</span></li>
</ul>
<p><span style="font-family: 宋体;"><strong>q.full()</strong>　　判断队列是否为满</span></p>
<p><span style="font-family: 宋体;"><strong>q.empty()</strong>　　判断队列是否为空</span></p>
<p><span style="font-family: 宋体;"><strong>q.qsize()</strong>　　判断当前队列有多少消息&nbsp;</span></p>
<p><span style="font-family: 宋体;"><strong>q.close()</strong>　　关闭队列</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">from</span> multiprocessing <span style="color: #0000ff;">import</span><span style="color: #000000;"> Process, Queue
</span><span style="color: #0000ff;">from</span> time <span style="color: #0000ff;">import</span><span style="color: #000000;"> sleep
</span><span style="color: #0000ff;">from</span> random <span style="color: #0000ff;">import</span><span style="color: #000000;"> randint

</span><span style="color: #008000;">#</span><span style="color: #008000;">  创建消息队列</span>
q = Queue(3<span style="color: #000000;">)


</span><span style="color: #008000;">#</span><span style="color: #008000;"> 请求进程</span>
<span style="color: #0000ff;">def</span><span style="color: #000000;"> request():
  </span><span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span> range(2<span style="color: #000000;">):
    x </span>= randint(0, 100<span style="color: #000000;">)
    y </span>= randint(0, 100<span style="color: #000000;">)
    q.put((x, y))


</span><span style="color: #008000;">#</span><span style="color: #008000;"> 处理进程</span>
<span style="color: #0000ff;">def</span><span style="color: #000000;"> handle():
  </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> True:
    sleep(</span>1<span style="color: #000000;">)
    </span><span style="color: #0000ff;">try</span><span style="color: #000000;">:
      x, y </span>= q.get(timeout=2<span style="color: #000000;">)
    </span><span style="color: #0000ff;">except</span><span style="color: #000000;">:
      </span><span style="color: #0000ff;">break</span>
    <span style="color: #0000ff;">else</span><span style="color: #000000;">:
      </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">"</span><span style="color: #800000;">%d + %d = %d</span><span style="color: #800000;">"</span> % (x, y, x +<span style="color: #000000;"> y))


p1 </span>= Process(target=<span style="color: #000000;">request)
p2 </span>= Process(target=<span style="color: #000000;">handle)
p1.start()
p2.start()
p1.join()
p2.join()
</span><span style="color: #008000;">#</span><span style="color: #008000;"> 12 + 61 = 73</span><span style="color: #008000;">
#</span><span style="color: #008000;"> 69 + 48 = 117</span></pre>
</div>
<h2><span style="font-family: 宋体;">共享内存&nbsp;</span></h2>
<p><span style="font-family: 宋体;">在内存中开辟一段空间，存储数据，对多个进程可见，每次写入共享内存中的数据会覆盖之前的内容，效率高，速度快</span></p>
<p><span style="font-family: 宋体;"><strong>from multiprocessing import Value, Array</strong></span></p>
<p><span style="font-family: 宋体;"><strong>obj = Value(ctype,obj)</strong></span></p>
<p><span style="font-family: 宋体;"><strong>功能</strong>：开辟共享内存空间&nbsp;</span></p>
<p><span style="font-family: 宋体;"><strong>参数</strong>：ctype　　字符串　　要转变的c的数据类型，对比类型对照表</span></p>
<p><span style="font-family: 宋体;">　　obj　　共享内存的初始化数据</span></p>
<p><span style="font-family: 宋体;">返回：共享内存对象</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">from</span> multiprocessing <span style="color: #0000ff;">import</span><span style="color: #000000;"> Process,Value
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> time
</span><span style="color: #0000ff;">from</span> random <span style="color: #0000ff;">import</span><span style="color: #000000;"> randint

</span><span style="color: #008000;">#</span><span style="color: #008000;"> 创建共享内存</span>
money = Value(<span style="color: #800000;">'</span><span style="color: #800000;">i</span><span style="color: #800000;">'</span>, 5000<span style="color: #000000;">)

</span><span style="color: #008000;">#</span><span style="color: #008000;">  修改共享内存</span>
<span style="color: #0000ff;">def</span><span style="color: #000000;"> man():
  </span><span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span> range(30<span style="color: #000000;">):
    time.sleep(</span>0.2<span style="color: #000000;">)
    money.value </span>+= randint(1, 1000<span style="color: #000000;">)

</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> girl():
  </span><span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span> range(30<span style="color: #000000;">):
    time.sleep(</span>0.15<span style="color: #000000;">)
    money.value </span>-= randint(100, 800<span style="color: #000000;">)

m </span>= Process(target=<span style="color: #000000;">man)
g </span>= Process(target=<span style="color: #000000;">girl)
m.start()
g.start()
m.join()
g.join()

</span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">"</span><span style="color: #800000;">一月余额:</span><span style="color: #800000;">"</span>, money.value)   <span style="color: #008000;">#</span><span style="color: #008000;"> 获取共享内存值</span><span style="color: #008000;">
#</span><span style="color: #008000;"> 一月余额: 4264</span></pre>
</div>
<p><span style="font-family: 宋体;"><strong>obj = Array(ctype,obj)</strong></span></p>
<p><span style="font-family: 宋体;"><strong>功能</strong>：开辟共享内存</span></p>
<p><span style="font-family: 宋体;"><strong>参数</strong>：ctype　　要转化的c的类型</span></p>
<p><span style="font-family: 宋体;">　　obj　　要存入共享的数据</span></p>
<p><span style="font-family: 宋体;">　　　　如果是列表　　将列表存入共享内存，要求数据类型一致</span></p>
<p><span style="font-family: 宋体;">　　　　如果是正整数　　表示开辟几个数据空间</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">from</span> multiprocessing <span style="color: #0000ff;">import</span><span style="color: #000000;"> Process, Array

</span><span style="color: #008000;">#</span><span style="color: #008000;"> 创建共享内存</span><span style="color: #008000;">
#</span><span style="color: #008000;"> shm = Array('i',[1,2,3])</span><span style="color: #008000;">
#</span><span style="color: #008000;"> shm = Array('i',3)  # 表示开辟三个空间的列表</span>
shm = Array(<span style="color: #800000;">'</span><span style="color: #800000;">c</span><span style="color: #800000;">'</span>,b<span style="color: #800000;">"</span><span style="color: #800000;">hello</span><span style="color: #800000;">"</span>) <span style="color: #008000;">#</span><span style="color: #008000;">字节串</span>

<span style="color: #0000ff;">def</span><span style="color: #000000;"> fun():
  </span><span style="color: #008000;">#</span><span style="color: #008000;"> 共享内存对象可迭代</span>
  <span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span><span style="color: #000000;"> shm:
    </span><span style="color: #0000ff;">print</span><span style="color: #000000;">(i)
  shm[0] </span>= b<span style="color: #800000;">'</span><span style="color: #800000;">H</span><span style="color: #800000;">'</span><span style="color: #000000;">

p </span>= Process(target=<span style="color: #000000;">fun)
p.start()
p.join()

</span><span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span> shm:   <span style="color: #008000;">#</span><span style="color: #008000;"> 子进程修改，父进程中也跟着修改</span>
  <span style="color: #0000ff;">print</span><span style="color: #000000;">(i)

</span><span style="color: #0000ff;">print</span>(shm.value) <span style="color: #008000;">#</span><span style="color: #008000;"> 打印字节串　b'Hello'</span></pre>
</div>
<h2><span style="font-family: 宋体;">信号量(信号灯集)</span></h2>
<p><span style="font-family: 宋体;">通信原理：给定一个数量对多个进程可见。多个进程都可以操作该数量增减,并根据数量值决定自己的行为。</span></p>
<p><span style="font-family: 宋体;"><strong>from multiprocessing import Semaphore</strong></span><br /><span style="font-family: 宋体;"><strong>sem = Semaphore(num)</strong></span><br /><span style="font-family: 宋体;">创建信号量对象</span></p>
<ul>
<li><span style="font-family: 宋体;">参数 : 信号量的初始值</span></li>
<li><span style="font-family: 宋体;">返回值 : 信号量对象</span></li>





</ul>
<p><span style="font-family: 宋体;"><strong>sem.acquire()&nbsp;</strong>将信号量减1 当信号量为0时阻塞</span><br /><span style="font-family: 宋体;"><strong>sem.release()&nbsp;</strong>将信号量加1</span><br /><span style="font-family: 宋体;"><strong>sem.get_value()</strong>&nbsp;获取信号量数量</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">from</span> multiprocessing <span style="color: #0000ff;">import</span><span style="color: #000000;"> Process, Semaphore

sem </span>= Semaphore(3)    <span style="color: #008000;">#</span><span style="color: #008000;"> 创建信号量，最多允许３个任务同时执行</span>

<span style="color: #0000ff;">def</span><span style="color: #000000;"> rnewu():
  sem.acquire()   </span><span style="color: #008000;">#</span><span style="color: #008000;"> 每执行一次减少一个信号量</span>
  <span style="color: #0000ff;">print</span>(<span style="color: #800000;">"</span><span style="color: #800000;">执行任务.....执行完成</span><span style="color: #800000;">"</span><span style="color: #000000;">)
  sem.release()   </span><span style="color: #008000;">#</span><span style="color: #008000;"> 执行完成后增加信号量</span>


<span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span> range(3):  <span style="color: #008000;">#</span><span style="color: #008000;"> 有３个人想要执行任务</span>
  p = Process(target=<span style="color: #000000;">rnewu)
  p.start()
  p.join()</span></pre>
</div>
<p>&nbsp;</p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>