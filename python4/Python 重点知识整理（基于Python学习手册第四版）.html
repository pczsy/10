<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修Python 重点知识整理（基于Python学习手册第四版）' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>Python 重点知识整理（基于Python学习手册第四版）</center></div><div class='banquan'>原文出处:本文由博客园博主小xxxx程序员提供。<br/>
原文连接:https://www.cnblogs.com/xcxy-boke/p/11215187.html</div><br>
    <h1><span style="font-size: 18px;"><em><strong>字节型编译</strong></em></span></h1>
<p><span style="font-size: 14px;">如果Python在系统中有写的权限，当程序运行时Python会把源码编译成字节码（与系统环境无关）存在一个.pyc扩展名文件中，如果没有修改源码而重新运行程序时，不会进行编译的步骤而使用字节码，可以优化运行速度。</span></p>
<h1><span style="font-size: 18px;"><em><strong>变量、对象和引用</strong></em></span></h1>
<p><span style="font-size: 14px;">变量与对象是分开的，它们通过引用来建立连接，变量名是对象的引用。变量是一个系统表的元素，拥有指向对象连接的空间；对象是分配的一块内存，有俩个头部信息，一个类型标志符去标识这个对象的类型，一个是引用的计数器（回收机制）；引用是自动形成的从变量到对象的指针。</span></p>
<p><span style="font-size: 14px;">通常x，y指向不同的对象x is y应该是FALSE，但是Python内部会自动缓存小的数字和字符串，所以x，y都指向了缓存中的42的对象。</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;">1</span> x = 42
<span style="color: #008080;">2</span> y = 42
<span style="color: #008080;">3</span> x ==<span style="color: #000000;"> y
</span><span style="color: #008080;">4</span> Out[15<span style="color: #000000;">]: True
</span><span style="color: #008080;">5</span> x <span style="color: #0000ff;">is</span><span style="color: #000000;"> y
</span><span style="color: #008080;">6</span> Out[16]: True</pre>
</div>
<h1><em><span style="font-size: 18px;"><strong>常用的内置类型</strong></span></em></h1>
<p><span style="font-size: 14px;">数字,字符串，列表，字典，元组，文件，集合，编程单元类型（函数、模块、类），与实现相关的类型（编译的代码堆跟踪），其他类型（类型、None、bool值）</span></p>
<p><span style="font-size: 14px;">不可变类型：数字，字符串，元组，bool（对于不可变类型和可变的类型进行修改时尽量使用 +=，节约一个对象的空间）</span></p>
<p><span style="font-size: 14px;">可变类型：字典，列表，集合（需要修改变量内容的方法则是直接在原来对象上修改）</span></p>
<p><span style="font-size: 14px;">函数是可变对象。类则是初始化时创建的一个命名空间，是独立的存储空间，实例化时会单独创建一存储空间给实例而函数不会。</span></p>
<h1><span style="font-size: 18px;"><em><strong>函数帮助</strong></em></span></h1>
<p><span style="font-size: 18px;"><span style="font-size: 14px;">dir()方法，列出可可调用的方法，包括双下划线的方法</span></span></p>
<p><span style="font-size: 18px;"><span style="font-size: 14px;">help()方法，传达方法名，返回说明文档</span></span></p>
<p><span style="font-size: 18px;"><em><strong>列表解析</strong></em></span></p>
<p><span style="font-size: 14px;">[]、{}是列表解析，（）是生成生成器。</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;">1</span> M = [[1,2,3<span style="color: #000000;">],
</span><span style="color: #008080;">2</span>      [4,5,6<span style="color: #000000;">],
</span><span style="color: #008080;">3</span>      [7,8,9<span style="color: #000000;">]]
</span><span style="color: #008080;">4</span> col = [row[1] <span style="color: #0000ff;">for</span> row <span style="color: #0000ff;">in</span> M]</pre>
</div>
<p>也可以是 {} 的列表解析。比直接用for效率高。</p>
<p><span style="font-size: 15px;"><strong>map:</strong></span><span class="pln">map<span class="pun">(<span class="kwd">function<span class="pun">,<span class="pln"> iterable<span class="pun">,<span class="pln"> <span class="pun">...)，对iterable逐一进行function，返回的是迭代器</span></span></span></span></span></span></span></span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;">1</span> &gt;&gt;&gt; map(<span style="color: #0000ff;">lambda</span> x, y: x + y, [1, 3, 5, 7, 9], [2, 4, 6, 8, 10<span style="color: #000000;">])
</span><span style="color: #008080;">2</span> &lt;map at 0x3ebed04208&gt;</pre>
</div>
<p>&nbsp;</p>
<p><span style="font-size: 15px;"><strong>filter:</strong></span><span class="pln">filter<span class="pun">(<span class="kwd">function<span class="pun">,<span class="pln"> iterable<span class="pun">)，filter()&nbsp;函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的迭代器。</span></span></span></span></span></span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;">1</span> <span style="color: #0000ff;">def</span><span style="color: #000000;"> is_odd(n):
</span><span style="color: #008080;">2</span>     <span style="color: #0000ff;">return</span> n % 2 == 1
<span style="color: #008080;">3</span>  
<span style="color: #008080;">4</span> newlist = filter(is_odd, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10<span style="color: #000000;">])
</span><span style="color: #008080;">5</span> <span style="color: #0000ff;">print</span><span style="color: #000000;">(newlist)
</span><span style="color: #008080;">6</span> &lt;filter object at 0x0000003EBED044E0&gt;</pre>
</div>
<p>&nbsp;<span style="font-size: 15px;"><strong>zip:</strong><span style="font-size: 14px;">取得一个或多个序列为参数，然后返回元组的列表，将这些序列中的并排的元素配对。长度不同则以最短的为准。</span></span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;">1</span> list(zip([1,2,3],[4,5,6,7<span style="color: #000000;">]))
</span><span style="color: #008080;">2</span> Out[38]: [(1, 4), (2, 5), (3, 6)]</pre>
</div>
<h1><span style="font-size: 18px;"><em><strong>字典&amp;集合</strong></em></span></h1>
<p><span style="font-size: 14px;"><span style="color: #ff0000;">都是哈希映射</span>。</span></p>
<p><span style="font-size: 14px;"><strong><span style="font-size: 15px;">字典：</span></strong>是一系列的键值对，key:value,键必须是不可变对象（数字、字符串等）。dict是一个可迭代对象，next返回的是他的键。key可以是任意的不可比对象。</span></p>
<p><span style="font-size: 14px;">dict.get(key,default)、dict.setdefault(key,default)、dict.updata():合并操作（会覆盖相同的元素）、dict.pop(key):删除指定元素、dict.(zip([1,2,3],[4,5,6])):把俩个列表组合成键值对</span></p>
<p><span style="font-size: 15px;"><strong>集合：</strong><span style="font-size: 14px;">&amp;:交集&nbsp; |:并集&nbsp; a ^ b:a不在b和b不在a的元素&nbsp; a - b:b不在a的元素&nbsp; &lt;、&gt;:包含。set()只能接受一个参数，如果有多个参数则只能变成list等类型。集合只能包含不可变对象，因为集合的实现是哈希结构，是根据只来映射，所以集合不能是list等可变的对象。</span></span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;">1</span> x = set(<span style="color: #800000;">'</span><span style="color: #800000;">123456</span><span style="color: #800000;">'</span><span style="color: #000000;">)
</span><span style="color: #008080;">2</span> <span style="color: #000000;">x
</span><span style="color: #008080;">3</span> Out[3]: {<span style="color: #800000;">'</span><span style="color: #800000;">1</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">2</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">3</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">4</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">5</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">6</span><span style="color: #800000;">'</span><span style="color: #000000;">}
</span><span style="color: #008080;">4</span> <span style="color: #000000;">type({})　　　　　　　　　　# x = {}初始化是一个字典，如果想初始化一个集合只能用set()函数
</span><span style="color: #008080;">5</span> Out[6]: dict</pre>
</div>
<p><span style="font-size: 18px;"><em><strong>列表</strong></em></span></p>
<p><span style="font-size: 14px;">嵌套的数组结构。（插入、删除元素效率慢（尽量用append、extend、pop），查找效率快）</span></p>
<p><span style="font-size: 14px;">分片赋值是先删除所选择的分片的元素再进行插入操作。所以也会有效率的问题，所以尽量少用。如果是一个元素的替换则不属于分片赋值</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;">1</span> [<span style="color: #800000;">'</span><span style="color: #800000;">xsa</span><span style="color: #800000;">'</span>,<span style="color: #800000;">'</span><span style="color: #800000;">sd</span><span style="color: #800000;">'</span>] * 3   # [0] * 100 进行初始化<br /><br />
<span style="color: #008080;">2</span> Out[20]: [<span style="color: #800000;">'</span><span style="color: #800000;">xsa</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">sd</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">xsa</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">sd</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">xsa</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">sd</span><span style="color: #800000;">'</span><span style="color: #000000;">]
</span><span style="color: #008080;">3</span> <span style="color: #800000;">'</span><span style="color: #800000;">xsa</span><span style="color: #800000;">'</span> * 3
<span style="color: #008080;">4</span> Out[21]: <span style="color: #800000;">'</span><span style="color: #800000;">xsaxsaxsa</span><span style="color: #800000;">'</span></pre>
</div>
<p>&nbsp;</p>
<p><span style="font-size: 18px;"><em><strong>文件</strong></em></span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;">1</span> <span style="color: #000000;">with open() as f:
</span><span style="color: #008080;">2</span>     f.readlines()        <span style="color: #008000;">#</span><span style="color: #008000;"> 读取全部行，按行返回list</span>
<span style="color: #008080;">3</span>     f.read()                <span style="color: #008000;">#</span><span style="color: #008000;"> 读取全部内容，返回字符串</span>
<span style="color: #008080;">4</span>     f.readline()            <span style="color: #008000;">#</span><span style="color: #008000;">返回一行的内容，字符串</span>
<span style="color: #008080;">5</span> <span style="color: #0000ff;">for</span> line <span style="color: #0000ff;">in</span> open():　　　　<span style="color: #008000;">#</span><span style="color: #008000;"> open是一个可迭代对象，一行一行的读取数据</span>
<span style="color: #008080;">6</span> 　　<span style="color: #0000ff;">pass</span> </pre>
</div>
<p>&nbsp;<span style="font-size: 18px;"><em><strong>赋值</strong></em></span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;">1</span> spam = <span style="color: #800000;">'</span><span style="color: #800000;">Spam</span><span style="color: #800000;">'</span>
<span style="color: #008080;">2</span> spam,ham = <span style="color: #800000;">'</span><span style="color: #800000;">yum</span><span style="color: #800000;">'</span>,<span style="color: #800000;">'</span><span style="color: #800000;">YUM</span><span style="color: #800000;">'       # 自动转成元组，存储变量的值</span>
<span style="color: #008080;">3</span> [spam,ham] = [<span style="color: #800000;">'</span><span style="color: #800000;">yum</span><span style="color: #800000;">'</span>,<span style="color: #800000;">'</span><span style="color: #800000;">YUM</span><span style="color: #800000;">'</span><span style="color: #000000;">]
</span><span style="color: #008080;">4</span> a,b,c,d = <span style="color: #800000;">'</span><span style="color: #800000;">spam</span><span style="color: #800000;">'</span>
<span style="color: #008080;">5</span> a,*b = <span style="color: #800000;">'</span><span style="color: #800000;">spam</span><span style="color: #800000;">'</span>
<span style="color: #008080;">6</span> spam = ham = <span style="color: #800000;">'</span><span style="color: #800000;">lunch</span><span style="color: #800000;">'</span>
<span style="color: #008080;">7</span> spam += 42</pre>
</div>
<p>&nbsp;</p>
<p><span style="font-size: 15px;"><strong>序列解包：</strong><span style="font-size: 14px;">带星号的名称可能只匹配单个或空的项，但是返回一个列表。只能有一个带星号的名称。</span></span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;">1</span> a,b,c,d,*e = <span style="color: #800000;">'</span><span style="color: #800000;">spam</span><span style="color: #800000;">'</span>
<span style="color: #008080;">2</span> <span style="color: #000000;">a,b,c,d,e 
</span><span style="color: #008080;">3</span> Out[8]: (<span style="color: #800000;">'</span><span style="color: #800000;">s</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">p</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">m</span><span style="color: #800000;">'</span><span style="color: #000000;">, [])
</span><span style="color: #008080;">4</span> 
<span style="color: #008080;">5</span> *a = <span style="color: #800000;">'</span><span style="color: #800000;">spam</span><span style="color: #800000;">'</span>
<span style="color: #008080;">6</span> SyntaxError: starred assignment target must be <span style="color: #0000ff;">in</span> a list <span style="color: #0000ff;">or</span><span style="color: #000000;"> tuple
</span><span style="color: #008080;">7</span> *a, = <span style="color: #800000;">'</span><span style="color: #800000;">spam</span><span style="color: #800000;">'</span>
<span style="color: #008080;">8</span> <span style="color: #000000;">a
</span><span style="color: #008080;">9</span> Out[11]: [<span style="color: #800000;">'</span><span style="color: #800000;">s</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">p</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">m</span><span style="color: #800000;">'</span>]</pre>
</div>
<p>&nbsp;</p>
<h1><span style="font-size: 18px;"><em><strong>print</strong></em></span></h1>
<p><span style="font-size: 14px;">print([object,...][,sep = ' '][,end = '\n'][,file = sys.stdout])</span></p>
<p><span style="font-size: 14px;">sep,end,file如果给出的话，必须作为关键字参数给定。file指定文本将要发送的文件，标准流或者类似文件的对象。带有一个类似文件的write(string)方法的任何对象都可以传递。</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">print</span><span style="color: #000000;">(x,y)
</span><span style="color: #008080;"> 2</span> <span style="color: #000000;">等价于
</span><span style="color: #008080;"> 3</span> <span style="color: #0000ff;">import</span><span style="color: #000000;"> sys
</span><span style="color: #008080;"> 4</span> sys.stdout.write(str(x) + str(y) + <span style="color: #800000;">'</span><span style="color: #800000;">\n</span><span style="color: #800000;">'</span><span style="color: #000000;">)
</span><span style="color: #008080;"> 5</span> 
<span style="color: #008080;"> 6</span> <span style="color: #008000;">#</span><span style="color: #008000;"> 重定向到指定文件(也可以直接指定file参数 -)</span>
<span style="color: #008080;"> 7</span> <span style="color: #0000ff;">import</span><span style="color: #000000;"> sys
</span><span style="color: #008080;"> 8</span> sys.stdout = open(<span style="color: #800000;">'</span><span style="color: #800000;">file_path</span><span style="color: #800000;">'</span>,<span style="color: #800000;">'</span><span style="color: #800000;">w/a/..</span><span style="color: #800000;">'</span>,encodeing = <span style="color: #800000;">'</span><span style="color: #800000;">utf-8/....</span><span style="color: #800000;">'</span><span style="color: #000000;">)
</span><span style="color: #008080;"> 9</span> <span style="color: #000000;">...
</span><span style="color: #008080;">10</span> <span style="color: #0000ff;">print</span>(x,y)</pre>
</div>
<h1><span style="font-size: 18px;"><em><strong>迭代器</strong></em></span></h1>
<p><span style="font-size: 15px;"><strong>单个迭代器：</strong><span style="font-size: 14px;">zip、map、filter不支持多个迭代器，生成器是单迭代器。</span></span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;">1</span> x = zip([1,2,3],[4,5,6<span style="color: #000000;">])
</span><span style="color: #008080;">2</span> I1 =<span style="color: #000000;"> x
</span><span style="color: #008080;">3</span> I2 =<span style="color: #000000;"> x
</span><span style="color: #008080;">4</span> <span style="color: #000000;">next(I1) 
</span><span style="color: #008080;">5</span> Out[52]: (1, 4<span style="color: #000000;">)
</span><span style="color: #008080;">6</span> <span style="color: #000000;">next(I2)
</span><span style="color: #008080;">7</span> Out[53]: (2, 5<span style="color: #000000;">)
</span><span style="color: #008080;">8</span> <span style="color: #000000;">next(x)
</span><span style="color: #008080;">9</span> Out[54]: (3, 6)</pre>
</div>
<p>&nbsp;<span style="font-size: 18px;"><em><strong>函数</strong></em></span></p>
<p><span style="font-size: 14px;">函数与类相似也是一个命名空间，可以用fun.args来对函数里面的属性进行赋值(与原来函数内部的属性分开，存在__dict__变量里)，但是不能查看或修改函数里面的属性。</span></p>
<p><span style="font-size: 15px;"><strong>作用域：</strong><span style="font-size: 14px;">当你在一个程序中使用变量名时，python创建、改变或查找变量名都是在所谓的命名空间（一个保存变量名的地方）中进行的。在哪里赋值决定了他的命名空间。</span></span></p>
<p><span style="font-size: 15px;"><span style="font-size: 14px;">LEGB原则：本地作用域（L）、上层结构中def或lambda的本地作用域（E）、全局作用域（G）、内置作用域（B）。</span></span></p>
<p><span style="font-size: 15px;"><strong>工厂函数：</strong><span style="font-size: 14px;">能记住嵌套作用域的变量值的函数，尽管那个作用域已经不在了。（类更适合记住状态）</span></span></p>
<p><span style="font-size: 15px;"><span style="font-size: 14px;">嵌套作用域中的变量在嵌套的函数被调用时才进行查找，所以实际记住的是相同的一个值（在最后一次循环迭代中循环变量的值）。可以使用默认参数来记住当前的状态，默认参数是记录在函数对象中的。</span></span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;">1</span> t = [<span style="color: #0000ff;">lambda</span> i:i * x <span style="color: #0000ff;">for</span> x <span style="color: #0000ff;">in</span> range(5<span style="color: #000000;">)] # t = [lambda i,x = x:i * x for x in range(5)]
</span><span style="color: #008080;">2</span> t[0](1<span style="color: #000000;">)
</span><span style="color: #008080;">3</span> Out[3]: 4 
<span style="color: #008080;">4</span> t[0](2<span style="color: #000000;">)
</span><span style="color: #008080;">5</span> Out[4]: 8</pre>
</div>
<p>&nbsp;</p>
<p><span style="font-size: 15px;"><strong>nonlocal：</strong><span style="font-size: 14px;">nonlocal应用于一个嵌套的函数的作用域中的一个名称，而不是所有def之外的全局模块作用域，声明时该变量必须已经定义，否则将产生错误。对变量名的查找从嵌套的def的作用域中开始，而不是从本地作用域开始，只限定在嵌套的def中。不会在全局作用域中查找。（global查找也是跳过本地作用域）</span></span></p>
<h1><span style="font-size: 18px;"><em><strong>参数</strong></em></span></h1>
<p><span style="font-size: 15px;"><strong>传递参数：</strong><span style="font-size: 14px;">1.参数的传递时通过自动将对象赋值给本地变量名来实现的。2.在函数内部的参数名的赋值不会影响调用者。3.改变函数的可变对象参数的值也许会对调用者有影响。4.不可变参数通过值传递的，可变参数通过&ldquo;指针&rdquo;进行传递的。</span></span></p>
<p><span style="font-size: 15px;"><span style="font-size: 14px;">在函数调用中，参数必须以此顺序出现：任何位置参数（value），后面跟着任何关键字参数（name = value）和*sequence形式的组合，后面跟着**dict形式。</span></span></p>
<p><span style="font-size: 15px;"><span style="font-size: 14px;">在函数的头部，参数必须以此顺序出现：任意一般的参数（name），紧跟着任何的默认参数（name = value），如果有的话后面是*name或*的形式，后面跟着任何name或name = value keyword-only参数，后面跟着**name形式。</span></span></p>
<p><span style="font-size: 15px;"><span style="font-size: 14px;">参数匹配：</span></span></p>
<p><span style="font-size: 15px;"><span style="font-size: 14px;">1.通过位置分配非关键字参数。</span></span></p>
<p><span style="font-size: 15px;"><span style="font-size: 14px;">2.通过匹配变量名分配关键字参数</span></span></p>
<p><span style="font-size: 15px;"><span style="font-size: 14px;">3.其他额外的非关键字分配到*name元组中</span></span></p>
<p><span style="font-size: 15px;"><span style="font-size: 14px;">4.其他额外的关键字参数分配到**name字典中。</span></span></p>
<p><span style="font-size: 15px;"><span style="font-size: 14px;">5.用默认值分配给在头部未得到分配的参数。</span></span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;">1</span> <span style="color: #0000ff;">def</span><span style="color: #000000;"> func(a,b,c,d):
</span><span style="color: #008080;">2</span>     <span style="color: #0000ff;">print</span><span style="color: #000000;">(a,b,c,d)
</span><span style="color: #008080;">3</span> func(1,c = 3,*(2,),**{<span style="color: #800000;">'</span><span style="color: #800000;">d</span><span style="color: #800000;">'</span>:4<span style="color: #000000;">})
</span><span style="color: #008080;">4</span> 1 2 3 4</pre>
</div>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;">1</span> <span style="color: #0000ff;">def</span> f(a,*b,c = 6,**<span style="color: #000000;">d):
</span><span style="color: #008080;">2</span>     <span style="color: #0000ff;">print</span><span style="color: #000000;">(a,b,c,d)
</span><span style="color: #008080;">3</span> f(1,*(2,3),**dict(x = 4,y = 5))
<span style="color: #008080;">4</span> 1 (2, 3) 6 {<span style="color: #800000;">'</span><span style="color: #800000;">x</span><span style="color: #800000;">'</span>: 4, <span style="color: #800000;">'</span><span style="color: #800000;">y</span><span style="color: #800000;">'</span>: 5}</pre>
</div>
<p>&nbsp;<span style="font-size: 18px;"><em><strong>import</strong></em></span></p>
<p><span style="font-size: 15px;"><strong>流程：</strong><span style="font-size: 14px;">在第一次导入文件时执行以下三个步骤，如果导入相同的模块则只是提取内存中已加载的模块对象。Python把已加载的模块存储到sys,modules表中。如果需要再次导入要调用reload。</span></span></p>
<p><span style="font-size: 14px;">1.找到模块文件（sys.path）</span></p>
<p><span style="font-size: 14px;">2.编译成位码（需要时）</span></p>
<p><span style="font-size: 14px;">3.执行模块的代码来创建其所定义的对象</span></p>
<p><span style="font-size: 14px;">搜索路径：1.程序的主程序　　2.PYTHONPATH目录　　3.标准链接库目录　　4.任何的.pth文件的内容（如果存在的话 ）</span></p>
<p><span style="font-size: 14px;">模块文件选择：.py&nbsp; .pyc 目录&nbsp; 编译扩展模块（通常用C/C++）等不限于Python文件<br /></span></p>
<p><span style="font-size: 15px;"><strong>from：</strong><span style="font-size: 14px;">除了会读取整个模块（运行），并把变量名赋值到另一个作用域的同名变量（可变对象是引用）</span></span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;">1</span> <span style="color: #0000ff;">from</span> module <span style="color: #0000ff;">import</span><span style="color: #000000;"> name1,name2
</span><span style="color: #008080;">2</span> <span style="color: #008000;">#</span><span style="color: #008000;"> 等价于</span>
<span style="color: #008080;">3</span> <span style="color: #0000ff;">import</span><span style="color: #000000;"> module
</span><span style="color: #008080;">4</span> name1 =<span style="color: #000000;"> module.name1
</span><span style="color: #008080;">5</span> name2 =<span style="color: #000000;"> module.name2
</span><span style="color: #008080;">6</span> <span style="color: #0000ff;">del</span> module</pre>
</div>
<p><span style="font-size: 15px;"><strong>包导入：</strong><span style="font-size: 14px;">以</span><span style="font-size: 14px;">'.'相隔路径名。包导入语句的路径中的每一个目录内都必须有一个__init__.py（导入包会先运行此文件的代码但可以为空，用来标识此目录是包）文件，否则这个包导入失败。<br /></span></span></p>
<p><span style="font-size: 15px;"><strong>包的相对导入（包内文件的导入原则）：</strong><span style="font-size: 14px;">from语句现在可以使用前面的点号 "." 来指定，它们需要位于同一包中的模块（包的相对导入），而不是位于模块导入搜索路径的模块（绝对导入）。不会在sys.path中查找，只在包内查找。否则在sys.path中查找。（只适用于from语句，import默认绝对导入</span></span><span style="font-size: 15px;"><span style="font-size: 14px;">）</span></span></p>
<p>&nbsp;<span style="font-size: 18px;"><em><strong>类</strong></em></span></p>
<p><span style="font-size: 14px;">类：实例工厂。类的属性提供了行为（数据以及函数），所有从类产生的实例都继承该类的属性</span></p>
<p><span style="font-size: 14px;">实例：代表程序领域中具体的元素。实例属性记录数据，而每个特定对象的数据都不同。初始化一个实例都会分配单独的存储空间。不可以修改父类的数据，只能引用，如果进行赋值的操作会在实例空间初始化或引用赋值（father类有属性x，而children实例运行children.x += 1不会修改father的值，会在自己的命名空间上先引用父类的x在+1，然后存放在自己的实例空间上，children有x属性）</span></p>
<p><span style="font-size: 14px;">属性继承搜索：先搜索本地实例，然后是该对象之上的所有类，由下至上，由左到右。（广度优先）</span></p>
<p><span style="font-size: 14px;">self：self指向调用自己的实例对象。</span></p>
<p><span style="font-size: 14px;">__class__：显示实例链接到父类名称</span></p>
<p><span style="font-size: 14px;">__bases__：一个元组，显示继承的父类</span></p>
<p><span style="font-size: 14px;">__bese__：显示第一个父类名称</span></p>
<p><span style="font-size: 14px;">__dict__：显示模块的属性（dict形式）</span></p>
<p><span style="font-size: 14px;">__doc__：文档字符串(函数也有此属性)，常放在类的开头，用'''.......'''</span></p>
<p><span style="font-size: 14px;">__slots__：这个属性一般是在class语句顶层内将字符串名顺序赋值给变量__slots__，只有__slots__列表内的这些变量名可赋值给实例属性（__slots__内的变量类不能再定义）。如果实例想赋值实例属性，则实例会搜索父类查看实例属性是否存在父类的__slots__中，如果任意一父类存在则可以赋值，否则失败。（如果父类的__slots__内有__dict__变量则都可以赋值，因为实例属性赋值是通过调用__dict__方法，把变量名存__dict__字典中）</span></p>
<p><span style="font-size: 15px;"><strong>运算符重载：</strong></span>当类的实例出现在内置操作中，Python会自动调用你的方法。</p>
<p>运算符重载让类拦截常规的Python运算&nbsp; &nbsp; 类可重载所有Python表达式运算符&nbsp; &nbsp;重载使类实例的行为像内置类型&nbsp; &nbsp;重载使通过提供特殊名称的类方法来实现是</p>
<p><span>__call__：当调用实例时使用__call__方法。把实例当做一个方法来调用。</span></p>
<p><span>__init__（构造函数）：初始化实例时自动调用此方法。</span></p>
<p>__sub__：捕获减法表达式</p>
<p>__add__、__radd__：加法运算符，右侧+（只有当+右侧的对象是实例对象时才会调用__radd__，其他所有情况调用__add__）</p>
<p>__iadd__：X += Y</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;">1</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Number:
</span><span style="color: #008080;">2</span>     <span style="color: #0000ff;">def</span> <span style="color: #800080;">__init__</span><span style="color: #000000;">(self,start):
</span><span style="color: #008080;">3</span>         self.data =<span style="color: #000000;"> start
</span><span style="color: #008080;">4</span>     <span style="color: #0000ff;">def</span> <span style="color: #800080;">__sub__</span><span style="color: #000000;">(self,other):
</span><span style="color: #008080;">5</span>         <span style="color: #0000ff;">return</span> Number(self.data - other)</pre>
</div>
<p>__str__：打印、转换（__str__比__repr__的优先级高）</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;">1</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Str(object):
</span><span style="color: #008080;">2</span>     <span style="color: #0000ff;">def</span> <span style="color: #800080;">__str__</span><span style="color: #000000;">(self):
</span><span style="color: #008080;">3</span>         <span style="color: #0000ff;">return</span> <span style="color: #800000;">"</span><span style="color: #800000;">__str__ called</span><span style="color: #800000;">"</span>    
<span style="color: #008080;">4</span>     <span style="color: #0000ff;">def</span> <span style="color: #800080;">__repr__</span><span style="color: #000000;">(self):
</span><span style="color: #008080;">5</span>          <span style="color: #0000ff;">return</span> <span style="color: #800000;">"</span><span style="color: #800000;">__repr__ called</span><span style="color: #800000;">"</span></pre>
</div>
<p>__getitem__：索引运算</p>
<p>__setitem__:索引赋值语句</p>
<p>__delitem__：索引和分片的删除</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Indexer:
</span><span style="color: #008080;"> 2</span>     data = [5,6,7,8,9<span style="color: #000000;">]
</span><span style="color: #008080;"> 3</span>     <span style="color: #0000ff;">def</span> <span style="color: #800080;">__getitem__</span><span style="color: #000000;">(self,index):
</span><span style="color: #008080;"> 4</span>         <span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">getitem:</span><span style="color: #800000;">'</span><span style="color: #000000;">,index)
</span><span style="color: #008080;"> 5</span>         <span style="color: #0000ff;">return</span><span style="color: #000000;"> self.data[index]
</span><span style="color: #008080;"> 6</span>     <span style="color: #0000ff;">def</span> <span style="color: #800080;">__setitem__</span><span style="color: #000000;">(self,index,value):
</span><span style="color: #008080;"> 7</span>         self.data[index] =<span style="color: #000000;"> value
</span><span style="color: #008080;"> 8</span> x =<span style="color: #000000;"> Indexer()
</span><span style="color: #008080;"> 9</span> x[2:4<span style="color: #000000;">]
</span><span style="color: #008080;">10</span> slice(2, 4<span style="color: #000000;">, None)
</span><span style="color: #008080;">11</span> Out[38]: [7, 8]<br />12 for item in x:　　　　# for语句的作用是从0到更大的索引值，每次循环都会调用类的__getitem__，可以支持所有的迭代环境（in、列表解析、map、iter）<br />13 　　print(item)</pre>
</div>
<p>__iter__、__next__：迭代环境（Python中所有的迭代环境都会先尝试__iter__，在尝试__getitem__）</p>
<p>__contains__：in 方法，for i in range(5)调用__iter__</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Squares:
</span><span style="color: #008080;"> 2</span>     <span style="color: #0000ff;">def</span> <span style="color: #800080;">__init__</span><span style="color: #000000;">(self,start,stop):
</span><span style="color: #008080;"> 3</span>         self.value = start - 1
<span style="color: #008080;"> 4</span>         self.stop =<span style="color: #000000;"> stop
</span><span style="color: #008080;"> 5</span>     <span style="color: #0000ff;">def</span> <span style="color: #800080;">__iter__</span><span style="color: #000000;">(self):
</span><span style="color: #008080;"> 6</span>         <span style="color: #0000ff;">return</span><span style="color: #000000;"> self
</span><span style="color: #008080;"> 7</span>     <span style="color: #0000ff;">def</span> <span style="color: #800080;">__next__</span><span style="color: #000000;">(self):
</span><span style="color: #008080;"> 8</span>         <span style="color: #0000ff;">if</span> self.value ==<span style="color: #000000;"> self.stop:
</span><span style="color: #008080;"> 9</span>             <span style="color: #0000ff;">raise</span><span style="color: #000000;"> StopIteration
</span><span style="color: #008080;">10</span>         self.value += 1
<span style="color: #008080;">11</span>         <span style="color: #0000ff;">return</span> self.value ** 2</pre>
</div>
<p>__getattr__：属性引用（如果不能再类中找到属性，则调用此方法）</p>
<p>__setattr__：属性赋值（拦截所有属性赋值操作）</p>
<p>__delattr__：属性删除</p>
<p>__getattribute__：拦截所有属性，而不只那些未定义的属性。</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Empty:
</span><span style="color: #008080;"> 2</span>     <span style="color: #0000ff;">def</span> <span style="color: #800080;">__getattr__</span><span style="color: #000000;">(self,attrname):
</span><span style="color: #008080;"> 3</span>         <span style="color: #0000ff;">if</span> attrname == <span style="color: #800000;">'</span><span style="color: #800000;">age</span><span style="color: #800000;">'</span><span style="color: #000000;">:
</span><span style="color: #008080;"> 4</span>             <span style="color: #0000ff;">return</span> 40
<span style="color: #008080;"> 5</span>         <span style="color: #0000ff;">else</span><span style="color: #000000;">:
</span><span style="color: #008080;"> 6</span>             <span style="color: #0000ff;">raise</span><span style="color: #000000;"> AttributeError
</span><span style="color: #008080;"> 7</span>     <span style="color: #0000ff;">def</span> <span style="color: #800080;">__setattr__</span><span style="color: #000000;">(self,attrname,value):
</span><span style="color: #008080;"> 8</span>         <span style="color: #0000ff;">if</span> attrname == <span style="color: #800000;">'</span><span style="color: #800000;">age</span><span style="color: #800000;">'</span><span style="color: #000000;">:
</span><span style="color: #008080;"> 9</span>             self.<span style="color: #800080;">__dict__</span>[attrname] =<span style="color: #000000;"> value
</span><span style="color: #008080;">10</span>         <span style="color: #0000ff;">else</span><span style="color: #000000;">:
</span><span style="color: #008080;">11</span>             <span style="color: #0000ff;">raise</span> AttributeError</pre>
</div>
<p>__or__：or运算符</p>
<p class="p2"><span class="s1">__lt__、 __gt__、&nbsp;</span><span class="s1">__le__、 __ge__、&nbsp;</span><span class="s1">__eq__、 __ne__：&lt;、&gt;、&lt;=、&gt;=、==、！=<br /></span></p>
<p>__bool__、__len__：bool()、len()。进行布尔值的判断，如果没有定义__bool__则会找__len__（一个非0的长度为True）</p>
<p>__del__：析构函数，回收实例空间是自动运行&nbsp;</p>
<p><span style="font-size: 15px;"><strong>伪私有属性：</strong></span>用一个 _ 来编写内部名称（_X），但这只是让你知道此变量是一个不应该修改的名字，不是一个真正的私有变量。</p>
<p><span style="font-size: 15px;"><strong>变量名压缩：</strong></span>class语句内开头有俩个下划线但是结尾没有俩个下划线的变量名会自动扩张，从而包含了所在类的名称。例如：Spam类内__X的变量名会自动变成_Spam__X，原始变量名会在头部加入一个下划线，然后是所在类名称。（防止变量名的冲突）</p>
<h1><span style="font-size: 18px;"><em><strong>装饰器</strong></em></span></h1>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;">1</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> D:
</span><span style="color: #008080;">2</span> <span style="color: #000000;">    @staticmethod(A,B)
</span><span style="color: #008080;">3</span>     <span style="color: #0000ff;">def</span><span style="color: #000000;"> meth(slef):
</span><span style="color: #008080;">4</span>         <span style="color: #0000ff;">pass</span>
<span style="color: #008080;">5</span> <span style="color: #008000;">#</span><span style="color: #008000;"> 等价于</span>
<span style="color: #008080;">6</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> D:
</span><span style="color: #008080;">7</span>     <span style="color: #0000ff;">def</span><span style="color: #000000;"> meth(slef):
</span><span style="color: #008080;">8</span>         <span style="color: #0000ff;">pass</span>
<span style="color: #008080;">9</span>     meth = staticmethod(A,B)(meth)</pre>
</div>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;">1</span> <span style="color: #0000ff;">def</span><span style="color: #000000;"> decorator(F):
</span><span style="color: #008080;">2</span>     <span style="color: #0000ff;">def</span> wrapper(*args,**<span style="color: #000000;">kargs):
</span><span style="color: #008080;">3</span> <span style="color: #000000;">        ...
</span><span style="color: #008080;">4</span>         F(*args,**<span style="color: #000000;">kargs)
</span><span style="color: #008080;">5</span> <span style="color: #000000;">        ...
</span><span style="color: #008080;">6</span>     <span style="color: #0000ff;">return</span> wrapper</pre>
</div>
<p>&nbsp;</p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>