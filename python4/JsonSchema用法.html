<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修JsonSchema用法' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>JsonSchema用法</center></div><div class='banquan'>原文出处:本文由博客园博主upuptop提供。<br/>
原文连接:https://www.cnblogs.com/upuptop/p/12034759.html</div><br>
    <h1 id="jsonschema用法">JsonSchema用法</h1>
<h2 id="简介">简介</h2>
<p>JSON Schema是基于JSON格式，用于定义JSON数据结构以及校验JSON数据内容。<br />
JSON Schema官网地址：<a href="http://json-schema.org/" class="uri">http://json-schema.org/</a></p>
<blockquote>
<p>JsonSchema类似于xml的schema和DTD的作用，主要是用来规范json的格式。</p>
</blockquote>
<h2 id="关键字及其描述">关键字及其描述</h2>
<table>
<thead>
<tr class="header">
<th>关键字</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>$schema</td>
<td>表示该JSON Schema文件遵循的规范</td>
</tr>
<tr class="even">
<td>title</td>
<td>为该JSON Schema文件提供一个标题</td>
</tr>
<tr class="odd">
<td>description</td>
<td>关于该JSON Schema文件的描述信息</td>
</tr>
<tr class="even">
<td>type</td>
<td>表示待校验元素的类型（例如，最外层的type表示待校验的是一个JSON对象，内层type分别表示待校验的元素类型为，整数，字符串，数字）</td>
</tr>
<tr class="odd">
<td>properties</td>
<td>定义待校验的JSON对象中，各个key-value对中value的限制条件</td>
</tr>
<tr class="even">
<td>requiredv</td>
<td>定义待校验的JSON对象中，必须存在的key</td>
</tr>
<tr class="odd">
<td>minimum</td>
<td>用于约束取值范围，表示取值范围应该大于或等于minimum</td>
</tr>
<tr class="even">
<td>exclusiveMinimum</td>
<td>如果minimum和exclusiveMinimum同时存在，且exclusiveMinimum的值为true，则表示取值范围只能大于minimum</td>
</tr>
<tr class="odd">
<td>maximum</td>
<td>用于约束取值范围，表示取值范围应该小于或等于maximum</td>
</tr>
<tr class="even">
<td>exclusiveMaximum</td>
<td>如果maximum和exclusiveMaximum同时存在，且exclusiveMaximum的值为true，则表示取值范围只能小于maximum</td>
</tr>
<tr class="odd">
<td>multipleOf</td>
<td>用于约束取值，表示取值必须能够被multipleOf所指定的值整除</td>
</tr>
<tr class="even">
<td>maxLength</td>
<td>字符串类型数据的最大长度</td>
</tr>
<tr class="odd">
<td>minLength</td>
<td>字符串类型数据的最小长度</td>
</tr>
<tr class="even">
<td>pattern</td>
<td>使用正则表达式约束字符串类型数据</td>
</tr>
</tbody>
</table>
<h2 id="json-schema关键字详解">JSON Schema关键字详解</h2>
<p>JsonSchema代码：</p>
<pre><code><code>
{
    &quot;$schema&quot;: &quot;http://json-schema.org/draft-04/schema#&quot;,
    &quot;title&quot;: &quot;TestInfo&quot;,
    &quot;description&quot;: &quot;some information about test&quot;,
    &quot;type&quot;: &quot;object&quot;,
    &quot;properties&quot;: {
        &quot;name&quot;: {
            &quot;description&quot;: &quot;Name of the test&quot;,
            &quot;type&quot;: &quot;string&quot;
        },
        &quot;age&quot;: {
            &quot;description&quot;: &quot;age of test&quot;,
            &quot;type&quot;: &quot;integer&quot;
        }
    },
    &quot;required&quot;: [
        &quot;name&quot;
    ]
}</code></pre>
<p>详细解释：</p>
<ul>
<li>$schema:用于指定JSONSchema的版本信息，该值由官方提供，不可乱写。该关键字可以省略。</li>
<li>title：当前schema的标题信息。可以省略</li>
<li>description：当前节点的描述</li>
<li>type：当前节点的类型，最外层type代表json的最外层是什么样的类型。例如上方的例子中，符合该JsonSchema的json数据必需是一个JsonObject而不能是一个JsonArray</li>
<li>properties：代表当前节点的子节点信息。例如上方的例子中，符合该JsonSchema的json数据的信息可以存在“name”节点和“age”节点。按照上面的配置required信息来看，name是必需要有的，而age是非必需的。</li>
<li>required： 是一个数组类型，代表当前节点下必需的节点key。例如上方例子中，规定了json的格式必需要有name节点。</li>
</ul>
<p>符合上述JsonSchema的json数据如下：</p>
<p>第一种（不含有age节点，只含有name一个节点或者name及其若干个节点）：</p>
<pre><code><code>{
  &quot;name&quot;: &quot;upuptop&quot;
}
</code></pre>
<p>第二种（含有age节点，age节点的值必需为integer类型）：</p>
<pre><code><code>{
  &quot;name&quot;: &quot;upuptop&quot;,
  &quot;age&quot;: 123,
  &quot;create_time&quot;: &quot;2019-12-12&quot;
}</code></pre>
<h2 id="type的常用取值">type的常用取值</h2>
<table>
<thead>
<tr class="header">
<th>type取值</th>
<th>对应的python数据类型</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>object</td>
<td>Object</td>
</tr>
<tr class="even">
<td>array</td>
<td>List</td>
</tr>
<tr class="odd">
<td>integer</td>
<td>int</td>
</tr>
<tr class="even">
<td>number</td>
<td>float或int</td>
</tr>
<tr class="odd">
<td>null</td>
<td>None</td>
</tr>
<tr class="even">
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr class="odd">
<td>string</td>
<td>String</td>
</tr>
</tbody>
</table>
<h2 id="关键字详解">关键字详解</h2>
<h3 id="最外层type为object时">最外层type为object时</h3>
<ul>
<li><p>properties</p>
<blockquote>
<p>该关键字的值是一个对象。</p>
</blockquote></li>
</ul>
<p>用于指定JSON对象中的各种不同key应该满足的校验逻辑，如果待校验JSON对象中所有值都能够通过该关键字值中定义的对应key的校验逻辑，<br />
<strong>每个key对应的值，都是一个JSON Schema</strong>，则待校验JSON对象通过校验。<br />
从这里，我们可以看到，只要待校验JSON对象的所有key分别都通过对应的JSON Schema的校验检测，这个对象才算是通过校验。</p>
<pre><code><code>
&quot;properties&quot;: {
    &quot;name&quot;: {
      &quot;description&quot;: &quot;姓名必须由2-3个字组成&quot;,
      &quot;type&quot;: &quot;string&quot;,
      &quot;maxLength&quot;: 3,
      &quot;minLength&quot;: 2
    },
    &quot;age&quot;: {
      &quot;description&quot;: &quot;年龄必须大于18岁。并且不能超过60岁&quot;,
      &quot;type&quot;: &quot;integer&quot;,
      &quot;minimum&quot;: 18,
      &quot;maximum&quot;: 60
    }
  }
</code></pre>
<p>解释：<strong>每个key对应的值，都是一个JSON Schema:</strong>例如上方例子中，每一个key(name/age)对应的值都是一个JSONSchema，JSONSchema中的关键字及描述都可以使用。</p>
<ul>
<li><p>required</p>
<blockquote>
<p>该关键字的值是一个数组，而数组中的元素必须是字符串，而且必须是唯一的。</p>
</blockquote></li>
</ul>
<p>该关键字限制了JSON对象中必须包含哪些一级key。<br />
如果一个JSON对象中含有required关键字所指定的所有一级key，则该JSON对象能够通过校验。</p>
<pre><code><code>&quot;required&quot;: [&quot;id&quot;,&quot;name&quot;,&quot;price&quot;]</code></pre>
<ul>
<li><p>minProperties、maxProperties</p>
<blockquote>
<p>这两个关键字的值都是非负整数。规定最多节点个数与最少节点个数。</p>
</blockquote></li>
</ul>
<p>指定了待校验JSON对象中一级key的个数限制，minProperties指定了待校验JSON对象可以接受的最少一级key的个数，而maxProperties指定了待校验JSON对象可以接受的最多一级key的个数。</p>
<p>另外，需要注意的是，省略minProperties关键字和该关键字的值为0，具有相同效果。而，如果省略maxProperties关键字则表示对一级key的最大个数没有限制。例如，如果限制一个JSON对象的一级key的最大个数为5，最小个数为1，则JSON Schema如下：</p>
<pre><code><code>&quot;minProperties&quot;: 1,
&quot;maxProperties&quot;: 5</code></pre>
<ul>
<li><p>patternProperties</p>
<blockquote>
<p>该关键字的值是一个对象，该JSON对象的每一个一级key都是一个正则表达式，value都是一个JSON Schema。<br />
指定符合正则表达式的key的规则。<br />
只有待校验JSON对象中的一级key，通过与之匹配的patternProperties中的一级正则表达式，<br />
对应的JSON Schema的校验，才算通过校验。例如，如果patternProperties对应的值如下</p>
</blockquote></li>
</ul>
<pre><code><code>&quot;patternProperties&quot;: {
        &quot;^a&quot;: {
            &quot;type&quot;: &quot;number&quot;
        },
        &quot;^b&quot;: {
            &quot;type&quot;: &quot;string&quot;
        }
}</code></pre>
<p>上面的JSON Schema表示，待校验JSON对象中，所有以a开头的一级key的value都必须是number，所有以b开头的一级key的value都必须是string。</p>
<ul>
<li><p>additionalProperties</p>
<blockquote>
<p>该关键字的值是一个JSON Schema。</p>
</blockquote></li>
</ul>
<p>如果待校验JSON对象中存在，既没有在properties中被定义，又没有在patternProperties中被定义，那么这些一级key必须通过additionalProperties的校验。</p>
<h3 id="最外层type为array时">最外层type为array时</h3>
<ul>
<li><p>items:</p>
<blockquote>
<p>该关键字的值是一个有效的JSON Schema或者一组有效的JSON Schema。</p>
</blockquote></li>
</ul>
<p>当该关键字的值是一个有效的JSON Schema时，只有待校验JSON数组中的所有元素均通过校验，整个数组才算通过校验。例如，如果items关键字的具体定义如下：</p>
<pre><code><code>{
   &quot;type&quot;: &quot;array&quot;,
   &quot;items&quot;: {
     &quot;type&quot;: &quot;string&quot;,
     &quot;minLength&quot;: 5 
   }
}</code></pre>
<p>上面的JSON Schema的意思是，待校验JSON数组的元素都是string类型，且最小可接受长度是5。那么下面这个JSON数组明显是符合要求的，具体内容如下：</p>
<pre><code><code>[&quot;myhome&quot;, &quot;green&quot;]</code></pre>
<p>那么下面这个JSON数据则是不符合要求，因为第一个元素的长度小于5，具体内容如下：</p>
<pre><code><code>[&quot;home&quot;, &quot;green&quot;]</code></pre>
<p>以上对于items的介绍是对于所有元素来规定的。</p>
<p><strong>注意</strong><br />
下面对items的详解，趋向于每一个元素的规则。</p>
<p>这里需要注意的是，如果items定义的有效的JSON Schema的数量和待校验JSON数组中元素的数量不一致，那么就要采用<strong>“取小原则”</strong>。即，如果items定义了3个JSON Schema，但是待校验JSON数组只有2个元素，这时，只要待校验JSON数组的前两个元素能够分别通过items中的前两个JSON Schema的校验，那么，我们认为待校验JSON数组通过了校验。而，如果待校验JSON数组有4个元素，这时，只要待校验JSON数组的前三个元素能够通过items中对应的JSON Schema的校验，我们就认为待校验JSON数组通过了校验。</p>
<p>例如，如果items的值如下：</p>
<pre><code><code>
{
    &quot;type&quot;: &quot;array&quot;,
    &quot;items&quot;: [
        {
            &quot;type&quot;: &quot;string&quot;,
            &quot;minLength&quot;: 5
        },
        {
            &quot;type&quot;: &quot;number&quot;,
            &quot;minimum&quot;: 10
        },
        {
            &quot;type&quot;: &quot;string&quot;
        }
    ]
}</code></pre>
<p>上面的JSON Schema指出了待校验JSON数组应该满足的条件，数组的第一个元素是string类型，且最小可接受长度为5，数组的第二个元素是number类型，最小可接受的值为10，数组的第三个元素是string类型。那么下面这两个JSON数组明显是符合要求的，具体内容如下：</p>
<pre><code><code>[&quot;green&quot;, 10, &quot;good&quot;]
[&quot;helloworld&quot;, 11]</code></pre>
<p>下面这两个JSON数组却是不符合要求的，具体内容如下：</p>
<pre><code><code>[&quot;green&quot;, 9, &quot;good&quot;]
[&quot;good&quot;, 12]</code></pre>
<ul>
<li><p>additionalItems</p>
<blockquote>
<p>该关键字的值是一个有效的JSON Schema。主要规定除了items内部规定的元素之外的元素规则。只有在items是一个schema数组的时候才可以使用。</p>
</blockquote></li>
</ul>
<p>需要<strong>注意</strong>的是，该关键字只有在items关键字的值为一组有效的JSON Schema的时候，才可以使用，用于规定超出items中JSON Schema总数量之外的待校验JSON数组中的剩余的元素应该满足的校验逻辑。当然了，只有这些剩余的所有元素都满足additionalItems的要求时，待校验JSON数组才算通过校验。</p>
<p>其实，你可以这么理解，当items的值为一组有效的JOSN Schema的时候，一般可以和additionalItems关键字组合使用，items用于规定对应位置上应该满足的校验逻辑，而additionalItems用于规定超出items校验范围的所有剩余元素应该满足的条件。如果二者同时存在，那么只有待校验JSON数组同时通过二者的校验，才算真正地通过校验。</p>
<p>另外，需要注意的是，如果items只是一个有效的JSON Schema，那么就不能使用additionalItems，原因也很简单，因为items为一个有效的JSON Schema的时候，其规定了待校验JSON数组所有元素应该满足的校验逻辑。additionalItems已经没有用武之地了。</p>
<p>如果一个additionalItems的值如下：</p>
<pre><code><code>
{
    &quot;type&quot;: &quot;array&quot;,
    &quot;items&quot;: [
        {
            &quot;type&quot;: &quot;string&quot;,
            &quot;minLength&quot;: 5
        },
        {
            &quot;type&quot;: &quot;number&quot;,
            &quot;minimum&quot;: 10
        }
    ],
    &quot;additionalItems&quot;: {
        &quot;type&quot;: &quot;string&quot;,
        &quot;minLength&quot;: 2
    }
}</code></pre>
<p>上面的JSON Schema的意思是，待校验JSON数组第一个元素是string类型，且可接受的最短长度为5个字符，第二个元素是number类型，且可接受的最小值为10，剩余的其他元素是string类型，且可接受的最短长度为2。那么，下面三个JSON数组是能够通过校验的，具体内容如下：</p>
<pre><code><code>
[&quot;green&quot;, 10, &quot;good&quot;]
[&quot;green&quot;, 11]
[&quot;green&quot;, 10, &quot;good&quot;, &quot;ok&quot;]</code></pre>
<p>下面JSON数组是无法通过校验的，具体内容如下：</p>
<pre><code><code>
[&quot;green&quot;, 10, &quot;a&quot;]
[&quot;green&quot;, 10, &quot;ok&quot;, 2]</code></pre>
<ul>
<li><p>minItems、maxItems</p>
<blockquote>
<p>这两个关键字的值都是非负整数。<br />
指定了待校验JSON数组中元素的个数限制，minItems指定了待校验JSON数组可以接受的最少元素个数，而maxItems指定了待校验JSON数组可以接受的最多元素个数。</p>
</blockquote></li>
</ul>
<p>另外，需要注意的是，省略minItems关键字和该关键字的值为0，具有相同效果。而，如果省略maxItems关键字则表示对元素的最大个数没有限制。</p>
<p>例如，如果限制一个JSON数组的元素的最大个数为5，最小个数为1，则JSON Schema如下：</p>
<pre><code><code>&quot;minItems&quot;: 1,
&quot;maxItems&quot;: 5</code></pre>
<ul>
<li><p>uniqueItems</p>
<blockquote>
<p>该关键字的值是一个布尔值，即boolean（true、false）。</p>
</blockquote></li>
</ul>
<p>当该关键字的值为true时，只有待校验JSON数组中的所有元素都具有<strong>唯一性</strong>时，才能通过校验。当该关键字的值为false时，任何待校验JSON数组都能通过校验。<br />
另外，需要注意的是，省略该关键字和该关键字的值为false时，具有相同的效果。例如：</p>
<pre><code><code>&quot;uniqueItems&quot;: true</code></pre>
<h3 id="当type的值为integer或者number时">当type的值为integer或者number时</h3>
<blockquote>
<p>integer和number的区别，integer相当于python中的int类型，而number相当于python中的int或float类型</p>
</blockquote>
<ul>
<li><p>multipleOf</p>
<blockquote>
<p>该关键字的值是一个大于0的number，即可以是大于0的int，也可以是大于0的float。只有待校验的值能够被该关键字的值<strong>整除</strong>，才算通过校验。</p>
</blockquote></li>
</ul>
<p>如果含有该关键字的JSON Schema如下：</p>
<pre><code><code>
{
    &quot;type&quot;: &quot;integer&quot;,
    &quot;multipleOf&quot;: 2
}</code></pre>
<blockquote>
<p>那么，2、4、6都是可以通过校验的，但是，3、5、7都是无法通过校验的，当然了，2.0、4.0也是无法通过校验的，但是，并不是因为multipleOf关键字，而是因为type关键字。</p>
</blockquote>
<p>如果含有multipleOf关键字的JSON Schema如下：</p>
<pre><code><code>{
    &quot;type&quot;: &quot;number&quot;,
    &quot;multipleOf&quot;: 2.0
}</code></pre>
<blockquote>
<p>那么，2、2.0、4、4.0都是可以通过校验的，但是，3、3.0、3、3.0都是无法通过校验的。</p>
</blockquote>
<ul>
<li>maximum 、exclusiveMaximum</li>
</ul>
<blockquote>
<p><code>maximum</code>该关键字的值是一个number，即可以是int，也可以是float。该关键字规定了待校验元素可以通过校验的最大值。即传入的值必须小于maximum。<br />
<code>exclusiveMaximum</code>该关键字和<code>maximum</code>一样，规定了待校验元素可以通过校验的最大值，不同的是待校验元素可以等于exclusiveMaximum指定的值。即比maximum多了一个他自身这个边界值.</p>
</blockquote>
<pre><code><code>{
    &quot;type&quot;: &quot;number&quot;,
#  设定 maximum 为12.3 则传入值必须小于12.3
#    &quot;maximum&quot;: 12.3,
#  设定 exclusiveMaximum为12.3 则传入值是小于等于12.3
    &quot;exclusiveMaximum&quot;: 12.3
}
</code></pre>
<ul>
<li><p>minimum、exclusiveMinimum</p>
<blockquote>
<p><code>minimum</code>、<code>exclusiveMinimum</code>关键字的用法和含义与<code>maximum</code>、<code>exclusiveMaximum</code>相似。唯一的区别在于，一个约束了待校验元素的最小值，一个约束了待校验元素的最大值。</p>
</blockquote></li>
</ul>
<h3 id="当type取值为string时">当type取值为string时</h3>
<ul>
<li><p>maxLength</p>
<blockquote>
<p>该关键字的值是一个非负整数。该关键字规定了待校验JSON元素可以通过校验的最大长度，即待校验JSON元素的最大长度必须小于或者等于该关键字的值。</p>
</blockquote></li>
<li><p>minLength</p>
<blockquote>
<p>该关键字的值是一个非负整数。该关键字规定了待校验JSON元素可以通过校验的最小长度，即待校验JSON元素的最小长度必须大于或者等于该关键字的值。</p>
</blockquote></li>
<li><p>pattern</p>
<blockquote>
<p>该关键字的值是一个正则表达式。只有待校验JSON元素符合该关键字指定的正则表达式，才算通过校验。</p>
</blockquote></li>
<li><p>format</p>
<blockquote>
<p>该关键字的值可以是以下取值：<code>date</code>、<code>date-time</code>（时间格式）、<code>email</code>（邮件格式）、<code>hostname</code>（网站地址格式）、<code>ipv4</code>、<code>ipv6</code>、<code>uri</code>等等。</p>
</blockquote></li>
</ul>
<pre><code><code>
{
    &quot;type&quot;: &quot;string&quot;,
    &quot;format&quot;: &quot;email&quot;
}</code></pre>
<p>使用format关键字时，<strong>在实例化validator时必须给它传<code>format_checker</code>参数,fromat_checker参数的值即使各种版本的JSON模式规范的验证器类</strong>，如：</p>
<p><a href="https://python-jsonschema.readthedocs.io/en/latest/validate/#jsonschema.Draft7Validator">Draft7Validator</a><br />
<a href="https://python-jsonschema.readthedocs.io/en/latest/validate/#jsonschema.Draft6Validator">Draft6Validator</a><br />
<a href="https://python-jsonschema.readthedocs.io/en/latest/validate/#jsonschema.Draft4Validator">Draft4Validator</a></p>
<p>当你实例化validator时,如果没有给它传format_checker参数, jsonschema是不会自动校验schema中的format关键字的.因此,你需要做以下步骤:<br />
1.额外导入JSON Schema某个版本的模式规范如：from jsonschema import draft7_format_checker<br />
2.实例化validator时传入：validate(instance=json_data, schema=my_schema, format_checker=draft7_format_checker)</p>
<h3 id="全类型可用">全类型可用</h3>
<ul>
<li><p>enum</p>
<blockquote>
<p>该关键字的值是一个数组，该数组至少要有一个元素，且数组内的每一个元素都是唯一的。<br />
如果待校验的JSON元素和数组中的某一个元素相同，则通过校验。否则，无法通过校验。</p>
</blockquote></li>
</ul>
<p><strong>注意：</strong>该数组中的元素值可以是任何值，包括null。省略该关键字则表示无须对待校验元素进行该项校验。例如：</p>
<pre><code><code>
{
    &quot;type&quot;: &quot;number&quot;,
    &quot;enum&quot;: [2, 3, null, &quot;hello&quot;]
}</code></pre>
<ul>
<li><p>const</p>
<blockquote>
<p>该关键字的值可以是任何值，包括null。如果待校验的JSON元素的值和该关键字指定的值相同，则通过校验。否则，无法通过校验。</p>
</blockquote></li>
<li><p>allOf</p>
<blockquote>
<p>该关键字的值是一个非空数组，数组里面的每个元素都必须是一个有效的JSON Schema。<br />
只有待校验JSON元素通过数组中<strong>所有的</strong>JSON Schema校验，才算真正通过校验。</p>
</blockquote></li>
<li><p>anyOf</p>
<blockquote>
<p>该关键字的值是一个非空数组，数组里面的每个元素都必须是一个有效的JSON Schema。<br />
如果待校验JSON元素能够通过数组中的<strong>任何一个</strong>~~~~JSON Schema校验，就算通过校验。</p>
</blockquote></li>
<li><p>oneOf</p>
<blockquote>
<p>该关键字的值是一个非空数组，数组里面的每个元素都必须是一个有效的JSON Schema。<br />
如果待校验JSON元素<strong>能且只能</strong>通过数组中的<strong>某一个</strong>JSON Schema校验，才算真正通过校验。<strong>不能通过任何一个校验和能通过两个及以上的校验</strong>，都<strong>不算真正</strong>通过校验。</p>
</blockquote></li>
<li><p>not</p>
<blockquote>
<p>该关键字的值是一个JSON Schema。只有待校验JSON元素<strong>不能通过</strong>该关键字指定的JSON Schema校验的时候，待校验元素才算通过校验。</p>
</blockquote></li>
<li><p>default</p>
<blockquote>
<p>该关键字的值是没有任何要求的。该关键字常常用来指定待校验JSON元素的默认值，当然，这个默认值最好是符合要求的，即能够通过相应的JSON Schema的校验。<br />
另外，需要注意的是，该关键字除了<strong>提示作用</strong>外，并不会产生任何实质性的影响。</p>
</blockquote></li>
</ul>
<h3 id="type关键字">type关键字</h3>
<blockquote>
<p>需要特别注意的是，type关键字的值可以是一个string，也可以是一个数组。<br />
如果type的值是一个string，则其值只能是以下几种：null、boolean、object、array、number、string、integer。<br />
如果type的值是一个数组，则数组中的元素都必须是string，且其取值依旧被限定为以上几种。<strong>只要带校验JSON元素是其中的一种</strong>，则通过校验。</p>
</blockquote>
<p><strong>注意，</strong>以上JSON Schema只是为了展示部分关键字的用法，可能和实际应用略有不同。</p>
<h3 id="dependencies关键字">dependencies关键字</h3>
<blockquote>
<p>依赖关系</p>
</blockquote>
<pre><code><code>{
  &quot;$schema&quot;: &quot;http://json-schema.org/draft-07/schema#&quot;,
  
  &quot;properties&quot;: {
  },
  &quot;dependencies&quot;: {
    &quot;age&quot;: [
      &quot;name&quot;
    ]
  },
 
}
</code></pre>
<blockquote>
<p>上述schema表示，age依赖于name，如果age出现，name必须出现</p>
</blockquote>
<h3 id="ref关键字">$ref关键字</h3>
<p>使用该关键字可以引用一个规范</p>
<pre><code><code>
&quot;warehouseLocation&quot;: {
      &quot;description&quot;: &quot;Coordinates of the warehouse where the product is located.&quot;,
      &quot;$ref&quot;: &quot;https://example.com/geographical-location.schema.json&quot;
    }
</code></pre>
<h3 id="if-then-else-关键字">if-then-else 关键字</h3>
<pre><code><code>
{
  &quot;$schema&quot;: &quot;http://json-schema.org/draft-07/schema#&quot;,
  &quot;type&quot;: &quot;object&quot;,
  &quot;properties&quot;: {
    &quot;foo&quot;: {
      &quot;type&quot;: &quot;string&quot;
    },
    &quot;bar&quot;: {
      &quot;type&quot;: &quot;string&quot;
    }
  },
  &quot;if&quot;: {
    &quot;properties&quot;: {
      &quot;foo&quot;: {
        &quot;enum&quot;: [
          &quot;bar&quot;,
          &quot;123&quot;
        ]
      }
    },
    &quot;required&quot;: [
      &quot;foo&quot;
    ]
  },
  &quot;then&quot;: {
    &quot;required&quot;: [
      &quot;bar&quot;
    ]
  },
  &quot;else&quot;: {
    &quot;required&quot;: [
      &quot;cc&quot;
    ]
  }
}

</code></pre>
<p>符合上述规则的json（最简单的两种方式）：</p>
<pre><code><code>{
  &quot;foo&quot;: &quot;bar22&quot;,
  &quot;cc&quot;: 123
}


{
  &quot;foo&quot;: &quot;bar&quot;,
  &quot;bar&quot;: &quot;123&quot;
}
</code></pre>
<p>概述：</p>
<pre><code><code>if条件为：key为foo的值是bar或者123 返回true，否则返回false
if返回true执行then：
    then的规则，bar必须存在
if返回false执行else
    else规则，cc必须存在</code></pre>
<blockquote>
<p>官方的参考文档如下：<br />
<a href="http://json-schema.org/latest/json-schema-validation.html" class="uri">http://json-schema.org/latest/json-schema-validation.html</a><br />
<a href="https://json-schema.org/implementations.html" class="uri">https://json-schema.org/implementations.html</a></p>
</blockquote>
<blockquote>
<p>本文参考：<a href="https://www.cnblogs.com/ChangAn223/articles/11234348.htm" class="uri">https://www.cnblogs.com/ChangAn223/articles/11234348.htm</a></p>
</blockquote>

</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>