<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修逻辑回归' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>逻辑回归</center></div><div class='banquan'>原文出处:本文由博客园博主Infi_chu提供。<br/>
原文连接:https://www.cnblogs.com/Infi-chu/p/11430448.html</div><br>
    <p>&nbsp;Infi-chu:</p>
<p><a href="http://www.cnblogs.com/Infi-chu/" target="_blank">http://www.cnblogs.com/Infi-chu/</a></p>
<p>逻辑回归（Logistic Regression）是机器学习中的一种分类模型，逻辑回归是一种分类算法，虽然名字中带有回归，但是它与回归之间有一定的联系。由于算法的简单和高效，在实际中应用非常广泛。</p>
<p>一、简介</p>
<p>1.应用场景</p>
<ul>
<li>广告点击率</li>
<li>是否为垃圾邮件</li>
<li>是否患病</li>
<li>金融诈骗</li>
<li>虚假账号</li>
</ul>
<p>特点：都属于两个类别之间的判断。逻辑回归就是解决二分类问题的利器</p>
<p>2.公式</p>
<p>输入：</p>
<p><img src="./images/逻辑回归0.png" alt="" /></p>
<p>逻辑回归的输入就是一个线性回归的结果。</p>
<p>激活函数：</p>
<ul>
<li>sigmoid函数</li>
</ul>
<p><img src="./images/逻辑回归1.png" alt="" /></p>
<ul>
<li>
<p>判断标准</p>
<ul>
<li>回归的结果输入到sigmoid函数当中</li>
<li>输出结果：[0, 1]区间中的一个概率值，默认为0.5为阈值</li>
</ul>
</li>
</ul>
<p>&nbsp;<img src="./images/逻辑回归2.png" alt="" /></p>
<p>【注】</p>
<p>逻辑回归最终的分类是通过属于某个类别的概率值来判断是否属于某个类别，并且这个类别默认标记为1(正例),另外的一个类别会标记为0(反例)。（方便损失计算）</p>
<p>输出结果解释(重要)：假设有两个类别A，B，并且假设我们的概率值为属于A(1)这个类别的概率值。现在有一个样本的输入到逻辑回归输出结果0.6，那么这个概率值超过0.5，意味着我们训练或者预测的结果就是A(1)类别。那么反之，如果得出结果为0.3那么，训练或者预测结果就为B(0)类别。</p>
<p>所以接下来我们回忆之前的线性回归预测结果我们用均方误差衡量，那如果对于逻辑回归，我们预测的结果不对该怎么去衡量这个损失呢？我们来看这样一张图：</p>
<p><img src="./images/逻辑回归3.png" alt="" /></p>
<p>3.损失&amp;优化</p>
<p>损失：</p>
<p>逻辑回归的损失，称之为<strong>对数似然损失</strong>，公式如下：</p>
<ul>
<li>分开类别：</li>
</ul>
<p><img src="./images/逻辑回归4.png" alt="" /></p>
<p>&nbsp;<img src="./images/逻辑回归5.png" alt="" /></p>
<ul>
<li>综合完整损失函数</li>
</ul>
<p><img src="./images/逻辑回归6.png" alt="" /></p>
<p>eg.</p>
<p><img src="./images/逻辑回归7.png" alt="" /></p>
<p>【注】</p>
<p>log(P), P值越大，结果越小。</p>
<p>&nbsp;优化：</p>
<p>&nbsp;同样使用梯度下降优化算法，去减少损失函数的值。这样去更新逻辑回归前面对应算法的权重参数，<strong>提升原本属于1类别的概率，降低原本是0类别的概率。</strong></p>
<p>&nbsp;</p>
<p>二、API</p>
<ul>
<li>
<p>sklearn.linear_model.LogisticRegression(solver='liblinear', penalty=&lsquo;l2&rsquo;, C = 1.0)</p>
<ul>
<li>
<p>solver可选参数:{'liblinear', 'sag', 'saga','newton-cg', 'lbfgs'}，</p>
<ul>
<li>默认: 'liblinear'；用于优化问题的算法。</li>
<li>
<p>对于小数据集来说，&ldquo;liblinear&rdquo;是个不错的选择，而&ldquo;sag&rdquo;和'saga'对于大型数据集会更快。</p>
</li>
<li>
<p>对于多类问题，只有'newton-cg'， 'sag'， 'saga'和'lbfgs'可以处理多项损失;&ldquo;liblinear&rdquo;仅限于&ldquo;one-versus-rest&rdquo;分类。</p>
</li>
</ul>
</li>
<li>
<p>penalty：正则化的种类</p>
</li>
<li>
<p>C：正则化力度</p>
</li>
</ul>
</li>
</ul>
<p>【注】</p>
<p>默认将数量少的当做正例</p>
<p>LogisticRegression方法相当于 SGDClassifier(loss="log", penalty=" "),SGDClassifier实现了一个普通的随机梯度下降学习。而使用LogisticRegression(实现了SAG)</p>
<p>&nbsp;</p>
<p>三、分类评估方法</p>
<p>1.分类评估方法</p>
<p>&nbsp;精准率&amp;召回率</p>
<p>　　混淆矩阵</p>
<p>　　在分类任务下，预测结果(Predicted Condition)与正确标记(True Condition)之间存在四种不同的组合，构成混淆矩阵(适用于多分类)</p>
<p><img src="./images/逻辑回归8.png" alt="" /></p>
<p>&nbsp;</p>
<p>　　精确率（Precision）&amp;召回率（Recall）</p>
<p>　　&nbsp;　　精确率：预测结果为正例样本中真实为正例的比例</p>
<p><img src="./images/逻辑回归9.png" alt="" /></p>
<p>　　　　召回率：真实为正例的样本中预测结果为正例的比例（查得全，对正样本的区分能力）</p>
<p>&nbsp;<img src="./images/逻辑回归10.png" alt="" /></p>
<p>　　F1-score</p>
<p>　　　　还有其他的评估标准，F1-score，反映了模型的稳健型</p>
<p><img src="./images/逻辑回归11.png" alt="" /></p>
<p>　　分类评估报告API</p>
<ul>
<li>sklearn.metrics.classification_report(y_true, y_pred, labels=[], target_names=None )</li>
<li>
<ul>
<li>y_true：真实目标值</li>
<li>y_pred：估计器预测目标值</li>
<li>labels:指定类别对应的数字</li>
<li>target_names：目标类别名称</li>
<li>return：每个类别精确率与召回率</li>
</ul>
</li>
</ul>
<div class="cnblogs_Highlighter">
<pre><code>ret = classification_report(y_test, y_predict, labels=(2,4), target_names=("良性", "恶性"))
print(ret)
</pre>
</div>
<p>&nbsp;</p>
<p>2.ROC曲线&amp;AUC指标</p>
<p>TPR&amp;FPR：</p>
<ul>
<li>TPR = TP / (TP + FN)
<ul>
<li>所有真实类别为1的样本中，预测类别为1的比例</li>
</ul>
</li>
<li>FPR = FP / (FP + TN)
<ul>
<li>所有真实类别为0的样本中，预测类别为1的比例</li>
</ul>
</li>
</ul>
<p>&nbsp;ROC曲线</p>
<p>ROC曲线的横轴就是FPRate，纵轴就是TPRate，当二者相等时，表示的意义则是：对于不论真实类别是1还是0的样本，分类器预测为1的概率是相等的，此时AUC为0.5</p>
<p><img src="./images/逻辑回归12.png" alt="" /></p>
<p>AUC指标：</p>
<ul>
<li>AUC的概率意义是随机取一对正负样本，正样本得分大于负样本的概率</li>
<li>AUC的最小值为0.5，最大值为1，取值越高越好</li>
<li><strong>AUC=1，完美分类器，采用这个预测模型时，不管设定什么阈值都能得出完美预测。绝大多数预测的场合，不存在完美分类器。</strong></li>
<li><strong>0.5&lt;AUC&lt;1，优于随机猜测。这个分类器（模型）妥善设定阈值的话，能有预测价值。</strong></li>
</ul>
<p>【注】</p>
<p><strong>最终AUC的范围在[0.5, 1]之间，并且越接近1越好</strong></p>
<p>AUC计算API</p>
<p>from sklearn.metrics import roc_auc_score</p>
<ul>
<li>sklearn.metrics.roc_auc_score(y_true, y_score)
<ul>
<li>计算ROC曲线面积，即AUC值</li>
<li>y_true：每个样本的真实类别，必须为0(反例),1(正例)标记</li>
<li>y_score：预测得分，可以是正类的估计概率、置信值或者分类器方法的返回值</li>
</ul>
</li>
</ul>
<div class="cnblogs_Highlighter">
<pre><code># 0.5~1之间，越接近于1约好
y_test = np.where(y_test &gt; 2.5, 1, 0)

print("AUC指标：", roc_auc_score(y_test, y_predict)
</pre>
</div>
<p>3.总结</p>
<ul>
<li>AUC只能用来评价二分类</li>
<li>AUC非常适合评价样本不平衡中的分类器性能</li>
</ul>
<p>&nbsp;</p>
<p>四、ROC曲线绘制</p>
<p>1.如果概率的序列是（1:0.9,2:0.7,3:0.8,4:0.6,5:0.5,6:0.4）</p>
<p>序列如图：</p>
<p><img src="./images/逻辑回归13.png" alt="" /></p>
<p>步骤：</p>
<p>1）把概率序列从高到低排序，得到顺序（1:0.9,3:0.8,2:0.7,4:0.6,5:0.5,6:0.4）；</p>
<p>2）从概率最大开始取一个点作为正类，取到点1，计算得到TPR=0.5，FPR=0.0；</p>
<p>3）从概率最大开始，再取一个点作为正类，取到点3，计算得到TPR=1.0，FPR=0.0；</p>
<p>4）再从最大开始取一个点作为正类，取到点2，计算得到TPR=1.0，FPR=0.25;</p>
<p>5）以此类推，得到6对TPR和FPR。</p>
<p>然后把这6对数据组成6个点(0,0.5),(0,1.0),(0.25,1),(0.5,1),(0.75,1),(1.0,1.0)。</p>
<p>这6个点在二维坐标系中能绘出来。</p>
<p><img src="./images/逻辑回归14.png" alt="" /></p>
<p>2.如果概率的序列是（1:0.9,2:0.8,3:0.7,4:0.6,5:0.5,6:0.4）</p>
<p>序列如图：</p>
<p>&nbsp;<img src="./images/逻辑回归15.png" alt="" /></p>
<p>步骤：</p>
<p>1）把概率序列从高到低排序，得到顺序（1:0.9,2:0.8,3:0.7,4:0.6,5:0.5,6:0.4）；</p>
<p>2）从概率最大开始取一个点作为正类，取到点1，计算得到TPR=0.5，FPR=0.0；</p>
<p>3）从概率最大开始，再取一个点作为正类，取到点2，计算得到TPR=0.5，FPR=0.25；</p>
<p>4）再从最大开始取一个点作为正类，取到点3，计算得到TPR=1.0，FPR=0.25;</p>
<p>5）以此类推，得到6对TPR和FPR。</p>
<p>然后把这6对数据组成6个点(0,0.5),(0.25,0.5),(0.25,1),(0.5,1),(0.75,1),(1.0,1.0)。</p>
<p>这6个点在二维坐标系中能绘出来。</p>
<p><img src="./images/逻辑回归16.png" alt="" /></p>
<p>3.如果概率的序列是（1:0.4,2:0.6,3:0.5,4:0.7,5:0.8,6:0.9）</p>
<p>序列如图：</p>
<p>&nbsp;<img src="./images/逻辑回归17.png" alt="" /></p>
<p>步骤：</p>
<p>1）把概率序列从高到低排序，得到顺序（6:0.9,5:0.8,4:0.7,2:0.6,3:0.5,1:0.4）；</p>
<p>2）从概率最大开始取一个点作为正类，取到点6，计算得到TPR=0.0，FPR=0.25；</p>
<p>3）从概率最大开始，再取一个点作为正类，取到点5，计算得到TPR=0.0，FPR=0.5；</p>
<p>4）再从最大开始取一个点作为正类，取到点4，计算得到TPR=0.0，FPR=0.75;</p>
<p>5）以此类推，得到6对TPR和FPR。</p>
<p>然后把这6对数据组成6个点(0.25,0.0),(0.5,0.0),(0.75,0.0),(1.0,0.0),(1.0,0.5),(1.0,1.0)。</p>
<p>这6个点在二维坐标系中能绘出来。</p>
<p><img src="./images/逻辑回归18.png" alt="" /></p>
<p>4.意义</p>
<p>如上图的例子，总共6个点，2个正样本，4个负样本，取一个正样本和一个负样本的情况总共有8种。</p>
<p>上面的第一种情况，从上往下取，无论怎么取，正样本的概率总在负样本之上，所以分对的概率为1，AUC=1。再看ROC曲线，它的积分是什么？也是1，ROC曲线的积分与AUC相等。</p>
<p>上面第二种情况，如果取到了样本2和3，那就分错了，其他情况都分对了；所以分对的概率是0.875，AUC=0.875。再看ROC曲线，它的积分也是0.875，ROC曲线的积分与AUC相等。</p>
<p>上面的第三种情况，无论怎么取，都是分错的，所以分对的概率是0，AUC=0.0。再看ROC曲线，它的积分也是0.0，ROC曲线的积分与AUC相等。</p>
<p>很牛吧，其实AUC的意思是&mdash;&mdash;Area Under roc Curve，就是ROC曲线的积分，也是ROC曲线下面的面积。</p>
<p>绘制ROC曲线的意义很明显，不断地把可能分错的情况扣除掉，从概率最高往下取的点，每有一个是负样本，就会导致分错排在它下面的所有正样本，所以要把它下面的正样本数扣除掉（1-TPR，剩下的正样本的比例）。总的ROC曲线绘制出来了，AUC就定了，分对的概率也能求出来了。</p>
<p>&nbsp;</p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>