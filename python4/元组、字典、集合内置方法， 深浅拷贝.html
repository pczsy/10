<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修元组、字典、集合内置方法， 深浅拷贝' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>元组、字典、集合内置方法， 深浅拷贝</center></div><div class='banquan'>原文出处:本文由博客园博主SetCreed提供。<br/>
原文连接:https://www.cnblogs.com/setcreed/p/11544687.html</div><br>
    <div class="toc">
    <p class="toc-title">目录</p>
    <div class="toc-list">
        <ul>
        <li><a href="#元组内置方法">元组内置方法</a><ul>
        <li><a href="#作用">作用</a></li>
        <li><a href="#定义方式">定义方式</a></li>
        <li><a href="#使用方法">使用方法</a></li>
        <li><a href="#有序or无序">有序or无序</a></li>
        <li><a href="#可变or不可变">可变or不可变</a></li>
        </ul></li>
        <li><a href="#字典内置方法">字典内置方法</a><ul>
        <li><a href="#作用-1">作用</a></li>
        <li><a href="#定义方式-1">定义方式</a></li>
        <li><a href="#使用方法-1">使用方法</a></li>
        <li><a href="#有序or无序-1">有序or无序</a></li>
        <li><a href="#可变or不可变-1">可变or不可变</a></li>
        </ul></li>
        <li><a href="#集合内置方法">集合内置方法</a><ul>
        <li><a href="#作用-2">作用</a></li>
        <li><a href="#定义方式-2">定义方式</a></li>
        <li><a href="#使用方法-2">使用方法</a></li>
        <li><a href="#有序or无序-2">有序or无序</a></li>
        <li><a href="#可变or不可变-2">可变or不可变</a></li>
        </ul></li>
        <li><a href="#数据类型总结">数据类型总结</a><ul>
        <li><a href="#存值个数">存值个数</a></li>
        <li><a href="#有序or无序-3">有序or无序</a></li>
        <li><a href="#可变or不可变-3">可变or不可变</a></li>
        </ul></li>
        <li><a href="#深浅拷贝">深浅拷贝</a><ul>
        <li><a href="#可变or不可变-4">可变or不可变</a></li>
        <li><a href="#拷贝">拷贝</a></li>
        <li><a href="#浅拷贝">浅拷贝</a></li>
        <li><a href="#深拷贝对象">深拷贝对象</a></li>
        </ul></li>
        </ul>
    </div>
</div>
<h1 id="元组内置方法">元组内置方法</h1>
<h2 id="作用">作用</h2>
<p>元组可以看成只可取不可修改的列表，元组一创建就被写死了</p>
<h2 id="定义方式">定义方式</h2>
<p>()内用逗号隔开多个元素（可以为任意数据类型）</p>
<pre><code><code>tup = tuple((1, 2, 3))
print(tup, type(tup))

# 如果元组只有一个元素，必须得加逗号
tup1 = (1,)
print(tup1, type(tup1))</code></pre>
<h2 id="使用方法">使用方法</h2>
<pre><code><code>tup = (1,2,3,4,5,)

# 1.索引取值
print(tup[1])   # 2

# 2.切片
print(tup[1:4])  # (2, 3, 4)

# 3.for循环
for i in tup:
    print(tup)
    
# 4.len长度
print(len(tup))   # 5

# 5.in / not in
print(0 in tup)   # False

# 6.index获取索引
print(tup.index(1))   # 0

# 7.count计数
print(tup.count(1))   # 1</code></pre>
<h2 id="有序or无序">有序or无序</h2>
<p>元组能索引取值，是有序的</p>
<h2 id="可变or不可变">可变or不可变</h2>
<p>算是不可变吧</p>
<h1 id="字典内置方法">字典内置方法</h1>
<h2 id="作用-1">作用</h2>
<p>存储多个值，对每个数据有描述意义</p>
<h2 id="定义方式-1">定义方式</h2>
<p>{}内用逗号隔开多个键key(具有描述意义，不能为可变数据类型):值value（任意数据类型）</p>
<h2 id="使用方法-1">使用方法</h2>
<pre><code><code>dic = {&#39;a&#39;:1, &#39;b&#39;:2}

# 1.按key取值
print(dic[&#39;a&#39;])  # 1

# 2.按key修改值
dic[&#39;a&#39;] = 666
print(dic)  #  {&#39;a&#39;: 666, &#39;b&#39;: 2}

dic[&#39;c&#39;] = 3   # 没有就加值
print(dic)   # {&#39;a&#39;: 666, &#39;b&#39;: 2, &#39;c&#39;: 3}

# 3.for循环
for i in dic:
    print(i)  # 只能取到key值
    
# 4.in / not in 
print(&#39;a&#39; in dic)   # True

# 5.len
print(len(dic))   # 3

# 6.keys/values/items 
print(dic.keys())      # dict_keys([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])
print(dic.values())    # dict_values([666, 2, 3])
print(dic.items())     # dict_items([(&#39;a&#39;, 666), (&#39;b&#39;, 2), (&#39;c&#39;, 3)])

# 7.get
print(dic.get(&#39;a&#39;))   # get取值，如果没有返回None

# 8.update
dic1 = {&#39;a&#39;: 1, &#39;c&#39;: 2}
dic2 = {&#39;b&#39;: 1, &#39;d&#39;: 2}
dic1.update(dic2)
print(dic1)   # {&#39;a&#39;: 1, &#39;c&#39;: 2, &#39;b&#39;: 1, &#39;d&#39;: 2}

# 9.fromkeys  创建一个新字典，如没有value值，默认None
print(dic.fromkeys([&#39;a&#39;,&#39;b&#39;,&#39;c&#39;], 1))   # {&#39;a&#39;: 1, &#39;b&#39;: 1, &#39;c&#39;: 1}

# 10.# setdefault  # 字典有这个key，就不修改，没有则增加
dic.setdefault(&#39;j&#39;, 2)
dic.setdefault(&#39;a&#39;, 2)
print(dic)</code></pre>
<h2 id="有序or无序-1">有序or无序</h2>
<p>字典无序</p>
<h2 id="可变or不可变-1">可变or不可变</h2>
<p>字典可变</p>
<h1 id="集合内置方法">集合内置方法</h1>
<h2 id="作用-2">作用</h2>
<p>进行 交集 / 并集 / 补集等运算，可以去重，但是集合内元素是乱序的</p>
<h2 id="定义方式-2">定义方式</h2>
<p>{}内以逗号隔开多个元素（不能可为变数据类型）</p>
<pre><code><code>s = {&#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;a&#39;, 1, &#39;v&#39;, 2, 2, &#39;c&#39;, 3, 3, 4, 5, 6}  # 对于数字而言，不会乱序；但是对于其他，就乱序
print(s)
# {1, 2, &#39;a&#39;, 3, 4, 5, 6, &#39;v&#39;, &#39;c&#39;}</code></pre>
<h2 id="使用方法-2">使用方法</h2>
<p><img src="./images/元组、字典、集合内置方法， 深浅拷贝0.png" /></p>
<pre><code><code>se1 = {&#39;cwz&#39;, &#39;neo&#39;, &#39;woods&#39;}
se2 = {&#39;reese&#39;, &#39;chars&#39;, &#39;cwz&#39;}

# 1.并集
print(se1 | se2)    # {&#39;neo&#39;, &#39;reese&#39;, &#39;cwz&#39;, &#39;woods&#39;, &#39;chars&#39;}

# 2.交集
print(se1 &amp; se2)    # {&#39;cwz&#39;}

# 3. 差集
print(se1 - se2)    # {&#39;neo&#39;, &#39;woods&#39;}

# 4.补集
print(se1 ^ se2)   # {&#39;reese&#39;, &#39;chars&#39;, &#39;neo&#39;, &#39;woods&#39;}

# 5.add
se1.add(&#39;sad&#39;)
print(se1)          # {&#39;neo&#39;, &#39;sad&#39;, &#39;woods&#39;, &#39;cwz&#39;}

# 6.remove / discard
se1.remove(&#39;neo&#39;)  # 没有的，删除用remove会报错
print(se1)            # {&#39;sad&#39;, &#39;woods&#39;, &#39;cwz&#39;}

se2.discard(&#39;chars&#39;)  # 没有的，删除用discard不会报错
print(se2)            # {&#39;cwz&#39;, &#39;reese&#39;}

# 7.pop
se1.pop()   # 随机删除值
print(se1)  # {&#39;woods&#39;, &#39;cwz&#39;}</code></pre>
<h2 id="有序or无序-2">有序or无序</h2>
<p>无序</p>
<h2 id="可变or不可变-2">可变or不可变</h2>
<p>可变</p>
<h1 id="数据类型总结">数据类型总结</h1>
<h2 id="存值个数">存值个数</h2>
<ul>
<li>存一个值：整型 / 浮点型 / 字符串</li>
<li>存多个值：列表 / 元组 / 字典 / 集合</li>
</ul>
<h2 id="有序or无序-3">有序or无序</h2>
<ul>
<li>有序：字符串 / 列表 / 元组</li>
<li>无序：字典 / 集合</li>
</ul>
<h2 id="可变or不可变-3">可变or不可变</h2>
<ul>
<li>可变：列表 / 字典 / 集合</li>
<li>不可变：整型 / 浮点型 / 字符串 / 元组</li>
</ul>
<h1 id="深浅拷贝">深浅拷贝</h1>
<h2 id="可变or不可变-4">可变or不可变</h2>
<p>id值不可变，就是在原值基础上修改，为可变数据类型；</p>
<p>id值变化，就是重新申请一块内存空间放入新值，为不可变数据类型。</p>
<h2 id="拷贝">拷贝</h2>
<p>如果lt2是lt1的拷贝对象，则lt1内任何数据类型的元素变化，lt2也跟着变化。</p>
<pre><code><code>lt1 = [1,2,3,4,&#39;a&#39;,[1,23,5]]
lt2 = lt1
print(lt1)
print(&#39;lt1_id: &#39;, id(lt1))
lt1.append(&#39;b&#39;)
print(&#39;*&#39;*50)
print(lt1)
print(&#39;lt1_id: &#39;, id(lt1))
print(lt2)
print(&#39;lt2_id: &#39;, id(lt2))

# 打印结果：
[1, 2, 3, 4, &#39;a&#39;, [1, 23, 5]]
lt1_id:  1990616507080
**************************************************
[1, 2, 3, 4, &#39;a&#39;, [1, 23, 5], &#39;b&#39;]
lt1_id:  1990616507080
[1, 2, 3, 4, &#39;a&#39;, [1, 23, 5], &#39;b&#39;]
lt2_id:  1990616507080</code></pre>
<h2 id="浅拷贝">浅拷贝</h2>
<p>如果lt2是lt1的浅拷贝对象，则lt1内的不可变元素发生了变化，lt2不变；</p>
<p>如果lt1内的可变元素发生了改变，则lt2跟着改变</p>
<pre><code><code>import copy

lt1 = [1, 2, 3, 4, &#39;a&#39;, [1, 23, 5]]
lt2 = copy.copy(lt1)
lt1.append(99)
print(&#39;lt1: &#39;, lt1)
print(&#39;lt1_id: &#39;, id(lt1))
print(&#39;lt2: &#39;, lt2)
print(&#39;lt2_id: &#39;, id(lt2))
print(&#39;*&#39;*50)
lt1[5].append(&#39;qq&#39;)
print(&#39;lt1[5]: &#39;, lt1)
print(&#39;lt1[5]_id: &#39;, id(lt1))
print(&#39;lt2: &#39;, lt2)
print(&#39;lt2_id: &#39;, id(lt2))

# 打印结果：
lt1:  [1, 2, 3, 4, &#39;a&#39;, [1, 23, 5], 99]
lt1_id:  2049177903816
lt2:  [1, 2, 3, 4, &#39;a&#39;, [1, 23, 5]]
lt2_id:  2049299510728
**************************************************
lt1[5]:  [1, 2, 3, 4, &#39;a&#39;, [1, 23, 5, &#39;qq&#39;], 99]
lt1[5]_id:  2049177903816
lt2:  [1, 2, 3, 4, &#39;a&#39;, [1, 23, 5, &#39;qq&#39;]]
lt2_id:  2049299510728</code></pre>
<h2 id="深拷贝对象">深拷贝对象</h2>
<p>如果lt2是lt1的深拷贝对象，则lt1内的不可变数据类型元素改变，lt2不变；</p>
<p>如果lt1内的可变数据类型元素改变，lt2不变</p>
<pre><code><code>import copy

lt1 = [1, 2, 3, [4, 5, 6]]
lt2 = copy.deepcopy(lt1)

print(&#39;id(lt1)&#39;, id(lt1))
print(id(lt1[0]))
print(id(lt1[1]))
print(id(lt1[2]))
print(id(lt1[3]))
print(id(lt1[3][0]))
print(id(lt1[3][1]))
print(id(lt1[3][2]))

print(&#39;*&#39; * 50)

print(&#39;id(lt2)&#39;, id(lt2))
print(id(lt2[0]))
print(id(lt2[1]))
print(id(lt2[2]))
print(id(lt2[3]))
print(id(lt2[3][0]))
print(id(lt2[3][1]))
print(id(lt2[3][2]))

# 打印结果：
id(lt1) 2156612313800
140728121221968
140728121222000
140728121222032
2156612313736
140728121222064
140728121222096
140728121222128
**************************************************
id(lt2) 2156760304520
140728121221968
140728121222000
140728121222032
2156642018504
140728121222064
140728121222096
140728121222128</code></pre>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>