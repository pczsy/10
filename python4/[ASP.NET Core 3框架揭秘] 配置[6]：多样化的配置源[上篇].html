<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修[ASP.NET Core 3框架揭秘] 配置[6]：多样化的配置源[上篇]' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>[ASP.NET Core 3框架揭秘] 配置[6]：多样化的配置源[上篇]</center></div><div class='banquan'>原文出处:本文由博客园博主Artech提供。<br/>
原文连接:https://www.cnblogs.com/artech/p/inside-asp-net-core-05-06.html</div><br>
    <p>.NET Core采用的这个全新的配置模型的一个主要的特点就是对多种不同配置源的支持。我们可以将内存变量、命令行参数、环境变量和物理文件作为原始配置数据的来源。如果采用物理文件作为配置源，我们可以选择不同的格式(比如XML、JSON和INI等)。如果这些默认支持的配置源形式还不能满足你的需求，我们还可以通过注册自定义IConfigurationSource的方式将其他形式数据作为配置来源。</p><h1><font size="4">一、MemoryConfigurationSource</font></h1><p>在之前的实例演示都在使用MemoryConfigurationSource来提供原始的配置。我们知道MemoryConfigurationSource配置源采用一个字典对象（具体来说应该是一个元素类型为<font color="#ff0000">KeyValuePair&lt;string, string&gt;</font>的集合）作为存放原始配置数据的容器。作为一个IConfigurationSource对象，它总是通过创建某个对应的IConfigurationProvider对象来完成具体的配置数据读取工作，那么MemoryConfigurationSource会提供一个怎样的IConfigurationProvider呢？</p><div class="cnblogs_code" style="padding: 5px; border: 1px solid #cccccc; border-image: none; background-color: #f5f5f5;"><pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> MemoryConfigurationSource : IConfigurationSource
{
    </span><span style="color: #0000ff;">public</span> IEnumerable&lt;KeyValuePair&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">string</span>&gt;&gt; InitialData { <span style="color: #0000ff;">get</span>; <span style="color: #0000ff;">set</span><span style="color: #000000;">; }
    </span><span style="color: #0000ff;">public</span> IConfigurationProvider Build(IConfigurationBuilder builder) =&gt; <span style="color: #0000ff;">new</span> MemoryConfigurationProvider(<span style="color: #0000ff;">this</span><span style="color: #000000;">);
}</span></pre></div><p>上面给出的代码片段体现了MemoryConfigurationSource的完整定义，我们可以看到它具有一个IEnumerable&lt;KeyValuePair&lt;string, string&gt;&gt;类型的属性<font color="#ff0000">InitialData</font>来存放初始的配置数据。从Build方法的实现可以看出，真正被它用来读取原始配置数据的是一个MemoryConfigurationProvider类型的对象，该类型的定义如下面的代码片段所示。</p><div class="cnblogs_code" style="padding: 5px; border: 1px solid #cccccc; border-image: none; background-color: #f5f5f5;"><pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> MemoryConfigurationProvider : ConfigurationProvider,  IEnumerable&lt;KeyValuePair&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">string</span>&gt;&gt;<span style="color: #000000;">
{
    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> MemoryConfigurationProvider(MemoryConfigurationSource source);
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> Add(<span style="color: #0000ff;">string</span> key, <span style="color: #0000ff;">string</span><span style="color: #000000;"> value);
    </span><span style="color: #0000ff;">public</span> IEnumerator&lt;KeyValuePair&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">string</span>&gt;&gt;<span style="color: #000000;"> GetEnumerator();
    IEnumerator IEnumerable.GetEnumerator();
}</span></pre></div><p>从上面的代码片段可以看出，MemoryConfigurationProvider派生于抽象类ConfigurationProvider，同时还实现了IEnumerable&lt;KeyValuePair&lt;string, string&gt;&gt;接口。我们知道ConfigurationProvider对象直接使用一个Dictionary&lt;string, string&gt;来保存配置数据，当我们根据一个MemoryConfigurationSource对象调用构造函数创建MemoryConfigurationProvider的时候，它只需要将通过InitialData属性保存的配置数据转移到这个字典中即可。MemoryConfigurationProvider还定义了一个Add方法使我们可以在任何时候都可以向配置字典中添加一个新的配置项。</p><p>通过前面对配置模型的介绍，我们知道IConfigurationProvider对象在配置模型中所起的作用就是<font color="#ff0000">读取原始的配置数据并将其转换成配置字典</font>。在所有的预定义的IConfigurationProvider实现类型中，MemoryConfigurationProvider最为简单直接，因为它对应的配置源就是一个配置字典，所以根本不需要作任何的结构转换。</p><p>在利用MemoryConfigurationSource生成配置的时候，我们需要将它注册到IConfigurationBuilder对象之上。具体来说，我们可以像前面演示的实例一样直接调用IConfigurationBuilder接口的Add方法，也可以调用如下所示的两个重载的AddInMemoryCollection扩展方法。</p><div class="cnblogs_code" style="padding: 5px; border: 1px solid #cccccc; border-image: none; background-color: #f5f5f5;"><pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> MemoryConfigurationBuilderExtensions
{
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> IConfigurationBuilder AddInMemoryCollection(  <span style="color: #0000ff;">this</span><span style="color: #000000;"> IConfigurationBuilder configurationBuilder);
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> IConfigurationBuilder AddInMemoryCollection(  <span style="color: #0000ff;">this</span> IConfigurationBuilder configurationBuilder,   IEnumerable&lt;KeyValuePair&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">string</span>&gt;&gt;<span style="color: #000000;"> initialData);
}</span></pre></div><h1><font size="4">二、EnvironmentVariablesConfigurationSource</font></h1><p>顾名思义，环境变量就是描述当前执行环境并影响进程执行行为的变量。按照作用域的不同，我们将环境变量划分成三类，即分别针对当前系统、当前用户和当前进程的环境变量。对于Windows系统来说，系统和用户级别的环境变量保存在注册表中，其路径分别为&#8220;HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Session Manager\Environment&#8221;和&#8220;HKEY_CURRENT_USER\Environment &#8221;。</p><p>环境变量的提取和维护可以通过静态类型Environment来完成。具体来说，我们可以调用它的静态方法<font color="#ff0000">GetEnvironmentVariable</font>获得某个指定名称的环境变量的值，而<font color="#ff0000">GetEnvironmentVariables</font>方法则会返回所有的环境变量，EnvironmentVariableTarget枚举类型的参数代表环境变量作用域决定的存储位置。如果在调用GetEnvironmentVariable或者GetEnvironmentVariables方法时没有显式指定target参数或者将参数指定为EnvironmentVariableTarget.Process，在进程初始化前存在的所有环境变量（包括针对系统、当前用户和当前进程）将会作为候选列表。</p><div class="cnblogs_code" style="padding: 5px; border: 1px solid #cccccc; border-image: none; background-color: #f5f5f5;"><pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Environment
{
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">string</span> GetEnvironmentVariable(<span style="color: #0000ff;">string</span><span style="color: #000000;"> variable);
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">string</span> GetEnvironmentVariable(<span style="color: #0000ff;">string</span><span style="color: #000000;"> variable,  EnvironmentVariableTarget target);

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span><span style="color: #000000;"> IDictionary GetEnvironmentVariables();
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span><span style="color: #000000;"> IDictionary GetEnvironmentVariables( EnvironmentVariableTarget target);

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> SetEnvironmentVariable(<span style="color: #0000ff;">string</span> variable, <span style="color: #0000ff;">string</span><span style="color: #000000;"> value);
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> SetEnvironmentVariable(<span style="color: #0000ff;">string</span> variable, <span style="color: #0000ff;">string</span><span style="color: #000000;"> value,  EnvironmentVariableTarget target);
}

</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">enum</span><span style="color: #000000;"> EnvironmentVariableTarget
{
      Process,
      User,
      Machine
}</span></pre></div><p>环境变量的添加、修改和删除均由SetEnvironmentVariable方法来完成，如果没有显式指定target参数，默认采用的是EnvironmentVariableTarget.Process。如果希望删除指定名称的环境变量，我们只需要在调用这个方法的时候将value参数设置为Null或者空字符串即可。</p><p>除了在程序中利用静态类型Environment，我们还可以采用命令行的方式查看和设置环境变量。除此之外，我们在<font color="#ff0000">开发环境</font>中还可以利用&#8220;系统属性（System Properties）&#8221;设置工具以可视化的方式查看和设置系统和用户级别的环境变量（&#8220;This PC&#8221;&gt;&#8220;Properties&#8221;&gt;&#8220;Change Settings&#8221;&gt;&#8220;Advanced&#8221;&gt;&#8220;Environment Variables&#8221;）。如果采用Visual Studio 来调试我们编写的应用，我们可以采用设置项目属性的方式来设置进程级别的环境变量（&#8220;Properties&#8221; &gt; &#8220;Debug&#8221;&gt; &#8220;Environment Variables&#8221; ）。在第1章 &#8220;全新的开发体验&#8221; 中我们提到过，设置的环境变量会被保存到<font color="#ff0000">launchSettings.json</font>文件中。</p><p><a href="https://img2018.cnblogs.com/blog/19327/201912/19327-20191219084221290-91952509.png"><img width="353" height="166" title="6-16、" style="border: 0px currentcolor; border-image: none; display: inline; background-image: none;" alt="6-16、" src="./images/[ASP.NET Core 3框架揭秘] 配置[6]：多样化的配置源[上篇]0.png" border="0" /></a></p><p>针对环境变量的配置源通过如下这个 EnvironmentVariablesConfigurationSource类型来表示，该类型定义在NuGet包&#8220;Microsoft.Extensions.Configuration.EnvironmentVariables&#8221;之中。该类型定义了一个字符串类型的属性Prefix，它表示环境变量名的前缀。如果我们设置了这个Prefix属性，系统只会选择名称以此作为前缀的环境变量。</p><div class="cnblogs_code" style="padding: 5px; border: 1px solid #cccccc; border-image: none; background-color: #f5f5f5;"><pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> EnvironmentVariablesConfigurationSource : IConfigurationSource
{
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">string</span> Prefix { <span style="color: #0000ff;">get</span>; <span style="color: #0000ff;">set</span><span style="color: #000000;">; }
    </span><span style="color: #0000ff;">public</span> IConfigurationProvider Build(IConfigurationBuilder builder)=&gt; <span style="color: #0000ff;">new</span><span style="color: #000000;"> EnvironmentVariablesConfigurationProvider(Prefix);
}</span></pre></div><p>通过前面给出的代码片段我们可以看出EnvironmentVariablesConfigurationSource配置源会利用对应的EnvironmentVariablesConfigurationProvider对象来读取环境变量，此操作体现在如下所示的Load方法中。由于环境变量本身就是一个数据字典，所以EnvironmentVariables<br />ConfigurationProvider对象无需再进行结构上的转换。当Load方法被执行之后，它只需要将符合条件的环境变量筛选出来并添加到自己的配置字典中即可。</p><div class="cnblogs_code" style="padding: 5px; border: 1px solid #cccccc; border-image: none; background-color: #f5f5f5;"><pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> EnvironmentVariablesConfigurationProvider : ConfigurationProvider
{
    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">readonly</span> <span style="color: #0000ff;">string</span><span style="color: #000000;"> _prefix;
    </span><span style="color: #0000ff;">public</span> EnvironmentVariablesConfigurationProvider(<span style="color: #0000ff;">string</span> prefix = <span style="color: #0000ff;">null</span>) =&gt;  _prefix = prefix ?? <span style="color: #0000ff;">string</span><span style="color: #000000;">.Empty;
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">override</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> Load()
    {
        </span><span style="color: #0000ff;">var</span> dictionary =<span style="color: #000000;"> Environment.GetEnvironmentVariables()
            .Cast</span>&lt;DictionaryEntry&gt;<span style="color: #000000;">()
            .Where(it </span>=&gt;<span style="color: #000000;"> it.Key.ToString().StartsWith( _prefix, StringComparison.OrdinalIgnoreCase))
            .ToDictionary(it </span>=&gt; it.Key.ToString().Substring(_prefix.Length),   it =&gt;<span style="color: #000000;"> it.Value.ToString());
        Data </span>= <span style="color: #0000ff;">new</span> Dictionary&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;">( dictionary, StringComparer.OrdinalIgnoreCase);
    }
}</span></pre></div><p>值得一提的是，如果我们在创建EnvironmentVariablesConfigurationProvider对象时指定了用于筛选环境变量的前缀，当符合条件的环境变量被添加到自身的配置字典之后，<font color="#ff0000">配置项的名称会将此前缀剔除</font>。比如前缀设置为&#8220;FOO_&#8221;，环境变量&#8220;FOO_BAR&#8221;被添加到配置字典之后，配置项 名称会变成&#8220;BAR&#8221;，这个细节也体现在上面定义的Load方法中。</p><p>在使用EnvironmentVariablesConfigurationSource的时候，我们可以调用Add方法将它注册到指定的IConfigurationBuilder对象上。除此之外，EnvironmentVariablesConfigurationSource的注册还可以直接调用IConfigurationBuilder接口的如下三个重载的扩展方法AddEnvironmentVariables来完成。</p><div class="cnblogs_code" style="padding: 5px; border: 1px solid #cccccc; border-image: none; background-color: #f5f5f5;"><pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> EnvironmentVariablesExtensions
{
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> IConfigurationBuilder AddEnvironmentVariables(  <span style="color: #0000ff;">this</span><span style="color: #000000;"> IConfigurationBuilder configurationBuilder);
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> IConfigurationBuilder AddEnvironmentVariables(  <span style="color: #0000ff;">this</span> IConfigurationBuilder builder,  Action&lt;EnvironmentVariablesConfigurationSource&gt;<span style="color: #000000;"> configureSource);
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> IConfigurationBuilder AddEnvironmentVariables(  <span style="color: #0000ff;">this</span> IConfigurationBuilder configurationBuilder, <span style="color: #0000ff;">string</span><span style="color: #000000;"> prefix);
}</span></pre></div><p>我们照例编写一个简单的实例来演示如何利用环境变量作为配置源。如下面的代码片段所示，我们调用Environment的静态方法SetEnvironmentVariable方法设置了四个环境变量，变量名称具有相同的前缀TEST_。我们调用方法AddEnvironmentVariables创建一个Environment<br />VariablesConfigurationSource对象并将其注册到创建的<a>ConfigurationBuilder</a> 之上，在调用该方法时我们将环境变量名称前缀 设置为 &#8220;TEST_&#8221;。我们最终将由ConfigurationBuilder构建出的IConfiguration对象绑定成一个Profile对象。</p><div class="cnblogs_code" style="padding: 5px; border: 1px solid #cccccc; border-image: none; background-color: #f5f5f5;"><pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Program
{
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> Main()
    {
        Environment.SetEnvironmentVariable(</span><span style="color: #800000;">"</span><span style="color: #800000;">TEST_GENDER</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">Male</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        Environment.SetEnvironmentVariable(</span><span style="color: #800000;">"</span><span style="color: #800000;">TEST_AGE</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">18</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        Environment.SetEnvironmentVariable(</span><span style="color: #800000;">"</span><span style="color: #800000;">TEST_CONTACTINFO:EMAILADDRESS</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">foobar@outlook.com</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        Environment.SetEnvironmentVariable(</span><span style="color: #800000;">"</span><span style="color: #800000;">TEST_CONTACTINFO:PHONENO</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">123456789</span><span style="color: #800000;">"</span><span style="color: #000000;">);

        </span><span style="color: #0000ff;">var</span> profile = <span style="color: #0000ff;">new</span><span style="color: #000000;"> ConfigurationBuilder()
            .AddEnvironmentVariables(</span><span style="color: #800000;">"</span><span style="color: #800000;">TEST_</span><span style="color: #800000;">"</span><span style="color: #000000;">)
            .Build()
            .Get</span>&lt;Profile&gt;<span style="color: #000000;">();

        Debug.Assert(profile.Equals(</span><span style="color: #0000ff;">new</span> Profile(Gender.Male, <span style="color: #800080;">18</span>, <span style="color: #800000;">"</span><span style="color: #800000;">foobar@outlook.com</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">123456789</span><span style="color: #800000;">"</span><span style="color: #000000;">)));
    }
}</span></pre></div><h1><font size="4">三、CommandLineConfigurationSource<strong>对象</strong></font></h1><p>在很多情况下，我们会采用Self-Host的方式将一个ASP.NET Core应用寄宿到一个托管进程中，在这种情况下我们倾向于采用命令行的方式来启动寄宿程序。当以命令行的形式启动一个ASP.NET Core应用时，我们希望直接使用命名行开关（Switch）来控制应用的一些行为，所以命令行开关自然也就成为了配置常用的来源之一。配置模型针对这种配置源的支持是通过CommandLineConfigurationSource来实现的，该类型定义在NuGet包 &#8220;Microsoft.Extensions.Configuration.CommandLine&#8221;中。</p><p>在以命令行的形式执行某个命令的时候，命令行开关（包括名称和值）体现为一个简单的字符串数组，所以CommandLineConfigurationSource的根本目的在于将命名行开关从字符串数组转换成配置字典。要充分理解这个转换规则，我们先得来了解一下CommandLine<br />ConfigurationSource支持的命令行开关究竟采用怎样的形式来指定。我们通过一个简单的实例来说明命令行开关的几种指定方式。假设我们有一个命令&#8220;exec&#8221;并采用如下所示的方式执行某个托管程序（app）。</p><div class="cnblogs_code" style="padding: 5px; border: 1px solid #cccccc; border-image: none; background-color: #f5f5f5;"><pre><code>exec app {options}</pre></div><p>在执行这个命令的时候我们通过相应的命令行开关指定多个选项。总的来说，命令行开关的指定形式大体上分为两种，我将它们称为&#8220;<font color="#ff0000">单参数（Single Argument</font>）&#8221;和&#8220;<font color="#ff0000">双参数（Double Arguments）</font>&#8221;。所谓单参数形式就是采用<font color="#ff0000">等号</font>（&#8220;=&#8221;）将命令行开关的名称和值通过如下方法采用一个参数来指定。</p><div class="cnblogs_code" style="padding: 5px; border: 1px solid #cccccc; border-image: none; background-color: #f5f5f5;"><pre><code>{name}=<span style="color: #000000;">{value}
{prefix}{name}</span>={value}</pre></div><p>对于第二种单参数命令行开关的指定形式，我们可以在开关名称前面添加一个前缀，目前的前缀支持&#8220;<font color="#ff0000">/</font>&#8221;、&#8220;<font color="#ff0000">--</font>&#8221;和&#8220;<font color="#ff0000">-</font>&#8221;三种。遵循这样的格式，我们可以采用如下三种方式将命令行开关architecture设置为&#8220;x64&#8221;。下面的列表之所以没有使用&#8220;-&#8221;前缀，是因为这个前缀要求使用&#8220;命令行开关映射（Switch Mapping）&#8221;，我们稍后会对此作单独介绍。</p><div class="cnblogs_code" style="padding: 5px; border: 1px solid #cccccc; border-image: none; background-color: #f5f5f5;"><pre><code>exec app architecture=<span style="color: #000000;">x64
exec app </span>/architecture=<span style="color: #000000;">x64
exec app </span>--architecture=x64</pre></div><p>除了采用单参数形式，我们还可以采用双参数形式来指定命令行开关，所谓的&#8220;双参数&#8221;就是使用两个参数分别定义命令行开关的名称和值。这种形式采用的具体格式为&#8220;{prefix}{name} {value}&#8221;，所以上述的这个命令行开关architecture也可以采用如下的方式来指定。</p><div class="cnblogs_code" style="padding: 5px; border: 1px solid #cccccc; border-image: none; background-color: #f5f5f5;"><pre><code>exec app /<span style="color: #000000;">architecture x64
exec app &#8211;</span>-architecture x64</pre></div><p>命令行开关的全名和缩写之间具有一个<font color="#ff0000">映射关系（Switch Mapping）</font>。以上述的这两个命令行开关为例，我们可以采用首字母&#8220;a&#8221;来代替&#8220;architecture&#8221;。如果使用&#8220;-&#8221;作为前缀，不论采用单参数还是双参数形式，都必须使用映射后的开关名称。值得一提的是，同一个命令行开关可以具有多个映射，比如我们也可以同时将&#8220;architecture&#8221;映射为&#8220;arch&#8221;。假设&#8220;architecture&#8221;具有了这两种映射，我们就可以按照如下两种方式指定CPU架构。</p><div class="cnblogs_code" style="padding: 5px; border: 1px solid #cccccc; border-image: none; background-color: #f5f5f5;"><pre><code>exec app -a=<span style="color: #000000;">x64
exec app </span>-arch=<span style="color: #000000;">x64
exec app </span>-<span style="color: #000000;">a x64
exec app </span>-arch x64</pre></div><p>在了解了命令行开关的指定形式之后，我们接着来说说CommandLineConfigurationSource类型和由它提供的CommandLineConfigurationProvider。由于原始的命令行参数总是体现为一个采用空格分隔的字符串，这样的字符串可以进一步转换成一个字符串集合，所以CommandLineConfigurationSource对象以字符串集合作为配置源。如下面的代码片断所示，CommandLineConfigurationSource类型具有Args和SwitchMappings两个属性，前者代表承载着原始命令行参数的字符串集合，后者则保存了命令行开关的缩写与全称之间的映射关系。<a>CommandLineConfigurationSource</a>实现 的Build方法会根据这两个属性创建并返回一个CommandLineConfigurationProvider对象。</p><div class="cnblogs_code" style="padding: 5px; border: 1px solid #cccccc; border-image: none; background-color: #f5f5f5;"><pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> CommandLineConfigurationSource : IConfigurationSource
{
    </span><span style="color: #0000ff;">public</span> IEnumerable&lt;<span style="color: #0000ff;">string</span>&gt; Args { <span style="color: #0000ff;">get</span>; <span style="color: #0000ff;">set</span><span style="color: #000000;">; }
    </span><span style="color: #0000ff;">public</span> IDictionary&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">string</span>&gt; SwitchMappings { <span style="color: #0000ff;">get</span>; <span style="color: #0000ff;">set</span><span style="color: #000000;">; }

    </span><span style="color: #0000ff;">public</span> IConfigurationProvider Build(IConfigurationBuilder builder) =&gt; <span style="color: #0000ff;">new</span><span style="color: #000000;"> CommandLineConfigurationProvider( Args,SwitchMappings); 
}</span></pre></div><p>具有如下定义的CommandLineConfigurationProvider对象依然是抽象类ConfigurationProvider的继承者。CommandLineConfigurationProvider对象的目的很明确，就是对体现为字符串集合的原始命令行参数进行解析，并将解析出来的参数名称和值添加到配置字典中 ，这一切都是在重写的Load方法中完成的。</p><div class="cnblogs_code" style="padding: 5px; border: 1px solid #cccccc; border-image: none; background-color: #f5f5f5;"><pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> CommandLineConfigurationProvider : ConfigurationProvider
{
    </span><span style="color: #0000ff;">protected</span> IEnumerable&lt;<span style="color: #0000ff;">string</span>&gt; Args { <span style="color: #0000ff;">get</span><span style="color: #000000;">; }
    </span><span style="color: #0000ff;">public</span> CommandLineConfigurationProvider(IEnumerable&lt;<span style="color: #0000ff;">string</span>&gt; args,  IDictionary&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">string</span>&gt; switchMappings = <span style="color: #0000ff;">null</span><span style="color: #000000;">);
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">override</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> Load();
}</span></pre></div><p>在采用基于命令行参数作为配置源的时候，我们可以创建一个CommandLineConfigurationSource并将其注册到ConfigurationBuilder上。我们也可以调用IConfigurationBuilder接口的如下三个扩展方法AddCommandLine将两个步骤合二为一。</p><div class="cnblogs_code" style="padding: 5px; border: 1px solid #cccccc; border-image: none; background-color: #f5f5f5;"><pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> CommandLineConfigurationExtensions
{
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> IConfigurationBuilder AddCommandLine(  <span style="color: #0000ff;">this</span> IConfigurationBuilder builder,  Action&lt;CommandLineConfigurationSource&gt;<span style="color: #000000;"> configureSource);
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> IConfigurationBuilder AddCommandLine(  <span style="color: #0000ff;">this</span> IConfigurationBuilder configurationBuilder, <span style="color: #0000ff;">string</span><span style="color: #000000;">[] args);
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> IConfigurationBuilder AddCommandLine(  <span style="color: #0000ff;">this</span> IConfigurationBuilder configurationBuilder, <span style="color: #0000ff;">string</span>[] args,  IDictionary&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> switchMappings);
}</span></pre></div><p>为了让读者朋友们对CommandLineConfigurationSource/CommandLineConfigurationProvider解析命令行参数采用的策略有一个深刻的认识，我们来演示一个简单的实例。如下面的代码片段所示，我们创建了一个ConfigurationBuilder对象并调用AddCommandLine方法注册了针对命令行参数的配置源，Main方法的参数args直接作为原始的命令行参数。</p><div class="cnblogs_code" style="padding: 5px; border: 1px solid #cccccc; border-image: none; background-color: #f5f5f5;"><pre><code><span style="color: #0000ff;">class</span><span style="color: #000000;"> Program
{
    </span><span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> Main(<span style="color: #0000ff;">string</span><span style="color: #000000;">[] args)
    {
        </span><span style="color: #0000ff;">try</span><span style="color: #000000;">
        {
            </span><span style="color: #0000ff;">var</span> mapping = <span style="color: #0000ff;">new</span> Dictionary&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;">
            {
                [</span><span style="color: #800000;">"</span><span style="color: #800000;">-a</span><span style="color: #800000;">"</span>]     = <span style="color: #800000;">"</span><span style="color: #800000;">architecture</span><span style="color: #800000;">"</span><span style="color: #000000;">,
                [</span><span style="color: #800000;">"</span><span style="color: #800000;">-arch</span><span style="color: #800000;">"</span>]     = <span style="color: #800000;">"</span><span style="color: #800000;">architecture</span><span style="color: #800000;">"</span><span style="color: #000000;">
            };
            </span><span style="color: #0000ff;">var</span> configuration = <span style="color: #0000ff;">new</span><span style="color: #000000;"> ConfigurationBuilder()
                .AddCommandLine(args, mapping)
                .Build();
            Console.WriteLine($</span><span style="color: #800000;">"</span><span style="color: #800000;">Architecture: {configuration[</span><span style="color: #800000;">"</span>architecture<span style="color: #800000;">"</span><span style="color: #800000;">]}</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        }
        </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (Exception ex)
        {
            Console.WriteLine($</span><span style="color: #800000;">"</span><span style="color: #800000;">Error: {ex.Message}</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        }
    }
}</span></pre></div><p>在调用扩展方法AddCommandLine注册CommandLineConfigurationSource的时候，我们指定了一个命令行开关映射表，它将命令行开关 &#8220;architecture&#8221; 映射为 &#8220;a&#8221; 和 &#8220;arch&#8221; 。需要注意的是，在通过字典定义命令行开关映射的时候，作为目标名称的Key应该添加 &#8220;-&#8221; 前缀。接下来我们调用ConfigurationBuilder的Build方法创建出IConfiguration对象，并从中提取出 &#8220;architecture&#8221; 配置项的值并打印出来。如下图所示，我们采用命令行的形式启动这个程序并以不同的形式指定 &#8220;architecture&#8221; 的值。</p><p><a href="https://img2018.cnblogs.com/blog/19327/201912/19327-20191219084222083-613785024.png"><img width="278" height="308" title="6-17" style="border: 0px currentcolor; border-image: none; display: inline; background-image: none;" alt="6-17" src="./images/[ASP.NET Core 3框架揭秘] 配置[6]：多样化的配置源[上篇]1.png" border="0" /></a></p><p><a href="https://www.cnblogs.com/artech/p/inside-asp-net-core-05-01.html">[ASP.NET Core 3框架揭秘] 配置[1]：读取配置数据[上篇]</a><br /><a href="https://www.cnblogs.com/artech/p/inside-asp-net-core-05-02.html">[ASP.NET Core 3框架揭秘] 配置[2]：读取配置数据[下篇]</a><br /><a href="https://www.cnblogs.com/artech/p/inside-asp-net-core-05-03.html">[ASP.NET Core 3框架揭秘] 配置[3]：配置模型总体设计</a><br /><a href="https://www.cnblogs.com/artech/p/inside-asp-net-core-05-04.html">[ASP.NET Core 3框架揭秘] 配置[4]：将配置绑定为对象</a><br /><a href="https://www.cnblogs.com/artech/p/inside-asp-net-core-05-05.html">[ASP.NET Core 3框架揭秘] 配置[5]：配置数据与数据源的实时同步</a><br /><a href="https://www.cnblogs.com/artech/p/inside-asp-net-core-05-06.html">[ASP.NET Core 3框架揭秘] 配置[6]：多样化的配置源[上篇]</a><br /><a href="https://www.cnblogs.com/artech/p/inside-asp-net-core-05-07.html">[ASP.NET Core 3框架揭秘] 配置[7]：多样化的配置源[中篇]</a><br /><a href="https://www.cnblogs.com/artech/p/inside-asp-net-core-05-08.html">[ASP.NET Core 3框架揭秘] 配置[8]：多样化的配置源[下篇]</a><br /><a href="https://www.cnblogs.com/artech/p/inside-asp-net-core-05-09.html">[ASP.NET Core 3框架揭秘] 配置[9]：自定义配置源</a> </p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>