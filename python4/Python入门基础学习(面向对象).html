<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修Python入门基础学习(面向对象)' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>Python入门基础学习(面向对象)</center></div><div class='banquan'>原文出处:本文由博客园博主大四毕业前来个offer提供。<br/>
原文连接:https://www.cnblogs.com/hhs1998/p/11769879.html</div><br>
    <p><span style="font-size: 14pt;">Python基础学习笔记（四）</span></p>
<p>&nbsp;</p>
<p><strong><span style="font-size: 14pt;">面向对象的三个基本特征：</span></strong></p>
<ul>
<li><span style="font-size: 14pt;">封装：把客观事物抽象并封装成对象，即将属性，方法和事件等集合在一个整体内</span></li>
<li><span style="font-size: 14pt;">继承：允许使用现有类的功能并在无须重新改写原来的类情况下，对这些功能进行拓展</span></li>
<li><span style="font-size: 14pt;">多态性：派生类具有基类的所有非私有数据和行为以及新类自己定义的所有数据或行为，即子类具有两个有效类型：子类的类型及其继承基类的类型。对象可以表示多个类型的能力称为多态性</span></li>
</ul>
<p>&nbsp;</p>
<p><strong><span style="font-size: 14pt;">类与对象的概念：</span></strong></p>
<p><span style="font-size: 14pt;">类和变量是面向对象编程的两个核心概念</span></p>
<p><span style="font-size: 14pt;">类：对一群具有相同<strong>特征（属性）</strong>或者<strong>行为（方法）</strong>的事物一个统称，抽象的，如：王者荣耀里的泛指的英雄</span></p>
<p><span style="font-size: 14pt;">对象：由类创建出来的一个具体存在，可以直接使用，如：英雄中的李白</span></p>
<p>&nbsp;</p>
<p><strong><span style="font-size: 14pt;">类的设计：</span></strong></p>
<p><span style="font-size: 14pt;"><strong>1.类型</strong>：满足大驼峰命名法（每个单词首字母大写，单词与单词之间没有下划线）</span></p>
<p><span style="font-size: 14pt;"><strong>2.属性</strong>：事物具有什么样的特征</span></p>
<p><span style="font-size: 14pt;"><strong>3.方法</strong>：事物具有什么样的行为</span></p>
<p>&nbsp;</p>
<p><strong><span style="font-size: 14pt;">属性与方法的确定：</span></strong></p>
<p><span style="font-size: 14pt;"><strong>1.</strong>对对象<strong>特征的描述</strong>，可以定义成<strong>属性</strong></span></p>
<p><span style="font-size: 14pt;"><strong>2.</strong>对象具有的<strong>行为（动词）</strong>，通常可以定义成<strong>方法</strong></span></p>
<p>&nbsp;</p>
<p><span style="font-size: 14pt;"><strong>类的定义以及创建对象：</strong></span></p>
<p><span style="font-size: 14pt;">类定义的格式：</span></p>
<p><span style="font-size: 14pt;"><strong><img src="./images/Python入门基础学习(面向对象)0.png" alt="" width="255" height="156" /></strong></span></p>
<p><span style="font-size: 14pt;">创建对象格式：</span></p>
<p><span style="font-size: 14pt;"><img src="./images/Python入门基础学习(面向对象)1.png" alt="" /></span></p>
<p>&nbsp;</p>
<p><span style="font-size: 14pt;"><strong>实例属性：</strong></span></p>
<p><span style="font-size: 14pt;">通过"self.变量名"定义的属性，称为实例属性，也称为实例变量，每个实例包含类的一个单独副本</span></p>
<p><span style="font-size: 14pt;"><strong>初始化</strong>（一般在__int__函数中）：<strong>self.实例变量名 = 初始值</strong></span></p>
<p><span style="font-size: 14pt;"><strong>其他函数</strong>中可以通过self访问：<strong>self.实例变量 = 值</strong></span></p>
<p><span style="font-size: 14pt;"><strong>创建对象</strong>实例，通过对象访问：<strong>obj1.实例变量名 = 值</strong></span></p>
<p><span style="font-size: 14pt;">例子：</span></p>
<div class="cnblogs_Highlighter">
<pre><code><span style="font-size: 14pt;">class Person:
    def __init__(self,name,age):
        self.name = name
        self.age = age
    def say_hi(self):
        print('您好!我叫%s'%(self.name))
person = Person('HHS','21')
person.say_hi()
print('今年{0}'.format(person.age))<br />输出：<br /></span><span style="font-size: 14pt;">您好!我叫HHS<br /></span><span style="font-size: 14pt;">今年21</span></pre>
</div>
<p>&nbsp;</p>
<p><strong><span style="font-size: 14pt;">类属性：</span></strong></p>
<p><span style="font-size: 14pt;">Python也允许声明属于类本身的变量，即类变量、静态属性</span></p>
<p><span style="font-size: 14pt;">类属性属于整个类，不是特定实例的一部分，而是所有实例之间共享的一个副本</span></p>
<p><span style="font-size: 14pt;"><strong>初始化</strong>（一般在类体中）：<strong>类变量名 = 初始值</strong></span></p>
<p><span style="font-size: 14pt;"><strong>类的访问</strong>：<strong>类名.类变量名 = 值</strong></span></p>
<p><span style="font-size: 14pt;">例子：</span></p>
<div class="cnblogs_Highlighter">
<pre><code><span style="font-size: 14pt;">class Person:
    count = 0
    name = "HHS"
#test
Person.count += 1
print(Person.count) #1
print(Person.name)  #HHS
p1 = Person()
p2 = Person()
print((p1.name,p2.name))    #('HHS', 'HHS')
Person.name = '华南理工大学广州学院'
print((p1.name,p2.name))    #('华南理工大学广州学院', '华南理工大学广州学院')
p2.name = '计算机科学与技术'
print((p1.name,p2.name))    #('华南理工大学广州学院', '计算机科学与技术')
p2.count += 1
print((Person.count,p1.count,p2.count)) #(1, 1, 2)</span></pre>
</div>
<p><span style="font-size: 14pt;"><strong>说明：</strong></span></p>
<p><span style="font-size: 14pt;">类属性如果通过&lsquo;obj.属性名'访问，则属于该实例的实例属性，虽然类属性可以使用对象实例来访问，但这样容易造成困惑。所以建议不要这样使用，而是应该使用标准的访问方式：<strong>类名.类变量名</strong></span></p>
<p>&nbsp;</p>
<p><span style="font-size: 14pt;"><strong>私有属性和公有属性：</strong></span></p>
<p><span style="font-size: 14pt;">Python类的成员没有访问控制限制，与其他面向对象的语言不同</span></p>
<p><span style="font-size: 14pt;">通常约定两个下划线开头且吧不以两个下划线结束的属性为私有（private），其他为公共（public）</span></p>
<p><span style="font-size: 14pt;">不能直接访问私有属性，但可以在方法中访问</span></p>
<div class="cnblogs_Highlighter">
<pre><code><span style="font-size: 14pt;">class A:
    __name = 'class A'
    def get_name():
        print(A.__name)
#test
A.get_name() #class A
A.__name    #AttributeError: type object 'A' has no attribute '__name'
</span></pre>
</div>
<p>&nbsp;</p>
<p><strong><span style="font-size: 14pt;">特殊属性：</span></strong></p>
<p><span style="font-size: 14pt;">以双下划线开始和结束的方法，称为特殊方法</span></p>
<p><span style="font-size: 14pt;">常见的特殊方法：</span></p>
<p><em><span style="font-size: 14pt;"><strong>object.__dict__ 　　对象的属性字典</strong></span></em></p>
<p><em><span style="font-size: 14pt;"><strong>object.__class__ 　　对象所属的类</strong></span></em></p>
<p><em><span style="font-size: 14pt;"><strong>class.__bases__　　类的基类元组</strong></span></em></p>
<p><em style="font-family: 'Courier New'; font-size: 12px;"><span style="font-size: 14pt;"><strong><strong>class.__bases__　　类的基类</strong></strong></span></em></p>
<p><em><span style="font-size: 14pt;"><strong>class.__name__　　类的名字</strong></span></em></p>
<p><span style="font-size: 14pt;"><strong>class.__mro__　　方法查找顺序，基类的顺序</strong></span></p>
<p><span style="font-size: 14pt;"><strong>class.__subclasses__()　　子类序列</strong></span></p>
<div class="cnblogs_Highlighter">
<pre><code><span style="font-size: 14pt;">class Person:
    def __init__(self,name,age):
        self.name = name
        self.age = age
    def say_hi(self):
        print('您好!我叫%s'%(self.name))
person = Person('HHS','21')
print(person.__dict__)　　<strong>#object.__dict__</strong>  输出：{'name': 'HHS', 'age': '21'}
print(person.__class__)　　<strong>#object.__class__</strong> 输出：&lt;class '__main__.Person'&gt;
print(Person.__bases__)　　<strong>#class.__bases__</strong> 输出：(&lt;class 'object'&gt;,)
print(Person.__base__)　　<strong>#class.__base__</strong> 输出：&lt;class 'object'&gt;
print(Person.__name__)　　<strong>#class.__name__</strong> 输出：Person
print(Person.__mro__)　　<strong>#class.__mro__</strong> 输出：(&lt;class '__main__.Person'&gt;, &lt;class 'object'&gt;)
print(Person.__subclasses__())　　<strong>#class.__subclasses__()</strong> 输出：[]
</span></pre>
</div>
<p>&nbsp;</p>
<p><span style="font-size: 14pt;"><strong>实例方法：</strong></span></p>
<p><span style="font-size: 14pt;">类方法的第一个参数一般为self，这种方法称为实例方法</span></p>
<p><span style="font-size: 14pt;">格式：def 方法名（self，[形参列表]）：函数体</span></p>
<p><strong><span style="font-size: 14pt;">注意：</span></strong><span style="font-size: 14pt;">第一个参数虽然为self，但是调用时，用户不需要传给该参数值（self相当于this）</span></p>
<div class="cnblogs_Highlighter">
<pre><code><span style="font-size: 14pt;">class Person:
    def say_hi(self,love):
        # self.love = love 这句不写也可以正常输出
        print('我喜欢的游戏为{0}'.format(love))
p = Person()
p.say_hi('自由幻想手游')
</span></pre>
</div>
<p>&nbsp;</p>
<p><strong><span style="font-size: 14pt;">静态方法：</span></strong></p>
<p><span style="font-size: 14pt;">Python允许声明属于与对象实例无关的方法，称为静态方法，静态方法不对特定实例进行操作，在静态方法中访问对象实例会报错。静态方法通过装饰器@staticmethod来定义，其声明格式如下：</span></p>
<div class="cnblogs_Highlighter">
<pre><code><span style="font-size: 14pt;">@staticmethod
def 静态方法名（[形参列表]）：
    函数体
#静态方法一般通过类名来访问，也可以通过对象实例来调用
#如：类名.静态方法名（[实参列表]）</span></pre>
</div>
<p><span style="font-size: 14pt;">例子：</span></p>
<div class="cnblogs_Highlighter">
<pre><code><span style="font-size: 14pt;">class Temperature:
    @staticmethod
    def c2f(t_c):   #将摄氏度转换为华氏温度
        t_c = float(t_c)
        t_f = (t_c * 9/5) + 32
        return t_f
</span></pre>
</div>
<p>&nbsp;</p>
<p><strong><span style="font-size: 14pt;">类方法：</span></strong></p>
<p><span style="font-size: 14pt;">Python也允许声明属于类本身的方法，即类方法。类方法不对特定实例进行操作，通过@classmethod来定义，第一个形参必须为类对象本身，通常为cls，</span><span style="font-size: 14pt;">格式如下：</span></p>
<div class="cnblogs_Highlighter">
<pre><code><span style="font-size: 14pt;">@classmethod
def 类方法名(cls,[形参列表]):
    函数体
#类方法一般通过类名来访问，也可通过对象实例调用
#格式如下
类名.类方法名([实参列表])</span></pre>
</div>
<p><span style="font-size: 14pt;">例子：</span></p>
<div class="cnblogs_Highlighter">
<pre><code><span style="font-size: 14pt;">class Foo:
    classname = 'Foo'
    def __init__(self,name):
        self.name = name
    def f1(self):
        print(self.name)
    @staticmethod
    def f2():
        print('static')
    @classmethod
    def f3(cls):
        print(cls.classname)
</span></pre>
</div>
<p>&nbsp;</p>
<p><strong><span style="font-size: 14pt;">__init__方法（构造函数）和__new__方法：</span></strong></p>
<p><span style="font-size: 14pt;">Python类中，可以定义特殊的方法：__new__方法和__init__方法</span></p>
<p><span style="font-size: 14pt;">__new__是一个类方法，创建对象时调用，返回当前对象的一个实例，一般无须重载该方法</span></p>
<p><span style="font-size: 14pt;">__init__是一个构造函数，用于执行类的实例和初始化工作，创建完对象后调用，初始化当前对象的实例，无返回值</span></p>
<p><strong><span style="font-size: 14pt;">&nbsp;</span></strong></p>
<p><strong><span style="font-size: 14pt;">__del__方法（析构函数）：</span></strong></p>
<p><span style="font-size: 14pt;">Python类体中，可以定义一个特殊的方法__del__方法</span></p>
<p><span style="font-size: 14pt;">用于实现销毁类的实例所需的操作，如释放占用的非托管资源（打开的文件，网络连接等）</span></p>
<p><span style="font-size: 14pt;">默认情况下，对象不再被使用时，__del__方法运行，由于Python解释器实现自动垃圾回收，无法保证这个方法何时运行</span></p>
<p><span style="font-size: 14pt;">例子：</span></p>
<div class="cnblogs_Highlighter">
<pre><code><span style="font-size: 14pt;">class Offer:
    def __init__(self,name):
        self.name = name
        print('{0}太晚参加秋招'.format(name))
    def __del__(self):
        print('{0}炸了,只能去搬砖了'.format(self.name))
of1 = Offer('HHS')
del of1
</span></pre>
</div>
<p>&nbsp;</p>
<p><strong><span style="font-size: 14pt;">__str__方法：</span></strong></p>
<p><span style="font-size: 14pt;">在Python中，使用print输出<strong>对象变量</strong>，默认情况下，会输出这个变量的<strong>引用对象</strong>时由<strong>哪一个类创建的对象，</strong>以及<strong>内存地址</strong></span></p>
<p><span style="font-size: 14pt;">如果希望print（对象变量），可以打印自定义内容，可以利用__str__方法</span></p>
<p><span style="font-size: 14pt;">注意：此方法必须返回一个字符串</span></p>
<div class="cnblogs_Highlighter">
<pre><code><span style="font-size: 14pt;">class Offer:
    def __init__(self,name):
        self.name = name
    def __str__(self):
        return '这是一个求Offer的对象'
of1 = Offer('HHS')
print(of1)　　#输出：这是一个求offer的对象</span></pre>
</div>
<p>&nbsp;</p>
<p><strong><span style="font-size: 14pt;">方法的重载：</span></strong></p>
<p><span style="font-size: 14pt;">在其他程序设计语言中，方法可以重载，即可以定义多个重名方法，只要保证方法签名唯一。方法签名包括三个部分：<strong>方法名</strong>，<strong>参数数量</strong>和<strong>参数类型</strong></span></p>
<p><span style="font-size: 14pt;">但Python本身为动态语言，<strong>方法的参数没有声明类型</strong>，<strong>参数的数量由可选参数和可变参数来控制</strong>，故<strong>Python对象方法不需要重载</strong>，定义一个方法即可实现多种调用，从而实现相当于其他程序设计语言的重载功能</span></p>
<p>&nbsp;</p>
<p><strong><span style="font-size: 14pt;">继承：</span></strong></p>
<p><strong><span style="font-size: 14pt;">派生类：</span></strong><span style="font-size: 14pt;">Pyhon支持多继承，即一个派生类可以继承多个基类。</span></p>
<p><span style="font-size: 14pt;">声明如下：</span></p>
<div class="cnblogs_Highlighter">
<pre><code><span style="font-size: 14pt;">class 派生类名(基类1,[基类2,...]):　　#若无继承，默认继承object，派生类(object)
    类体</span></pre>
</div>
<p><span style="font-size: 14pt;">注意：声明派生类时，必须在其构造函数中调用基类的构造函数。</span></p>
<p><span style="font-size: 14pt;">格式：基类名.__init__(self,参数列表)</span></p>
<p><span style="font-size: 14pt;">例子：</span></p>
<div class="cnblogs_Highlighter">
<pre><code><span style="font-size: 14pt;">class Person:
    def __init__(self,name,age):
        self.name = name
        self.age = age
    def say_hi(self):
        print(self.name,self.age)
class Student(Person):
    def __init__(self,name,age,stu_id):
        Person.__init__(self,name,age)
        self.stu_id = stu_id
    def say_hi(self):
        Person.say_hi(self)
        print(self.stu_id)
p = Person('H',10)
p.say_hi()
stu = Student('HHS',21,'9199')
stu.say_hi()<br />输出：<br />H 10<br />HHS 21<br />9199</span></pre>
</div>
<p>&nbsp;</p>
<p><strong><span style="font-size: 14pt;">对象的引用：</span></strong></p>
<p><span style="font-size: 14pt;">对象的赋值实际上是对象引用，创建一个对象并把它赋值给一个变量，该变量是指该对象的引用其id()返回值保持一致</span></p>
<p><span style="font-size: 14pt;">例如：a = b</span></p>
<p>&nbsp;</p>
<p><strong><span style="font-size: 14pt;">对象的浅拷贝：</span></strong></p>
<p><span style="font-size: 14pt;">Python拷贝一般是浅拷贝，即拷贝对象，对象中包含的子对象不拷贝，而是引用一个子对象</span></p>
<ul>
<li><span style="font-size: 14pt;">切片操作　　#a[::-1]</span></li>
<li><span style="font-size: 14pt;">对象实例化　　#list(a)</span></li>
<li><span style="font-size: 14pt;">copy模块的copy函数　　#copy.copy(a)</span></li>
</ul>
<p><span style="font-size: 14pt;">&nbsp;</span></p>
<p><strong><span style="font-size: 14pt;">对象的深拷贝：</span></strong></p>
<p><span style="font-size: 14pt;">如果要递归拷贝对象中包含的子对象，可以使用copy模块的deepcopy函数</span></p>
<div class="cnblogs_Highlighter">
<pre><code><span style="font-size: 14pt;">import copy
a = [1,'hhs',[1,2,3]]
a1 = copy.copy(a)
a2 = copy.deepcopy(a)
print(id(a[2]),id(a1[2]),id(a2[2]))
#输出：5517400 5517400 7564344
</span></pre>
</div>
<p>&nbsp;</p>
<p>　　</p>
<p>&nbsp;</p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>