<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修操作系统详解' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>操作系统详解</center></div><div class='banquan'>原文出处:本文由博客园博主changxin7提供。<br/>
原文连接:https://www.cnblogs.com/changxin7/p/11336055.html</div><br>
    <h2 id="一-为什么要有操作系统">一 为什么要有操作系统</h2>
<p>（<strong>两本书：现代操作系统、操作系统原理，学好python以后再去研究吧~~）</strong></p>
<p>　　现代的计算机系统主要是由一个或者多个处理器，主存，硬盘，键盘，鼠标，显示器，打印机，网络接口及其他输入输出设备组成。</p>
<p>　　一般而言，现代计算机系统是一个复杂的系统。</p>
<p>　　其一：如果每位应用程序员都必须掌握该系统所有的细节，那就不可能再编写代码了（严重影响了程序员的开发效率：全部掌握这些细节可能需要一万年....）</p>
<p>　　其二：并且管理这些部件并加以优化使用，是一件极富挑战性的工作，于是，计算安装了一层软件（系统软件），称为操作系统。它的任务就是为用户程序提供一个更好、更简单、更清晰的计算机模型，并管理刚才提到的所有设备。</p>
<p><strong>总结：</strong></p>
<p>　　<strong>程序员无法把所有的硬件操作细节都了解到，管理这些硬件并且加以优化使用是非常繁琐的工作，这个繁琐的工作就是操作系统来干的，有了他，程序员就从这些繁琐的工作中解脱了出来，只需要考虑自己的应用软件的编写就可以了，应用软件直接使用操作系统提供的功能来间接使用硬件。</strong></p>
<h2 id="二-什么是操作系统">二 什么是操作系统</h2>
<p>　　<strong>精简的说的话，操作系统就是一个协调、管理和控制计算机硬件资源和软件资源的控制程序。操作系统所处的位置如图1</strong></p>
<pre><code><code>#操作系统位于计算机硬件与应用软件之间，本质也是一个软件。操作系统由操作系统的内核（运行于内核态，管理硬件资源）以及系统调用（运行于用户态，为应用程序员写的应用程序提供系统调用接口）两部分组成，所以，单纯的说操作系统是运行于内核态的，是不准确的。</code></pre>
<p><img src="./images/操作系统详解0.png" alt="img" /></p>
<p>​ 图1</p>
<p>　　<strong>细说的话，操作系统应该分成两部分功能：</strong></p>
<pre><code><code>#一：隐藏了丑陋的硬件调用接口（键盘、鼠标、音箱等等怎么实现的，就不需要你管了），为应用程序员提供调用硬件资源的更好，更简单，更清晰的模型（系统调用接口）。应用程序员有了这些接口后，就不用再考虑操作硬件的细节，专心开发自己的应用程序即可。
例如：操作系统提供了文件这个抽象概念，对文件的操作就是对磁盘的操作，有了文件我们无需再去考虑关于磁盘的读写控制（比如控制磁盘转动，移动磁头读写数据等细节），

#二：将应用程序对硬件资源的竞态请求变得有序化
例如：很多应用软件其实是共享一套计算机硬件，比方说有可能有三个应用程序同时需要申请打印机来输出内容，那么a程序竞争到了打印机资源就打印，然后可能是b竞争到打印机资源，也可能是c，这就导致了无序，打印机可能打印一段a的内容然后又去打印c...,操作系统的一个功能就是将这种无序变得有序。</code></pre>
<pre><code><code>#作用一：为应用程序提供如何使用硬件资源的抽象
例如：操作系统提供了文件这个抽象概念，对文件的操作就是对磁盘的操作，有了文件我们无需再去考虑关于磁盘的读写控制

注意：
    操作系统提供给应用程序的该抽象是简单，清晰，优雅的。为何要提供该抽象呢？
    硬件厂商需要为操作系统提供自己硬件的驱动程序（设备驱动，这也是为何我们要使用声卡，就必须安装声卡驱动。。。），厂商为了节省成本或者兼容旧的硬件，它们的驱动程序是复杂且丑陋的
    操作系统就是为了隐藏这些丑陋的信息，从而为用户提供更好的接口
    这样用户使用的shell，Gnome，KDE看到的是不同的界面，但其实都使用了同一套由linux系统提供的抽象接口


#作用二：管理硬件资源
    现代的操作系统运行同时运行多道程序，操作系统的任务是在相互竞争的程序之间有序地控制对处理器、存储器以及其他I/O接口设备的分配。
例如：
    同一台计算机上同时运行三个程序，它们三个想在同一时刻在同一台计算机上输出结果，那么开始的几行可能是程序1的输出，接着几行是程序2的输出，然后又是程序3的输出，最终将是一团糟（程序之间是一种互相竞争资源的过程）
    操作系统将打印机的结果送到磁盘的缓冲区，在一个程序完全结束后，才将暂存在磁盘上的文件送到打印机输出，同时其他的程序可以继续产生更多的输出结果（这些程序的输出没有真正的送到打印机），这样，操作系统就将由竞争产生的无序变得有序化。

详解</code></pre>
<p>详解</p>
<p><img src="./images/操作系统详解1.png" alt="img" /></p>
<p>​ 图 2</p>
<h2 id="三-操作系统与普通软件的区别">三 操作系统与普通软件的区别</h2>
<p>　　1.主要区别是：你不想用暴风影音了你可以选择用迅雷播放器或者干脆自己写一个，但是你无法写一个属于操作系统一部分的程序（时钟中断处理程序），操作系统由硬件保护，不能被用户修改。</p>
<p>　　2.操作系统与用户程序的差异并不在于二者所处的地位。特别地，操作系统是一个大型、复杂、长寿的软件，</p>
<ul>
<li>大型：linux或windows的源代码有五百万行数量级。按照每页50行共1000行的书来算，五百万行要有100卷，要用一整个书架子来摆置，这还仅仅是内核部分。用户程序，如GUI，库以及基本应用软件（如windows Explorer等），很容易就能达到这个数量的10倍或者20倍之多。</li>
<li>长寿：操作系统很难编写，如此大的代码量，一旦完成，操作系统所有者便不会轻易扔掉，再写一个。而是在原有的基础上进行改进。（基本上可以把windows95/98/Me看出一个操作系统，而windows NT/2000/XP/Vista则是两位一个操作系统，对于用户来说它们十分相似。还有UNIX以及它的变体和克隆版本也演化了多年，如System V版，Solaris以及FreeBSD等都是Unix的原始版，不过尽管linux非常依照UNIX模式而仿制，并且与UNIX高度兼容，但是linux具有全新的代码基础）</li>
</ul>
<h2 id="四-操作系统发展史">四 操作系统发展史</h2>
<h4 id="第一代19401955-手工操作----穿孔卡片">第一代（<strong>1940~1955</strong>） 手工操作----穿孔卡片</h4>
<p>第一代计算机的产生背景：</p>
<p>第一代之前人类是想用机械取代人力，第一代计算机的产生是计算机由机械时代进入电子时代的标志，从Babbage失败之后一直到第二次世界大战，数字计算机的建造几乎没有什么进展，第二次世界大战刺激了有关计算机研究的爆炸性进展。</p>
<p>lowa州立大学的john Atanasoff教授和他的学生Clifford Berry建造了据认为是第一台可工作的数字计算机。该机器使用300个真空管。大约在同时，Konrad Zuse在柏林用继电器构建了Z3计算机，英格兰布莱切利园的一个小组在1944年构建了Colossus，Howard Aiken在哈佛大学建造了Mark 1，宾夕法尼亚大学的William Mauchley和他的学生J.Presper Eckert建造了ENIAC。这些机器有的是二进制的，有的使用真空管，有的是可编程的，但都非常原始，设置需要花费数秒钟时间才能完成最简单的运算。</p>
<p>在这个时期，同一个小组里的工程师们，设计、建造、编程、操作及维护同一台机器，所有的程序设计是用纯粹的机器语言编写的，甚至更糟糕，需要通过成千上万根电缆接到插件板上连成电路来控制机器的基本功能。没有程序设计语言（汇编也没有），操作系统则是从来都没听说过。使用机器的过程更加原始，详见下‘工作过程’</p>
<p><img src="./images/操作系统详解2.png" alt="img" /></p>
<p>特点：<br />
没有操作系统的概念<br />
所有的程序设计都是直接操控硬件</p>
<p>工作过程：<br />
程序员在墙上的机时表预约一段时间，然后程序员拿着他的插件版到机房里，将自己的插件板街道计算机里，这几个小时内他独享整个计算机资源，后面的一批人都得等着(两万多个真空管经常会有被烧坏的情况出现)。</p>
<p>后来出现了穿孔卡片，可以将程序写在卡片上，然后读入机而不用插件板</p>
<p><img src="./images/操作系统详解3.png" alt="img" /></p>
<p>优点：</p>
<p>程序员在申请的时间段内独享整个资源，可以即时地调试自己的程序（有bug可以立刻处理）</p>
<p>缺点：</p>
<p>浪费计算机资源，一个时间段内只有一个人用。<br />
注意：同一时刻只有一个程序在内存中，被cpu调用执行，比方说10个程序的执行，是串行的</p>
<p>穿孔卡带的过程：程序员将对应于程序和数据的已穿孔的纸带（或卡片）装入输入机，然后启动输入机把程序和数据输入计算机内存，接着通过控制台开关启动程序针对数据运行；计算完毕，打印机输出计算结果；用户取走结果并卸下纸带（或卡片）后，才让下一个用户上机。</p>
<h4 id="第二代19551965-磁带存储---批处理系统"><strong>第二代（1955~1965） 磁带存储---批处理系统</strong></h4>
<p>第二代计算机的产生背景：</p>
<p>由于当时的计算机非常昂贵，自认很自然的想办法较少机时的浪费。通常采用的方法就是批处理系统。</p>
<p>特点：<br />
设计人员、生产人员、操作人员、程序人员和维护人员直接有了明确的分工，计算机被锁在专用空调房间中，由专业操作人员运行，这便是‘大型机’。</p>
<p>有了操作系统的概念</p>
<p>有了程序设计语言：FORTRAN语言或汇编语言，写到纸上，然后穿孔打成卡片，再讲卡片盒带到输入室，交给操作员，然后喝着咖啡等待输出接口</p>
<p>工作过程：插图</p>
<p><img src="./images/操作系统详解4.png" alt="img" /></p>
<p><img src="./images/操作系统详解5.png" alt="img" /></p>
<p>第二代如何解决第一代的问题/缺点：<br />
1.把一堆人的输入攒成一大波输入，<br />
2.然后顺序计算（这是有问题的，但是第二代计算也没有解决）<br />
3.把一堆人的输出攒成一大波输出</p>
<p>现代操作系统的前身:(见图）</p>
<p><strong>优点</strong>：批处理，节省了机时</p>
<p><strong>缺点</strong>：1.整个流程需要人参与控制，将磁带搬来搬去（中间俩小人）</p>
<p>2.计算的过程仍然是顺序计算-》串行</p>
<p>3.程序员原来独享一段时间的计算机，现在必须被统一规划到一批作业中，等待结果和重新调试的过程都需要等同批次的其他程序都运作完才可以（这极大的影响了程序的开发效率，无法及时调试程序）</p>
<h4 id="第三代19551965集成电路多道程序系统"><strong>第三代(1955~1965)集成电路,多道程序系统</strong></h4>
<p>第三代计算机的产生背景：</p>
<p>20世纪60年代初期，大多数计算机厂商都有两条完全不兼容的生产线。</p>
<p>一条是面向字的：大型的科学计算机，如IBM 7094，见上图，主要用于科学计算和工程计算</p>
<p>另外一条是面向字符的：商用计算机，如IBM 1401，见上图，主要用于银行和保险公司从事磁带归档和打印服务</p>
<p>开发和维护完全不同的产品是昂贵的，同时不同的用户对计算机的用途不同。</p>
<p>IBM公司试图通过引入system/360系列来同时满足科学计算和商业计算，360系列低档机与1401相当，高档机比7094功能强很多，不同的性能卖不同的价格</p>
<p>360是第一个采用了（小规模）芯片（集成电路）的主流机型，与采用晶体管的第二代计算机相比，性价比有了很大的提高。这些计算机的后代仍在大型的计算机中心里使用，<strong>此乃现在服务器的前身</strong>，这些服务器每秒处理不小于千次的请求。</p>
<p>如何解决第二代计算机的问题1：<br />
卡片被拿到机房后能够很快的将作业从卡片读入磁盘，于是任何时刻当一个作业结束时，操作系统就能将一个作业从磁带读出，装进空出来的内存区域运行，这种技术叫做<br />
同时的外部设备联机操作：SPOOLING，该技术同时用于输出。当采用了这种技术后，就不在需要IBM1401机了，也不必将磁带搬来搬去了（中间俩小人不再需要）</p>
<p>如何解决第二代计算机的问题2：</p>
<p>第三代计算机的操作系统广泛应用了第二代计算机的操作系统没有的关键技术：多道技术</p>
<p><strong>cpu在执行一个任务的过程中，若需要操作硬盘，则发送操作硬盘的指令，指令一旦发出，硬盘上的机械手臂滑动读取数据到内存中，这一段时间，cpu需要等待，时间可能很短，但对于cpu来说已经很长很长，长到可以让cpu做很多其他的任务，如果我们让cpu在这段时间内切换到去做其他的任务，这样cpu不就充分利用了吗。这正是多道技术产生的技术背景</strong></p>
<p><strong>多道技术：</strong></p>
<p>多道技术中的多道指的是多个程序，多道技术的实现是为了解决多个程序竞争或者说共享同一个资源（比如cpu）的有序调度问题，解决方式即多路复用，多路复用分为时间上的复用和空间上的复用。</p>
<p><strong>空间上的复用</strong>：将内存分为几部分，每个部分放入一个程序，这样，同一时间内存中就有了多道程序。</p>
<p><img src="./images/操作系统详解6.png" alt="img" /></p>
<p><strong>时间上的复用</strong>：当一个程序在等待I/O时，另一个程序可以使用cpu，如果内存中可以同时存放足够多的作业，则cpu的利用率可以接近100%，类似于我们小学数学所学的<strong>统筹方法</strong>。（操作系统采用了多道技术后，可以控制进程的切换，或者说进程之间去争抢cpu的执行权限。这种切换不仅会在一个进程遇到io时进行，一个进程占用cpu时间过长也会切换，或者说被操作系统夺走cpu的执行权限）</p>
<pre><code><code>现代计算机或者网络都是多用户的，多个用户不仅共享硬件，而且共享文件，数据库等信息，共享意味着冲突和无序。

操作系统主要使用来

1.记录哪个程序使用什么资源

2.对资源请求进行分配

3.为不同的程序和用户调解互相冲突的资源请求。

我们可将上述操作系统的功能总结为：处理来自多个程序发起的多个（多个即多路）共享（共享即复用）资源的请求，简称多路复用

多路复用有两种实现方式

1.时间上的复用

当一个资源在时间上复用时，不同的程序或用户轮流使用它，第一个程序获取该资源使用结束后，在轮到第二个。。。第三个。。。

例如：只有一个cpu，多个程序需要在该cpu上运行，操作系统先把cpu分给第一个程序，在这个程序运行的足够长的时间（时间长短由操作系统的算法说了算）或者遇到了I/O阻塞，操作系统则把cpu分配给下一个程序，以此类推，直到第一个程序重新被分配到了cpu然后再次运行，由于cpu的切换速度很快，给用户的感觉就是这些程序是同时运行的，或者说是并发的，或者说是伪并行的。至于资源如何实现时间复用，或者说谁应该是下一个要运行的程序，以及一个任务需要运行多长时间，这些都是操作系统的工作。

2.空间上的复用

每个客户都获取了一个大的资源中的一小部分资源，从而减少了排队等待资源的时间。

例如：多个运行的程序同时进入内存，硬件层面提供保护机制来确保各自的内存是分割开的，且由操作系统控制，这比一个程序独占内存一个一个排队进入内存效率要高的多。

有关空间复用的其他资源还有磁盘，在许多系统中，一个磁盘同时为许多用户保存文件。分配磁盘空间并且记录谁正在使用哪个磁盘块是操作系统资源管理的典型任务。

这两种方式合起来便是多道技术

详解</code></pre>
<p>详解</p>
<p>空间上的复用最大的问题是：程序之间的内存必须分割，这种分割需要在硬件层面实现，由操作系统控制。如果内存彼此不分割，则一个程序可以访问另外一个程序的内存，</p>
<p>首先丧失的是安全性，比如你的qq程序可以访问操作系统的内存，这意味着你的qq可以拿到操作系统的所有权限。</p>
<p>其次丧失的是稳定性，某个程序崩溃时有可能把别的程序的内存也给回收了，比方说把操作系统的内存给回收了，则操作系统崩溃。</p>
<p>第三代计算机的操作系统仍然是批处理</p>
<p>许多程序员怀念第一代独享的计算机，可以即时调试自己的程序。为了满足程序员们很快可以得到响应，出现了分时操作系统</p>
<p>如何解决第二代计算机的问题3：</p>
<p>分时操作系统：<br />
多个联机终端+多道技术</p>
<p>20个客户端同时加载到内存，有17在思考，3个在运行，cpu就采用多道的方式处理内存中的这3个程序，由于客户提交的一般都是简短的指令而且很少有耗时长的，索引计算机能够为许多用户提供快速的交互式服务，所有的用户都以为自己独享了计算机资源</p>
<p>CTTS：麻省理工（MIT）在一台改装过的7094机上开发成功的，CTSS兼容分时系统，<strong>第三代计算机广泛采用了必须的保护硬件（程序之间的内存彼此隔离）之后，分时系统才开始流行</strong></p>
<p>MIT，贝尔实验室和通用电气在CTTS成功研制后决定开发能够同时支持上百终端的MULTICS（其设计者着眼于建造满足波士顿地区所有用户计算需求的一台机器），很明显真是要上天啊，最后摔死了。</p>
<p>后来一位参加过MULTICS研制的贝尔实验室计算机科学家Ken Thompson开发了一个简易的，单用户版本的MULTICS，<strong>这就是后来的UNIX系统</strong>。基于它衍生了很多其他的Unix版本，为了使程序能在任何版本的unix上运行，IEEE提出了一个unix标准，即<strong>posix（可移植的操作系统接口Portable Operating System Interface）</strong></p>
<p>后来，在1987年，出现了一个UNIX的小型克隆，即minix，用于教学使用。芬兰学生Linus Torvalds基于它编写了Linux</p>
<h4 id="第四代1980至今现代计算机"><strong>第四代（1980~至今）现代计算机</strong></h4>
<p>　　进入20世纪80年代，大规模集成电路工艺技术的飞跃发展，微处理机的出现和发展，掀起了计算机大发展大普及的浪潮。一方面迎来了个人计算机的时代，同时又向计算机网络、分布式处理、巨型计算机和智能化方向发展。于是，操作系统有了进一步的发展，如：个人计算机操作系统、网络操作系统、分布式操作系统等。</p>
<p>　　1.个人计算机操作系统</p>
<p>　　　　个人计算机上的操作系统是联机交互的单用户操作系统，它提供的联机交互功能与通用分时系统提供的功能很相似。</p>
<p>　　　　由于是个人专用，因此一些功能会简单得多。然而，由于个人计算机的应用普及，对于提供更方便友好的用户接口和丰富功能的文件系统的要求会愈来愈迫切。</p>
<p>　　2.网络操作系统</p>
<p>　　　　计算机网络：通过通信设施，将地理上分散的、具有自治功能的多个计算机系统互连起来，实现信息交换、资源共享、互操作和协作处理的系统。</p>
<p>　　　　网络操作系统：在原来各自计算机操作系统上，按照网络体系结构的各个协议标准增加网络管理模块，其中包括：通信、资源共享、系统安全和各种网络应用服务。</p>
<p>　　　 就是添加了一些网络方面的功能。</p>
<p>　　3.分布式操作系统</p>
<p>　　　　表面上看，分布式系统与计算机网络系统没有多大区别。分布式操作系统也是通过通信网络，将地理上分散的具有自治功能的数据处理系统或计算机系统互连起来，实现信息交换和资源共享，协作完成任务。——硬件连接相同。</p>
<p>　　　　分布式：将一个大的任务拆分成几个小的任务，分配给不同的任务处理机制，具体怎么分配是由系统中的算法决定的，大家同时来运行自己的任务，然后各自将人物的返回结果再返回给你这个大的任务。</p>
<p>　　　　但有如下一些明显的区别：</p>
<p>　　　　　　（1）分布式系统要求一个统一的操作系统，实现系统操作的统一性。</p>
<p>　　　　　　（2）分布式操作系统管理分布式系统中的所有资源，它负责全系统的资源分配和调度、任务划分、信息传输和控制协调工作，并为用户提供一个统一的界面。</p>
<p>　　　　　　（3）用户通过这一界面，实现所需要的操作和使用系统资源，至于操作定在哪一台计算机上执行，或使用哪台计算机的资源，则是操作系统完成的，用户不必知道，此谓：系统的透明性。</p>
<p>　　　　　　（4）分布式系统更强调分布式计算和处理，因此对于多机合作和系统重构、坚强性和容错能力有更高的要求，希望系统有：更短的响应时间、高吞吐量和高可靠性。</p>
<p>　　　　分布式系统已经很普遍了，一般个人用不到，企业在处理比较大的任务的时候才会使用。</p>
<h2 id="五操作系统原理">五、操作系统原理</h2>
<h3 id="操作系统的资源管理技术">1. 操作系统的资源管理技术</h3>
<p>　　资源管理解决物理资源数量不足和合理分配资源这两个问题。<br />
<img src="./images/操作系统详解7.png" alt="PM2VM" /><br />
　　操作系统虚拟机为用户提供了一种简单、清晰、易用、高效的计算机模型。虚拟机的每种资源都是物力资源通过复用、虚拟和抽象而得到的产物。<br />
　　虚拟机提供进程运行的逻辑计算环境。从概念上来说，一个进程运行在一台虚拟机上，可以认为一个进程就是一台虚拟机，一台虚拟机就是一个进程。</p>
<ul>
<li>复用：<em>空分复用共享</em>和<em>时分复用共享</em>。
a. 空分复用共享(space-multiplexed sharing): 将资源从“空间”上分割成更小的单位供不同进程使用。在计算机系统中，内存和外存(磁盘)等是空分复用共享的。
<p>b. 时分复用共享(time-multiplexed sharing): 将资源从“时间”上分割成更小的单位供不同进程使用。在计算机系统中，处理器和磁盘机等是时分复用共享的。</p></li>
<li><p>虚拟：对资源进行转化、模拟或整合，把一个物理资源转变成多个逻辑上的对应物，也可以把多个物理资源变成单个逻辑上的对应物，即创建无须共享独占资源的假象，或创建易用且多于实际物理资源的虚拟资源假象，以达到多用户共享一套计算机物理资源的目的。虚拟技术可用于外部设备(外部设备同时联机操作(SPOOLing)),存储资源(虚拟内存)和文件系统(虚拟文件系统(Virtual File System, VFS))中。</p>
<blockquote>
<p>复用和虚拟相比较，复用所分割的是实际存在的物理资源，而虚拟则实现假想的同类资源。虚拟技术解决某类物理资源不足的问题，提供易用的虚拟资源和更好的运行环境。</p>
</blockquote></li>
<li><p>抽象：通过创建软件来屏蔽硬件资源的物理特性和实现细节，简化对硬件资源的操作、控制和使用。</p>
<blockquote>
<p>复用和虚拟的主要目标是解决物理资源数量不足的问题，抽象则用于处理系统复杂性，重点解决资源易用性。</p>
</blockquote></li>
</ul>
<h3 id="系统调用">2. 系统调用</h3>
<ul>
<li><p>系统调用： 为给应用程序的运行提供良好环境，内核提供了一系列具有预定功能的服务例程，通过一组称为系统调用（System Call）的接口呈现给用户，系统调用把应用程序的请求传送至内核，调用相应的服务例程完成所需处理，将处理结果返回给应用程序。<br />
<img src="./images/操作系统详解8.png" alt="OS_System_Call" /></p>
<blockquote>
<p>注：系统调用的编号称为功能号</p>
</blockquote></li>
<li><p>系统调用的执行过程： 当CPU执行程序中编写的由访管指令(supervisor, 也称自陷指令(trap)或中断指令(interrupt), 指引起处理器中断的机器指令)实现的系统调用时会产生异常信号，通过陷阱机制(也称异常处理机制，当异常或中断发生时，处理器捕捉到一个执行线程，并且将控制权转移到操作系统中某一个固定地址的机制)，处理器的状态由用户态(user mode, 又称目态或普通态)转变为核心态(kerbel mode, 又称管态或内核态)，进入操作系统并执行相应服务例程，以获得操作系统服务。当系统调用执行完毕时，处理器再次切换状态，控制返回至发出系统调用的程序。</p></li>
<li><p>系统调用是应用程序获得操作系统服务的唯一途径。</p></li>
</ul>
<blockquote>
<p>系统调用的作用：<br />
\1. 内核可以基于权限和规则对资源访问进行裁决，保证系统的安全性。<br />
\2. 系统调用对资源进行抽象，提供一致性接口，避免用户在使用资源时发生错误，且编程效率大大提高。</p>
<p>系统调用与函数调用的区别：<br />
\1. 调用形式和实现方式不同。功能号 VS 地址； 用户态转换到内核态 VS 用户态。<br />
\2. 被调用代码的位置不同。 动态调用 + 操作系统 VS 静态调用 + 用户级程序。<br />
\3. 提供方式不同。 操作系统 VS 编程语言。</p>
</blockquote>
<h3 id="操作系统内核">3. 操作系统内核</h3>
<ul>
<li>内核： 是一组程序模块，作为可信软件来提供支持进程并发执行的基本功能和基本操作，通常驻留在内核空间，运行于内核态，具有直接访问硬件设备和所有内存空间的权限，是仅有的能够执行特权指令的程序。</li>
<li>内核的功能：
a. 中断处理。中断处理是内核中最基本的功能，也是操作系统赖以活动的基础。
b. 时钟管理。时钟管理是内核的基本功能。
c. 短程调度。短程调度的职责是分配处理器，按照一定的策略管理处理器的转让，以及完成保护和恢复现场工作。
d. 原语管理。 原语是内核中实现特定功能的不可中断过程。</li>
</ul>
<blockquote>
<p>内核是操作系统对裸机的第一次改造，内核和裸机组成了第一层虚拟机，进程在虚拟机上运行。</p>
</blockquote>
<h3 id="处理器状态-内核态和用户态">4. 处理器状态： 内核态和用户态</h3>
<ul>
<li>仅在内核态下才能使用的指令称为特权指令，执行这些指令不仅影响运行程序自身，而且还会干扰其他程序及操作系统。 非特权指令在内核态和和用户态下都能工作。</li>
</ul>
<blockquote>
<p>现代计算机为处理器建立硬件标志位，称处理器状态位，通常是程序状态字(Program Status Word, PSW)中的一位，来将处理器的状态设置为内核态或用户态。</p>
</blockquote>
<ul>
<li>用户态向内核态转换的情况：
a. 程序请求操作系统服务， 执行系统调用。
b. 在程序运行时产生中断事件(如I/O操作完成)，运行程序被中断，转向中断处理程序处理。
c. 在程序运行时产生异常事件(如在目态下执行特权指令)，运行程序被打断，转向异常处理程序工作。</li>
</ul>
<blockquote>
<p>以上三种情况都是通过中断机制发生，可以说中断和异常是用户态到内核态转换的仅有途径。</p>
</blockquote>
<ul>
<li>用户栈和核心栈
a. 用户栈是用户进程空间中的一块区域。用于保存应用程序的子程序(函数)间相互调用的参数，返回值，返回点和子程序的局部变量。
b. 核心栈是内存中操作系统空间的一块区域。用于保存中断现场和保存操作系统程序(函数)间相互调用的参数，返回值，返回点和程序的局部变量。</li>
</ul>
<h3 id="中断interupt">5. 中断（Interupt）</h3>
<ul>
<li>中断：程序执行过程中遇到急需处理的事件时，暂时终止现行程序在CPU上的运行，转而执行相应的事件处理程序，待处理完成后再返回断点或调度其他程序的执行过程。</li>
<li>中断的分类：
a. 外中断(又称中断或异步中断)： 来自处理器之外的中断信号，如，时钟中断、键盘中断等。外中断可分为可屏蔽中断和非可屏蔽中断。
b. 内中断(又称异常或同步中断)，来自处理器内部的中断信号，如，访管中断，硬件故障中断，程序性中断等。内中断不能被屏蔽。</li>
<li>中断和异常的响应： 发现中断源 → 保护现场 → 转向中断/异常事件处理程序执行 → 恢复现场</li>
</ul>
<h3 id="进程">6. 进程</h3>
<ul>
<li>进程：具有独立功能的程序在某个数据集合上的一次运行活动，也是操作系统进行资源分配和保护的基本单位。
a. 从原理角度看，进程是支持程序执行的一种系统机制，它对处理器上运行程序的活动进行抽象。
<p>b. 从实现角度看，进程是一种数据结构，用来准确地刻画运行程序的状态和系统动态变化状况。</p></li>
<li><p>进程状态的七态模型</p>
<p><img src="./images/操作系统详解9.png" alt="OS_SEVEN" /></p>
a. 新建态(new): 进程被创建，尚未进入就绪队列。
b. 就绪态(ready): 进程具备运行条件，等待系统分配处理器。
c. 挂起就绪态(ready suspend)：进程具备运行条件，但目前在外存中。
d. 运行态(running): 进程占有处理器正在运行。
e. 终止态(exit): 进程达到正常结束点或被其他原因所终止，下一步将被撤销。
f. 等待态(wait): 又称阻塞态或休眠态。进程正在等待某个事件完成，目前不具备运行条件。
<p>g. 挂起等待态(blocked suspend): 进程正在等待某个事件完成，并且在外存中。</p></li>
<li><p>程序和数据刻画进程的静态特征，称为进程控制块的一种数据结构刻画进程的动态特征。进程映像(process image)包括进程控制块、进程程序块、进程核心块、进程数据块等要素。</p></li>
<li><p>进程控制块(Process Control Block, PCB)：进程存在的唯一标识，操作系统掌握进程的唯一资料结构和管理进程的主要依据。包括标识信息、现场信息和控制信息等信息。</p></li>
<li><p>进程队列(process queue)：处于同一状态的所有进程的PCB链接在一起的数据结构。 有两种队列组织方式：链接方式和索引方式。</p></li>
<li><p>进程切换必定在内核态而非用户态发生。</p></li>
<li><p>进程可以分为两部分，资源集合和线程集合。进程要支撑线程运行，为线程提供虚拟地址空间和各种资源。进程封装管理信息，线程封装执行信息。</p>
<p><img src="./images/操作系统详解10.png" alt="OS_MultiThread" /></p></li>
</ul>
<h3 id="处理器调度">7. 处理器调度</h3>
<ul>
<li>处理器调度层次：<br />
<img src="./images/操作系统详解11.png" alt="OS_Scheduling" />
a. 高级调度： 又称作业调度、长程调度。从输入系统的一批作业(job, 用户提交给操作系统计算的一个独立任务)中按照预定的调度策略挑选若干作业进入内存，为其分配所需资源并创建对应作业的用户进程。
b. 中级调度： 又称平衡调度，中程调度。根据内存资源情况决定内存所能容纳的进程数目，并完成外存和内存中进程对换工作。
<p>c. 低级调度：又称进程调度/线程调度，短程调度。根据某种原则决定就绪队列中那个进程/线程先获得处理器，并将处理器出让给它使用。</p></li>
<li>低级调度算法：
a. 先来先服务(First Come First Server, FCFS)算法。
b. 最短作业优先(Shortest Job First, SJF)算法。
c. 最短剩余时间优先(Shortest Remaining Time First, SRTF)算法： 假设当前某进程/线程正在运行，如果<em>有新进程/线程移入就绪队列</em>，若它所需的CPU运行时间比当前运行的进程/线程所需的剩余CPU时间还短，抢占式最短作业优先算法强行剥夺当前执行者的控制权，调度新进程/线程执行。
d. 最高响应比优先(Highest Response Ratio First, HRRF)算法:非剥夺式算法。其中，响应比 = (作业已等待时间 + 作业处理时间) / 作业处理时间。
e. 优先级调度算法：优先级高的选择进程/线程优先选择。
f. 轮转调度(Round-Robin, RR)算法： 也称时间片调度。就绪队列的进程轮流运行一个时间片。
<p>g. 多级反馈队列(Multi-Level Feedback Queue, MLFQ)算法。</p>
<blockquote>
衡量调度算法的性能指标：
a. 资源利用率: CPU利用率 = CPU有效工作时间/(CPU有效工作时间 + CPU空闲等待时间)
b. 吞吐率： 单位时间内CPU处理作业的个数。
c. 公平性： 确保每个进程都能获得合理的CPU份额和其他资源份额，不会出现饥饿现象。
d. 响应时间： 从交互式进程提交一个请求(命令)直到获得响应之间的时间间隔。
<p>e. 周转时间： 批处理用户从向系统提交作业开始到作业完成为止的时间间隔。<br />
平均周转时间：T = (∑ni=1ti∑i=1nti ) / n ， 其中 titi 表示作业i的周转时间。<br />
平均带权作业周转时间： T = (∑ni=1wi∑i=1nwi) / n, 其中 wi=ti/tkwi=ti/tk ， titi 表示作业i的周转时间。 tktk 表示作业i的运行时间。</p>
</blockquote></li>
</ul>
<h3 id="进程的交互">8. 进程的交互</h3>
<ul>
<li><p>进程互斥(Mutual Exclusion): 若干进程因相互抢夺<em>独占型资源</em>而产生的竞争制约关系。</p></li>
<li><p>进程同步(Synchronization): 为完成共同任务的并发进程基于某个条件来协调其活动，因为需要在某些位置上排定执行的先后次序而等待、传递信息或消息所产生的协作制约关系。</p>
<blockquote>
资源竞争会引发两个控制问题：
a. 死锁： 一组进程因争夺资源陷入永远等待的状态。
<p>b. 饥饿： 一个可运行进程由于由于其他进程总是优先于它，而被调度程序无限期地拖延而不能被执行。</p>
</blockquote></li>
</ul>
<h3 id="临界区管理">9. 临界区管理</h3>
<ul>
<li><p>并发进程中与共享变量有关的程序段称为临界区(Critical Section)。共享变量所代表的资源称为临界资源(Critical Resource)，即一次仅能供一个进程使用的资源。</p></li>
<li>临界区调度原则：
a. 择一而入。 一次之多只有一个进程进入临界区内执行。
b. 忙则要等。 如果已有进程在临界区中， 试图进入此临界区的其他进程应等待。
<p>c. 有限等待。 进入临界区内的进程应在有限时间内退出。</p></li>
<li><p>临界区管理的软件算法：Peterson算法。<br />
为每个进程设置标志，当标志值为 <code>true</code> 时表示该进程要求进入临界区，另外再设置一个指示器 <code>turn</code> 以指示可以由哪个进程进入临界区，当 <code>turn = i</code> 时则可由 <code>Pi</code> 进入临界区。</p>
<p><a><img src="./images/操作系统详解12.png" alt="复制代码" /></a></p>
<pre><code><code> 1 /* Peterson 算法 */
 2 
 3 bool inside[2];
 4 inside[0] = false;
 5 inside[1] = false;
 6 enum { 0, 1 } turn;
 7 
 8 /* 进程0 */
 9 process P0(){
10     inside[0] = true;               //请求...
11     turn = 1;
12     while(inside[1] &amp;&amp; turn == 1) ; //等待...
13 
14     /*临界区 */
15 
16     inside[0] = false;              //归还...
17 }
18 
19 /* 进程1 */
20 process P1(){
21     inside[1] = true;               //请求...
22     turn = 0;
23     while(inside[0] &amp;&amp; turn == 0) ; //等待...
24 
25     /*临界区 */
26 
27     inside[1] = false;              //归还...
28 }</code></pre>
<p><a><img src="./images/操作系统详解12.png" alt="复制代码" /></a></p></li>
<li><p>Peterson算法满足临界区管理的三个原则。</p></li>
<li>临界区管理的硬件设施:
a. 关中断。 在进程进入临界区时关中断，进程退出临界区时开中断。
b. 测试并设置指令。 利用机器指令TS(Test and Set)实现临界区的上锁和开锁原语操作。
<p>c. 对换指令。 利用对换指令实现临界区的上锁和开锁原语操作。</p></li>
</ul>
<h3 id="信号量samaphore和pv操作">10. 信号量(samaphore)和PV操作</h3>
<blockquote>
<p>PV操作都是原语操作， 不可中断。</p>
</blockquote>
<ul>
<li><p>信号量和PV操作</p>
<p><a><img src="./images/操作系统详解12.png" alt="复制代码" /></a></p>
<pre><code><code> 1 // 信号量
 2 typedef struct semaphore {
 3     int value;                 // 信号量值
 4     struct pcb* list;          // 指向“等待该信号量的进程队列”的指针
 5 };  
 6 
 7 // P操作
 8 void P(semaphore s){
 9     s.value--;                 // 信号量值减一
10 
11     // 如果信号量值小于0， 执行P操作的进程调用sleep(s.list)阻塞自己，
12     // 被置成“等待信号量s”状态，并移入s信号量队列，转向进程调度程序。
13     if(s.value &lt; 0) sleep(s.list);
14 }
15 
16 // V操作
17 void V(semaphore s){
18     s.value++;                 // 信号量值加一
19 
20     // 如果信号量小于等于0， 则调用wakeup(s.list)释放一个等待信号量s的进程，
21     // 并转换成就绪态， 进程则继续执行。
22     if(s.value &lt;= 0) wakeup(s.list);
23 }</code></pre>
<p><a><img src="./images/操作系统详解12.png" alt="复制代码" /></a></p></li>
<li>a. 若信号量值 <code>s.value</code> 为正值， 此值等于在封锁进程之前对信号量 <code>s</code> 可施行P操作的次数，即，s所代表的实际可用的资源数。
b. 若信号量值 <code>s.value</code> 为负值， 其绝对值等于登记在 <code>s</code> 信号量队列中的等待进程的数目。
<p>c. 通常P操作意味着请求一个资源，V操作意味着释放一个资源。在一定条件下，P操作也可表示挂起进程的操作，V操作代表唤醒被挂起进程的操作。</p></li>
<li><p>信号量实现互斥</p>
<p><a><img src="./images/操作系统详解12.png" alt="复制代码" /></a></p>
<pre><code><code> 1 semaphore mutex;
 2 mutex = 1；
 3 
 4 //进程Pi， i = 1， 2 ...， n
 5 process Pi(){
 6     P(mutex);
 7 
 8     /* 临界区 */
 9 
10     V(mutex);
11 }</code></pre>
<p><a><img src="./images/操作系统详解12.png" alt="复制代码" /></a></p></li>
</ul>
<h3 id="管程">11. 管程</h3>
<ul>
<li><p>管程(monitor)：代表共享资源的数据结构及并发进程在其上执行的一组构成就构成管程，管程被请求和释放资源的进程锁调用。</p>
<p><img src="./images/操作系统详解18.png" alt="OS_manitor" /></p>
a. 条件变量。 管程内的一种数据结构。只有在管程中才能被访问，进程可以在条件变量上等待或被唤醒。只能通过 <code>wait()</code> 和 <code>signal()</code> 原语操作来控制。
b. <code>wait()</code> 原语。 挂起调用进程并释放管程，直至另一个进程在条件变量上执行 <code>signal()</code>。
<p>c. <code>signal()</code> 原语。如果有其他的进程因对条件变量执行 <code>wait()</code> 而被挂起，便释放之。 如果没有进程在等待，那么相当于空操作，信号不被保存。</p></li>
</ul>
<h3 id="死锁">12. 死锁</h3>
<ul>
<li><p>死锁的主要解决方法： 死锁防止、死锁避免、死锁检测和恢复。</p></li>
<li>死锁产生的必要条件：
a. 互斥条件。 临界资源是独占资源，进程应互斥且排他地使用这些资源。
b. 占有和等待条件。 进程在请求资源得不到满足而等待时，不释放已占有的资源。
c. 不剥夺条件。已获资源只能由进程资源释放，不允许被其他程序剥夺。
<p>d. 循环等待条件。 存在循环等待链，其中每个进程都在等待下一个进程所持有的资源。</p>
<blockquote>
<p>死锁的防止就是去破坏死锁产生的必要条件。 如，使资源可同时使用(破坏互斥条件)、静态分配资源(破坏占有和等待条件)、剥夺调度(破坏不剥夺条件)、层次分配策略(循环等待条件)等。</p>
</blockquote></li>
<li><p>死锁避免： <a href="http://baike.baidu.com/link?url=8bOYnVjs5ya2QcVYp7L2OaIAWkGD1GhtTEQyXhJgbIjtSmLgagTfLCM8Wc1jhlvOJpCwOu7Ddx7ZVclFCdRJ40sjRnMde41J7a5IAWmVMeqzN0WdESisqZI_oblqfC5O34ntmWjsxt8lDV6FoUhDGa">银行家算法</a> (额…自己百度去吧。 = =!)</p></li>
<li>死锁检测和恢复： 进程-资源分配图(额…还是去百度吧。)
a. 如果进程-资源分配图中无环路，此时系统没有死锁。
b. 如果进程-资源分配图中有环路，且每个资源类中只有一个资源，则系统发生死锁。
<p>c. 如果进程-资源分配图中有环路，且所涉及的资源类有多个资源，则不一定会发生死锁。</p></li>
</ul>
<h3 id="可变分区存储管理">13. 可变分区存储管理</h3>
<ul>
<li>可变分区存储分配算法：
a. 最先适应分配算法。从未分配区的<em>开始位置</em>开始扫描，在找到的第一个能满足长度要求的空闲区上分配存储空间。
b. 下次适应分配算法。从未分配区<em>上次扫描结束处</em>开始顺序查找，在找到的第一个能满足长度要求的空闲区上分配存储空间。
c. 最优适应分配算法。扫描整个未分配区，选择能满足用户进程要求的<em>最小分区</em>分配存储空间。
d. 最坏适应分配算法。扫描整个未分配区，选择能满足用户进程要求的<em>最大分区</em>分配存储空间。
e. 快速适应分配算法。为经常用到的长度的空闲区设立单独的空闲区链表。</li>
</ul>
<h3 id="分页存储管理">14. 分页存储管理</h3>
<ul>
<li>基本概念：
a. 页面。 <em>进程逻辑地址空间</em>分成<em>大小相等</em>的区，每个区称为页面或页。(注： 页面的本质是逻辑地址空间)
b. 页框(kuàng, 0.0)。 又称页帧。<em>内存物理地址空间</em>分成<em>大小相等</em>的区，其大小和页面大小相等，每个区就是一个页框。(注： 页框的本质是物理地址空间)
<p>c. 逻辑地址。分页存储器的逻辑地址由页号和页内偏移两部分组成。</p>
<p><img src="./images/操作系统详解19.png" alt="OS_PageOffset" /></p>
d. 内存页框表。页框表的表项给出物理块使用情况：0为空闲，1为占用。
<p>e. 页表。页表是操作系统为进程建立的，是程序页面和内存页框的对照表，页表的每一栏指明程序中的某一页面和分得的页框之间的关系。</p></li>
<li><p>分页存储管理的地址转换</p>
<p><img src="./images/操作系统详解20.png" alt="OS_PageTable" /></p></li>
<li><p>翻译快表：也称转换后援缓冲(Translation Look_aside Buffer, TLB)。用来存放进程最近访问的部分页表项。(注： 翻译快表之于页表类似于Cache之于存储器)</p></li>
<li><p>二级页表：把整个页表分割成许多小页表，每个称为页表页，每个页表页含有若干个页表表项。页表页允许分散对应不连续的页框。为了找到页表页，应建立地址索引，称为页目录表，其表项指出页表页起始地址。</p></li>
<li><p>二级页表实现逻辑地址到物理地址转换的过程： 由硬件“页目录表基址寄存器”指出当前运行进程的页目录表的内存起始地址，加上“页目录位移”作为索引，可找到页表页在内存的起始地址，再以“页目录位移”作为索引，找到页表页在内存的起始位置，再以“页表页位移”作为索引，找到页表页的表项，此表项中包含一个页面对应的页框号，由页框号和页内偏移便可生成物理地址。</p>
<p><img src="./images/操作系统详解21.png" alt="OS_TwoLvPageTable" /></p>
<blockquote>
<p>注： 类比于书的目录，找某一段内容的时候，先在目录上找到对应的章节，再在对应的章节下面找具体的知识点。比如，我要在《操作系统原理》中查“多级页表”。首先我知道它是在存储管理一章的，于是就找到了“第四章 存储管理”（类似于找到了页目录表）。 然后在第四章下面找“多级页表”（类似于在页目录表下面找具体的页表页）。最后找到“多级页表”对应的页码（类似于在页表页中找到其对应的页框）。最后查阅对应的章节页码（类似于读取对应页框的数据）。</p>
</blockquote></li>
</ul>
<h3 id="分段存储管理">15. 分段存储管理</h3>
<p><img src="./images/操作系统详解22.png" alt="OS_Segment" /></p>
<blockquote>
<p>分段和分页的比较：</p>
<p>a. 分段是信息的<em>逻辑单位</em>，由源程序的逻辑结构及含义所决定，是用户可见的，段长由用户根据需要来确定，段起始地址可以从任何内存地址开始。引入的目的是<em>满足用户模块化程序设计的需要</em>。</p>
<p>b. 分页是信息的<em>物理单位</em>，与源程序的逻辑无关，是用户不可见的，页长由系统(硬件)决定，页面只能从页大小的整数倍地址开始。引入目的是<em>实现离散分配并提高内存利用率</em>。</p>
</blockquote>
<h3 id="虚拟存储管理">16. 虚拟存储管理</h3>
<ul>
<li><p>虚拟存储管理的基本思路：</p>
<p><img src="./images/操作系统详解23.png" alt="OS_VirtualMemory" /></p>
<p>把磁盘空间当做内存的一部分，进程的程序和数据部分放在内存中，部分放在磁盘上。程序运行时，它执行的指令或访问的数据在哪里由存储管理负责判断，并针对情况采取响应的措施。</p></li>
<li><p>请求分页虚存管理： 将进程信息副本存放在外存中，当它被调度投入运行时，程序和数据没有全部装进内存，仅装入当前使用页面，进程执行过程中访问到不在内存的页面时，产生缺页异常，再由系统自动调入。</p></li>
<li>全局页面替换策略(页面替换算法的作用范围是整个系统，不考虑进程的属主)：
a. 最佳页面替换算法(Optimal Replacement， OPT)。 淘汰不再访问的页或者距现在最长时间后才访问的页。
b. 先进先出页面替换算法(First in First Out Replacement， FIFO)。淘汰在内存中驻留时间最长的页。
c. 最近最少使用页面替换算法(Least Recently Used Replacement, LRU)。 淘汰最近一段时间内最久未被使用的页面。
d. 第二次机会页面替换算法(Second Chance Replacement， SCR)。 首先检查FIFO页面队列中的队首，这是最早进入内存的页面，如果其“引用位”为0，那么它最早进入且未被引用，此页被淘汰。如果其“引用位”为1，说明虽然它最早进内存，但最近仍在使用，于是将“引用位”清零，并把这个页面移到队尾，把它看做新调入的页面，再给它一次机会。
<p>e. 时钟页面替换算法(Clock Policy Replacement， Clock)。与SCR算法思路一致。只是用循环队列来构造页面队列，队列指针指向可能被淘汰的页面。如果队列指针指向的页的“引用位”为1，则将其置为0，同时队列指针指向下一个页。</p></li>
<li>局部页面替换算法(页面替换算法的作用局限于进程自身，要为进程维护称为工作集的一组页面)：
a. 局部最佳页面替换算法(Local Minimum Replacement, MIN)。 在t时刻时，若页面P在未来(t, t+delta)时间段内未被引用，则它被淘汰。
b. 工作集置换算法。 在t时刻时，若页面P在未来(t-delta, t)时间段内未被引用，则它被淘汰。
c. 模拟工作集替换算法。
<p>d. 缺页频率替换算法。</p></li>
</ul>
<h3 id="请求段页式虚拟内存管理">17. 请求段页式虚拟内存管理</h3>
<p><img src="./images/操作系统详解24.png" alt="OS_SegmentPage" /></p>
<ul>
<li>虚地址以程序的逻辑结构划分为段。</li>
<li>实地址划分为位置固定、大小相等的页框(块)。</li>
<li>逻辑地址分为三个部分：段号s、段内页号p、页内位移d。对于用户而言，段式虚拟地址应该由段号s和段内位移d’组成，操作系统内部自动把d’解释成段内页号p和页内位移号d。</li>
</ul>
<h3 id="io硬件原理io控制方式">18. I/O硬件原理：I/O控制方式</h3>
<ul>
<li>轮询方式： 又称程序直接控制方式。使用查询指令测试设备控制器的忙闲状态位，确定内存和设备是否能能交换数据。（注：所谓轮询，就好比，老湿依次问每一个童鞋：“有问题没？”， 如果没问题，就继续问下一个童鞋。如果这个童鞋有问题，这个老湿就停下了解决这个问题。然后又继续询问下一个童鞋。）</li>
<li>中断方式： 要求CPU和设备控制器及设备之间存在中断请求线，设备控制器的状态寄存器有相应的中断允许位。
a. 进程发出启动I/O指令。
b. 设备控制器检查状态寄存器的内容，执行相应的I/O操作，一旦传输完成，设备控制器通过中断请求线发出I/O中断信号。
c. CPU收到并响应I/O中断后，转向设备的I/O中断处理程序执行。
d. 中断处理程序执行数据读取操作，将I/O缓冲寄存器的内容写入内存。操作结束后退出中断程序恢复之前的状态。
e. 执行中断前之前运行的进程。<br />
（注： 类似于老湿在上面讲课，有童鞋问问题时，老湿就记录下自己讲到的位置，然后取回答童鞋的问题，回答完之后，又回到刚刚讲课的地方继续讲课）</li>
<li>DMA(Direct Memory Access, 直接存储器存取)方式： 内存和设备之间有一条数据通路成块的传输数据，无须CPU干9预，实际数据传输操作由DMA直接完成。</li>
<li>通道方式： CPU在执行主程序时遇到I/O请求，启动在指定通道上选址的设备，一旦启动成功，通道开始控制设备进行操作，这时CPU就可以执行其他任务并与通道并行工作，直到I/O操作完成；当通道发出I/O操作结束中断时，处理器才响应并停止当前工作，转而处理I/O操作结束时间。</li>
</ul>
<h3 id="io软件原理">19. I/O软件原理</h3>
<ul>
<li>I/O中断处理程序： 通常是设备驱动程序的组成部分之一。检查设备状态寄存器内容，判断产生中断原因，根据I/O操作的完成情况进行相应处理。若数据传输有错，应向上层软件报告设备出错信息，实施重新执行；若正常结束，应唤醒等待传输的进程，使其转换为就绪态；若有等待传输的I/O命令，应通知相关软件启动下一个I/O请求。</li>
<li>I/O设备驱动程序：设备驱动程序是设备专有的。把用户提交的逻辑I/O请求转化为物理I/O的启动和执行。同时监督设备是否正确执行，管理数据缓冲区，进行必要的纠错处理。</li>
<li>独立于设备的I/O软件</li>
<li>用户空间的I/O软件</li>
</ul>
<h3 id="缓冲技术">20. 缓冲技术</h3>
<ul>
<li><p>缓冲技术的基本思想： 当进程执行写操作输出数据时，先向系统申请一个输出缓冲区，然后将数据送至缓冲区，若是顺序写请求，则不断地把数据填入缓冲区，直至装满为止，此后进程可以继续计算，同时，系统将缓冲区的内容写在设备上。当进程执行读操作输入数据时，先向系统申请一个输入缓冲区，系统将设备上的一条物理记录读至缓冲区，根据要求把当前所需要的逻辑记录从缓冲区中选出并传送给进程。</p></li>
<li><p>单缓冲： 是最简单的缓冲技术，每当有I/O请求时，操作系统就在内存的系统区中开设一个缓冲区。不允许多个进程同时对一个缓冲器操作。</p>
<p><img src="./images/操作系统详解25.png" alt="OS_SingleBuffer" /></p></li>
<li><p>双缓冲： CPU可把输出到设备的数据放入其中一个缓冲器(区)、让设备慢慢处理；然后，它又可以从另一个为终端设置的缓冲器(区)中读取所需要的输入数据。</p>
<p><img src="./images/操作系统详解26.png" alt="OS_TwoBuffer" /></p></li>
<li><p>多缓冲： 是把多个缓冲区连接起来组成两部分，一部分专门用于输入，另一部分专门用于输出的缓冲结构。</p>
<p><img src="./images/操作系统详解27.png" alt="OS_MultiBuffer" /></p></li>
</ul>
<h3 id="驱动调度技术">21. 驱动调度技术</h3>
<ul>
<li>磁盘的物理结构：<br />
<img src="./images/操作系统详解28.png" alt="OS_DISK" /><br />
磁盘包括多个盘面，每个盘面有一个读写磁头，所有的磁头都固定在唯一的移动臂上同时移动。一个盘面上的读写磁头的轨迹称为磁道，读写磁头下的所有磁道形成柱面，一个磁道又可以划分为多个扇区。在磁盘上定位某个物理记录需要知道其柱面号、磁头号以及扇区号。定位物理记录时，磁头到达指定扇区的时间称为查找时间， 选择磁头号并旋转至指定扇区的时间称为搜索延迟。</li>
<li>磁道(柱面)的搜索定位算法：
a. 先来先服务算法(First Come First Server algorithm, FCFS)。
b. 最短查找时间优先算法： 总是执行查找时间最短的请求。
c. 扫描算法： 移动臂来回的扫过所有柱面，扫描处遇到I/O请求便进行处理。
d. 分步扫描算法： 将I/O请求分为长度为N的子队列，按FIFO算法依次处理每个队列，而每个子队列采用扫描算法，处理完一个后再服务下一个队列。
e. 电梯调度算法： 又称LOOK算法。<br />
<img src="./images/操作系统详解29.png" alt="OS_Elevator" /><br />
磁头号由外向内递增。
f. 循环扫描算法： 移动臂总是从0号柱面至最大号柱面顺序扫描，然后直接返回0号柱面重复进行，归途中不提供服务(而扫描算法归途是要提供服务的)。</li>
</ul>
<h3 id="设备独立性">22. 设备独立性</h3>
<ul>
<li>设备独立性： 用户通常不指定物理设备，而是指定逻辑设备，使得用户作业和物理设备分离开来，再通过其他途径建立逻辑设备和物理设备之间的映射，设备的这种特性称为设备独立性。</li>
</ul>
<h3 id="虚拟设备">23. 虚拟设备</h3>
<ul>
<li><p>外部设备同时联机操作(Simultaneous Peripheral Operations On Line, SPPPLing)：<br />
<img src="./images/操作系统详解30.png" alt="OS_SPOOLing" /></p>
a. 预输入程序。 控制信息从输入设备至输入井，填写预输入表以便在作业执行过程中要求输入信息时可以随时找到其存放位置。
b. 井管理程序。 作业执行过程中要求启动某台设备进程I/O操作时，作业控制程序截获这个要求并调用井管理程序控制从相应输入井读取信息，或将信息送至输出井。
<p>c. 缓输出程序。 当处理器空闲时，操作系统调用缓输出程序执行缓输出，它查看缓输出表是否有输出打印的文件，文件打印前还可能组织作业或文件标题，也可能对从输出井中读出的信息进行格式加工。</p></li>
</ul>
<h3 id="文件逻辑结构"><em>24. 文件逻辑结构</em></h3>
<ul>
<li>文件的逻辑结构的两种形式：
a. 流式文件。 一种无结构的文件，文件内的数据不再组成记录，只是一串顺序的信息集合，称为字节流文件。
b. 记录式文件。 一种有结构的文件，包含若干逻辑记录，逻辑记录是文件中按信息在逻辑上独立含义所划分的信息单位。</li>
</ul>
<h3 id="文件物理结构">25. 文件物理结构</h3>
<ul>
<li>文件物理结构： 文件的物理结构和组织是指逻辑文件在物理存储空间中的存放方法和组织关系。</li>
<li>常见组织方式：顺序文件、连接文件、直接文件和索引文件。</li>
</ul>
<h2 id="二qa">二、Q&amp;A</h2>
<h3 id="什么是操作系统操作系统在计算机系统中的主要作用是什么">1. 什么是操作系统？操作系统在计算机系统中的主要作用是什么？</h3>
<ul>
<li>定义： 操作系统尚无严格的定义。 一般可把操作系统定义为： 管理系统资源、控制程序执行、改善人机界面、提供各种服务，并合理组织计算机工作流程和为用户方便有效地使用计算机提供良好的运行环境的一种软件系统。</li>
<li>作用：
a. 服务用户。 操作系统作为用户接口和公共服务程序。
b. 进程交互。 操作系统作为进程执行的控制者和协调者。
c. 系统实现。 操作系统作为扩展机或虚拟机。
d. 资源管理。 操作系统作为资源的管理者和控制者。</li>
</ul>
<h3 id="什么是多道程序设计多道程序设计有什么特点">2. 什么是多道程序设计？多道程序设计有什么特点？</h3>
<ul>
<li>多道程序设计(multiprogramming)： 允许多个作业(程序)同时进入计算机系统的内存并启动交替计算的方法。</li>
<li>多道程序设计的特点： 从宏观上看是并行的，从微观上看是串行的。</li>
</ul>
<h3 id="计算机操作系统为什么引入进程">3. 计算机操作系统为什么引入进程？</h3>
<ul>
<li>刻画程序的并发性。</li>
<li>解决资源的共享性。</li>
</ul>
<h3 id="在分时系统中什么是响应时间它与哪些因素有关">4. 在分时系统中，什么是响应时间？它与哪些因素有关？</h3>
<ul>
<li>从交互式进程提交一个请求(命令)直到获得响应之间的时间间隔称为响应时间。</li>
<li>影响分时操作系统的响应时间的因素很多，如，CPU的处理速度、联机终端的数目、所用时间片的大小、系统调度开销和对换信息量的多少等。</li>
</ul>
<h3 id="解释并发性与并行性">5. 解释并发性与并行性</h3>
<ul>
<li>计算机操作系统中把并行性和并发性明显区分开，主要是从微观的角度来说的，具体是指进程的并行性（多处理机的情况下，多个进程同时运行）和并发性（单处理机的情况下，多个进程在同一时间间隔运行的）。</li>
<li>并行性是指硬件的并行性，两个或多个事件在同一时刻发生。</li>
<li>并发性是指进程的并发性，两个或多个事件在同一时间段内发生。</li>
</ul>
<h3 id="试述存储管理的基本功能">6. 试述存储管理的基本功能。</h3>
<ul>
<li>存储分配。</li>
<li>地址映射。</li>
<li>存储保护。</li>
<li>存储共享。</li>
<li>存储扩充。</li>
</ul>
<h3 id="何谓地址转换重定向哪些方法可以实现地址转换">7. 何谓地址转换(重定向)？哪些方法可以实现地址转换？</h3>
<ul>
<li><p>地址重定位： 又称地址转换，地址映射。 可执行程序逻辑地址转换(绑定)为物理地址的过程。</p></li>
<li>实现方法：
a. 静态地址重定位。 由装载程序实现装载代码模块的加载和地址转换，把它装入分配给进程的内存指定区域，其中的所有逻辑地址修改成内存物理地址。
<p>b. 动态地址重定位。</p>
<p><img src="./images/操作系统详解31.png" alt="OS_Dynamic" /></p>
由装载程序实现装载代码模块的加载和地址转换，把它装入分配给进程的内存指定区域，但对链接程序处理过的应用程序的逻辑地址则不做任何修改，程序内存起始地址被置于硬件专用寄存器 —— 重定位寄存器。程序执行过程中，每当CPU引用内存地址(访问程序和数据)时，由硬件截取此逻辑地址，并在它被发送到内存之前加上重定位寄存器的值，以便实现地址转换。
<p>c. 运行时链接地址重定位</p>
<blockquote>
程序链接的三种方式：
a. 静态链接。在程序装载到内存和运行前，就已将它的所有目标模块及所需要的库函数进行链接和装配成一个完整的可执行程序且此后不可拆分。
b. 动态链接。在程序装入内存前<em>并未</em>事先进行程序各目标模块的链接，而是在程序装载时一边装载一边链接，生成一个可执行文件。
<p>c. 运行时链接。 将某些目标模块或库函数的链接 推迟到执行时才进行。</p>
</blockquote></li>
</ul>
<h3 id="什么是文件的共享介绍文件共享的分类和实现思想">8. 什么是文件的共享？介绍文件共享的分类和实现思想。</h3>
<ul>
<li><ul>
<li><ul>
<li>文件共享： 不同进程共同使用同一个文件。</li>
<li>文件共享的分类：
a. 静态共享。 两个或多个进程通过文件链接(一个文件同时属于多个目录，但实际上仅有一处物理存储)达到共享同一个文件的目的，无论进程是否运行，其文件的链接关系都是存在的，因此称为静态共享。
b. 动态共享。 系统不同的应用程序或同一用户的不同进程并发地访问同一文件，这种共享关系只有当进程存在时才可能出现，一旦进程消亡，其共享关系也就随之消失。
c. 符号链接共享</li>
</ul></li>
</ul></li>
</ul>
<p>本篇部分博客摘自：<a href="https://www.cnblogs.com/jin-xin/articles/10078845.html" class="uri">https://www.cnblogs.com/jin-xin/articles/10078845.html</a></p>

</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>