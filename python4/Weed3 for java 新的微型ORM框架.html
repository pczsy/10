<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修Weed3 for java 新的微型ORM框架' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>Weed3 for java 新的微型ORM框架</center></div><div class='banquan'>原文出处:本文由博客园博主刘之西东提供。<br/>
原文连接:https://www.cnblogs.com/noear/p/12059171.html</div><br>
    <p>Weed3，微型ORM框架（支持：java sql，xml sql，annotation sql；template sql；事务；缓存；监听；等...）</p>
<p>05年时开发了第一代；<br />
08年时开发了第二代，那时候进入互联网公司，对性能有了全新的认识；<br />
14年时开发了第三代，因为不喜欢滥用反射，不喜欢有很多配置，所以一直在执着的没放弃。</p>
<p>前两代，都是在.net开发的；第三代，重点放在了java上。应该算是个功能全面且小巧的ORM框架：0.1mb，无其它依赖。对外的接口也不多，主要由DbContext上的四个接口发起所有的操作。</p>
<p>因为一些执念写的东西都算是比较微型的：</p>
<ul>
<li>Snack3（Json框架 70kb，有序列化，有Jsonpath，有格式转换机制；强调构建能力）</li>
<li>Solon（Web框架 80kb）</li>
<li>一个手机浏览器（0.1mb，可是有完整功能哦；算是一个创意作品）</li>
</ul>
<h4 id="weed3-特点和理念">Weed3 特点和理念：</h4>
<ul>
<li>高性能：两年前有个同事测过四个ORM框架，它是性能最好的（不知道现在是不是）。</li>
<li>跨平台：可以嵌入到JVM脚本引擎（js, groovy, lua, python, ruby）；也有.net，php版本。</li>
<li>很小巧：0.1Mb（且是功能完整，方案丰富；可极大简化数据库开发）。</li>
<li>有个性：不喜欢反射、不喜欢配置...（除了连接，不需要任何配置）。</li>
<li>其它的：支持缓存控制和跨数据库事务（算是分布式事务的一种吧）。</li>
</ul>
<h4 id="weed3-组件">Weed3 组件：</h4>
<table>
<thead>
<tr class="header">
<th>组件</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>org.noear:weed3</td>
<td>主框架（没有任何依赖）</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th>可选组件</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>org.noear:weed3-maven-plugin</td>
<td>Maven插件，用于生成Xml sql mapper</td>
</tr>
<tr class="even">
<td>org.noear:weed3-solon-plugin</td>
<td>Solon插件，支持@Db注解、Mapper直接注入</td>
</tr>
<tr class="odd">
<td></td>
<td></td>
</tr>
<tr class="even">
<td>org.noear:weed3.cache.memcached</td>
<td>基于 Memcached 适配的扩展缓存服务</td>
</tr>
<tr class="odd">
<td>org.noear:weed3.cache.redis</td>
<td>基于 Redis 适配的扩展缓存服务</td>
</tr>
<tr class="even">
<td>org.noear:weed3.cache.ehcache</td>
<td>基于 ehcache 适配的扩展缓存服务</td>
</tr>
<tr class="odd">
<td>org.noear:weed3.cache.j2cache</td>
<td>基于 j2cache 适配的扩展缓存服务</td>
</tr>
<tr class="even">
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>org.noear:weed3.render.beetl</td>
<td>基于 beetl 适配的扩展模板引擎</td>
</tr>
<tr class="even">
<td>org.noear:weed3.render.enjoy</td>
<td>基于 enjoy 适配的扩展模板引擎</td>
</tr>
<tr class="odd">
<td>org.noear:weed3.render.freemarker</td>
<td>基于 freemarker 适配的扩展模板引擎</td>
</tr>
<tr class="even">
<td>org.noear:weed3.render.velocity</td>
<td>基于 velocity 适配的扩展模板引擎</td>
</tr>
</tbody>
</table>
<h4 id="weed3-meven配置">Weed3 meven配置：</h4>
<pre><code><code>&lt;!-- 框架包 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.noear&lt;/groupId&gt;
    &lt;artifactId&gt;weed3&lt;/artifactId&gt;
    &lt;version&gt;3.2.6.2&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- maven 插件，用于生成Xml sql mapper接口 --&gt;
&lt;plugin&gt;
    &lt;groupId&gt;org.noear&lt;/groupId&gt;
    &lt;artifactId&gt;weed3-maven-plugin&lt;/artifactId&gt;
    &lt;version&gt;3.2.6.2&lt;/version&gt;
&lt;/plugin&gt;</code></pre>
<h4 id="weed3-入手流程">Weed3 入手流程：</h4>
<ul>
<li>配置DataSource信息</li>
<li>实始化DbContext</li>
<li>调用DbContext上的接口（需要大至了解一下语法...）</li>
</ul>
<h3 id="一-上下文对象-dbcontext">一、 上下文对象 DbContext</h3>
<h5 id="所有weed3的操作都是基于dbcontext上的接口的操作即一切从实例化dbcontext开始">所有weed3的操作，都是基于DbContext上的接口的操作。即，一切从实例化DbContext开始：</h5>
<ul>
<li>1.使用<code>application.yml</code>配置数据源（或别的格式配置，或配置服务），格式示例：</li>
</ul>
<pre class="ini"><code>#这是DbContext原生配置；如果是为连接池，请参考对方的配置；
demo.db:
    schema: demo
    url: jdbc:mysql://localdb:3306/demo?...
    driverClassName: com.mysql.cj.jdbc.Driver
    username: demo
    password: UL0hHlg0Ybq60xyb</code></pre>
<ul>
<li><p>2.有配置之后开始实列化DbContext：</p>
<blockquote>
<p>如果是 Spring 框架，可以通过注解获取配置<br />
如果是 solon 框架，可以通过注解 或 接口获取配置</p>
</blockquote></li>
</ul>
<pre class="java"><code>//使用Properties配置的示例
Properties properties = XApp.cfg().getProp(&quot;demo.db&quot;); //这是solon框架的接口
DbContext db  = new DbContext(properties); 

//使用Map配置的示例
DbContext db  = new DbContext(map); 

//使用proxool线程池配置的示例（好像现在不流行了）//proxool通过xml配置
DbContext db  = new DbContext(&quot;user&quot;,&quot;proxool.xxx_db&quot;); 

//使用DataSource配置的示例（一般使用连接池框架时用；推荐 Hikari 连接池）
//下行demo里用的正是 Hikari 连接池
DataSource dataSource = new HikariDataSource(...);
DbContext db  = new DbContext(&quot;user&quot;, dataSource); 

//还有就是用url,username,password（这个就不需要配置了）
DbContext db  = new DbContext(&quot;user&quot;,&quot;jdbc:mysql://x.x.x:3306/user&quot;,&quot;root&quot;,&quot;1234&quot;);

/* 我平时都用配置服务，所以直接由配置提供数据库上下文对象。 */
//使用配置服务直接拿到DbContext
DbContext db = WaterClient.Config.get(&quot;demo.db&quot;).getDb();</code></pre>
<h3 id="二四大接口-db.mapper-db.table-db.call-db.sql">二、四大接口 db.mapper(), db.table(), db.call(), db.sql()</h3>
<blockquote>
<p>四大接口，也是DbContext在不同场景上的四种应用方案</p>
<p>核心接口：db.mapper(), db.table()。代表两种完全不同的风格和口味。</p>
<p>补充接口：db.call(), db.sql()。应对特殊的应用场景。</p>
</blockquote>
<h6 id="其中db.table-db.call-db.sql-可以友好的嵌入到jvm脚本引擎js-groovy-lua-python-ruby和部分graalvm语言使用">其中db.table(), db.call(), db.sql() 可以友好的嵌入到<code>JVM脚本引擎</code>（js, groovy, lua, python, ruby）和部分<code>GraalVM</code>语言使用。</h6>
<h6 id="因为作者还有个嵌入式faas引擎统一的执行发起对象无注入无配置且弱类型的接口作用重大可以便利的嵌入各种语言中并提供统一的orm体验">因为作者还有个嵌入式FaaS引擎。统一的执行发起对象、无注入无配置、且弱类型的接口作用重大；可以便利的嵌入各种语言中，并提供统一的ORM体验。</h6>
<h5 id="一db.mapper提供mapper操作支持">（一）db.mapper()，提供mapper操作支持</h5>
<blockquote>
<p>mapper风格，是现在极为流行的一种。大多人都在用。</p>
<p>此接口提供了BaseMapper模式，@Sql注入模式，Xml sql配置模式。其中，Xml sql 的内部处理会在启动时预编译为Java class；性能应该是靠谱的（好像有点儿jsp的预编译味道）。</p>
</blockquote>
<ul>
<li><p>1.db.mapperBase(clz) 获取BaseMapper实例</p>
<blockquote>
<p>自Xxx-plus之后，要是个没有BaseMapper，好像都不好意思说自己是个ORM框架了。</p>
<p>这个接口确实带来了极大的方法，简单的CRUD完全省掉了。</p>
</blockquote></li>
</ul>
<pre class="java"><code>//直接使用BaseMapper
BaseMapper&lt;User&gt; userDao= db.mapperBase(User.class);

//增
userDao.insert(user,false); //false:表示排除null值

//删
userDao.deleteById(12); 

//改：通过ID改
userDao.updateById(user,false); //false:表示排除null值
//改：通过条件改
userDao.update(user,false,m-&gt;m.whereEq(User::getType,12).andEq(User::getSex,1));

//查.通过ID查
User user = userDao.selectById(12);
//查.通过条件查（条件，可以是字符串风格；可以是lambda风格）
User user = userDao.selectItem(m -&gt; m.whereEq(User::getId,12));</code></pre>
<ul>
<li>2.db.mapper(clz)，获取Mapper实例</li>
</ul>
<pre class="java"><code>@Namespace(&quot;demo.dso.db&quot;)
public interface UserDao { //此接口，可以扩展自 BaseMapper&lt;T&gt;
    @sql(&quot;select * from `user` where id=@{id}&quot;) //变量风格
    User getUserById(int id);
  
    @sql(&quot;select * from `user` where id=?&quot;)         //占位符风格
    User getUserById2(int id);
  
    @sql(&quot;#user_stat.sql&quot;)                                          //SQL模板风格（适用特别复杂的统计查询）
    User getUserById2(int id);
  
    long addUser(User m); //没有注解，需编写xml sql配置
}

UserDao userDao = db.mapper(UserDao.class);

User user = userDao.getUserById(12);
userDao.addUser(user);</code></pre>
<ul>
<li><p>3.db.mapper(xsqlid, args)，获取Xml sql mapper结果</p>
<blockquote>
<p>此接口的好处是，可以把DAO做成一个中台：把xml sql 放在数据库里，统一管理；并通过开发一个DAO网关，以RPC或REST API方式提供服务。<br />
```java<br />
Map&lt;String,Object&gt; args = new HashMap&lt;&gt;();<br />
args.put(&quot;id&quot;,22);</p>
</blockquote></li>
</ul>
<p>//xsqlid = @{sqlid} = @{namespace}.{id}<br />
User user = db.mapper(&quot;@demo.dso.db.getUserById&quot;,args);<br />
```</p>
<h5 id="二db.table提供纯java链式操作">（二）db.table()，提供纯java链式操作</h5>
<blockquote>
<p>这是Weed3最初的样子，这也是我最喜欢的方法。也是具体跨平台嵌入的关键能力。</p>
<p>BaseMapper内部也是由db.table()实现的，简单几行代就OK了。</p>
<p>灵活，有弹性，直接，可以实现任何SQL代码效果。开发管理后台，很爽（因为查询条件又杂又乱）。</p>
<p>此接口，可以方便的嵌入到JVM脚本引擎（js, groovy, lua, python, ruby），或GraalVM的语言里。</p>
</blockquote>
<h6 id="db.table-接口">db.table() 接口：</h6>
<h6 id="字符串风格弹性大自由方便可嵌入语法便于跨平台但改字段名会麻烦些没事儿也不乱改吧">1.字符串风格：弹性大、自由方便、可嵌入，语法便于跨平台；但改字段名会麻烦些（没事儿也不乱改吧）。</h6>
<ul>
<li>增,INSEERT</li>
</ul>
<pre class="java"><code>User user = new User();
..
//单条插入
db.table(&quot;user&quot;).set(&quot;name&quot;,&quot;noear&quot;).insert();
db.table(&quot;user&quot;).setEntity(user).insert();
db.table(&quot;user&quot;).setEntityIf(user, (k,v)-&gt;v!=null).insert(); //过滤null

//批量插入
db.table(&quot;user&quot;).insertList(list);</code></pre>
<ul>
<li>删,DELETE</li>
</ul>
<pre class="java"><code>//删掉id&lt;12的记录
db.table(&quot;user&quot;).whereLt(&quot;id&quot;,12).delete();</code></pre>
<ul>
<li>改,UPDATE</li>
</ul>
<pre class="java"><code>//改掉id=23的sex字段
db.table(&quot;user&quot;).set(&quot;sex&quot;,1).whereEq(&quot;id&quot;,23).update();

//根据手机号，新增或更新
public void saveUser(UserModel m){
  db.talbe(&quot;user&quot;).setEntityIf(m, (k,v)-&gt;v!=null).upsert(&quot;mobile&quot;);
}</code></pre>
<ul>
<li>查,SELECT</li>
</ul>
<pre class="java"><code>//统计id&lt;100, 名字长度&gt;10的记录数（可以自由的使用SQL函数）
db.table(&quot;user&quot;).where(&quot;id&lt;?&quot;, 100).and(&quot;LENGTH(name)&gt;?&quot;,10).count();

//查询20条，id&gt;10的记录
db.table(&quot;user&quot;).whereGte(&quot;id&quot;, 10).limit(20).select(&quot;*&quot;).getMapList();

//关联查询并输出一个实体
db.table(&quot;user u&quot;)
  .innerJoin(&quot;user_ex e&quot;).onEq(&quot;u.id&quot;,&quot;e.user_id&quot;)
  .whereEq(&quot;u.id&quot;, 10).andEq(&quot;e.sex&quot;,1)
  .limit(1)
  .select(&quot;u.*,e.sex user_sex&quot;)
  .getItem(User.class);
</code></pre>
<ul>
<li>具有过滤能力的接口：whereIf, andIf, orIf, setIf, setMapIf, setEntityIf</li>
</ul>
<pre class="java"><code>//如果有名字，加名字条件；（管理后台的查询，很实用的; 省了很多if）
db.talbe(&quot;user&quot;).whereIf(name!=null, &quot;name=?&quot;, name).limit(10).select(&quot;*&quot;);

//插入，过滤null
db.table(&quot;user&quot;).setMapIf(map,(k,v)-&gt;v!=null).insert(); //过滤null

//更新
db.table(&quot;user&quot;)
.setIf(name!=null, &quot;name&quot;,name)
.setIf(sex&gt;0, &quot;sex&quot;, sex)
.setIf(mobile!=null &amp;&amp; mobile.length() =11,&quot;mobile&quot;,mobile)
.where(&quot;id=?&quot;,id)
.update();</code></pre>
<h5 id="三db.call提供call操作">（三）db.call()，提供call操作</h5>
<ul>
<li>call 存储过程</li>
</ul>
<pre class="java"><code>User user = db.call(&quot;user_get&quot;).set(&quot;id&quot;,1).getItem(User.class);</code></pre>
<ul>
<li>call sql</li>
</ul>
<pre class="java"><code>//@Sql内部由此实现
//
User user = db.call(&quot;select * from user where id=@{id}&quot;).set(&quot;id&quot;,1).getItem(User.class);</code></pre>
<ul>
<li>call Xmlsql</li>
</ul>
<pre class="java"><code>//需@开头 + sqlid
//
User user = db.call(&quot;@demo.dso.db.getUser&quot;).set(&quot;id&quot;,1).getItem(User.class);</code></pre>
<ul>
<li>call template sql</li>
</ul>
<pre class="java"><code>//需#开头 + 模板路径
Map&lt;String,Object&gt; args = new DataItem().set(&quot;date&quot;,20201010).getMap();
db.call(&quot;#user_stat.sql&quot;, args).getMapList();</code></pre>
<h5 id="四db.sql提供手写sql操作">（四）db.sql()，提供手写sql操作</h5>
<pre class="java"><code>//所以接口最终都会转为db.sql()，算是最底层的一个接口
//
User user = db.sql(&quot;select * from user where id=?&quot;,12).getItem(User.class);

Long total = db.sql(&quot;select count(*) from user&quot;).getValue(0l);

//db.sql() 的快捷版: db.exe()，用于快速批处理
//
db.exe(&quot;delete from user where id=12&quot;);
db.exe(&quot;update user sex=1 where id=12&quot;);</code></pre>
<h3 id="三mapper-语法">三、Mapper 语法</h3>
<h5 id="一basemapper-接口">（一）BaseMapper 接口</h5>
<ul>
<li><code>Long insert(T entity, boolean excludeNull);</code></li>
<li><code>void insertList(List&lt;T&gt; list);</code></li>
<li><code>Integer deleteById(Object id);</code></li>
<li><code>Integer deleteByIds(Iterable&lt;Object&gt; idList);</code></li>
<li><code>Integer deleteByMap(Map&lt;String, Object&gt; columnMap);</code></li>
<li><code>Integer delete(Act1&lt;WhereQ&gt; condition);</code></li>
<li><code>Integer updateById(T entity, boolean excludeNull);</code></li>
<li><code>Integer update(T entity, boolean excludeNull, Act1&lt;WhereQ&gt; condition);</code></li>
<li><code>Long upsert(T entity, boolean excludeNull);</code></li>
<li><code>Long upsertBy(T entity, boolean excludeNull, String conditionFields);</code></li>
<li><code>boolean existsById(Object id);</code></li>
<li><code>boolean exists(Act1&lt;WhereQ&gt; condition);</code></li>
<li><code>T selectById(Object id);</code></li>
<li><code>List&lt;T&gt; selectByIds(Iterable&lt;Object&gt; idList);</code></li>
<li><code>List&lt;T&gt; selectByMap(Map&lt;String, Object&gt; columnMap);</code></li>
<li><code>T selectItem(T entity);</code></li>
<li><code>T selectItem(Act1&lt;WhereQ&gt; condition);</code></li>
<li><code>Map&lt;String, Object&gt; selectMap(Act1&lt;WhereQ&gt; condition);</code></li>
<li><code>Object selectValue(String column, Act1&lt;WhereQ&gt; condition);</code></li>
<li><code>Long selectCount(Act1&lt;WhereQ&gt; condition);</code></li>
<li><code>List&lt;T&gt; selectList(Act1&lt;WhereQ&gt; condition);</code></li>
<li><code>List&lt;Map&lt;String, Object&gt;&gt; selectMapList(Act1&lt;WhereQ&gt; condition);</code></li>
<li><code>List&lt;Object&gt; selectArray(String column, Act1&lt;WhereQ&gt; condition);</code></li>
<li><code>List&lt;T&gt; selectPage(int start, int end, Act1&lt;WhereQ&gt; condition);</code></li>
<li><code>List&lt;Map&lt;String, Object&gt;&gt; selectMapPage(int start, int end, Act1&lt;WhereQ&gt; condition);</code></li>
</ul>
<h5 id="二annotation-sql">（二）annotation sql</h5>
<ul>
<li>示例</li>
</ul>
<pre class="java"><code>ICacheServiceEx cache = new LocalCache().nameSet(&quot;cache&quot;);

//顺带加了缓存
@Sql(value=&quot;select * from user where id=@{id}&quot;, caching=&quot;cache&quot;)
public UserModel getUser(int id);</code></pre>
<ul>
<li>Sql 注解说明</li>
</ul>
<pre class="java"><code>@Target({ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface Sql {
    String value() default &quot;&quot;;      //代码
    String caching() default &quot;&quot;;    //缓存服务名称
    String cacheClear() default &quot;&quot;; //缓存清除标签
    String cacheTag() default &quot;&quot;;   //缓存标签
    int usingCache() default 0;     //缓存时间
}</code></pre>
<h5 id="三xml-sql">（三）Xml sql</h5>
<ul>
<li>示例</li>
</ul>
<pre><code><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;
&lt;mapper namespace=&quot;weed3demo.xmlsql2&quot;&gt;
    &lt;sql id=&quot;getUser&quot; :return=&quot;demo.model.UserModel&quot; :note=&quot;获取用户信息&quot;&gt;
        SELECT * FROM user WHERE id = @{id:int}
    &lt;/sql&gt;
&lt;/mapper&gt;</code></pre>
<ul>
<li>语法</li>
</ul>
<pre><code><code>mapper 开始标签
  namespace （属性：命名空间，{namespace}.{id} = sqlid）
    
sql 代码块定义指令
  id （属性：id）
  :require（属性：导入包或类）
  :param?（属性：外部输入变量申明；默认会自动生成::新增***）
  :declare（属性：内部变量类型预申明）
  :return（属性：返回类型）

  :note（属性：描述、说明、注解）

  :caching（属性：缓存服务name） //是对 ICacheController 接口的映射
  :cacheClear?（属性：清除缓存）
  :cacheTag?（属性：缓存标签，支持在入参或结果里取值替换）
  :usingCache?（属性：缓存时间,int）

if 判断控制指令（没有else）
  test （属性：判断检测代码）
     //xml避免语法增强:
     //lt(&lt;) lte(&lt;=) gt(&gt;) gte(&gt;=) and(&amp;&amp;) or(||)
        //例：m.sex gt 12 :: m.sex &gt;=12
     //简化语法增强:
     //??(非null,var!=null) ?!(非空字符串,StringUtils.isEmpty(var)==false)
        //例：m.icon??  ::m.icon!=null
        //例：m.icon?!  ::StringUtils.isEmpty(m.icon)==false

for 循环控制指令 （通过 ${var}_index 可获得序号，例：m_index::新增***）
  var （属性：循环变量申明）
  items （属性：集合变量名称）
  sep? （属性：分隔符::新增***）

trim 修剪指令
  trimStart（属性：开始位去除）
  trimEnd（属性：结尾位去除）
  prefix（属性：添加前缀）
  suffix（属性：添加后缀）

ref 引用代码块指令
  sql （属性：代码块id）

name:type    = 变量申明（可用于属性：:param, :declare，var，或宏定义 @{..},${..}）
@{name:type} = 变量注入
${name:type} = 变量替换

//列表([]替代&lt;&gt;)
:return=&quot;List[weed3demo.mapper.UserModel]&quot; =&gt; List&lt;UserModel&gt;
:return=&quot;List[String]&quot; =&gt; List&lt;String&gt; （Date,Long,...大写开头的单值类型）
:return=&quot;MapList&quot; =&gt; List&lt;Map&lt;String,Object&gt;&gt;
:return=&quot;DataList&quot; =&gt; DataList

//一行
:return=&quot;weed3demo.mapper.UserModel&quot; =&gt; UserModel
:return=&quot;Map&quot; =&gt; Map&lt;String,Object&gt;
:return=&quot;DataItem&quot; =&gt; DataItem

//单值
:return=&quot;String&quot; =&gt; String （任何单职类型）</code></pre>
<h3 id="四table-语法">四、Table 语法</h3>
<h5 id="一条件操作与mapper共享">（一）条件操作（与Mapper共享）</h5>
<table>
<thead>
<tr class="header">
<th>方法</th>
<th>效果说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>where, whereIf</td>
<td></td>
</tr>
<tr class="even">
<td>whereEq, whereNeq</td>
<td>==, !=</td>
</tr>
<tr class="odd">
<td>whereLt, whereLte</td>
<td>&lt;, &lt;=</td>
</tr>
<tr class="even">
<td>whereGt, whereGte</td>
<td>&gt;, &gt;=</td>
</tr>
<tr class="odd">
<td>whereLk, whereNlk</td>
<td>LIKE, NOT LIKE</td>
</tr>
<tr class="even">
<td>whereIn, whereNin</td>
<td>IN(..), NOT IN(..)</td>
</tr>
<tr class="odd">
<td>whereBtw, whereNbtw</td>
<td>BETWEEN, NOT BETWEEN</td>
</tr>
<tr class="even">
<td>and系统方法</td>
<td>同where</td>
</tr>
<tr class="odd">
<td>or系统方法</td>
<td>同where</td>
</tr>
<tr class="even">
<td>begin</td>
<td>(</td>
</tr>
<tr class="odd">
<td>end</td>
<td>)</td>
</tr>
</tbody>
</table>
<h5 id="二表操作table独占">（二）表操作（Table独占）</h5>
<table>
<thead>
<tr class="header">
<th>方法</th>
<th>效果说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>set, setIf</td>
<td>设置值</td>
</tr>
<tr class="even">
<td>setMap, setMapIf</td>
<td>设置值</td>
</tr>
<tr class="odd">
<td>setEntity, setEntityIf</td>
<td>设置值</td>
</tr>
<tr class="even">
<td>table</td>
<td>主表</td>
</tr>
<tr class="odd">
<td>innerJoin, leftJoin, rightJoin</td>
<td>关联表</td>
</tr>
<tr class="even">
<td>on, onEq</td>
<td>关联条件</td>
</tr>
<tr class="odd">
<td>orderBy, orderByAsc, orderByDesc</td>
<td>排序</td>
</tr>
<tr class="even">
<td>groupBy</td>
<td>组</td>
</tr>
<tr class="odd">
<td>having</td>
<td>组条件</td>
</tr>
<tr class="even">
<td>limit</td>
<td>限制范围</td>
</tr>
<tr class="odd">
<td>select</td>
<td>查询（返回IQuery）</td>
</tr>
<tr class="even">
<td>count</td>
<td>查询快捷版，统计数量</td>
</tr>
<tr class="odd">
<td>exists</td>
<td>查询快捷版，是否存在</td>
</tr>
<tr class="even">
<td>update</td>
<td>更新</td>
</tr>
<tr class="odd">
<td>insert</td>
<td>插入</td>
</tr>
<tr class="even">
<td>delete</td>
<td>删除</td>
</tr>
</tbody>
</table>
<h5 id="三iquery接口">（三）IQuery接口</h5>
<ul>
<li><code>long getCount() throws SQLException;</code></li>
<li><code>Object getValue() throws SQLException;</code></li>
<li><code>&lt;T&gt; T getValue(T def) throws SQLException;</code></li>
<li><code>Variate getVariate() throws SQLException;</code></li>
<li><code>&lt;T&gt; T getItem(Class&lt;T&gt; cls) throws SQLException;</code></li>
<li><code>&lt;T&gt; List&lt;T&gt; getList(Class&lt;T&gt; cls) throws SQLException;</code></li>
<li><code>DataList getDataList() throws SQLException;</code></li>
<li><code>DataItem getDataItem() throws SQLException;</code></li>
<li><code>List&lt;Map&lt;String,Object&gt;&gt; getMapList() throws SQLException;</code></li>
<li><code>Map&lt;String,Object&gt; getMap() throws SQLException;</code></li>
<li><code>&lt;T&gt; List&lt;T&gt; getArray(String column) throws SQLException;</code></li>
<li><code>&lt;T&gt; List&lt;T&gt; getArray(int columnIndex) throws SQLException;</code></li>
<li>等...</li>
</ul>
<h3 id="五-缓存和事务">五、 缓存和事务</h3>
<ul>
<li>缓存（不需要的可以跳过）</li>
</ul>
<pre class="java"><code>ICacheServiceEx cache = new LocalCache().nameSet(&quot;cache&quot;);

User user = db.table(&quot;user&quot;)
              .where(&quot;id=?&quot;,12)
              .caching(cache)  //加缓存，时间为cache的默认时间
              .select(&quot;*&quot;).getItem(User.class);</code></pre>
<ul>
<li>缓存控制（不需要的可以跳过）</li>
</ul>
<pre class="java"><code>//查询时，缓存
User user = db.table(&quot;user&quot;)
              .where(&quot;id&gt;?&quot;,12)
              .limit(100,20) //分页查询
              .caching(cache)
              .usingCache(60*5)     //缓存5分钟
              .cacheTag(&quot;user_all&quot;) //加缓存标签user_all
              .select(&quot;*&quot;).getList(User.class);

//更新时，清除缓存 //下次查询时，又可拿到最新数据
db.table(&quot;user&quot;).set(&quot;sex&quot;,0).where(&quot;id=101&quot;).update();
cache.clear(&quot;user_all&quot;);</code></pre>
<ul>
<li>单库数据库事务</li>
</ul>
<pre class="java"><code>db.tran(t-&gt;{
  //注册用户
  long user_id = userDao.addUser(user);
  
  //注册后送10个金币（在同一个事务里完成）
  userDao.addUserGold(user_id, 10);
});</code></pre>
<ul>
<li>跨库数据库事务（不知道算不算是分布式事务的一种）</li>
</ul>
<pre class="java"><code>new DbTranQueue().execute((tq) -&gt; {
    //用户系统，添加用户关金币
    db1.tran().join(tq).execute(t -&gt; {
        user.id = userDao.addUser(user); //id自增
    });

    //银行系统
    db2.tran().join(tq).execute(t -&gt; {
        bankDao.addAccount(user.id); //新建账号
        bankDao.addAccountGold(user.id, 10); //添加账号叫金币
        bankDao.addJournal(user.id,10); //添加日记账
    });
  
    //扩播消息//为后续横向扩展业务
    MsgUtil.sendMessage(&quot;user.registered&quot;,user.value);
});</code></pre>
<h3 id="六-监听与记录">(六) 监听与记录</h3>
<ul>
<li>监听异常</li>
</ul>
<pre class="java"><code>WeedConfig.onException((cmd,ex)-&gt;{
  //可以做个记录
    ex.printStackTrace();
});</code></pre>
<ul>
<li>观察性能</li>
</ul>
<pre class="java"><code>WeedConfig.onExecuteAft((cmd)-&gt;{
  //cmd.timespan()  //获取执行时长（毫秒）
});</code></pre>
<ul>
<li>记录行为</li>
</ul>
<pre class="java"><code>WeedConfig.onLog((cmd) -&gt; {
    if (cmd.isLog &gt;= 0) { //isLog: -1,不需要记录；0,默认；1,需要记录
        //cmd.text;         //执行代码
        //cmd.paramS;         //执行参数
        //cmd.paramMap();   //执行参数Map化
    }
});</code></pre>
<ul>
<li>代码过滤</li>
</ul>
<pre class="java"><code>//例：禁止DELETE操作
WeedConfig.onExecuteBef((cmd)-&gt;{
    if(cmd.text.indexOf(&quot;DELETE &quot;) &gt;=0){
        return false;
    }
    return true;
});</code></pre>
<h3 id="七-嵌入到jvm脚本">(七) 嵌入到JVM脚本</h3>
<ul>
<li>嵌入到javascript引擎（nashorn）</li>
</ul>
<pre class="java"><code>ScriptEngineManager scriptEngineManager = new ScriptEngineManager();
ScriptEngine _eng = scriptEngineManager.getEngineByName(&quot;nashorn&quot;);
Invocable _eng_call = (Invocable)_eng;
_eng.put(&quot;db&quot;, db);

/*
 * var map = db.table(&quot;user&quot;).where(&#39;id=?&#39;,1).getMap();
 * var user_id = map.id;
 */</code></pre>
<ul>
<li>嵌入到groovy引擎</li>
</ul>
<pre class="java"><code>ScriptEngineManager scriptEngineManager = new ScriptEngineManager();
ScriptEngine _eng = scriptEngineManager.getEngineByName(&quot;groovy&quot;);
Invocable _eng_call = (Invocable)_eng;
_eng.put(&quot;db&quot;, db);

/*
 * def map = db.table(&quot;user&quot;).where(&#39;id=?&#39;,1).getMap();
 * def user_id = map.id;
 */</code></pre>
<h3 id="八-语法说明">(八) 语法说明</h3>
<ul>
<li><a href="https://gitee.com/noear/weed3/blob/master/WEED3_XML_%E8%AF%AD%E6%B3%95.mdv">《WEED3 XML 语法》</a></li>
<li><a href="https://gitee.com/noear/weed3/blob/master/WEED3_%E6%A8%A1%E6%9D%BF_%E8%AF%AD%E6%B3%95.md">《WEED3 模板语法》</a></li>
<li><a href="https://gitee.com/noear/weed3/blob/master/WEED3_JAVA_%E6%8E%A5%E5%8F%A3%E5%AD%97%E5%85%B8.md">《WEED3 JAVA 接口字典》</a></li>
</ul>
<blockquote>
<p>有机会，将对一些细节再做介绍...</p>
</blockquote>

</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>