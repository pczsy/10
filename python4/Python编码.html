<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修Python编码' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>Python编码</center></div><div class='banquan'>原文出处:本文由博客园博主kolane提供。<br/>
原文连接:https://www.cnblogs.com/kolane/p/11538117.html</div><br>
    <h3 id="内存和硬盘都是用来存储的">1.内存和硬盘都是用来存储的。</h3>
<p>内存：速度快</p>
<p>硬盘：永久保存</p>
<p><img src="./images/Python编码0.png" alt="img" /></p>
<h3 id="文本编辑器存取文件的原理nodepadpycharmword"><strong>2.文本编辑器存取文件的原理（nodepad++,pycharm,word）</strong></h3>
<p>　　　打开编辑器就可以启动一个进程，是在内存中的，所以在编辑器编写的内容也都是存放在内存中的，断电后数据就丢失了。因而需要保存在硬盘上，点击保存按钮或快捷键，就把内存中的数据保存到了硬盘上。在这一点上，我们编写的py文件（没有执行时），跟编写的其他文件没有什么区别，都只是编写一堆字符而已。</p>
<h3 id="python解释器执行py文件的原理例如python-test.py"><strong>3.python解释器执行py文件的原理，例如python test.py</strong></h3>
<p>　　第一阶段：python解释器启动，此时就相当于启动了一个文本编辑器</p>
<p>　　第二阶段：python解释器相当于文本编辑器，去打开test.py，从硬盘上将test.py的文件内容读入到内存中</p>
<p>　　第三阶段：python解释器执行刚刚加载到内存中的test.py的代码（在该阶段，即执行时，才会识别python的语法，执行到字符串时，会开辟内存空间存放字符串）</p>
<p>总结：python解释器与文本编辑器的异同</p>
<p>相同点：python解释器是解释执行文件内容的，因而python解释器具备读py文件的功能，这一点与文本编辑器一样</p>
<p>不同点：文本编辑器将文件内容读入内存后，是为了显示/编辑，而python解释器将文件内容读入内存后，是为了执行（识别python的语法）</p>
<h3 id="什么是编码"><strong>4.什么是编码？</strong></h3>
<p>　　计算机想要工作必须通电，高低电平（高电平即二进制数1，低电平即二进制数0），也就是说计算机只认识数字。那么让计算机如何读懂人类的字符呢?</p>
<p>　　这就必须经过一个过程：</p>
<p>　　　　字符---------（翻译过程）-------------数字</p>
<p>　　这个过程实际就是一个字符如何对应一个特定数字的标准，这个标准称之为字符编码。</p>
<h3 id="以下两个场景涉及到字符编码的问题"><strong>5.以下两个场景涉及到字符编码的问题：</strong></h3>
<p>　　1.一个python文件中的内容是由一堆字符组成的（python文件未执行时）</p>
<p>　　2.python中的数据类型字符串是由一串字符组成的（python文件执行时）</p>
<h3 id="字符编码的发展史"><strong>6.字符编码的发展史</strong></h3>
<p><strong>阶段一：现代计算机起源于美国，最早诞生也是基于英文考虑的ASCII</strong></p>
<p>　　 ASCII:一个Bytes代表一个字符（英文字符/键盘上的所有其他字符），1Bytes=8bit，8bit可以表示0-2**8-1种变化，即可以表示256个字符</p>
<p>　　　　ASCII最初只用了后七位，127个数字，已经完全能够代表键盘上所有的字符了（英文字符/键盘的所有其他字符）</p>
<p>　　　　后来为了将拉丁文也编码进了ASCII表，将最高位也占用了</p>
<p><strong>阶段二:为了满足中文，中国人定制了GBK</strong></p>
<p>　　GBK:2Bytes代表一个字符，为了满足其他国家，各个国家纷纷定制了自己的编码，日本把日文编到<code>Shift_JIS</code>里，韩国把韩文编到<code>Euc-kr</code>里</p>
<p><strong>阶段三：各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。</strong></p>
<p>于是产生了unicode，统一用<strong>2Bytes</strong>代表一个字符，2**16-1=65535，可代表6万多个字符，因而兼容万国语言</p>
<p>但对于通篇都是英文的文本来说，这种编码方式无疑是多了一倍的存储空间（二进制最终都是以电或者磁的方式存储到存储介质中的）</p>
<p>于是产生了UTF-8，对英文字符只用1Bytes表示，对中文字符用3Bytes</p>
<p><strong>需要强调的是：</strong></p>
<p>　　<strong>unicode：</strong>简单粗暴，多有的字符都是2Bytes,优点是字符--数字的转换速度快；缺点是占用空间大。</p>
<p>　　<strong>utf-8:</strong>精准，可变长，优点是节省空间；缺点是转换速度慢，因为每次转换都需要计算出需要多长Bytes才能够准确表示。</p>
<p>1.内存中使用的编码是unicode，用空间换时间（程序都需要加载到内存才能运行，因而内存应该是越快越好）</p>
<p>2.硬盘中或网络传输用utf-8，保证数据传输的稳定性。</p>
<pre><code><code>1 所有程序，最终都要加载到内存，程序保存到硬盘不同的国家用不同的编码格式，但是到内存中我们为了兼容万国（计算机可以运行任何国家的程序原因在于此），统一且固定使用unicode， 
2 这就是为何内存固定用unicode的原因，你可能会说兼容万国我可以用utf－8啊，可以，完全可以正常工作，之所以不用肯定是unicode比utf－8更高效啊（uicode固定用2个字节编码
3 ，utf－8则需要计算），但是unicode更浪费空间，没错，这就是用空间换时间的一种做法，而存放到硬盘，或者网络传输，都需要把unicode转成utf－8， 
4 因为数据的传输，追求的是稳定，高效，数据量越小数据传输就越靠谱，于是都转成utf－8格式的，而不是unicode。</code></pre>
<h3 id="七字符编码转换"><strong>七、字符编码转换</strong>　　</h3>
<p>unicode------&gt;encode(编码)--------&gt;utf-8</p>
<p>utf-8----------&gt;decode---------&gt;unicode</p>
<p><img src="./images/Python编码1.png" alt="img" /></p>
<p><strong>文件从内存刷到硬盘的操作简称存文件</strong></p>
<p><strong>文件从硬盘读到内存的操作简称读文件</strong></p>
<p><strong>乱码：存文件时就已经乱码 或者 存文件时不乱码而读文件时乱码</strong></p>
<p>总结：</p>
<p>无论是何种编辑器，要防止文件出现乱码（请一定注意，存放一段代码的文件也仅仅只是一个普通文件而已，此处指的是文件没有执行前，我们打开文件时出现的乱码）</p>
<p>核心法则就是，文件以什么编码保存的，就以什么编码方式打开</p>
<h3 id="八-文本编辑器之python解释器">八、 文本编辑器之python解释器</h3>
<p>文件test.py以gbk格式保存，内容为：</p>
<p>　　x='林'</p>
<p>无论是</p>
<p>　　python2 test.py</p>
<p>还是</p>
<p>　　python3 test.py</p>
<p>都会报错（因为python2默认ascii，python3默认utf-8）</p>
<p>除非在文件开头指定#coding:gbk</p>
<h3 id="九程序的执行"><strong>九、程序的执行</strong></h3>
<p>python3 test.py 或 python2 test.py（执行test.py的第一步，一定是先将文件内容读入到内存中）</p>
<p><strong>阶段一：启动python解释器</strong></p>
<p><strong>阶段二：python解释器此时就是一个文本编辑器，负责打开文件test.py,即从硬盘中读取test.py的内容到内存中</strong></p>
<p>此时，python解释器会读取test.py 的第一行内容，#coding :utf-8,来决定以什么编码格式来读入内存，这一行就是来设定python解释器这个软件的编码使用的编码格式这个编码，python2默认使用ASCII，python3中默认使用utf-8</p>
<p><strong>阶段三：读取已经加载到内存的代码（unicode编码的二进制），然后执行，执行过程中可能会开辟新的内存空间，比如x=&quot;egon&quot;</strong></p>
<p>内存的编码使用unicode，不代表内存中全都是unicode编码的二进制，</p>
<p>在程序执行之前，内存中确实都是unicode编码的二进制,比如从文件中读取了一行x=&quot;egon&quot;,其中的x，等号，引号，地位都一样，都是普通字符而已，都是以unicode编码的二进制形式存放与内存中的</p>
<p>但是程序在执行过程中，会申请内存（与程序代码所存在的内存是俩个空间），可以存放任意编码格式的数据，比如x=&quot;egon&quot;,会被python解释器识别为字符串，会申请内存空间来存放&quot;hello&quot;，然后让x指向该内存地址，此时新申请的该内存地址保存也是unicode编码的egon,如果代码换成x=&quot;egon&quot;.encode('utf-8'),那么新申请的内存空间里存放的就是utf-8编码的字符串egon了</p>
<h3 id="十python2与python3的区别"><strong>十、python2与python3的区别</strong></h3>
<p>在python2中有两种字符串类型str和unicode</p>
<p>　　在python2中，str就是编码后的结果bytes，所以在Python2中，unicode字符编码的结果就是str/bytes</p>
<pre class="python"><code>#coding:utf-8
s=&#39;林&#39; #在执行时,&#39;林&#39;会被以conding:utf-8的形式保存到新的内存空间中

print repr(s) #&#39;\xe6\x9e\x97&#39; 三个Bytes,证明确实是utf-8，16进制形式，转换为二进制为11100110 10011110 10010111
print type(s) #&lt;type &#39;str&#39;&gt;

s.decode(&#39;utf-8&#39;) # &#39;\u006796&#39; 两个Bytes，证实为unicode，16进制形式，转换为二进制为1100111 10010111
# s.encode(&#39;utf-8&#39;) #报错，s为编码后的结果bytes，所以只能decode</code></pre>
<p>　　当python解释器执行到产生字符串的代码时（例如s=u'林'），会申请新的内存地址，然后将'林'以unicode的格式存放到新的内存空间中，所以s只能encode，不能decode</p>
<pre class="python"><code>s=u&#39;林&#39;
print repr(s) #u&#39;\u6797&#39;
print type(s) #&lt;type &#39;unicode&#39;&gt;

# s.decode(&#39;utf-8&#39;) #报错，s为unicode，所以只能encode
s.encode(&#39;utf-8&#39;)</code></pre>
<p><strong>对于unicode格式的数据来说，无论怎么打印，都不会乱码</strong></p>
<p>python3中的字符串与python2中的u'字符串'，都是unicode，所以无论如何打印都不会乱码</p>
<p>在python3中也有两种字符串类型str和bytes
<br />
　　str是unicode</p>
<pre class="python"><code>#coding:utf-8
s=&#39;林&#39; #当程序执行时，无需加u，&#39;林&#39;也会被以unicode形式保存新的内存空间中,

#s可以直接encode成任意编码格式
s.encode(&#39;utf-8&#39;)
s.encode(&#39;gbk&#39;)

print(type(s)) #&lt;class &#39;str&#39;&gt;</code></pre>
<h2 id="字符编码总结">字符编码总结：</h2>
<h4 id="以什么编码存的就以什么编码取出">1.以什么编码存的就以什么编码取出</h4>
<p>　　内存固定使用unicode编码，</p>
<p>　　我们可以控制的编码是往硬盘存放或者基于网络传输选择编码。</p>
<h4 id="数据是最先产生于内存中是unicode格式要想传输需要转成bytes格式">2.数据是最先产生于内存中，是unicode格式，要想传输需要转成bytes格式</h4>
<p>#unicode------&gt;encode (utf-8)--------&gt;bytes</p>
<p>拿到bytes，就可以往文件内存存放或者基于网络传输</p>
<p>#bytes------&gt;decode (utf-8)--------&gt;unicode</p>
<h4 id="python3中字符串被识别成unicode">3.python3中字符串被识别成unicode</h4>
<p>python3中的字符串encode得到bytes</p>
<h4 id="了解">4.了解</h4>
<p>　　python2中的字符串就是bytes</p>
<p>　　python2中的字符串前面加u，就是unicode</p>
<h4 id="任何程序的运行都需要加载到内存中">5.任何程序的运行都需要加载到内存中</h4>
<h2 id="python-标准数据类型bytes"><a href="https://segmentfault.com/a/1190000004450876">Python 标准数据类型：Bytes</a></h2>
<p>Bytes 对象是由单个字节作为基本元素（8位，取值范围 0-255）组成的序列，为不可变对象。</p>
<p>Bytes 对象只负责以二进制字节序列的形式记录所需记录的对象，至于该对象到底表示什么（比如到底是什么字符）则由相应的编码格式解码所决定。我们可以通过调用 bytes() 类（没错，它是类，不是函数）生成 bytes 实例，其值形式为 b'xxxxx'，其中 'xxxxx' 为一至多个转义的<strong>十六进制</strong>字符串（单个 x 的形式为：\xHH，其中 \x 为小写的十六进制转义字符，HH 为二位十六进制数）组成的序列，每个十六进制数代表一个字节（八位二进制数，取值范围 0-255），对于同一个字符串如果采用不同的编码方式生成 bytes 对象，就会形成不同的值：</p>
<p><img src="./images/Python编码2.png" alt="clipboard.png" /></p>
<p>比如上例中的 a 字符串对象，其十进制 unicode 值为 24464，分别使用 'utf-8' 和 'gb2312' 两种编码格式将其转换成 bytes 对象 b 和 c ，结果 b 和 c 的值是完全不同的，由于基于的编码格式不一致， b c 长度甚至都不相同，前者有 3 个字节长度，后者有 2 个字节长度：</p>
<p><img src="./images/Python编码3.png" alt="clipboard.png" /></p>
<p>另外，对于 ASCII 字符串，可以直接使用 b'xxxx' 赋值创建 bytes 实例，但对于非 ASCII 编码的字符则不能通过这种方式创建 bytes 实例：</p>
<p><img src="./images/Python编码4.png" alt="clipboard.png" /></p>
<p>由于 bytes 是序列，因此我们可以通过索引或切片访问它的元素：</p>
<p><img src="./images/Python编码5.png" alt="clipboard.png" /></p>
<p>可以发现如果以单个索引的形式访问元素，其会直接返回单个字节的十进制整数，而以序列片段的形式访问时，则返回相应的十六进制字符序列。</p>
<p>对于 bytes 实例，如果需要还原成相应的字符串，则需要借助内置的解码函数 decode()，借助相应的编码格式解码为正常字符串对象，如果采用错误的编码格式解码，则有可能发生错误：</p>
<p><img src="./images/Python编码6.png" alt="clipboard.png" /></p>

</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>