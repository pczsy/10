<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修自定义模块' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>自定义模块</center></div><div class='banquan'>原文出处:本文由博客园博主changxin7提供。<br/>
原文连接:https://www.cnblogs.com/changxin7/p/11240494.html</div><br>
    <h3 id="模块的定义与分类"><strong>1. 模块的定义与分类</strong></h3>
<h4 id="模块是什么"><strong>模块是什么？</strong></h4>
<p>​ 这几天，我们进入模块的学习。在学习模块之前，我们首先要知道，什么是模块？</p>
<p>​ 一个函数封装一个功能，你使用的软件可能就是由n多个函数组成的（先备考虑面向对象）。比如抖音这个软件，不可能将所有程序都写入一个文件，所以咱们应该将文件划分，这样其组织结构要好并且代码不冗余。加入分了10个文件，每个文件里面可能都有相同的功能（函数），怎么办？所以将这些相同的功能封装到一个文件中，那么这个存储着很多常用的功能的py文件，就是模块。 模块就是文件，存放一堆常用的函数，谁用谁拿。怎么拿？比如：我要策马奔腾共享人世繁华，应该怎么样？我应该骑马，你也要去浪，你是不是也要骑马。 我们说一个函数就是一个功能，那么把一些常用的函数放在一个py文件中，这个文件就称之为模块，模块，就是一些列常用功能的集合体。</p>
<h4 id="为什么要使用模块"><strong>为什么要使用模块?</strong></h4>
<ol>
<li><p>从文件级别组织程序，更方便管理 随着程序的发展，功能越来越多，为了方便管理，我们通常将程序分成一个个的文件，这样做程序的结构更清晰，方便管理。这时我们不仅仅可以把这些文件当做脚本去执行，还可以把他们当做模块来导入到其他的模块中，实现了功能的重复利用</p></li>
<li><p>拿来主义，提升开发效率 同样的原理，我们也可以下载别人写好的模块然后导入到自己的项目中使用，这种拿来主义，可以极大地提升我们的开发效率，避免重复造轮子。</p></li>
</ol>
<p>​ <strong>ps：人们常说的脚本是什么？</strong></p>
<p>如果你退出python解释器然后重新进入，那么你之前定义的函数或者变量都将丢失，因此我们通常将程序写到文件中以便永久保存下来，需要时就通过python test.py方式去执行，此时test.py被称为脚本script。</p>
<p>所以，脚本就是一个python文件，比如你之前写的购物车，模拟博客园登录系统的文件等等。</p>
<h4 id="模块的分类"><strong>模块的分类</strong></h4>
<p>Python语言中，模块分为三类。</p>
<p>​ 第一类：内置模块，也叫做标准库。此类模块就是python解释器给你提供的，比如我们之前见过的time模块,os模块。标准库的模块非常多（200多个，每个模块又有很多功能），我们这几天就讲常用的十几种，后面课程中还会陆续的讲到。</p>
<p>​ 第二类：第三方模块，第三方库。一些python大神写的非常好用的模块，必须通过pip install 指令安装的模块，比如BeautfulSoup, Django,等等。大概有6000多个。</p>
<p>​ 第三类：自定义模块。我们自己在项目中定义的一些模块。</p>
<p>这几天，我们先学第一类和第三类模块，第二类模块会在我们并发编程开始逐渐的接触学习。</p>
<p>今天，我们先讲第三类，自定义模块。</p>
<p>我们先定义一个模块，定义一个模块其实很简单就是写一个文件，里面写一些代码（变量，函数）即可。此文件的名字为tbjx.py，文件内容如下：</p>
<pre><code><code>print(&#39;from the tbjx.py&#39;)
name = &#39;太白金星&#39;

def read1():
    print(&#39;tbjx模块：&#39;,name)

def read2():
    print(&#39;tbjx模块&#39;)
    read1()

def change():
    global name
    name = &#39;barry&#39;</code></pre>
<h3 id="import"><strong>2. import</strong></h3>
<h4 id="import-使用"><strong>2.1 import 使用</strong></h4>
<p>import 翻译过来是一个导入的意思。</p>
<p>这里一定要给同学强调那个文件执行文件，和哪个文件是被执行模块。</p>
<p>​ 模块可以包含可执行的语句和函数的定义，这些语句的目的是初始化模块，它们只在模块名第一次遇到导入import语句时才执行（import语句是可以在程序中的任意位置使用的,且针对同一个模块很import多次,为了防止你重复导入，python的优化手段是：第一次导入后就将模块名加载到内存了，后续的import语句仅是对已经加载到内存中的模块对象增加了一次引用，不会重新执行模块内的语句），如下 import tbjx #只在第一次导入时才执行tbjx.py内代码,此处的显式效果是只打印一次'from the tbjx.py',当然其他的顶级代码也都被执行了,只不过没有显示效果.</p>
<pre><code><code>代码示例：

import tbjx
import tbjx
import tbjx
import tbjx
import tbjx


执行结果：只是打印一次：
from the tbjx.py</code></pre>
<p><img src="./images/自定义模块0.png" alt="img" /></p>
<h4 id="第一次导入模块执行三件事"><strong>2.2 第一次导入模块执行三件事</strong></h4>
<p>​ 1.创建一个以模块名命名的名称空间。</p>
<p>​ 2.执行这个名称空间（即导入的模块）里面的代码。</p>
<p>​ 3.通过此模块名. 的方式引用该模块里面的内容（变量，函数名，类名等）。 这个名字和变量名没什么区别，都是‘第一类的’，且使用tbjx.名字的方式可以访问tbjx.py文件中定义的名字，tbjx.名字与test.py中的名字来自两个完全不同的地方。</p>
<p>​ ps：<strong>重复导入会直接引用内存中已经加载好的结果</strong></p>
<h4 id="被导入模块有独立的名称空间"><strong>2.3 被导入模块有独立的名称空间</strong></h4>
<p>​ 每个模块都是一个独立的名称空间，定义在这个模块中的函数，把这个模块的名称空间当做全局名称空间，这样我们在编写自己的模块时，就不用担心我们定义在自己模块中全局变量会在被导入时，与使用者的全局变量冲突。</p>
<p>示例：</p>
<pre><code><code>当前是meet.py

import tbjx.py
name = &#39;alex&#39;
print(name)
print(tbjx.name)
&#39;&#39;&#39;
from the tbjx.py
alex
太白金星
&#39;&#39;&#39;

def read1():
    print(666)
tbjx.read1()
&#39;&#39;&#39;
from the tbjx.py
tbjx模块： 太白金星
&#39;&#39;&#39;

name = &#39;日天&#39;
tbjx.change()
print(name)
print(tbjx.name)
&#39;&#39;&#39;
from the tbjx.py
日天
barry
&#39;&#39;&#39;</code></pre>
<p><strong>让同学们将上面的代码练习一下。</strong></p>
<h4 id="为模块起别名"><strong>2.4 为模块起别名</strong></h4>
<p>别名其实就是一个外号,我们小的时候，都喜欢给学生们起外号对吧。</p>
<p>​ <strong>1. 好处可以将很长的模块名改成很短,方便使用.</strong></p>
<pre><code><code>import tbjx as t
t.read1()</code></pre>
<p>​ <strong>2. 有利于代码的扩展和优化。</strong></p>
<pre><code><code>#mysql.py
def sqlparse():
    print(&#39;from mysql sqlparse&#39;)
#oracle.py
def sqlparse():
    print(&#39;from oracle sqlparse&#39;)

#test.py
db_type=input(&#39;&gt;&gt;: &#39;)
if db_type == &#39;mysql&#39;:
    import mysql as db
elif db_type == &#39;oracle&#39;:
    import oracle as db

db.sqlparse()</code></pre>
<h4 id="导入多个模块"><strong>2.5 导入多个模块</strong></h4>
<p>​ 我们以后再开发过程中，免不了会在一个文件中，导入多个模块，推荐写法是一个一个导入。</p>
<pre><code><code>import os,sys,json   # 这样写可以但是不推荐

推荐写法

import os
import sys
import json</code></pre>
<p>　　<strong>多行导入：易于阅读 易于编辑 易于搜索 易于维护。</strong></p>
<h3 id="from-...-import-..."><strong>3 from ... import ...</strong></h3>
<h4 id="from-...-import-...-使用"><strong>3.1 from ... import ... 使用</strong></h4>
<pre><code><code>from ... import ... 的使用示例。

from tbjx import name, read1
print(name)
read1()
&#39;&#39;&#39;
执行结果：
from the tbjx.py
太白金星
tbjx模块： 太白金星

&#39;&#39;&#39;</code></pre>
<h4 id="from...import...-与import对比"><strong>3.2 from...import... 与import对比</strong></h4>
<p>​ 唯一的区别就是：使用from...import...则是将spam中的名字直接导入到当前的名称空间中，所以在当前名称空间中，直接使用名字就可以了、无需加前缀：tbjx.</p>
<p>from...import...的方式有好处也有坏处</p>
<p>​ 好处：使用起来方便了</p>
<p>​ 坏处：容易与当前执行文件中的名字冲突</p>
<p>示例演示：</p>
<ol>
<li><strong>执行文件有与模块同名的变量或者函数名，会有覆盖效果。</strong></li>
</ol>
<pre><code><code>name = &#39;oldboy&#39;
from tbjx import name, read1, read2
print(name)  
&#39;&#39;&#39;
执行结果：
太白金星
&#39;&#39;&#39;
----------------------------------------
from tbjx import name, read1, read2
name = &#39;oldboy&#39;
print(name)  

&#39;&#39;&#39;
执行结果：
oldboy

&#39;&#39;&#39;
----------------------------------------
def read1():
    print(666)
from tbjx import name, read1, read2
read1()

&#39;&#39;&#39;
执行结果：
tbjx模块： 太白金星
&#39;&#39;&#39;
----------------------------------------

from tbjx import name, read1, read2
def read1():
    print(666)
read1()

&#39;&#39;&#39;
执行结果：
tbjx模块： 666
&#39;&#39;&#39;</code></pre>
<p>​ 　<strong>2. 当前位置直接使用read1和read2就好了，执行时，仍然以tbjx.py文件全局名称空间</strong></p>
<pre><code><code>#测试一：导入的函数read1，执行时仍然回到tbjx.py中寻找全局变量 &#39;alex&#39;
#test.py
from tbjx import read1
name = &#39;alex&#39;
read1()
&#39;&#39;&#39;
执行结果:
from the spam.py
spam-&gt;read1-&gt;name = &#39;太白金星&#39;
&#39;&#39;&#39;

#测试二:导入的函数read2，执行时需要调用read1(),仍然回到tbjx.py中找read1()
#test.py
from tbjx import read2
def read1():
    print(&#39;==========&#39;)
read2()

&#39;&#39;&#39;
执行结果:
from the tbjx.py
tbjx-&gt;read2 calling read
tbjx-&gt;read1-&gt;tbjx &#39;barry&#39;
&#39;&#39;&#39;
    4.3.3 也支持as

通过这种方式引用模块也可以对模块进行改名。

from tbjx import read1 as read
read()</code></pre>
<h4 id="img3.4-一行导入多个"><strong><img src="./images/自定义模块1.png" alt="img" />3.4 一行导入多个</strong></h4>
<pre><code><code>from tbjx import read1,read2,name</code></pre>
<h4 id="from-...-import"><strong>3.5 from ... import *</strong></h4>
<p>​ from spam import * 把tbjx中所有的不是以下划线(_)开头的名字都导入到当前位置</p>
<p>​ 大部分情况下我们的python程序不应该使用这种导入方式，因为*你不知道你导入什么名字，很有可能会覆盖掉你之前已经定义的名字。而且可读性极其的差，在交互式环境中导入时没有问题。</p>
<p>可以使用<strong>all</strong>来控制*（用来发布新版本），在tbjx.py中新增一行</p>
<pre><code><code>__all__=[&#39;money&#39;,&#39;read1&#39;] #这样在另外一个文件中用from spam import *就这能导入列表中规定的两个名字</code></pre>
<h4 id="模块循环导入问题"><strong>3.6 模块循环导入问题</strong></h4>
<p>​ 模块循环/嵌套导入抛出异常的根本原因是由于在python中模块被导入一次之后，就不会重新导入，只会在第一次导入时执行模块内代码</p>
<p>​ 在我们的项目中应该尽量避免出现循环/嵌套导入，如果出现多个模块都需要共享的数据，可以将共享的数据集中存放到某一个地方在程序出现了循环/嵌套导入后的异常分析、解决方法如下（<strong>了解，以后尽量避免</strong>）</p>
<p>示范文件内容如下</p>
<pre><code><code>#创建一个m1.py
print(&#39;正在导入m1&#39;)
from m2 import y

x=&#39;m1&#39;

#创建一个m2.py
print(&#39;正在导入m2&#39;)
from m1 import x

y=&#39;m2&#39;

#创建一个run.py
import m1

#测试一
执行run.py会抛出异常
正在导入m1
正在导入m2
Traceback (most recent call last):
  File &quot;/Users/linhaifeng/PycharmProjects/pro01/1 aaaa练习目录/aa.py&quot;, line 1, in &lt;module&gt;
    import m1
  File &quot;/Users/linhaifeng/PycharmProjects/pro01/1 aaaa练习目录/m1.py&quot;, line 2, in &lt;module&gt;
    from m2 import y
  File &quot;/Users/linhaifeng/PycharmProjects/pro01/1 aaaa练习目录/m2.py&quot;, line 2, in &lt;module&gt;
    from m1 import x
ImportError: cannot import name &#39;x&#39;


#测试一结果分析
先执行run.py---&gt;执行import m1，开始导入m1并运行其内部代码---&gt;打印内容&quot;正在导入m1&quot;
---&gt;执行from m2 import y 开始导入m2并运行其内部代码---&gt;打印内容“正在导入m2”---&gt;执行from m1 import x,由于m1已经被导入过了，所以不会重新导入，所以直接去m1中拿x，然而x此时并没有存在于m1中，所以报错


#测试二:执行文件不等于导入文件，比如执行m1.py不等于导入了m1
直接执行m1.py抛出异常
正在导入m1
正在导入m2
正在导入m1
Traceback (most recent call last):
  File &quot;/Users/linhaifeng/PycharmProjects/pro01/1 aaaa练习目录/m1.py&quot;, line 2, in &lt;module&gt;
    from m2 import y
  File &quot;/Users/linhaifeng/PycharmProjects/pro01/1 aaaa练习目录/m2.py&quot;, line 2, in &lt;module&gt;
    from m1 import x
  File &quot;/Users/linhaifeng/PycharmProjects/pro01/1 aaaa练习目录/m1.py&quot;, line 2, in &lt;module&gt;
    from m2 import y
ImportError: cannot import name &#39;y&#39;


#测试二分析
执行m1.py，打印“正在导入m1”，执行from m2 import y ，导入m2进而执行m2.py内部代码---&gt;打印&quot;正在导入m2&quot;，执行from m1 import x，此时m1是第一次被导入，执行m1.py并不等于导入了m1，于是开始导入m1并执行其内部代码---&gt;打印&quot;正在导入m1&quot;，执行from m1 import y，由于m1已经被导入过了，所以无需继续导入而直接问m2要y，然而y此时并没有存在于m2中所以报错



# 解决方法:
方法一:导入语句放到最后
#m1.py
print(&#39;正在导入m1&#39;)

x=&#39;m1&#39;

from m2 import y

#m2.py
print(&#39;正在导入m2&#39;)
y=&#39;m2&#39;

from m1 import x

方法二:导入语句放到函数中
#m1.py
print(&#39;正在导入m1&#39;)

def f1():
    from m2 import y
    print(x,y)

x = &#39;m1&#39;

# f1()

#m2.py
print(&#39;正在导入m2&#39;)

def f2():
    from m1 import x
    print(x,y)

y = &#39;m2&#39;

#run.py
import m1

m1.f1()</code></pre>
<h3 id="py文件的两种功能"><strong>4. py文件的两种功能</strong></h3>
<p>编写好的一个python文件可以有两种用途：<br />
一：脚本，一个文件就是整个程序，用来被执行（比如你之前写的模拟博客园登录那个作业等）<br />
二：模块，文件中存放着一堆功能，用来被导入使用<br />
​<br />
python为我们内置了全局变量__name__，<br />
当文件被当做脚本执行时：<strong>name</strong> 等于'<strong>main</strong>'<br />
当文件被当做模块导入时：__name__等于模块名<br />
​<br />
#作用：用来控制.py文件在不同的应用场景下执行不同的逻辑（或者是在模块文件中测试代码）</p>
<pre><code><code>if __name__ == &#39;__main__&#39;:</code></pre>
<pre><code><code>print(&#39;from the tbjx.py&#39;)

__all__ = [&#39;name&#39;, &#39;read1&#39;,]

name = &#39;太白金星&#39;


def read1():
   print(&#39;tbjx模块：&#39;,name)


def read2():
   print(&#39;tbjx模块&#39;)
   read1()


def change():
   
   global name
   name = &#39;barry&#39;
   
if __name__ == &#39;__main__&#39;:  
   # 在模块文件中测试read1()函数
   # 此模块被导入时 __name__ == tbjx 所以不执行
   read1()</code></pre>
<h3 id="模块的搜索路径"><strong>5. 模块的搜索路径</strong></h3>
<p>当你引用一个模块时，不见得每次都可以import到：</p>
<p><img src="./images/自定义模块2.png" alt="img" /></p>
<p>上面的示例可以得知，引用模块也是按照一定规则进行引用的。</p>
<p>​ Python中引用模块是按照一定的规则以及顺序去寻找的，这个查询顺序为：先从内存中已经加载的模块进行寻找找不到再从内置模块中寻找，内置模块如果也没有，最后去sys.path中路径包含的模块中寻找。它只会按照这个顺序从这些指定的地方去寻找，如果最终都没有找到，那么就会报错。</p>
<p>​ <strong>内存中已经加载的模块-&gt;内置模块-&gt;sys.path路径中包含的模块</strong></p>
<p><strong>模块的查找顺序</strong></p>
<ol>
<li>在第一次导入某个模块时（比如tbjx），会先检查该模块是否已经被加载到内存中（当前执行文件的名称空间对应的内存），如果有则直接引用（ps：python解释器在启动时会自动加载一些模块到内存中，可以使用sys.modules查看）</li>
<li>如果没有，解释器则会查找同名的内置模块</li>
<li>如果还没有找到就从sys.path给出的目录列表中依次寻找tbjx.py文件。</li>
</ol>
<p><strong>需要特别注意的是：我们自定义的模块名不应该与系统内置模块重名。虽然每次都说，但是仍然会有人不停的犯错</strong></p>
<pre><code><code>#在初始化后，python程序可以修改sys.path,路径放到前面的优先于标准库被加载。

&gt; &gt; &gt; import sys
&gt; &gt; &gt; sys.path.append(&#39;/a/b/c/d&#39;)
&gt; &gt; &gt; sys.path.insert(0,&#39;/x/y/z&#39;) #排在前的目录，优先被搜索
&gt; &gt; &gt; 注意：搜索时按照sys.path中从左到右的顺序查找，位于前的优先被查找，sys.path中还可能包含.zip归档文件和.egg文件，python会把.zip归档文件当成一个目录去处理，

#首先制作归档文件：zip module.zip foo.py bar.py 
import sys
sys.path.append(&#39;module.zip&#39;)
import foo,bar

#也可以使用zip中目录结构的具体位置
sys.path.append(&#39;module.zip/lib/python&#39;)

#windows下的路径不加r开头，会语法错误
sys.path.insert(0,r&#39;C:\Users\Administrator\PycharmProjects\a&#39;)

#至于.egg文件是由setuptools创建的包，这是按照第三方python库和扩展时使用的一种常见格式，.egg文件实际上只是添加了额外元数据(如版本号，依赖项等)的.zip文件。

#需要强调的一点是：只能从.zip文件中导入.py，.pyc等文件。使用C编写的共享库和扩展块无法直接从.zip文件中加载（此时setuptools等打包系统有时能提供一种规避方法），且从.zip中加载文件不会创建.pyc或者.pyo文件，因此一定要事先创建他们，来避免加载模块是性能下降。

接下来我们就开始讲解python常用的内置模块，由于Python常用的模块非常多，我们不可能将所有的模块都讲完， 所以只针对于工作中经常用到模块进行讲解。剩下的模块可以在课余时间自学。</code></pre>

</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>