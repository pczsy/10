<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修Python基础 — 面向对象编程基础' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>Python基础 — 面向对象编程基础</center></div><div class='banquan'>原文出处:本文由博客园博主丁可乐提供。<br/>
原文连接:https://www.cnblogs.com/dwlovelife/p/11578896.html</div><br>
    <div class="toc">
    <p class="toc-title">目录</p>
    <div class="toc-list">
        <ul>
        <li><a href="#面向对象编程基础">1. 面向对象编程基础</a></li>
        <li><a href="#定义类和创建对象">2. 定义类和创建对象</a></li>
        <li><a href="#init-方法">3. <strong>init</strong>() 方法</a></li>
        <li><a href="#魔法方法">4. 魔法方法</a></li>
        <li><a href="#访问可见性问题">5. 访问可见性问题</a></li>
        <li><a href="#练习">5. 练习</a></li>
        </ul>
    </div>
</div>
<h2 id="面向对象编程基础">1. 面向对象编程基础</h2>
<p>把一组数据结构和处理它们的方法组成对象（object），把相同行为的对象归纳为类（class），通过类的封（encapsulation）隐藏内部细节，通过继承（inheritance）实现类的特化（specialization）和泛化（generalization），通过多态（polymorphism）实现基于对象类型的动态分派。</p>
<p>简而言之，面向对象在我看来，把一个实体的属性抽象出来，然后去操作这个抽象的实体，这个实体可以有种种行为（方法），而不在是简单的单一结果。</p>
<p><strong>面向对象编程的2个非常重要的概念：类和对象</strong></p>
<p>对象是面向对象编程的核心，在使用对象的过程中，为了将具有共同特征和行为的一组对象抽象定义，提出了另外一个新的概念——类</p>
<p><strong>类就相当于制造飞机时的图纸，用它来进行创建的飞机就相当于对象</strong></p>
<blockquote>
<p>类和对象之间的关系</p>
</blockquote>
<p><img src="./images/Python基础 — 面向对象编程基础0.png" /></p>
<p> </p>
<p><strong>面向对象有三大支柱：封装、继承和多态。 </strong></p>
<p> </p>
<h2 id="定义类和创建对象">2. 定义类和创建对象</h2>
<p><strong>定义类：</strong>在Python中可以使用<code>class</code>关键字定义类，然后在类中通过之前学习过的函数来定义方法</p>
<p><strong>定义一个类</strong></p>
<pre><code><code>class Car:
    # 方法
    def getCarInfo(self):
        print(&#39;车轮子个数:%d, 颜色%s&#39;%(self.wheelNum, self.color))

    def move(self):
        print(&quot;车正在移动...&quot;)</code></pre>
<p>  </p>
<p><strong>创建一个对象</strong></p>
<pre><code><code># -*- coding:utf-8 -*-
&quot;&quot;&quot;
定义一个类,再创建一个对象
version:0.1
author:coke
&quot;&quot;&quot;
#类
class Car:
    #方法
    def getCarInfo(self):
        print(&#39;车轮子个数:%d,颜色%s&#39;%(self.wheelNum,self.color))
    
    def move(self):
        print(&quot;车正在移动&quot;)
    
BMW = Car()
BMW.color = &quot;黑色&quot;
BMW.wheelNum = 4
BMW.getCarInfo()
BMW.move()</code></pre>
<p><strong>注：</strong>这里出现了 <code>self</code>，所谓的<code>self</code>，可以理解为自己 ，某个对象调用其方法时，python解释器会把这个对象作为第一个参数传递给<code>self</code>，所以开发者只需要传递后面的参数即可</p>
<p> </p>
<h2 id="init-方法">3. <strong>init</strong>() 方法</h2>
<p>在上一小节的demo中，我们已经给BMW这个对象添加了2个属性，wheelNum（车的轮胎数量）以及color（车的颜色），试想如果再次创建一个对象的话，肯定也需要进行添加属性，显然这样做很费事，那么有没有办法能够在创建对象的时候，就顺便把车这个对象的属性给设置呢？</p>
<pre><code><code># -*- coding:utf-8 -*-
&quot;&quot;&quot;
_init_使用
version:0.1
author:coke
&quot;&quot;&quot;
#定义汽车类
class Car:
    def __init__(self):
        self.wheelNum = 4
        self.color = &#39;蓝色&#39;
    def move(self):
        print(&#39;车在跑，目标:夏威夷&#39;)

# 创建对象
BMW = Car()
print(&#39;车的颜色为:%s&#39;%BMW.color)
print(&#39;车轮胎数量为:%d&#39;%BMW.wheelNum)</code></pre>
<p> </p>
<p><strong>总结：当创建Car对象后，在没有调用<code>__init__()</code>方法的前提下，BMW就默认拥有了2个属性wheelNum和color，原因是<code>__init__()</code>方法是在创建对象后，就立刻被默认调用了 </strong></p>
<p> </p>
<h2 id="魔法方法">4. 魔法方法</h2>
<p>在python中方法名如果是<code>__xxxx__()</code>的，那么就有特殊的功能，因此叫做“魔法”方法</p>
<p><strong>当使用print输出对象的时候，只要自己定义了<code>__str__(self)</code>方法，那么就会打印从在这个方法中return的数据 </strong></p>
<pre><code><code># -*- coding:utf-8 -*-
&quot;&quot;&quot;
_init_使用
version:0.1
author:coke
&quot;&quot;&quot;
#定义汽车类
class Car:
    def __init__(self,newWheelNum,newColor):
        self.wheelNum = newWheelNum
        self.color = newColor
    def __str__(self):
        msg = &quot;车轮胎数:&quot; + str(self.wheelNum) + &quot; 车的颜色:&quot; + self.color
        return msg

    def move(self):
        print(&quot;车在跑，目标夏威夷&quot;)

BWM = Car(4,&quot;green&quot;)
BWM.move()
print(BWM)</code></pre>
<p> </p>
<h2 id="访问可见性问题">5. 访问可见性问题</h2>
<p>在很多面向对象编程语言中，我们通常会将对象的属性设置为私有的（private）或受保护的（protected），简单的说就是不允许外界访问，而对象的方法通常都是公开的（public），因为公开的方法就是对象能够接受的消息。<strong>在Python中，属性和方法的访问权限只有两种，也就是公开的和私有的，如果希望属性是私有的，在给属性命名时可以用两个下划线作为开头</strong>，下面的代码可以验证这一点。</p>
<pre><code><code># -*- coding:utf-8 -*-
&quot;&quot;&quot;
测试可见性
version:0.1
author:coke
&quot;&quot;&quot;
class Test:
    def __init__(self, foo):
        self.__foo = foo

    def __bar(self):
        print(self.__foo)
        print(&#39;__bar&#39;)


def main():
    test = Test(&#39;hello&#39;)
    # AttributeError: &#39;Test&#39; object has no attribute &#39;__bar&#39;
    test.__bar()
    # AttributeError: &#39;Test&#39; object has no attribute &#39;__foo&#39;
    print(test.__foo)


if __name__ == &quot;__main__&quot;:
    main()</code></pre>
<p> </p>
<p><strong>但是，Python并没有从语法上严格保证私有属性或方法的私密性，它只是给私有的属性和方法换了一个名字来“妨碍”对它们的访问，事实上如果你知道更换名字的规则仍然可以访问到它们，</strong>下面的代码就可以验证这一点。之所以这样设定，可以用这样一句名言加以解释，就是“We are all consenting adults here”。因为绝大多数程序员都认为开放比封闭要好，而且程序员要自己为自己的行为负责。</p>
<pre><code><code># -*- coding:utf-8 -*-
&quot;&quot;&quot;
测试可见性
version:0.2
author:coke
&quot;&quot;&quot;
class Test:
    def __init__(self,foo):
        self.__foo = foo
    def __bar(self):
        print(self.__foo);
        print(&quot;__bar&quot;)
    
    def __str__(self):
        return self.__foo
def main():
    test = Test(&quot;hello&quot;)
    print(test)
    #事实上还是可以在外部访问 __foo属性
    print(test._Test__foo)

if __name__ == &quot;__main__&quot;:
    main()</code></pre>
<p><strong>在实际开发中，我们并不建议将属性设置为私有的</strong>，因为这会导致子类无法访问（后面会讲到）。<strong>所以大多数Python程序员会遵循一种命名惯例就是让属性名以单下划线开头来表示属性是受保护的</strong>，本类之外的代码在访问这样的属性时应该要保持慎重</p>
<p> </p>
<h2 id="练习">5. 练习</h2>
<p>为了更好的理解面向对象编程，下面以“烤地瓜”为案例，进行分析</p>
<p><strong>示例属性如下:</strong></p>
<ul>
<li>cookedLevel : 这是数字；0~3表示还是生的，超过3表示半生不熟，超过5表示已经烤好了，超过8表示已经烤成木炭了！我们的地瓜开始时时生的</li>
<li>cookedString : 这是字符串；描述地瓜的生熟程度</li>
<li>condiments : 这是地瓜的配料列表，比如番茄酱、芥末酱等</li>
</ul>
<p><strong>示例方法如下:</strong></p>
<ul>
<li><code>cook()</code> : 把地瓜烤一段时间</li>
<li><code>addCondiments()</code> : 给地瓜添加配料</li>
<li><code>__init__()</code> : 设置默认的属性</li>
<li><code>__str__()</code> : 让print的结果看起来更好一些</li>
</ul>
<p> </p>
<ul>
<li>1、定义类，并且定义__init__()方法</li>
</ul>
<pre><code><code>#定义`地瓜`类
class SweetPotato:
    &#39;这是烤地瓜的类&#39;

    #定义初始化方法
    def __init__(self):
        self.cookedLevel = 0
        self.cookedString = &quot;生的&quot;
        self.condiments = []</code></pre>
<p> </p>
<ul>
<li>2、添加&quot;烤地瓜&quot;方法</li>
</ul>
<pre><code><code>#烤地瓜方法
    def cook(self, time):
        self.cookedLevel += time
        if self.cookedLevel &gt; 8:
            self.cookedString = &quot;烤成灰了&quot;
        elif self.cookedLevel &gt; 5:
            self.cookedString = &quot;烤好了&quot;    
        elif self.cookedLevel &gt; 3:
            self.cookedString = &quot;半生不熟&quot;
        else:
            self.cookedString = &quot;生的&quot;</code></pre>
<p> </p>
<ul>
<li>3、基本的功能已经有了一部分，赶紧测试一下</li>
</ul>
<pre><code><code>mySweetPotato = SweetPotato()
print(mySweetPotato.cookedLevel)
print(mySweetPotato.cookedString)
print(mySweetPotato.condiments)</code></pre>
<p> </p>
<ul>
<li>4、定义addCondiments()方法和__str__()方法</li>
</ul>
<pre><code><code>    def __str__(self):
        msg = self.cookedString + &quot; 地瓜&quot;
        if len(self.condiments) &gt; 0:
            msg = msg + &quot;(&quot;
            for temp in self.condiments:
                msg = msg + temp + &quot;, &quot;
            msg = msg.strip(&quot;, &quot;)

            msg = msg + &quot;)&quot;
        return msg

    def addCondiments(self, condiments):
        self.condiments.append(condiments)</code></pre>
<p> </p>
<p><strong>全部代码</strong></p>
<pre><code><code># -*- coding:utf-8 -*-
&quot;&quot;&quot;
烤地瓜
&quot;&quot;&quot;
class SweetPotato:
    &quot;这是烤地瓜的类&quot;

    #定义初始化方法
    def __init__(self):
        self.cookedLevel = 0
        self.cookedString = &quot;生的&quot;
        self.condiments = []
    
    #添加烤地瓜的方法
    def cook(self,time):
        self.cookedLevel += time
        if self.cookedLevel &gt; 10:
            self.cookedString = &quot;烤成灰了&quot;
        elif self.cookedLevel &gt; 5:
            self.cookedString = &quot;烤好了&quot;
        elif self.cookedLevel &gt; 3:
            self.cookedString = &quot;半生不熟&quot;
        else:
            self.cookedString = &quot;生的&quot;
    
    #添加配料
    def addCondiments(self,condiment):
        self.condiments.append(condiment)
    
    def __str__(self):
        msg = self.cookedString + &quot;地瓜&quot;
        if len(self.condiments) &gt; 0:
            msg = msg + &quot;(&quot;
            for temp in self.condiments:
                msg = msg + temp + &quot;, &quot;
            msg = msg.strip(&quot;, &quot;)
            msg = msg + &quot;)&quot;
        return msg

mySweetPotato = SweetPotato()
print(&quot;------有了一个地瓜，还没有烤--------&quot;)
print(mySweetPotato.cookedLevel)
print(mySweetPotato.cookedString)
print(mySweetPotato.condiments)
print(&quot;---------接下来进行烤地瓜------------&quot;)
print(&quot;---------地瓜烤了四分钟------------&quot;)
mySweetPotato.cook(4)
print(mySweetPotato)
print(&quot;---------地瓜又烤了分钟-----------&quot;)
mySweetPotato.cook(3)
print(mySweetPotato)
print(&quot;----------添加配料番茄酱------------&quot;)
mySweetPotato.addCondiments(&quot;番茄酱&quot;)
mySweetPotato.addCondiments(&quot;芥末酱&quot;)
mySweetPotato.cook(2)
print(mySweetPotato)</code></pre>
<p><strong>输出结果</strong><br />
<img src="./images/Python基础 — 面向对象编程基础1.png" /></p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>