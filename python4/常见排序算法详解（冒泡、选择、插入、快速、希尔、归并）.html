<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修常见排序算法详解（冒泡、选择、插入、快速、希尔、归并）' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>常见排序算法详解（冒泡、选择、插入、快速、希尔、归并）</center></div><div class='banquan'>原文出处:本文由博客园博主刚--提供。<br/>
原文连接:https://www.cnblogs.com/rungang/p/11391221.html</div><br>
    <p><strong>一、排序算法</strong></p>
<p><strong>1、冒泡排序（Bubble Sort）</strong></p>
<p><strong>定义</strong>：是一种简单的排序算法。它重复地遍历要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。遍历数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢&ldquo;浮&rdquo;到数列的顶端。</p>
<p><strong>原理：</strong></p>
<ul>
<li>比较相邻的元素。如果第一个比第二个大（升序），就交换他们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ul>
<div class="cnblogs_code">
<pre><code>list1 = [12, 54, 23, 56, 67, 45, 1<span style="color: #000000;">]

</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> bubbleSort():
    </span><span style="color: #800000;">'''</span><span style="color: #800000;">冒泡排序</span><span style="color: #800000;">'''</span>
    <span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span> range(len(list1) - 1, 0, -1<span style="color: #000000;">):
        </span><span style="color: #0000ff;">for</span> j <span style="color: #0000ff;">in</span><span style="color: #000000;"> range(i):
            </span><span style="color: #0000ff;">if</span> list1[j] &gt; list1[j + 1<span style="color: #000000;">]:
                list1[j], list1[j </span>+ 1] = list1[j + 1<span style="color: #000000;">], list1[j]
        </span><span style="color: #0000ff;">print</span><span style="color: #000000;">(list1)

bubbleSort()</span></pre>
</div>
<p><strong>时间复杂度：</strong></p>
<ul>
<li>最优时间复杂度：O(n) （表示遍历一次发现没有任何可以交换的元素，排序结束。）</li>
<li>最坏时间复杂度：O(n2)</li>
<li>稳定性：稳定</li>
</ul>
<p><strong>效果图：</strong></p>
<p>&nbsp;<img src="./images/常见排序算法详解（冒泡、选择、插入、快速、希尔、归并）0.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;<strong>2、选择排序</strong></p>
<p><strong>定义：</strong>选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<div class="cnblogs_code">
<pre><code>list1 = [2, 6, 9, 5, 3, 1<span style="color: #000000;">]

</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> selection_sort(list1):
    n </span>=<span style="color: #000000;"> len(list1)
    </span><span style="color: #008000;">#</span><span style="color: #008000;"> 需要进行n-1次选择操作</span>
    <span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span> range(n - 1<span style="color: #000000;">):
        </span><span style="color: #008000;">#</span><span style="color: #008000;"> 记录最小位置</span>
        min_pos =<span style="color: #000000;"> i
        </span><span style="color: #008000;">#</span><span style="color: #008000;"> 从i+1位置到末尾选择出最小数据</span>
        <span style="color: #0000ff;">for</span> j <span style="color: #0000ff;">in</span> range(i + 1<span style="color: #000000;">, n):
            </span><span style="color: #0000ff;">if</span> list1[j] &lt;<span style="color: #000000;"> list1[min_pos]:
                min_pos </span>=<span style="color: #000000;"> j
        </span><span style="color: #008000;">#</span><span style="color: #008000;"> 如果选择出的数据不在正确位置，进行交换</span>
        <span style="color: #0000ff;">if</span> min_pos !=<span style="color: #000000;"> i:
            list1[i], list1[min_pos] </span>=<span style="color: #000000;"> list1[min_pos], list1[i]

        </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">----》</span><span style="color: #800000;">'</span><span style="color: #000000;">, list1)

selection_sort(list1)</span></pre>
</div>
<p><strong>时间复杂度：</strong></p>
<ul>
<li>最优时间复杂度：O(n2)</li>
<li>最坏时间复杂度：O(n2)</li>
<li>稳定性：不稳定（考虑升序每次选择最大的情况）</li>
</ul>
<p><strong>效果图：</strong></p>
<p><img src="./images/常见排序算法详解（冒泡、选择、插入、快速、希尔、归并）1.png" alt="" /></p>
<p>&nbsp;</p>
<p><strong>3、插入排序</strong></p>
<p><strong>定义：</strong>插入排序（英语：Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>
<div class="cnblogs_code">
<pre><code>list1 = [3, 2, 9, 5, 1<span style="color: #000000;">, 0]


</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> insert_sort(list1):
    </span><span style="color: #800000;">'''</span><span style="color: #800000;">插入排序</span><span style="color: #800000;">'''</span>
    <span style="color: #008000;">#</span><span style="color: #008000;"> 从第二个位置，即下标为1的元素开始向前插入</span>
    <span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span> range(1<span style="color: #000000;">, len(list1)):
        </span><span style="color: #008000;">#</span><span style="color: #008000;"> 从第i个元素开始向前比较，如果小于前一个元素，交换位置</span>
        <span style="color: #0000ff;">for</span> j <span style="color: #0000ff;">in</span> range(i, 0, -1<span style="color: #000000;">):
            </span><span style="color: #0000ff;">if</span> list1[j] &lt; list1[j - 1<span style="color: #000000;">]:
                list1[j], list1[j </span>- 1] = list1[j - 1<span style="color: #000000;">], list1[j]
        </span><span style="color: #0000ff;">print</span><span style="color: #000000;">(list1)


insert_sort(list1)</span></pre>
</div>
<p><strong>时间复杂度：</strong></p>
<ul>
<li>最优时间复杂度：O(n) （升序排列，序列已经处于升序状态）</li>
<li>最坏时间复杂度：O(n2)</li>
<li>稳定性：稳定</li>
</ul>
<p>&nbsp;<strong>效果图：</strong></p>
<p><img src="./images/常见排序算法详解（冒泡、选择、插入、快速、希尔、归并）2.png" alt="" /></p>
<p>&nbsp;</p>
<p><strong>4、快速排序</strong></p>
<p><strong>定义：</strong>快速排序（英语：Quicksort），又称划分交换排序（partition-exchange sort），通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>
<p>步骤为：</p>
<ol>
<li>从数列中挑出一个元素，称为"基准"（pivot），</li>
<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</li>
<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>
</ol>
<p>递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</p>
<div class="cnblogs_code">
<pre><code>list1 = [89, 56, 34, 16, 98, 110, 78, 90<span style="color: #000000;">]


</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> quik_sort(list1, start, end):
    </span><span style="color: #800000;">'''</span><span style="color: #800000;">快速排序</span><span style="color: #800000;">'''</span>
    <span style="color: #008000;">#</span><span style="color: #008000;"> 递归退出的条件</span>
    <span style="color: #0000ff;">if</span> start &gt;=<span style="color: #000000;"> end:
        </span><span style="color: #0000ff;">return</span>
    
    <span style="color: #008000;">#</span><span style="color: #008000;"> 设定起始元素要寻找位置的基准标准</span>
    mid =<span style="color: #000000;"> list1[start]
    </span><span style="color: #008000;">#</span><span style="color: #008000;"> low为序列左边的由左向右移动的游标</span>
    low =<span style="color: #000000;"> start
    </span><span style="color: #008000;">#</span><span style="color: #008000;"> high为序列左边的由右向左移动的游标</span>
    high =<span style="color: #000000;"> end

    </span><span style="color: #0000ff;">while</span> low &lt;<span style="color: #000000;"> high:
        </span><span style="color: #008000;">#</span><span style="color: #008000;"> 若low与high未重合high指向的元素不比基准元素小，则high向左移动</span>
        <span style="color: #0000ff;">while</span> low &lt; high <span style="color: #0000ff;">and</span> list1[high] &gt;=<span style="color: #000000;"> mid:
            high </span>-= 1<span style="color: #000000;">
        list1[low] </span>=<span style="color: #000000;"> list1[high]
        </span><span style="color: #008000;">#</span><span style="color: #008000;"> 若low与high未重合low指向的元素不比基准元素小，则low向左移动</span>
        <span style="color: #0000ff;">while</span> low &lt; high <span style="color: #0000ff;">and</span> list1[low] &lt;<span style="color: #000000;"> mid:
            low </span>+= 1<span style="color: #000000;">
        list1[high] </span>=<span style="color: #000000;"> list1[low]
    
    </span><span style="color: #008000;">#</span><span style="color: #008000;"> 退出循环后，low与high重合，此时所指位置为基准元素的正确位置</span>
    <span style="color: #008000;">#</span><span style="color: #008000;"> 将基准元素放到该位置</span>
    list1[low] =<span style="color: #000000;"> mid
    
    </span><span style="color: #008000;">#</span><span style="color: #008000;"> 左边序列快速排序  递归</span>
    quik_sort(list1, start, low - 1<span style="color: #000000;">)
    </span><span style="color: #008000;">#</span><span style="color: #008000;"> 右边序列快速排序</span>
    quik_sort(list1, low + 1<span style="color: #000000;">, end)
    </span><span style="color: #0000ff;">print</span><span style="color: #000000;">(list1)


quik_sort(list1, 0, len(list1) </span>- 1)</pre>
</div>
<p><strong>时间复杂读：</strong></p>
<ul>
<li>最优时间复杂度：O(nlogn)</li>
<li>最坏时间复杂度：O(n2)</li>
<li>稳定性：不稳定</li>
</ul>
<p><strong>演示：</strong></p>
<p><strong><img src="./images/常见排序算法详解（冒泡、选择、插入、快速、希尔、归并）3.png" alt="" /></strong></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;<strong>5、希尔排序</strong></p>
<p>&nbsp;<strong>定义：</strong>希尔排序(Shell Sort)是插入排序的一种。也称缩小增量排序，是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。该方法因DL．Shell于1959年提出而得名。 希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p>
<p><strong>&nbsp;基本思想：</strong>将数组列在一个表中并对列分别进行插入排序，重复这过程，不过每次用更长的列（步长更长了，列数更少了）来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身还是使用数组进行排序。</p>
<div class="cnblogs_code">
<pre><code>list1 = [23, 17, 77, 54, 12, 43, 65, 45<span style="color: #000000;">]

</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> shell_sort(list1):
    </span><span style="color: #800000;">'''</span><span style="color: #800000;">插入排序</span><span style="color: #800000;">'''</span><span style="color: #000000;">
    n </span>=<span style="color: #000000;"> len(list1)

    </span><span style="color: #008000;">#</span><span style="color: #008000;"> 初始化步长</span>
    gap = n // 2
    <span style="color: #0000ff;">while</span> gap &gt;<span style="color: #000000;"> 0:
        </span><span style="color: #008000;">#</span><span style="color: #008000;"> 按步长进行插入排序</span>
        <span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span><span style="color: #000000;"> range(gap, n):
            j </span>=<span style="color: #000000;"> i
            </span><span style="color: #0000ff;">while</span> j &gt;= gap <span style="color: #0000ff;">and</span> list1[j - gap] &gt;<span style="color: #000000;"> list1[j]:
                list1[j </span>- gap], list1[j] = list1[j], list1[j -<span style="color: #000000;"> gap]
                j </span>-=<span style="color: #000000;"> gap

        gap </span>= gap // 2
        <span style="color: #0000ff;">print</span><span style="color: #000000;">(list1)

shell_sort(list1)</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;<strong>时间复杂度：</strong></p>
<ul>
<li>最优时间复杂度：根据步长序列的不同而不同</li>
<li>最坏时间复杂度：O(n2)</li>
<li>稳定想：不稳定</li>
</ul>
<p><strong>演示：</strong></p>
<p><img src="./images/常见排序算法详解（冒泡、选择、插入、快速、希尔、归并）4.png" alt="" /></p>
<p>&nbsp;</p>
<p><strong>6、归并排序</strong></p>
<p><strong>定义：</strong>归并排序是采用分治法的一个非常典型的应用。归并排序的思想就是先递归分解数组，再合并数组。</p>
<p>将数组分解最小之后，然后合并两个有序数组，基本思路是比较两个数组的最前面的数，谁小就先取谁，取了后相应的指针就往后移一位。然后再比较，直至一个数组为空，最后把另一个数组的剩余部分复制过来即可。</p>
<p><strong>原理：</strong></p>
<p><strong><img src="./images/常见排序算法详解（冒泡、选择、插入、快速、希尔、归并）5.png" alt="" /></strong></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">def</span><span style="color: #000000;"> merge_sort(list1):
    </span><span style="color: #800000;">'''</span><span style="color: #800000;">归并排序</span><span style="color: #800000;">'''</span>
    <span style="color: #0000ff;">if</span> len(list1) &lt;= 1<span style="color: #000000;">:
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> list1
    </span><span style="color: #008000;">#</span><span style="color: #008000;"> 二分分解</span>
    num = len(list1) // 2<span style="color: #000000;">
    left </span>=<span style="color: #000000;"> merge_sort(list1[:num])
    right </span>=<span style="color: #000000;"> merge_sort(list1[num:])
    </span><span style="color: #0000ff;">print</span><span style="color: #000000;">(left)
    </span><span style="color: #0000ff;">print</span><span style="color: #000000;">(right)
    </span><span style="color: #008000;">#</span><span style="color: #008000;"> 进行合并</span>
    <span style="color: #0000ff;">return</span><span style="color: #000000;"> merge(left, right)


</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> merge(left, right):
    </span><span style="color: #800000;">'''</span><span style="color: #800000;">合并操作，将两个有序数组left[]  right[]合并成一个大的有序数组</span><span style="color: #800000;">'''</span>
    <span style="color: #008000;">#</span><span style="color: #008000;"> left与right定义下标</span>
    l, r =<span style="color: #000000;"> 0, 0
    result </span>=<span style="color: #000000;"> []
    </span><span style="color: #0000ff;">while</span> l &lt; len(left) <span style="color: #0000ff;">and</span> r &lt;<span style="color: #000000;"> len(right):
        </span><span style="color: #0000ff;">if</span> left[l] &lt;<span style="color: #000000;"> right[r]:
            result.append(left[l])
            l </span>+= 1
        <span style="color: #0000ff;">else</span><span style="color: #000000;">:
            result.append(right[r])
            r </span>+= 1<span style="color: #000000;">
    result </span>+=<span style="color: #000000;"> left[l:]
    result </span>+=<span style="color: #000000;"> right[r:]
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> result


list1 </span>= [12, 34, 21, 56, 43, 67<span style="color: #000000;">]
a </span>=<span style="color: #000000;"> merge_sort(list1)
</span><span style="color: #0000ff;">print</span>(a)</pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;<strong>时间复杂度：</strong></p>
<ul>
<li>最优时间复杂度：O(nlogn)</li>
<li>最坏时间复杂度：O(nlogn)</li>
<li>稳定性：稳定</li>
</ul>
<p>&nbsp;</p>
<p><strong>&nbsp;6种排序算法比较：</strong></p>
<p><img src="./images/常见排序算法详解（冒泡、选择、插入、快速、希尔、归并）6.png" alt="" /></p>
<p>&nbsp;</p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>