<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修IT黑马-面向对象' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>IT黑马-面向对象</center></div><div class='banquan'>原文出处:本文由博客园博主生如逆旅提供。<br/>
原文连接:https://www.cnblogs.com/srnl/p/11746187.html</div><br>
    <h1 id="先说面向过程">先说面向过程</h1>
<p>面向过程主要考虑的是怎么做<br />
把完成摸个需求的 所有步骤 从头到尾 逐步实现<br />
根据开发需求,将某些功能独立的代码封装成一个又一个的函数<br />
最后完成的代码就是顺序的调用不同的函数.<br />
特点是:<br />
注重不准走与过程,不注重职责分工.<br />
如果需求复杂,代码会变的很复杂</p>
<h2 id="开发复杂项目没有固定套路开发难度很大.">开发复杂项目,没有固定套路,开发难度很大.</h2>
<h1 id="面向对象">面向对象</h1>
<p>侧重点是谁来做?<br />
相比较函数,面向对象是更大的封装,根据职责在一个对象中封装多个方法.<br />
在完成某偶一个需求前首先确定职责--要做的事情(方法)<br />
根据职责确定不同的对象,在对象内部封装不同的方法(多个)<br />
最后完成的代码就是顺序的让不同对象调用不同的方法.<br />
特点是:<br />
注重对象和职责,不同的对象承担不同的职责<br />
更加适合对应复杂的需求变化,最专门应对复杂项目开发,提供固定套路<br />
需要面向过程的基础上,再学习一些面向对象的语法.<br />
例子:</p>
<h2 id="image.png"><img src="./images/IT黑马-面向对象0.png" alt="image.png" /></h2>
<p>类和对象是面向对象编程的两个核心概念<br />
类是对一群具有相同特征或者行为的实物的一个统称,是抽象的,不能直接使用<br />
特征被称为 属性<br />
行为被称为 方法<br />
对象 是由类创建出来的一个具体存在,可以直接使用<br />
由哪一个类创建出来的对象 就拥有在哪一个类中定义的 属性和方法<br />
类相当于图纸,对象就是用图纸创造出来的东西<br />
在程序开发中先有类,再有对象.<br />
类和对象的关系:<br />
类是模板,对象是根据类这个模板创建出来的.<br />
类只有一个,而对象可以有很多个.<br />
不同的对象之间属性可能会各不相同.</p>
<h2 id="类中定义了什么-属性和方法对象中就有什么属性和方法不可能多也不可能少.">类中定义了什么 属性和方法,对象中就有什么属性和方法,不可能多也不可能少.</h2>
<h1 id="类的设计">类的设计</h1>
<p>在使用面向对象开发前应该啥偶先分析需求,确定一下,程序中需要包含哪些类!<br />
在程序开发中药设计一个类,通常需要满足以下三个要素.:</p>
<ol>
<li>类名,这类事物的 <strong>名字</strong> ,满足大驼峰命名法(每个单词的首字母大写,单词与单词之间没有下划线)</li>
<li>属性,这类事物具有什么样的特征</li>
<li>方法,这类事物具有什么样的行为.</li>
</ol>
<h2 id="类名的确定">类名的确定</h2>
<p>名词提炼法:分析整个业务流程,出现的 名词,通常就是要找到的类.</p>
<h2 id="属性和方法的确定">属性和方法的确定</h2>
<ul>
<li>对对象的特征描述, 通常可以定义成属性.</li>
<li>对对象具有的行为(动词),通常可以定义成方法.<br />
提示:需求中没有涉及的属性或方法在涉及类时,不需要考虑.</li>
</ul>
<hr />
<h1 id="基础语法">基础语法</h1>
<h2 id="dir内置函数">dir内置函数</h2>
<ul>
<li>在python中对象是无所不在的,变量,数据,函数都是对象<br />
在python中可以使用两个方法验证:</li>
</ul>
<ol>
<li>在标识符/数据后输入一个.. 然后按下tab ipython会提示改对象能够调用的方法列表.</li>
<li>使用内置的dir传入标识符/数据/可以查看对象内所有属性及方法:<code>dir(print)</code></li>
<li>dir后可以看到 <code>__doc__</code> 方法 这是定义类时候的说明.<br />
4.提示 <code>__方法名__</code>格式的方法是python提供的内置方法/属性,:<br />
4.1 <code>__new__</code> 创建对象时候会被自动调用<br />
4.2 <code>__init__</code> 对象被初始化时会自动调用<br />
4.3 <code>__del__</code> 对象被从内存中销毁前会自动调用<br />
4.4 <code>__str__</code> 返回对象的描述信息,print函数输出使用.</li>
</ol>
<hr />
<h1 id="定义简单的类只包含方法">定义简单的类(只包含方法)</h1>
<ul>
<li>面向对象是更大的封装,在一个类中封装多个方法,这样通过这个类创建出来的对象,就可以直接调用这些方法了!</li>
</ul>
<ol>
<li>定义只包含方法的类</li>
</ol>
<pre><code><code>class 类名:
  def 方法1(self, 参数列表):
    pass
  def 方法2(self, 参数列表):
    pass</code></pre>
<ul>
<li>方法的定义格式和之前学习的函数几乎一样</li>
<li>区别在于第一个参数必须是<code>self</code><br />
*注意类名命名规则要符合大驼峰命名法.<br />
2.创建对象</li>
<li>当一个类 定义完成之后,要使用这个类来创建对象语法如下</li>
</ul>
<pre><code><code>对象变量 = 类名()</code></pre>
<hr />
<h1 id="第一个面向对象的演练">第一个面向对象的演练</h1>
<ol>
<li>需求分析(很重要)</li>
</ol>
<ul>
<li>小猫爱吃鱼, 小猫要喝水<br />
1.1 定义一个猫类 Cat<br />
1.2 定义两个方法 eat 和 dirnk<br />
2.代码：</li>
</ul>
<pre><code><code>class Cat():
  def eat(self):
    print(&#39;吃鱼吃鱼&#39;)
  def drink(self):
    print(&#39;喝水喝水&#39;)
#开始调用
tom = Cat()
tom.eat()
tom.drink()</code></pre>
<hr />
<h1 id="引用概念的强调">引用概念的强调</h1>
<blockquote>
<p>在面向对象开发中,引用概念是同样适用的!<br />
解释器先执行等号右边的内容 在内存中创建了一个对象<br />
然后在让tom这个变量引用这个对象的内存地址.</p>
</blockquote>
<ul>
<li>在python中使用类创建对象后,tom变量中仍然记录的是对象在内存中的地址.</li>
<li>也就是tom变量引用了新建的猫对象</li>
<li>使用print输出对象变量.默认情况下是能够输出这个变量应用的对象是由哪一个类创建的对象,以及在内存中的地址(十六进制表示.)</li>
</ul>
<blockquote>
<p>在计算机中通常使用十六进制表示内存地址<br />
%d 可以以10进制输出数字<br />
%x 可以以16进制输出数字<br />
应用id函数<br />
addr = id(tom)<br />
print(&quot;%d&quot; % addr) # %x可以看到16进制.</p>
</blockquote>
<hr />
<h1 id="再创建多个对象">再创建多个对象</h1>
<pre><code><code>lazy_cat = Cat()
lazy_cat.eat()
lazy_cat.drink()</code></pre>
<p>这两个猫对象 不是同一个对象,查看其内存地址就可以知道了.<br />
但是如果我们用另外一个变量去接收lazy_cat 例如<br />
<code>mao1 = lazy_cat</code></p>
<h2 id="这样mao1-和lazy_cat就是一样的了-只是变量名字的变化">这样mao1 和lazy_cat就是一样的了 只是变量名字的变化</h2>
<h1 id="在类的外部给类增加属性不要用会报错">在类的外部给类增加属性(不要用,会报错!)</h1>
<ul>
<li>在python中,要在对象外设置属性,非常容易 但是不推荐使用,因为对象属性的封装应该封装在类的内部</li>
<li>只需要在类的外部的代码中直接通过<code>.</code>设置一个属性即可</li>
</ul>
<pre><code><code>huamao.name  = &#39;花猫&#39;
# 调用
huamao.name</code></pre>
<hr />
<h1 id="利用self在类封装的方法中输出对象属性">利用self在类封装的方法中输出对象属性</h1>
<pre><code><code>class Cat:
  def eat(self):
    print(&quot;%s 爱吃鱼&quot; % self.name)
# 测试
mao1  = Cat()
mao1.name = &#39;汤姆&#39;
mao1.eat()</code></pre>
<ul>
<li>self 就是记录这个对象本身的,可以知道具体操作的那个对象.</li>
<li>哪一个对象调用的方法,self就是那个对象的应用.</li>
<li>在方法内部 想要使用那个属性,就用self.属性名 就可以了</li>
<li>在类封装方法内部 self 就表示当前调用方法的对象自己</li>
<li>在方法内部可以通过<code>self.</code>访问对象的属性,也可以通过<code>self.</code>调用其他对象的方法.</li>
</ul>
<hr />
<h1 id="初始化方法">初始化方法</h1>
<ul>
<li>当使用类名()创建对象时,会自动执行以下操作:
<ol>
<li>为对象在内存中分配空间 --创建对象</li>
<li>为对象的属性设置初始值 --初始化方法(init)</li>
</ol></li>
<li>这个初始化方法就是<code>__init__</code>方法,<code>__init__</code>方法是对象的内置方法.</li>
</ul>
<blockquote>
<p><code>__init__</code>方法是专门用来定义一个雷具有哪些属性的放方法<br />
在cat中增加 <code>__init__</code>方法,验证该方法在创建对象时会被自动调用</p>
</blockquote>
<pre><code><code>class Cat:
  &#39;&#39;&#39;这是一个猫类&#39;&#39;&#39;
  def __init__(self):
    print(&quot;初始化方法&quot;)</code></pre>
<ul>
<li>在`<code>__init__</code>方法内部使用 `self.属性名 = 属性值 就可以定义属性.</li>
<li>定义属性之后再使用Cat类创建对象 都会拥有该属性.</li>
</ul>
<pre><code><code># 重构Cat类
class Cat:
  def __init__(self):
    print(&#39;这是一个初始化方法&#39;)
    self.name = &#39;Tom&#39;
  def eat(self):
      print(&quot;%s爱吃鱼&quot; % self.name)
# 调用
tom = Cat()
tom.eat()
print(tom.name)</code></pre>
<hr />
<h1 id="改造初始化方法---舒适化的同时设置初始值">改造初始化方法 --舒适化的同时设置初始值</h1>
<ul>
<li>在开发中,如果希望在创建对象的同时就设置对象的属性,可以对<code>__init__</code>进行改造</li>
</ul>
<ol>
<li>把希望设置的属性值,定义成<code>__init__</code>方法的参数</li>
<li>在方法内部使用<code>self.属性 = 形参</code>接受外部传递的参数</li>
<li>在创建对象时,使用<code>类名(属性1,属性2)</code>调用<br />
例子:</li>
</ol>
<pre><code><code>class Cat:
  def __init__(self, name):
    print(&quot;初始化方法 %s&quot;% name)
    self.name = name
# 调用
tom = Cat(&#39;Tom&#39;)
</code></pre>
<hr />
<h1 id="del__和__str__方法"><code>__del__</code>和<code>__str__</code>方法</h1>
<ul>
<li>当时用类名创建对象时 分配完空间后,自动调用<code>__init__</code>方法但是当一个对象被从内存中销毁前会自动调用<code>__del__</code>方法.</li>
</ul>
<p>*生命周期</p>
<ol>
<li>一个对象从调用<code>类名()</code>创建,生命周期开始.</li>
<li>一个对象的<code>__del__</code>方法一旦被调用,生命周期结束</li>
<li>在对象的生命周期内,可以访问对象属性,或者让对象调用方法<br />
<img src="./images/IT黑马-面向对象1.png" alt="image.png" /></li>
</ol>
<ul>
<li>在python中,使用print输出对象变量,默认情况下会输出这个变量应用的对象使用哪一个类创建的对象,以及内存中管道地址.</li>
<li>在开发中 希望使用print 输出对象变量时,能够打印自定义的内容,就可以利用<code>__str__</code>这个内置方法付了.</li>
<li>注意 <code>__str__</code>方法必须返回一个字符串</li>
</ul>
<pre><code><code>class Cat:
  def __init__(self, new_name):
    self.name = new_name
    print(self.name +&#39;你好&#39;)
  def __del__(self):
    print(self.name+&#39;走了&#39;)
  def __str__(self):
    return &#39;这是__str__&#39;
</code></pre>
<hr />
<h1 id="面向对象练习.">面向对象练习.</h1>
<p>目标: 封装 小明爱跑步 存放家具</p>
<ol>
<li>封装<br />
1.1 封装是面向对象编程的一大特点<br />
1.2 面向对象编程的第一步 将属性和方法封装到一个抽象的类中.<br />
1.3 外界使用类创建对象,然后让对象调用方法<br />
1.4 对象方法的细节都被封装在类的内部</li>
<li>小明爱跑步.<br />
2.1 小明体重 75.0公斤<br />
2.2 小明每次跑步会减肥0.5公斤<br />
2.3 吃东西体重增加1公斤.<br />
<img src="./images/IT黑马-面向对象2.png" alt="image.png" /></li>
</ol>
<ul>
<li>在对象的方法内部,是可以直接访问对象的属性的.</li>
</ul>
<hr />
<h2 id="中间部分略过以后补">中间部分略过,以后补</h2>
<h1 id="私有属性和方法">私有属性和方法</h1>
<h2 id="应用场景和定义">应用场景和定义</h2>
<ul>
<li>在实际开发中,对象的某些属性或方法可能只希望在对象的内部被使用,而不希望在外部被访问到</li>
<li>私有属性就是对象不希望公开的属性
</li>
<li>私有方法就是对象不希望公开的方法</li>
</ul>
<h2 id="定义方式">定义方式</h2>
<ul>
<li>在定义属性或方法时,在属性名或者方法名前面增加两个下划线,定义就是私有属性或方法.<br />
例子:</li>
</ul>
<pre><code><code>class Women:

  def __init__(self, name):

    self.name = name 
    self.__age = 18
   def secret(self):
    print(&quot;%s 的年龄是 %d &quot;%(self.name, self.__age))
# 测试
xiaofang = Women(&quot;小芳&quot;)
print(xiaofang.__age)  # 这个就调用不了了.私有属性 在外界不能被直接访问.
xiaofang.secret()  # 但是在对象的方法内部可以访问.
方法同理 不希望外界调用的方法前面加`__`,外部就调用不了了,只可以在类的内部调用.
</code></pre>
<h1 id="伪私有属性和方法">伪私有属性和方法</h1>
<blockquote>
<p>在日常开发中不要使用这种方式,访问队形的私有属性或私有方法.</p>
</blockquote>
<ul>
<li>在python,并没有真正意义的私有</li>
<li>加了<code>__</code>实际只是python做了一些特殊处理</li>
<li>具体方式为:在在名称前面加上 <code>_类名__名称</code><br />
例子:<br />
<code>print(xiaofang._Women__age)</code></li>
</ul>

</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>