<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修函数的第一类对象,f格式化,迭代器以及递归' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>函数的第一类对象,f格式化,迭代器以及递归</center></div><div class='banquan'>原文出处:本文由博客园博主Bugbiss提供。<br/>
原文连接:https://www.cnblogs.com/tutougold/p/11210447.html</div><br>
    <h1 id="函数名的第一类对象及使用f格式化以及迭代器">函数名的第一类对象及使用,f格式化以及迭代器</h1>
<h2 id="函数的第一类对象">1.函数的第一类对象</h2>
<pre><code><code>第一类对象 --特殊点

1.可以当作值被赋值给变量

def func():
    print(1)
a = func
a()

2.可以当作元素存放在容器中

def func()
    print(1)
lst = [func,func,func]
for i in lst
    i()


3.函数名可以当作函数的参数

def func(f):
    f()
def foo():
    print(1)
func(foo)


4.函数名可以当作函数的返回值
def func():
    def foo():
        print(1)
    return foo
a = func()
a()



def f(1):
    def f2():
        print(1)
        def f3():
            print(2)
        return f2
    ret = f2()
    return ret
print(f1())
</code></pre>
<h2 id="f字符串格式化">2.f字符串格式化</h2>
<pre><code><code># python3.6版本及以上才能够使用

s = f&quot;你好(&#39;hello&#39;)&quot;                 # 填充字符串
s1 = F&quot;你好(&#39;hello&#39;)&quot;

s1 = f&quot;你好{s}&quot;                     # 填充变量
print(s1)

s1 = f&quot;{35+15}&quot;                    #填充计算公式
print(s1)

a = 10                            #填充表达式
b = 20
s1 = f&quot;(a if a&gt;b else b)&quot;
print(s1)

s1 = f&quot;{{{{{{&#39;你好..&#39;}}}}}}&quot;        #填充大括号
print(s1)

s1 = f&quot;{{}}&quot;
print(s1)

s1 = f&quot;{&#39;{}{}{}&#39;}&quot;
print(s1)

s1 = f&quot;{print(123)}&quot;
print(s1)

def prin(a):
    print(a)
s1 = f&quot;{prin(123)}&quot;
prin(s1)

def foo():
    def func():
        a = 1
        return a
    return func()

s1 = f&quot;{foo()}&quot;
print(s1)

lst = [1,2,3,4,5]
s1 = f&quot;{lst[0:5]}&quot;
print(s1)

dic = {&#39;key1&#39;:123,&#39;key2&#39;:456}
s1 = f&quot;{dic[&#39;key2&#39;]}&quot;
print(s1)</code></pre>
<h2 id="迭代器">3.迭代器</h2>
<pre><code><code>可迭代对象
list,dict,str,set,tuple   --可迭代对象,使用灵活

验证是否为可迭代对象:
方式一:
    list.__iter__()
    dict.__iter__()
方式二:
    查看源码
方式三:
    print(dir(list))
    
官方声明:只要具有__iter__()方法的就是可迭代对象
    
可迭代对象的优点:
    1.使用灵活
    2.直接查看值
可迭代对象的缺点:
    1.消耗内存
    
取值方式:
    list,tuple,str   --索引
    dict             --键
    set              --直接取值
   


迭代器:
官方声明只要具有__iter__()  和 __next__()就是迭代器
f = open(&quot;t1.txt&quot;,&quot;r&quot;)
f.__iter__()
f.__next__()

lst = [1,2,3,4,5]
new_lst = lst.__iter__()      # 将可迭代对象转换成迭代器

new_lst.__iter__()
new_lst.__next__()

s = &quot;123456&quot;
new_s = s.__iter__()         #将可迭代对象转换成迭代器
print(new_s)
new_s.__iter__()
new.s.__next__()

new_s = s.__iter__()        #将可迭代对象转换成迭代器
print(new_s)
new_s.__iter__()
print(new_s.__next__())
print(new_s.__next__())
print(new_s.__next__())

s = &quot;123456&quot;               #更改for的本质
s = [1,2,3,4,5,6]
count = len(s)
new_s = s.__iter__()
while count:
    print(new_s.__next__())
    count -= 1
    
s = &quot;123456&quot;
new_s = s.__iter__()           # for的真实本质
while True:
    try:
        print(new_s.__next__())        
    except StopIteration:
        break
        
except Exception:
    print(&quot;万能审查&quot;)
    break
    
    
总结:
    可迭代对象:
        优点:使用灵活,可以直接查看值
        缺点:占内存,不能迭代取值
    迭代器:
        优点:节省内存,惰性机制
        缺点:使用不灵活,操作比较繁琐,不能直接查看元素
            
            
迭代器的特性:
    1.一次性的(永远就没有了)
    2.不能逆行(不能后退)
    3.惰性机制(节省内存)
 
什么是可迭代对象:
    具有很多私有方法,具有__iter__()方法的就是一个可迭代对象
什么是迭代器:
    具有__iter__()和__next__()方法的就是迭代器
    
迭代器什么时候使用:当容器中数据量较多的时候使用迭代器</code></pre>
<h2 id="递归">4.递归</h2>
<pre><code><code>递归:
    1.自己调用自己(不断调用自己本身)    --死递归
    2.有明确的终止条件
    #满足两个以上的才是有效递归
递:一直执行直到碰到结束条件
归:从结束条件开始往回退
    
def func():
    print(123)
    func()
func()   
# 官方声明:最大层次1000,实际测试997/998

def age(n):
    if n == 4:
        return &quot;你好&quot;
    else:
        return age(n+1)
print(age(1))

##过程
def age2(n):
    if n == 3:
        return &quot;你好&quot;
def age1(n):
    if n == 3:
        return &quot;你好&quot;
    else:
        age2(n+1)
def age(n):
    if n == 3:
        return &quot;你好&quot;
    else:
        age1(n+1)
age(1)


1.宝元 18-2-2-2
2.太白 18-2-2
3.wusir 18-2
4.alex 18

def age(n):
    if n == 4:
        return 18
    else:
        return age(n+1)-2
print(age(1))


##过程
def age4(n):
    if n == 4:
        return 18
def age3(n):
    if n == 4:
        return 18
    else:
        return age4(n+1)-2
def age2(n):
    if n == 4:
        return 18
    else:
        return age3(n+1)-2
def age1(n):
    if n == 4:
        return 18
    else:
        return age2(n+1)-2
print(age1(1))

</code></pre>

</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>