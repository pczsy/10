<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修Python3程序设计指南：02 数据类型' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>Python3程序设计指南：02 数据类型</center></div><div class='banquan'>原文出处:本文由博客园博主CppPython提供。<br/>
原文连接:https://www.cnblogs.com/fatcat01/p/11719221.html</div><br>
    <div class="toc">
    <p class="toc-title">目录</p>
    <div class="toc-list">
        <ul>
        <li><a href="#标识符与关键字">1、标识符与关键字</a><ul>
        <li><a href="#规则">1.1 规则</a></li>
        <li><a href="#约定">1.2 约定</a></li>
        </ul></li>
        <li><a href="#integral类型">2、Integral类型</a><ul>
        <li><a href="#整数">2.1 整数</a><ul>
        <li><a href="#数值型操作符与函数">2.1.1 数值型操作符与函数</a></li>
        <li><a href="#使用数据类型创建对象">2.1.2 使用数据类型创建对象</a></li>
        <li><a href="#整数位逻辑操作符">2.1.3 整数位逻辑操作符</a></li>
        </ul></li>
        <li><a href="#布尔型">2.2 布尔型</a></li>
        </ul></li>
        <li><a href="#浮点类型">3、浮点类型</a><ul>
        <li><a href="#浮点数">3.1 浮点数</a></li>
        <li><a href="#复数">3.2 复数</a></li>
        <li><a href="#十进制数">3.3 十进制数</a></li>
        </ul></li>
        <li><a href="#字符串">4、字符串</a><ul>
        <li><a href="#str函数">4.1 str()函数</a></li>
        <li><a href="#字符串的表示">4.2 字符串的表示</a></li>
        <li><a href="#字符串的分片与步长">4.3 字符串的分片与步长</a></li>
        <li><a href="#字符串操作符与方法">4.4 字符串操作符与方法</a></li>
        <li><a href="#str.format对字符串格式化">4.5 str.format()对字符串格式化</a></li>
        </ul></li>
        </ul>
    </div>
</div>
<p><img src="./images/Python3程序设计指南：02 数据类型0.png" alt="数据类型导图" /></p>
<h1 id="标识符与关键字">1、标识符与关键字</h1>
<p>创建一个数据项时，我们或者将其赋值给一个变量，或者将其插入到一个组合中。为对象引用赋予的名称叫<strong>标识符</strong>。</p>
<h2 id="规则">1.1 规则</h2>
<p>有效的Python标识符是任意长度的飞空字符序列，其中包括一个“引导字符”，以及0个或多个“后续字符”，Python标识符必须符合两条<strong>规则</strong>：</p>
<ol>
<li>只要是Unicode编码的字母，都可以充当引导字符，包括ASCII字母、下划线以及大多数非英文语言的字母。</li>
<li>Python标识符不能与Python关键字同名。</li>
</ol>
<p>如何查看Python关键字呢？只需两行代码：</p>
<pre><code><code># 查看Python关键字
import keyword
print(keyword.kwlist)</code></pre>
<p>输出结果如下：</p>
<pre><code><code>[&#39;False&#39;, &#39;None&#39;, &#39;True&#39;, &#39;and&#39;, &#39;as&#39;, &#39;assert&#39;, &#39;break&#39;, &#39;class&#39;, &#39;continue&#39;, &#39;def&#39;, &#39;del&#39;, &#39;elif&#39;, &#39;else&#39;, &#39;except&#39;, &#39;finally&#39;, &#39;for&#39;, &#39;from&#39;, &#39;global&#39;, &#39;if&#39;, &#39;import&#39;, &#39;in&#39;, &#39;is&#39;, &#39;lambda&#39;, &#39;nonlocal&#39;, &#39;not&#39;, &#39;or&#39;, &#39;pass&#39;, &#39;raise&#39;, &#39;return&#39;, &#39;try&#39;, &#39;while&#39;, &#39;with&#39;, &#39;yield&#39;]</code></pre>
<h2 id="约定">1.2 约定</h2>
<ol>
<li>不要使用Python预定义的标识符名对自定义的标识符进行命名。</li>
<li>避免使用开头和结尾都是下划线的标识符。因为Python定义了各种特殊方法和变量，使用的就是这样的名称。</li>
</ol>
<h1 id="integral类型">2、Integral类型</h1>
<p>Python提供了两种内置的Integral类型，即<strong>int</strong>和<strong>bool</strong>。在布尔表达式中，0与False都表示False，其他任意整数与True都表示True。在数字表达式中，True表示1，False表示0。</p>
<h2 id="整数">2.1 整数</h2>
<p>整数的大小只受限于机器的内存大小。默认情况下，整数采用的是十进制。二进制以<strong>0b</strong>引导，八进制以<strong>0o</strong>引导，十六进制以<strong>0x</strong>引导，大小写都可以。</p>
<h3 id="数值型操作符与函数">2.1.1 数值型操作符与函数</h3>
<table>
<thead>
<tr class="header">
<th>语法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>x+y</td>
<td>将数x与数y相加</td>
</tr>
<tr class="even">
<td>x-y</td>
<td>从x减去y</td>
</tr>
<tr class="odd">
<td>x*y</td>
<td>将x与y相乘</td>
</tr>
<tr class="even">
<td>x/y</td>
<td>用x除以y，得到一个浮点值（如果x或y是复数就产生一个复数）</td>
</tr>
<tr class="odd">
<td>x//y</td>
<td>用x除以y，舍弃小数部分，得到一个整数</td>
</tr>
<tr class="even">
<td>x%y</td>
<td>用x除以y，取模（余数）</td>
</tr>
<tr class="odd">
<td>x**y</td>
<td>x的y次幂</td>
</tr>
<tr class="even">
<td>-x</td>
<td>对x取复数，如果x非零，就改变其符号</td>
</tr>
<tr class="odd">
<td>+x</td>
<td>不做任何操作，有时候用于澄清代码</td>
</tr>
<tr class="even">
<td>abs(x)</td>
<td>返回x的绝对值</td>
</tr>
<tr class="odd">
<td>divmod(x,y)</td>
<td>以二元组的形式返回x除以y所得的商和余数（两个整数）</td>
</tr>
<tr class="even">
<td>pow(x,y)</td>
<td>与x**y等同</td>
</tr>
<tr class="odd">
<td>pow(x,y,z)</td>
<td>(x**y)%z的另一种写法</td>
</tr>
<tr class="even">
<td>round(x,n)</td>
<td>返回浮点数x四舍五入后得到的相应整数（如果给定n，就将浮点数转换为小数点后有n位）</td>
</tr>
</tbody>
</table>
<p>所有二元数学操作符（+、-、*、/、//、%、与**）都有相应的增强版赋值操作符（+=、-=、*=、/=、//=、%=、与**=）。</p>
<h3 id="使用数据类型创建对象">2.1.2 使用数据类型创建对象</h3>
<p>对象的创建可以通过给变量赋字面意义上的值，比如<code>x=17</code>，或者将相关的数据类型作为函数进行调用，比如<code>x=int(17)</code>。</p>
<p>使用数据类型创建对象时，有3种用例：</p>
<ol>
<li><strong>不使用参数调用数据类型函数</strong>。此时，对象会被赋值为一个默认值，比如<code>x=int()</code>会创建一个值为0的整数。所有内置数据类型都可以作为函数并不带任何参数进行调用。</li>
<li><strong>使用一个参数调用数据类型函数</strong>。如果给定的参数是同样的数据类型，就会创建一个新对象；否则会尝试进行转换。
<ul>
<li>如果给定参数支持到给定数据类型的转换，但是转换失败，会产生一个<strong>ValueError</strong>异常，否则返回给定类型的对象。</li>
<li>如果给定参数不支持到给定数据类型的转换，就会产生一个<strong>TypeError</strong>异常。</li>
</ul></li>
</ol>
<p><strong>整数转换函数：</strong></p>
<table>
<thead>
<tr class="header">
<th>语法</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>bin(i)</td>
<td style="text-align: left;">返回整数i的二进制表示（字符串），比如<code>bin(100)='0b01100100'</code></td>
</tr>
<tr class="even">
<td>hex(i)</td>
<td style="text-align: left;">返回整数i的十六进制表示（字符串），比如<code>hex(100)='0x64'</code></td>
</tr>
<tr class="odd">
<td>int(x)</td>
<td style="text-align: left;">将对象x转换为整数，失败时会产生ValueError异常，如果x的数据类型不知道到整数的转换，就会产生TypeError异常；如果x是一个浮点数，就会截取其整数部分</td>
</tr>
<tr class="even">
<td>int(s, base)</td>
<td style="text-align: left;">将字符串s转换为整数，如果给定了可选的基参数，那么应该为2到36之间的整数</td>
</tr>
<tr class="odd">
<td>oct(i)</td>
<td style="text-align: left;">返回整数i的八进制表示（字符串），比如<code>oct(100)='0o144'</code></td>
</tr>
</tbody>
</table>
<ol>
<li><strong>给定两个或多个参数</strong>——但不是所有数据类型都支持，而对支持这一情况的数据类型，参数类型以及内涵都是变化的。</li>
</ol>
<h3 id="整数位逻辑操作符">2.1.3 整数位逻辑操作符</h3>
<table>
<thead>
<tr class="header">
<th>语法</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>i|j</td>
<td style="text-align: left;">对整数i和整数j进行为逻辑OR运算</td>
</tr>
<tr class="even">
<td>i^j</td>
<td style="text-align: left;">对整数i和整数j进行为逻辑XOR运算</td>
</tr>
<tr class="odd">
<td>i&amp;j</td>
<td style="text-align: left;">对整数i和整数j进行为逻辑AND运算</td>
</tr>
<tr class="even">
<td>i&lt;&lt;j</td>
<td style="text-align: left;">将i左移j位，类似于i*(2**j)，但不带溢出检查</td>
</tr>
<tr class="odd">
<td>i&gt;&gt;j</td>
<td style="text-align: left;">将i左移j位，类似于i//(2**j)，但不带溢出检查</td>
</tr>
<tr class="even">
<td>~i</td>
<td style="text-align: left;">反转i的每一位</td>
</tr>
</tbody>
</table>
<h2 id="布尔型">2.2 布尔型</h2>
<p>有两个内置的布尔型对象：<strong>True</strong>与<strong>False</strong>。</p>
<p>布尔数据也可以当做函数进行调用——不指定参数时将返回False，给定的是布尔型参数时，会返回该参数的一个拷贝，给定的是其他类型的参数时，则会尝试将其转换为布尔数据类型。</p>
<p>所有内置的数据类型与标准库提供的数据类型都可以转换为一个布尔型值。</p>
<h1 id="浮点类型">3、浮点类型</h1>
<p>Python提供了3中浮点值：内置的float与complex类型，以及来自标准库的decimal.Decimal类型。</p>
<p>float类型存放双精度的浮点数。</p>
<h2 id="浮点数">3.1 浮点数</h2>
<p>比较两个float数是否相等（按机器所能提供的最大精度）：</p>
<pre><code><code>import sys

def equal_float(a, b):
    return abs(a - b) &lt;= sys.float_info.epsilon</code></pre>
<p>Python的floatS通常会提供之多<strong>17</strong>个数字的精度。</p>
<h2 id="复数">3.2 复数</h2>
<p>复数这种数据类型是固定的，其中存放的是一对浮点数，一个表示实数部分，一个表示虚数部分。复数的两个部分都以属性名的形式存在，分别为real与imag，例如：</p>
<pre><code><code>z = -23.1+8.94j
print(z.real, z.imag)</code></pre>
<p>除//、%、divmod()以及三个参数的pow()之外，所有数值型操作符与函数都可以用于对复数进行操作，赋值操作符的增强版也可以。</p>
<p>复数类型有一个方法conjugate()用于改变虚数部分的符号，例如：</p>
<pre><code><code>z = -23.1+8.94j
y = z.conjugate()

###
y = -23.1-8,94j</code></pre>
<p>要使用复数，可以先导入cmath模块，该模块提供了math模块中大多数三角函数与对数的复数版，也包括一些复数特定的函数。</p>
<h2 id="十进制数">3.3 十进制数</h2>
<p>decimal模块可以提供固定的十进制数，其精度可以由我们自己指定。涉及Decimals的计算要比浮点数的计算慢。</p>
<pre><code><code>In [5]: import decimal
In [6]: a = decimal.Decimal(4532)
In [7]: b = decimal.Decimal(&quot;543129.98789798&quot;)
In [8]: a+b
Out[8]: Decimal(&#39;547661.98789798&#39;)</code></pre>
<p>十进制数是由<strong>decimal.Decimal()</strong>函数创建，该函数可以接受一个整数或一个字符串作为参数——但不能以浮点数作为参数，因为浮点数不够精确。</p>
<h1 id="字符串">4、字符串</h1>
<p>字符串是使用固定不变的str数据类型表示的，其中存放Unicode字符序列。</p>
<h2 id="str函数">4.1 str()函数</h2>
<p><strong>str()</strong>函数的用法：</p>
<ul>
<li><p><strong>创建字符串对象</strong>，参数为空时，返回一个空字符串，参数为非字符串类型时返回改参数的字符串形式，参数为字符串时，返回该字符串的拷贝。</p>
<pre><code><code>In [9]: string1 = str()
In [10]: string2 = str(1234)
In [11]: string3 = str(&#39;hello&#39;)

In [12]: string1
Out[12]: &#39;&#39;

In [13]: string2
Out[13]: &#39;1234&#39;

In [14]: string3
Out[14]: &#39;hello&#39;</code></pre></li>
<li><p><strong>转换函数</strong>，此时要求第一个参数为字符串或可以转换为字符串的其他数据类型，其后跟两个可选的字符串参数，其中一个用于指定要使用的编码格式，另一个用于指定如何处理编码错误。</p></li>
</ul>
<h2 id="字符串的表示">4.2 字符串的表示</h2>
<ul>
<li>单引号：<code>s = 'hello'</code></li>
<li>双引号：<code>s = &quot;hello&quot;</code></li>
<li>三引号：<code>s = '''hello python'''</code>或<code>s = &quot;&quot;&quot;hello python&quot;&quot;&quot;</code></li>
</ul>
<p>在引号包含的字符串中使用引号：</p>
<ul>
<li>使用与引号包含的字符串不同的引号，例如<code>s = &quot;this is a 'str'.&quot;</code></li>
<li>如果两者引号相同，那就需要使用转义字符，例如<code>s = &quot;this is a \&quot;str\&quot;.&quot;</code></li>
</ul>
<p>如果要写一个长字符串，跨越了多行，如何表示？</p>
<ul>
<li><p>使用三引号（注意行尾的&quot;&quot;，如果不加，则打印出来带有换行符）：</p>
<pre><code><code>In [29]: s = &quot;&quot;&quot;This is the first way to
    ...: solve the problem&quot;&quot;&quot;

In [30]: s
Out[30]: &#39;This is the first way to \nsolve the problem&#39;

In [31]: s = &quot;&quot;&quot;This is the first way to \
    ...: solve the problem&quot;&quot;&quot;

In [32]: s
Out[32]: &#39;This is the first way to solve the problem&#39;</code></pre></li>
<li><p>使用&quot;+&quot;和&quot;&quot;:</p>
<pre><code><code>In [33]: s = &quot;This is not the best way to join two long strings &quot; + \
    ...: &quot;together since it relines on ugly newline escaping&quot;

In [34]: s
Out[34]: &#39;This is not the best way to join two long strings together since it relines on ugly newline escaping&#39;</code></pre></li>
<li><p>使用圆括号：</p>
<pre><code><code>In [35]: s = (&quot;This is the nice way to join two long strings &quot;
    ...: &quot;together;it relines on string literal concatenation.&quot;)

In [36]: s
Out[36]: &#39;This is the nice way to join two long strings together;it relines on string literal concatenation.&#39;</code></pre></li>
</ul>
<p>Python的“Idioms and Anti-Idioms”HOWTO文档建议<strong>总是使用圆括号将跨越多行的任何语句进行封装，而不使用专一的换行符</strong>。</p>
<h2 id="字符串的分片与步长">4.3 字符串的分片与步长</h2>
<p>字符串的索引位置从0开始，直至字符串长度值减去1。使用负索引位置也可以，此时的计数方式是从最后一个字符到第一个字符。</p>
<p>假如我们设置<code>s='Python'</code>，下图展示了字符串所有有效索引位置：</p>
<p><img src="./images/Python3程序设计指南：02 数据类型1.png" alt="字符串索引位" /></p>
<p>分片操作有三种语法：</p>
<ul>
<li>seq[start] ：从序列中提取start位置的数据项。</li>
<li>seq[start:end] ：从start开始到end结束的数据项（不包含）。</li>
<li>seq[start: end:step] ：从start开始到end结束的数据项（不包含）每隔step个字符进行提取。</li>
</ul>
<p>其中seq可以是任意<strong>序列</strong>，比如列表、字符或元组。start、end与step必须是<strong>整数</strong>。</p>
<p>第二和第三种语法，我们可以忽略任意的整数索引值：忽略起点索引值，就默认为<strong>0</strong>；如果忽略终点索引值，就默认为<strong>len(seq)</strong>。</p>
<p><strong>step可以为负值</strong>，如果为负值就从end开始往start方向提取，我们可以利用这一特性进行序列的<strong>倒序</strong>排列操作：</p>
<pre><code><code>In [40]: s = &#39;python&#39;

In [41]: s[::-1]
Out[41]: &#39;nohtyp&#39;</code></pre>
<h2 id="字符串操作符与方法">4.4 字符串操作符与方法</h2>
<p>由于字符串是固定序列，所有可用于固定序列的功能都可以用于字符串，包括使用<strong>in</strong>进行成员测试，使用+=进行追加操作，使用*进行复制操作等。</p>
<p>令<code>s = 'i like Python'</code>:</p>
<table>
<thead>
<tr class="header">
<th>语法</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>s.capitalize()</td>
<td>返回字符串s的副本，并将首字母变为大写</td>
<td>'I like python'</td>
</tr>
<tr class="even">
<td>s.center(width, char)</td>
<td>返回s中间的一个子字符串，长度为width，并使用空格或可选的char（长度为1的字符串）进行填充</td>
<td></td>
</tr>
<tr class="odd">
<td>s.count(t, start, end)</td>
<td>返回s中（或在start : end分片中）子字符串t出现的次数</td>
<td>s.count('i')<br />2</td>
</tr>
<tr class="even">
<td>s.encode(encoding, err)</td>
<td>返回bytes对象，该对象使用默认的编码格式或指定的编码格式来表示该字符串并根据可选的err参数处理错误</td>
<td>s.encode('gbk')<br />b'i like Python'</td>
</tr>
<tr class="odd">
<td>s.endswith(x, start,end)</td>
<td>如果s（或在s的start : end分片）以字符串x（或元组x中的任意字符串）结尾，就返回True</td>
<td>s.endswith('n')<br />True</td>
</tr>
<tr class="even">
<td>s.expandtabs(size)</td>
<td>返回s的副本，其中的制表符使用8个或指定数量的空格替换</td>
<td></td>
</tr>
<tr class="odd">
<td>s.find(t, start, end)</td>
<td>返回t在s中（或s的start : end分片中）的最左位置，如果没找到返回-1。使用s.rfind()则可以发现相应的最右边位置。</td>
<td>s.find('like')<br />2</td>
</tr>
<tr class="even">
<td>s.format(...)</td>
<td>返回按给定参数进行格式化后的字符串副本，后面会讲</td>
<td></td>
</tr>
<tr class="odd">
<td>s.index(t,start,end)</td>
<td>返回t在s中（或s的start : end分片中）的最左位置，如果没有找到会产生ValueError异常。如果使用rindex()可以从右边开始搜索。</td>
<td>s.index('y')<br />8</td>
</tr>
<tr class="even">
<td>s.isalnum()</td>
<td>如果s非空，并且其中的每个字符都是字母数字，返回True</td>
<td>False</td>
</tr>
<tr class="odd">
<td>s.isalpha()</td>
<td>如果s非空，并且其中的每个字符都是字母，返回True</td>
<td>False</td>
</tr>
<tr class="even">
<td>s.isdecimal()</td>
<td>如果s非空，并且其中的每个字符都是Unicode的基数为10的数字，返回True</td>
<td>False</td>
</tr>
<tr class="odd">
<td>s.isidentifier()</td>
<td>如果s非空，并且是一个有效的标识符，返回True</td>
<td>False</td>
</tr>
<tr class="even">
<td>s.islower()</td>
<td>如果s至少有一个可以小写的字符，并且其所有的可小写的字符都是小写的，返回True</td>
<td>False</td>
</tr>
<tr class="odd">
<td>s.isnumeric()</td>
<td>如果s非空，并且其中的每个字符都是数值的Unicode字符，比如数字或小数，返回True</td>
<td>False</td>
</tr>
<tr class="even">
<td>s.isprintable()</td>
<td>如果s非空，并且其中的每个字符都是可打印的，包括空格但不包括换行，返回True</td>
<td>True</td>
</tr>
<tr class="odd">
<td>s.isspace()</td>
<td>如果s非空，并且其中的每个字符都是空白字符，返回True</td>
<td>False</td>
</tr>
<tr class="even">
<td>s.istitle()</td>
<td>如果s非空，并且首字母大写，返回True</td>
<td>False</td>
</tr>
<tr class="odd">
<td>s.isupper()</td>
<td>如果s至少有一个可以大写的字符，并且其所有的可大写的字符都是大写的，返回True</td>
<td>False</td>
</tr>
<tr class="even">
<td>s.join(seq)</td>
<td>返回序列seq中每个项连接起来后的结果，并以s（可以为空）在每两项之间分隔</td>
<td>s.join(['first', 'second'])<br />'firsti like Pythonsecond'</td>
</tr>
<tr class="odd">
<td>s.ljust(width, char)</td>
<td>返回长度为width的字符串（使用空格或可选的char（长度为1的字符串）进行填充）中左对齐的字符串s的一个副本。使用s.rjust()可以右对齐，s.center()可以中间对齐</td>
<td></td>
</tr>
<tr class="even">
<td>s.lower()</td>
<td>将s中的字符变为小写</td>
<td>'i like python'</td>
</tr>
<tr class="odd">
<td>s. maketrans(<em>x</em>[,<em>y</em>[,<em>z</em>]])</td>
<td>该静态函数返回可用于str.translate()方法的转换表。<br /> 如果只有一个参数，它必须是dict类型，键key为长度为1的字符（unicode字符码或者字符），值value为任意长度字符串或者None。键key对应的字符将被转换为值value对应的字符（串）。<br /> 如果有两个参数，他们长度必须相等，每一个x字符将被转换为对应的y字符。如果有第三个参数，其对应的字符将被转换为None。</td>
<td>m = {'e':'f', 'o':'p'}<br />s.maketrans(m)<br />{101: 'f', 111: 'p'}</td>
</tr>
<tr class="even">
<td>s.partition(t)</td>
<td>返回包含3个字符串的元组--字符串s在t的最左边部分、t、字符串s在t最右边部分。如果t不在s内，则返回s与两个空字符串。使用s.rpartition()可以在t最右边部分进行分区</td>
<td>s.partition('like')<br />('i ', 'like', ' Python')</td>
</tr>
<tr class="odd">
<td>s.replace(t,u,n)</td>
<td>返回s的副本，其中每个（或最多n个，如果给定）字符串t使用u替换</td>
<td>s.replace('like','love')<br />'i love Python'</td>
</tr>
<tr class="even">
<td>s.split(t,n)</td>
<td>返回一个字符串列表，要求在字符串t处至多分割n次。如果没有给定n，就分隔尽可能多次，如果t没有给定，就在空白处分割。使用s.rsplit()可以从右边进行分割</td>
<td>s.split('i')<br />['', ' l', 'ke Python']</td>
</tr>
<tr class="odd">
<td>s.splitlines(f)</td>
<td>返回在行终结符处进行分割产生的行列表，并剥离行终结符（除非f为True）</td>
<td>s.splitlines()<br />['i like Python']</td>
</tr>
<tr class="even">
<td>s.startswith(s,start,end)</td>
<td>如果s（或在s的start : end分片）以字符串x（或元组x中的任意字符串）开始，就返回True</td>
<td>s.startswith('i')<br />True</td>
</tr>
<tr class="odd">
<td>s.stripe(chars)</td>
<td>返回s的一个副本，并将开始处与结尾处的空白字符（或字符串chars中的字符）移除，s.lstripe()仅剥离起始处的相应字符，s.rstripe()仅剥离结尾出的相应字符</td>
<td>s.strip('n')<br />'i like Pytho'</td>
</tr>
<tr class="even">
<td>s.swapcase()</td>
<td>返回s的副本，并将其中大写字符变为小写，小写字符变为大写</td>
<td>'I LIKE pYTHON'</td>
</tr>
<tr class="odd">
<td>s.title()</td>
<td>返回s的副本，并将每个单词的首字母变为大写，其它字母变为小写</td>
<td>'I Like Python'</td>
</tr>
<tr class="even">
<td>s.translate()</td>
<td>返回一个使用参数map转换后的字符串，map必须是一个unicode字符码（整形）到unicode字符，字符串或None的映射表，未被映射的字符保持不表，被映射为None的字符将被删除。</td>
<td>m = {'e':'f', 'o':'p'}<br />s.maketrans(m)<br />s.translate(trans)<br />'i likf Pythpn'</td>
</tr>
<tr class="odd">
<td>s.upper()</td>
<td>返回s的大写化版本</td>
<td>'I LIKE PYTHON'</td>
</tr>
<tr class="even">
<td>s.zfill(w)</td>
<td>返回s的副本，如果比w短，就在开始处添加0，使其长度为w</td>
<td>s.zfill(15)<br />'00i like Python'</td>
</tr>
</tbody>
</table>
<p>Python还有一些其他库模块提供字符串相关的功能：</p>
<ul>
<li>difflib，用于展示文件或字符串之间的差别</li>
<li>io模块的io.StringIO类，用于读写字符串，就像对文件的读写操作一样</li>
<li>textwrap，该模块提供了用于包裹于填充字符串的函数和方法</li>
<li>string，其中定义了一些有用的常量，比如ascii_letters与ascii_lowercase</li>
</ul>
<h2 id="str.format对字符串格式化">4.5 str.format()对字符串格式化</h2>
<p>str.format()方法会返回一个新字符串，在新字符串中，原字符串中的替换字段被适当格式化后的参数所替代，格式化后的参数可以是字符串或数字类型：</p>
<pre><code><code>In [103]: &#39;{0}{1}&#39;.format(&#39;The price of this apple is $&#39;,10)
Out[103]: &#39;The price of this apple is $10&#39;</code></pre>
<p>如果需要在格式化字符串中包含花括号，就需要将其复写：</p>
<pre><code><code>In [104]: &#39;{0}{{{1}}}&#39;.format(&#39;The price of this apple is $&#39;,10)
Out[104]: &#39;The price of this apple is ${10}&#39;</code></pre>
<p>str.format()替换字段可以使用下面的任意一种语法格式：</p>
<ul>
<li>{field_name}</li>
<li>{field_name!conversion}</li>
<li>{field_name:format_specification}</li>
<li>{field_name!conversion:format_specification}</li>
</ul>
<p>字段名是一个与某个str.format()方法参数对应的整数，或者是方法的某个关键字参数的名称</p>
<pre><code><code>In [105]: &#39;{who} turned {age} this year.&#39;.format(who=&#39;she&#39;, age=19)
Out[105]: &#39;she turned 19 this year.&#39;
    
In [106]: &#39;The {who} was {0} last week&#39;.format(12, who=&#39;boy&#39;)
Out[106]: &#39;The boy was 12 last week&#39;</code></pre>
<p>字段名可以引用集合数据类型，例如：列表</p>
<pre><code><code>In [108]: &#39;Both of {0[0]} and {0[1]} are my friends.&#39;.format([&#39;Jenny&#39;,&#39;Danny&#39;])
Out[108]: &#39;Both of Jenny and Danny are my friends.&#39;</code></pre>
<p>从Python3.1开始，我们可以忽略字段名：</p>
<pre><code><code>In [109]: &#39;The {} was {} last week&#39;.format(&#39;boy&#39;,12)
Out[109]: &#39;The boy was 12 last week&#39;</code></pre>
<blockquote>
<p>本文由博客一文多发平台 <a href="https://openwrite.cn?from=article_bottom">OpenWrite</a> 发布！</p>
</blockquote>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>