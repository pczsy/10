<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修什么是反射？' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>什么是反射？</center></div><div class='banquan'>原文出处:本文由博客园博主hncboy提供。<br/>
原文连接:https://www.cnblogs.com/hncboy/p/12040072.html</div><br>
    <h1 class="md-end-block md-heading"><span class="md-plain md-expand">一、反射的定义</span></h1>
<p class="md-end-block md-p"><span class="md-plain">本文基于 JDK8，<span class=" md-link"><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/reflection/index.html"><span class="md-plain">Oracle官网</span></a><span class="md-plain">对反射的解释是</span></span></span></p>
<blockquote>
<p class="md-end-block md-p"><span class="md-plain">Reflection enables Java code to discover information about the fields, methods and constructors of loaded classes, and to use reflected fields, methods, and constructors to operate on their underlying counterparts, within security restrictions. The API accommodates applications that need access to either the public members of a target object (based on its runtime class) or the members declared by a given class. It also allows programs to suppress default reflective access control.</span></p>
<p class="md-end-block md-p"><span class="md-plain">反射使 Java 代码可以发现有关已加载类的字段，方法和构造函数的信息，并在安全性限制内使用反射对这些字段，方法和构造函数进行操作。</span></p>
</blockquote>
<p class="md-end-block md-p"><span class="md-plain">简而言之，指在 Java 程序运行时</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">给定的一个类（Class）对象，通过反射获取这个类（Class）对象的所有成员结构。</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">给定的一个具体的对象，能够动态地调用它的方法及对任意属性值进行获取和赋值。</span></p>
</li>
</ul>
<p class="md-end-block md-p"><span class="md-plain">这种动态获取类的内容，创建对象、以及动态调用对象的方法及操作属性的机制为反射。即使该对象的类型在编译期间是未知，该类的 .class 文件不存在，也可以通过反射直接创建对象。</span></p>
<p class="md-end-block md-p"><span class="md-plain">优势</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">增加程序的灵活性，避免将固有的逻辑程序写死到代码里</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">代码简洁，可读性强，可提高代码的复用率</span></p>
</li>
</ul>
<p class="md-end-block md-p"><span class="md-plain">劣势</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">相较直接调用，在量大的情景下反射性能下降</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">存在一些内部暴露和安全隐患</span></p>
</li>
</ul>
<h1 class="md-end-block md-heading"><span class="md-plain">二、反射的运用</span></h1>
<p class="md-end-block md-p"><span class="md-plain">反射的源 java.lang.Class，Class 类是 JDK 对我们自定义的类和内置类的统一描述，Class 类中存储了类运行时的类型信息。在 Class 类，可以获取如下图所示类的公共信息。Class 类与反射的联系密切相关，Class 类和 java.lang.reflect 一起对反射提供了支持。</span></p>
<p class="md-end-block md-p"><span class="md-plain"><span class="md-softbreak">&nbsp;<span class="md-image md-img-loaded" data-src="./images/什么是反射？0.png"><img style="display: block; margin-left: auto; margin-right: auto;" src="./images/什么是反射？0.png" alt="在这里插入图片描述" /></span></span></span></p>
<p class="md-end-block md-p"><span class="md-plain"><span class="md-softbreak"><span class="md-image md-img-loaded" data-src="./images/什么是反射？0.png"><span class="md-softbreak"><span class="md-plain">定义两个类 Boy 和 Person，Person 作为 Boy 的父类，作为接下演示这个部分反射用法的类。</span></span></span></span></span></p>
<p class="md-end-block md-p"><span class="md-plain">Person.class</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Person {
​
    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> String name;
​
    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> age;
​
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> talk() {
        System.out.println(name </span>+ "is talking"<span style="color: #000000;">);
    }
}</span></pre>
</div>
<p class="md-end-block md-p"><span class="md-plain">Boy.class</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> Boy <span style="color: #0000ff;">extends</span><span style="color: #000000;"> Person {
    
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> height;
​
    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> weight;
​
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span><span style="color: #000000;"> String description;
​
    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> Boy() {}
​
    </span><span style="color: #0000ff;">private</span> Boy(<span style="color: #0000ff;">int</span><span style="color: #000000;"> height) {
        </span><span style="color: #0000ff;">this</span>.height =<span style="color: #000000;"> height;
    }
​
    </span><span style="color: #0000ff;">public</span> Boy(<span style="color: #0000ff;">int</span> height, <span style="color: #0000ff;">int</span><span style="color: #000000;"> weight) {
        </span><span style="color: #0000ff;">this</span>.height =<span style="color: #000000;"> height;
        </span><span style="color: #0000ff;">this</span>.weight =<span style="color: #000000;"> weight;
    }
​
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> playBasketball() {
        System.out.println(</span>"play basketball！"<span style="color: #000000;">);
    }
​
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> playBall(String ballType) {
        System.out.println(</span>"play " + ballType + "！"<span style="color: #000000;">);
    }
​
    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> pickUpGirl() {
        System.out.println(</span>"pick up girl！"<span style="color: #000000;">);
    }
​
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> getWeight() {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> weight;
    }
​
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> getHeight() {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> height;
    }
}</span></pre>
</div>
<h2 class="md-end-block md-heading"><span class="md-plain">2.1 获取 Class 对象实例的四种方法</span></h2>
<div class="cnblogs_code">
<pre><code>Class&lt;Boy&gt; clazz = Boy.<span style="color: #0000ff;">class</span>; <span style="color: #008000;">//</span><span style="color: #008000;"> 通过类的 class 属性</span>
Class&lt;?&gt; clazz2 = <span style="color: #0000ff;">new</span> Boy().getClass(); <span style="color: #008000;">//</span><span style="color: #008000;"> 通过运行时类对象的 getClass 方法获取</span>
Class&lt;?&gt; clazz3 = Class.forName("com.hncboy.corejava.reflection.Boy"); <span style="color: #008000;">//</span><span style="color: #008000;"> 通过类的全限定名获取</span>
Class&lt;?&gt; clazz4 = Main.<span style="color: #0000ff;">class</span>.getClassLoader().loadClass("com.hncboy.corejava.reflection.Boy"); <span style="color: #008000;">//</span><span style="color: #008000;"> 通过类加载器获取 </span></pre>
</div>
<h2 class="md-end-block md-heading"><span class="md-plain">2.2 反射获取类的基本信息</span></h2>
<p class="md-end-block md-p"><span class="md-plain">一个类的基本信息包含了修饰符，class 关键字，类名，父类，接口等信息，常用方法如下：</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">int</span> modifier = clazz.getModifiers(); <span style="color: #008000;">//</span><span style="color: #008000;"> 获取类的修饰符</span>
Package pack = clazz.getPackage(); <span style="color: #008000;">//</span><span style="color: #008000;"> 获取类的包名</span>
String fullClassName = clazz.getName(); <span style="color: #008000;">//</span><span style="color: #008000;"> 获取类的全路径名称</span>
String simpleClassName = clazz.getSimpleName(); <span style="color: #008000;">//</span><span style="color: #008000;"> 获取类的简单名称</span>
ClassLoader classLoader = clazz.getClassLoader(); <span style="color: #008000;">//</span><span style="color: #008000;"> 获取类的类加载器</span>
Class&lt;?&gt;[] interfacesClasses = clazz.getInterfaces(); <span style="color: #008000;">//</span><span style="color: #008000;"> 获取类实现的接口列表</span>
Class&lt;?&gt; superClass = clazz.getSuperclass(); <span style="color: #008000;">//</span><span style="color: #008000;"> 获取类的父类</span>
Annotation[] annotations = clazz.getAnnotations(); <span style="color: #008000;">//</span><span style="color: #008000;"> 获取类的注解列表</span></pre>
</div>
<p class="md-end-block md-p"><span class="md-plain">通过一个测试类，测试以上方法：</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Test {
​
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        Class</span>&lt;Boy&gt; clazz = Boy.<span style="color: #0000ff;">class</span><span style="color: #000000;">;
​
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 获取类的修饰符，如果有多个修饰符，取相加后的结果</span>
        <span style="color: #0000ff;">int</span> modifiers =<span style="color: #000000;"> clazz.getModifiers();
        System.out.println(</span>"modifiers: " +<span style="color: #000000;"> modifiers);
        System.out.println(</span>"modifiers toString: " +<span style="color: #000000;"> Modifier.toString(modifiers));
​
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 获取类的包名</span>
        Package pack =<span style="color: #000000;"> clazz.getPackage();
        System.out.println(</span>"package: " +<span style="color: #000000;"> pack);
​
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 获取类的全路径名称：包名 + 类名</span>
        String fullClassName =<span style="color: #000000;"> clazz.getName();
        System.out.println(</span>"fullClassName: " +<span style="color: #000000;"> fullClassName);
​
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 获取类的简单名称：只有类名</span>
        String simpleClassName =<span style="color: #000000;"> clazz.getSimpleName();
        System.out.println(</span>"simpleClassName: " +<span style="color: #000000;"> simpleClassName);
​
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 获取类的类加载器</span>
        ClassLoader classLoader =<span style="color: #000000;"> clazz.getClassLoader();
        System.out.println(</span>"classLoader: " +<span style="color: #000000;"> classLoader);
​
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 获取类实现的接口列表</span>
        Class&lt;?&gt;[] interfacesClasses =<span style="color: #000000;"> clazz.getInterfaces();
        System.out.println(</span>"interfacesClasses: " +<span style="color: #000000;"> Arrays.toString(interfacesClasses));
​
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 获取类的父类</span>
        Class&lt;?&gt; superClass =<span style="color: #000000;"> clazz.getSuperclass();
        System.out.println(</span>"superClass: " +<span style="color: #000000;"> superClass);
​
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 获取类的注解列表</span>
        Annotation[] annotations =<span style="color: #000000;"> clazz.getAnnotations();
        System.out.println(</span>"annotations: " +<span style="color: #000000;"> Arrays.toString(annotations));
    }
}</span></pre>
</div>
<p class="md-end-block md-p"><span class="md-plain">运行输出结果如下所示：</span></p>
<div class="cnblogs_code">
<pre><code>modifiers: 1<span style="color: #000000;">
modifiers toString: </span><span style="color: #0000ff;">public</span>
<span style="color: #0000ff;">package</span>: <span style="color: #0000ff;">package</span><span style="color: #000000;"> com.hncboy.corejava.reflection
fullClassName: com.hncboy.corejava.reflection.Boy
simpleClassName: Boy
classLoader: sun.misc.Launcher$AppClassLoader@18b4aac2
interfacesClasses: []
superClass: </span><span style="color: #0000ff;">class</span><span style="color: #000000;"> com.hncboy.corejava.reflection.Person
annotations: []</span></pre>
</div>
<p class="md-end-block md-p"><span class="md-plain">其中 getModifiers 以整数形式编码返回此类或接口的 Java 语言修饰符。通过查 <span class=" md-link"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Modifier.html"><span class="md-plain">java.lang.reflect.Modifier</span></a><span class="md-plain"> 的 API 可知，返回结果有如下类型，所有修饰符的值都为二进制运算的结果，通过位运算判断修饰符是最快的。<span class="md-softbreak"> <span class="md-image md-img-loaded" data-src="./images/什么是反射？1.png"><img src="./images/什么是反射？1.png" alt="在这里插入图片描述" /></span></span></span></span></span></p>
<h2 class="md-end-block md-heading"><span class="md-plain">2.2 反射对字段的操作 </span></h2>
<p class="md-end-block md-p"><span class="md-plain">字段的信息存储在 Field 类中， Field 提供有关类或接口的单个字段的信息，以及对它们的动态访问，并且可以对变量进行修改。反射字段可以是类（静态）字段或实例字段。常用方法如下：</span></p>
<div class="cnblogs_code">
<pre><code>Field[] fields = clazz.getFields(); <span style="color: #008000;">//</span><span style="color: #008000;"> 获取类中所有的公有字段</span>
Field[] declaredFields = clazz.getDeclaredFields(); <span style="color: #008000;">//</span><span style="color: #008000;"> 获取类中定义的字段</span>
Field nameField = clazz.getField("name"); <span style="color: #008000;">//</span><span style="color: #008000;"> 获取指定名称的公有字段</span>
Field declaredField = clazz.getDeclaredField("likeDesc"); <span style="color: #008000;">//</span><span style="color: #008000;"> 获取指定名称类中定义的字段</span>
<span style="color: #0000ff;">int</span> modifiersField = likeDescField.getModifiers(); <span style="color: #008000;">//</span><span style="color: #008000;"> 获取字段的修饰</span>
nameField.setAccessible(<span style="color: #0000ff;">true</span>); <span style="color: #008000;">//</span><span style="color: #008000;"> 指定字段强制访问</span>
nameField.set(person, "hncboy"); <span style="color: #008000;">//</span><span style="color: #008000;"> 成员字段赋值（需指定对象）</span>
descriptionField.set(<span style="color: #0000ff;">null</span>, "hncboy"); <span style="color: #008000;">//</span><span style="color: #008000;"> 静态字段赋值</span></pre>
</div>
<p class="md-end-block md-p"><span class="md-plain">通过一个测试类，测试以上方法：</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Test {
​
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> main(String[] args) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> Exception {
        Class</span>&lt;Boy&gt; clazz = Boy.<span style="color: #0000ff;">class</span><span style="color: #000000;">;
​
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 获取类中所有的公有字段，包含继承的</span>
        Field[] fields =<span style="color: #000000;"> clazz.getFields();
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (Field field : fields) {
            System.out.println(field);
        }
​
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 获取指定名称的公有字段，包含继承的</span>
        Field nameField = clazz.getField("name"<span style="color: #000000;">);
        System.out.println(nameField);
​
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 获取本类中定义的所有字段，不包含继承的，包含私有的</span>
        Field[] declaredFields =<span style="color: #000000;"> clazz.getDeclaredFields();
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (Field field : declaredFields) {
            System.out.println(field);
        }
​
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 获取本类中指定名称类中定义的字段</span>
        Field weightField = clazz.getDeclaredField("weight"<span style="color: #000000;">);
        System.out.println(weightField.getModifiers());
​
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 给指定字段赋值（需指定对象）</span>
        Boy boy =<span style="color: #000000;"> clazz.newInstance();
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 将该字段设置为强制访问</span>
        weightField.setAccessible(<span style="color: #0000ff;">true</span><span style="color: #000000;">);
        weightField.set(boy, </span>120<span style="color: #000000;">);
        System.out.println(boy.getWeight());
​
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 静态字段赋值，静态字段不需要指定对象</span>
        Field descField = clazz.getField("description"<span style="color: #000000;">);
        descField.set(</span><span style="color: #0000ff;">null</span>, "静态属性"<span style="color: #000000;">);
        System.out.println(Boy.description);
    }
}</span></pre>
</div>
<p class="md-end-block md-p"><span class="md-plain">运行输出结果如下所示：</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> com.hncboy.corejava.reflection.Boy.height
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span><span style="color: #000000;"> java.lang.String com.hncboy.corejava.reflection.Boy.description
</span><span style="color: #0000ff;">public</span><span style="color: #000000;"> java.lang.String com.hncboy.corejava.reflection.Person.name
</span><span style="color: #0000ff;">public</span><span style="color: #000000;"> java.lang.String com.hncboy.corejava.reflection.Person.name
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> com.hncboy.corejava.reflection.Boy.height
</span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> com.hncboy.corejava.reflection.Boy.weight
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span><span style="color: #000000;"> java.lang.String com.hncboy.corejava.reflection.Boy.description
</span>2
120<span style="color: #000000;">
静态属性</span></pre>
</div>
<p class="md-end-block md-p"><span class="md-plain">在直接访问私有 private 变量 weight 时，会报如下的错误，不能访问 Boy 类的私有变量。通过 Field 继承的 java.lang.reflect.AccessibleObject 类中的 setAccessible(boolean flag) 可以开启权限，setAccessible 方法通过调用 native setAccessible0 方法取消 Java 语言访问检查权限。</span></p>
<div class="cnblogs_code">
<pre><code>Exception in thread "main" java.lang.IllegalAccessException: Class com.hncboy.corejava.reflection.Test can not access a member of <span style="color: #0000ff;">class</span> com.hncboy.corejava.reflection.Boy with modifiers "private"<span style="color: #000000;">
    at sun.reflect.Reflection.ensureMemberAccess(Reflection.java:</span>102<span style="color: #000000;">)
    at java.lang.reflect.AccessibleObject.slowCheckMemberAccess(AccessibleObject.java:</span>296<span style="color: #000000;">)
    at java.lang.reflect.AccessibleObject.checkAccess(AccessibleObject.java:</span>288<span style="color: #000000;">)
    at java.lang.reflect.Field.set(Field.java:</span>761<span style="color: #000000;">)
    at com.hncboy.corejava.reflection.Test.main(Test.java:</span>41<span style="color: #000000;">)
 </span></pre>
</div>
<h2 class="md-end-block md-heading"><span class="md-plain">2.3 反射对方法的操作</span></h2>
<p class="md-end-block md-p"><span class="md-plain">方法的信息存储在 Method 类中， Method 提供有关类或接口上单个方法<span><em>的信息，以及对单个方法</em><span class="md-plain">的访问。反射方法可以是类方法或实例方法（包括抽象方法）。常用方法如下：</span></span></span></p>
<div class="cnblogs_code">
<pre><code>Method[] methods = clazz.getMethods(); <span style="color: #008000;">//</span><span style="color: #008000;"> 获取类中所有的公有方法</span>
Method[] declaredMethods = clazz.getDeclaredMethods(); <span style="color: #008000;">//</span><span style="color: #008000;"> 获取本类的所有方法</span>
Method talkMethod = clazz.getMethod("talk", String.<span style="color: #0000ff;">class</span>); <span style="color: #008000;">//</span><span style="color: #008000;"> 获取类中指定名称和参数的公有方法</span>
Method pugMethod = clazz.getDeclaredMethod("pickUpGirls"); <span style="color: #008000;">//</span><span style="color: #008000;"> 获取本类中定义的指定名称和参数的方法</span>
<span style="color: #0000ff;">int</span> modifiers = pugMethod.getModifiers(); <span style="color: #008000;">//</span><span style="color: #008000;"> 获取方法的修饰符</span>
talkMethod.invoke(boy, "I tell you"); <span style="color: #008000;">//</span><span style="color: #008000;"> 指定对象进行成员方法的调用</span>
pugMethod.setAccessible(<span style="color: #0000ff;">true</span>); <span style="color: #008000;">//</span><span style="color: #008000;"> 指定方法的强制访问</span>
pickUpGirlsMethod.invoke(<span style="color: #0000ff;">null</span>); <span style="color: #008000;">//</span><span style="color: #008000;"> 指定静态方法的调用</span></pre>
</div>
<p class="md-end-block md-p"><span class="md-plain">通过一个测试类，测试以上方法：</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Test {
​
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> main(String[] args) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> Exception {
        Class</span>&lt;Boy&gt; clazz = Boy.<span style="color: #0000ff;">class</span><span style="color: #000000;">;
​
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 获取类中定义的方法，包含继承的(Object)</span>
        Method[] methods =<span style="color: #000000;"> clazz.getMethods();
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (Method method : methods) {
            System.out.println(method);
        }
​
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 获取类中指定的方法（无参）</span>
        Method talkMethod = clazz.getMethod("talk"<span style="color: #000000;">);
        System.out.println(talkMethod.getName());
        
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 获取类中指定的方法（有参）</span>
        Method playMethod = clazz.getMethod("playBall", String.<span style="color: #0000ff;">class</span><span style="color: #000000;">);
        System.out.println(playMethod.getName());
​
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 获取本类中的所有方法，不包含继承，包含私有的</span>
        Method[] declaredMethods =<span style="color: #000000;"> clazz.getDeclaredMethods();
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (Method method : declaredMethods) {
            System.out.println(method);
        }
​
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 获取本类中特定的的方法</span>
        Method declaredMethod = clazz.getDeclaredMethod("pickUpGirl"<span style="color: #000000;">);
        System.out.println(declaredMethod.getName());
​
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 底层是基于构造器的创建无参构造器</span>
        Boy boy =<span style="color: #000000;"> clazz.newInstance();
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 调用公有有参方法</span>
        playMethod.invoke(boy, "足球"<span style="color: #000000;">);
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 调用私有无参方法，需要设置强制访问</span>
        declaredMethod.setAccessible(<span style="color: #0000ff;">true</span><span style="color: #000000;">);
        declaredMethod.invoke(boy);
​
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 调用静态方法</span>
        Method playBasketBallMethod = clazz.getDeclaredMethod("playBasketball"<span style="color: #000000;">);
        playBasketBallMethod.invoke(</span><span style="color: #0000ff;">null</span><span style="color: #000000;">);
    }
}</span></pre>
</div>
<p class="md-end-block md-p"><span class="md-plain">运行输出结果如下所示：</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> com.hncboy.corejava.reflection.Boy.playBasketball()
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> com.hncboy.corejava.reflection.Boy.getWeight()
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> com.hncboy.corejava.reflection.Boy.getHeight()
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> com.hncboy.corejava.reflection.Boy.playBall(java.lang.String)
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> com.hncboy.corejava.reflection.Person.talk()
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">void</span> java.lang.Object.wait() <span style="color: #0000ff;">throws</span><span style="color: #000000;"> java.lang.InterruptedException
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">void</span> java.lang.Object.wait(<span style="color: #0000ff;">long</span>,<span style="color: #0000ff;">int</span>) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> java.lang.InterruptedException
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">native</span> <span style="color: #0000ff;">void</span> java.lang.Object.wait(<span style="color: #0000ff;">long</span>) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> java.lang.InterruptedException
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> java.lang.Object.equals(java.lang.Object)
</span><span style="color: #0000ff;">public</span><span style="color: #000000;"> java.lang.String java.lang.Object.toString()
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">native</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> java.lang.Object.hashCode()
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">native</span><span style="color: #000000;"> java.lang.Class java.lang.Object.getClass()
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">native</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> java.lang.Object.notify()
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">native</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> java.lang.Object.notifyAll()
talk
playBall
</span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> com.hncboy.corejava.reflection.Boy.pickUpGirl()
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> com.hncboy.corejava.reflection.Boy.playBasketball()
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> com.hncboy.corejava.reflection.Boy.getWeight()
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> com.hncboy.corejava.reflection.Boy.getHeight()
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> com.hncboy.corejava.reflection.Boy.playBall(java.lang.String)
pickUpGirl
play 足球！
pick up girl！
play basketball！</span></pre>
</div>
<p class="md-end-block md-p"><span class="md-plain">在通过 getMethods 获取所有父类的公有方法，Boy 类的父类包含 Person 类和 Object 类，所以总共输出 14 个公有方法。getMethod 或 getDeclaredMethod 方法获取指定方法名无参的方法时，参数可以省略，直接传入方法名，获取带参数的方法时，如果类型错误会报 NoSuchMethodException 异常，如下所示。通过 method 的 invoke 方法传入实例对象调用实例方法，调用静态方法传入 null 即可。</span></p>
<div class="cnblogs_code">
<pre><code>Exception in thread "main" java.lang.NoSuchMethodException: com.hncboy.corejava.reflection.Boy.playBall(<span style="color: #0000ff;">int</span><span style="color: #000000;">)
    at java.lang.Class.getMethod(Class.java:</span>1786<span style="color: #000000;">)
    at com.hncboy.corejava.reflection.Test.main(Test.java:</span>29)</pre>
</div>
<h2 class="md-end-block md-heading"><span class="md-plain">2.4 反射对构造器的操作</span></h2>
<p class="md-end-block md-p"><span class="md-plain">构造器的信息存储在 Constructor 类中， Constructor 提供有关类的单个构造函数的信息，以及对类的访问。常用方法如下：</span></p>
<div class="cnblogs_code">
<pre><code>Constructor&lt;?&gt;[] constructors = clazz.getConstructors(); <span style="color: #008000;">//</span><span style="color: #008000;"> 获取类中所有的公有构造器</span>
Constructor&lt;?&gt;[] declaredConstructors = clazz.getDeclaredConstructors(); <span style="color: #008000;">//</span><span style="color: #008000;"> 获取类中所有的构造器</span>
Constructor&lt;?&gt; declaredConstructor = clazz.getDeclaredConstructor(); <span style="color: #008000;">//</span><span style="color: #008000;"> 获取类中无参的构造器</span>
Constructor&lt;?&gt; constructor = clazz.getDeclaredConstructor(String.<span style="color: #0000ff;">class</span>, String.<span style="color: #0000ff;">class</span>); <span style="color: #008000;">//</span><span style="color: #008000;"> 获取类中有参构造器</span>
<span style="color: #0000ff;">int</span> modifiers = constructor.getModifiers(); <span style="color: #008000;">//</span><span style="color: #008000;"> 获取构造器的修饰符</span>
declaredConstructor.newInstance(); <span style="color: #008000;">//</span><span style="color: #008000;"> 构造器实例对象</span>
declaredConstructor.setAccessible(<span style="color: #0000ff;">true</span>); <span style="color: #008000;">//</span><span style="color: #008000;"> 指定构造器的强制访问</span>
constructor.newInstance("hncboy"); <span style="color: #008000;">//</span><span style="color: #008000;"> 有参构造调用</span>
clazz.newInstance(); <span style="color: #008000;">//</span><span style="color: #008000;"> 直接调用默认无参构造</span></pre>
</div>
<p class="md-end-block md-p"><span class="md-plain">通过一个测试类，测试以上方法：</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Test {
​
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> main(String[] args) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> Exception {
        Class</span>&lt;Boy&gt; clazz = Boy.<span style="color: #0000ff;">class</span><span style="color: #000000;">;
​
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 获取类中所有的公有构造器</span>
        Constructor&lt;?&gt;[] constructors =<span style="color: #000000;"> clazz.getConstructors();
        </span><span style="color: #0000ff;">for</span> (Constructor&lt;?&gt;<span style="color: #000000;"> constructor : constructors) {
            System.out.println(constructor);
        }
​
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 获取类中所有的构造器，包含私有的</span>
        Constructor&lt;?&gt;[] declaredConstructors =<span style="color: #000000;"> clazz.getDeclaredConstructors();
        </span><span style="color: #0000ff;">for</span> (Constructor&lt;?&gt;<span style="color: #000000;"> constructor : declaredConstructors) {
            System.out.println(constructor);
        }
​
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 获取类中无参的构造器</span>
        Constructor&lt;?&gt; noParamsConstructor =<span style="color: #000000;"> clazz.getDeclaredConstructor();
        System.out.println(noParamsConstructor);
​
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 获取类中指定参数构造器</span>
        Constructor&lt;?&gt; constructor1 = clazz.getDeclaredConstructor(<span style="color: #0000ff;">int</span>.<span style="color: #0000ff;">class</span><span style="color: #000000;">);
        Constructor</span>&lt;?&gt; constructor2 = clazz.getDeclaredConstructor(<span style="color: #0000ff;">int</span>.<span style="color: #0000ff;">class</span>, <span style="color: #0000ff;">int</span>.<span style="color: #0000ff;">class</span><span style="color: #000000;">);
        System.out.println(noParamsConstructor.getModifiers());
        System.out.println(constructor1.getModifiers());
        System.out.println(constructor2.getModifiers());
​
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 调用构造器</span>
        Boy boy =<span style="color: #000000;"> (Boy) noParamsConstructor.newInstance();
        System.out.println(boy);
        constructor1.setAccessible(</span><span style="color: #0000ff;">true</span><span style="color: #000000;">);
        boy </span>= (Boy) constructor1.newInstance(177<span style="color: #000000;">);
        System.out.println(boy.getHeight());
    }
}</span></pre>
</div>
<p class="md-end-block md-p"><span class="md-plain">运行输出结果如下所示：</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> com.hncboy.corejava.reflection.Boy(<span style="color: #0000ff;">int</span>,<span style="color: #0000ff;">int</span><span style="color: #000000;">)
</span><span style="color: #0000ff;">public</span><span style="color: #000000;"> com.hncboy.corejava.reflection.Boy()
</span><span style="color: #0000ff;">public</span> com.hncboy.corejava.reflection.Boy(<span style="color: #0000ff;">int</span>,<span style="color: #0000ff;">int</span><span style="color: #000000;">)
</span><span style="color: #0000ff;">private</span> com.hncboy.corejava.reflection.Boy(<span style="color: #0000ff;">int</span><span style="color: #000000;">)
</span><span style="color: #0000ff;">public</span><span style="color: #000000;"> com.hncboy.corejava.reflection.Boy()
</span><span style="color: #0000ff;">public</span><span style="color: #000000;"> com.hncboy.corejava.reflection.Boy()
</span>1
2
1<span style="color: #000000;">
com.hncboy.corejava.reflection.Boy@4b67cf4d
</span>177</pre>
</div>
<p class="md-end-block md-p"><span class="md-plain">getConstructors 方法获取类中的所有公有构造器，构造器不能继承，所有只能获取本类中的。getDeclaredConstructors 获取本类的所有构造器，包含私有的。在获取特定参数构造器时，传入的要与构造器的参数一样，如 int.class 不能写成 Integer.class，因为自动拆箱是在编译过程中的，而反射是在运行期间的。</span></p>
<p class="md-end-block md-p"><span class="md-plain">通过反射，可使用 Class.newInstance() 或 Constructor.newInstance() 两种方式创建对象。Class 类下的 newInstance 是弱类型，只能调用无参的构造方法，如果没有默认构造方法，会抛出 InstantiationException 实例化异常，通过源码可知，该方法的本质上是 return tmpConstructor.newInstance((Object[])null); ，也是调用 Constructor 的 newInstance 方法 。 而 Constructor 类下的 newInstance 可以调用任意参数的构造器。</span></p>
<h1 class="md-end-block md-heading"><span class="md-plain">三、反射破坏单例</span></h1>
<p class="md-end-block md-p"><span class="md-plain">单例模式</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">私有化构造函数</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">全局唯一的公有访问点</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">对外提供获取实例的静态方法</span></p>
</li>
</ul>
<h2 class="md-end-block md-heading"><span class="md-plain">3.1 定义饿汉式 Hungry</span></h2>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Hungry {

    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> Hungry INSTANCE = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Hungry();

    </span><span style="color: #0000ff;">private</span><span style="color: #000000;"> Hungry() {}

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span><span style="color: #000000;"> Hungry getInstance() {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> INSTANCE;
    }
}</span></pre>
</div>
<h2 class="md-end-block md-heading"><span class="md-plain">3.2 定义懒汉式 Lazy</span></h2>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Lazy {
​
    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span><span style="color: #000000;"> Lazy instance;
​
    </span><span style="color: #0000ff;">private</span><span style="color: #000000;"> Lazy() {}
​
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span><span style="color: #000000;"> Lazy getInstance() {
        </span><span style="color: #0000ff;">if</span> (instance == <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">synchronized</span> (Lazy.<span style="color: #0000ff;">class</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">if</span> (instance == <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
                    instance </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Lazy();
                }
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> instance;
    }
}</span></pre>
</div>
<h2 class="md-end-block md-heading"><span class="md-plain">3.3 定义 SingletonDestroyer</span></h2>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> SingletonDestroyer {
​
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> main(String[] args) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> Exception {
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 破坏懒汉模式</span>
        Lazy lazyInstance =<span style="color: #000000;"> Lazy.getInstance();
        Constructor</span>&lt;Lazy&gt; lazyConstructor = Lazy.<span style="color: #0000ff;">class</span><span style="color: #000000;">.getDeclaredConstructor();
        lazyConstructor.setAccessible(</span><span style="color: #0000ff;">true</span><span style="color: #000000;">);
        Lazy lazyInstanceReflect </span>=<span style="color: #000000;"> lazyConstructor.newInstance();
        System.out.println(lazyInstance);
        System.out.println(lazyInstanceReflect);
​
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 破坏饿汉模式</span>
        Hungry hungryInstance =<span style="color: #000000;"> Hungry.getInstance();
        Constructor</span>&lt;Hungry&gt; hungryConstructor = Hungry.<span style="color: #0000ff;">class</span><span style="color: #000000;">.getDeclaredConstructor();
        hungryConstructor.setAccessible(</span><span style="color: #0000ff;">true</span><span style="color: #000000;">);
        Hungry hungryInstanceReflect </span>=<span style="color: #000000;"> hungryConstructor.newInstance();
        System.out.println(hungryInstance);
        System.out.println(hungryInstanceReflect);
    }
}</span></pre>
</div>
<p class="md-end-block md-p"><span class="md-plain">运行结果如下，通过反射机制可以破环单例模式，将私有化的构造器通过强制访问创建对象。</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #000000;">com.hncboy.corejava.reflection.Lazy@4b67cf4d
com.hncboy.corejava.reflection.Lazy@7ea987ac
com.hncboy.corejava.reflection.Hungry@12a3a380
com.hncboy.corejava.reflection.Hungry@29453f44</span></pre>
</div>
<h1 class="md-end-block md-heading"><span class="md-plain">四、反射实现简单 Spring IOC Bean 实例创建</span></h1>
<p class="md-end-block md-p"><span class="md-plain">IOC(Inversion of Control) 控制反转，他是一种设计思想，并非实际的技术，最核心的思想就是将预先设计的对象实例创建的控制权交给程序(IOC 容器)。 IOC 容器本质上是一个 K-V 结构的 Map。IOC 的实现原理就是工厂模式加反射机制。</span></p>
<p class="md-end-block md-p"><span class="md-plain">通过 <span class=" md-link"><a href="https://docs.spring.io/spring/docs/5.2.2.RELEASE/spring-framework-reference/core.html#beans-factory-class"><span class="md-plain">Spring</span></a><span class="md-plain"> 文档可查看 Bean 实例的三种创建方式：</span></span></span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<h5 class="md-end-block md-heading"><span class="md-plain">Instantiation with a Constructor 通过构造器实例化</span></h5>
</li>
<li class="md-list-item">
<h5 class="md-end-block md-heading"><span class="md-plain">Instantiation by Using an Instance Factory Method 通过静态工厂实例化</span></h5>
</li>
<li class="md-list-item">
<h5 class="md-end-block md-heading"><span class="md-plain">Instantiation by Using an Instance Factory Method 通过实例工厂实例化</span></h5>
</li>
</ul>
<p class="md-end-block md-p"><span class="md-plain">步骤如下：</span></p>
<h2 class="md-end-block md-heading"><span class="md-plain">4.1 添加三个类 A，B，C</span></h2>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> A {

    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> A() {
        System.out.println(</span>"调用 A 的无参构造器"<span style="color: #000000;">);
    }

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span><span style="color: #000000;"> B createBInstance() {
        System.out.println(</span>"调用 A 的静态方法 createBInstance"<span style="color: #000000;">);
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> B();
    }

    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> C createCInstance() {
        System.out.println(</span>"调用 A 的实例方法 createCInstance"<span style="color: #000000;">);
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> C();
    }
}

</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> B {}
</span><span style="color: #0000ff;">class</span> C {}</pre>
</div>
<h2 class="md-end-block md-heading"><span class="md-plain">4.2 添加 spring-ioc.xml</span></h2>
<p class="md-end-block md-p"><span class="md-plain">通过模拟该配置文件来进行对象的创建</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">&lt;?</span><span style="color: #ff00ff;">xml version="1.0" encoding="UTF-8"</span><span style="color: #0000ff;">?&gt;</span>
<span style="color: #0000ff;">&lt;</span><span style="color: #800000;">beans </span><span style="color: #ff0000;">xmlns</span><span style="color: #0000ff;">="http://www.springframework.org/schema/beans"</span><span style="color: #ff0000;">
       xmlns:xsi</span><span style="color: #0000ff;">="http://www.w3.org/2001/XMLSchema-instance"</span><span style="color: #ff0000;">
       xsi:schemaLocation</span><span style="color: #0000ff;">="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span><span style="color: #0000ff;">&gt;</span>

    <span style="color: #008000;">&lt;!--</span><span style="color: #008000;"> 创建方式1：无参构造器创建 A 对象</span><span style="color: #008000;">--&gt;</span>
    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">bean </span><span style="color: #ff0000;">id</span><span style="color: #0000ff;">="a"</span><span style="color: #ff0000;"> class</span><span style="color: #0000ff;">="com.hncboy.corejava.reflection.A"</span><span style="color: #0000ff;">/&gt;</span>

    <span style="color: #008000;">&lt;!--</span><span style="color: #008000;"> 创建方式2：静态工厂创建，调用 A 的 createBObj 方法来创建名为 b 的对象放入容器 </span><span style="color: #008000;">--&gt;</span>
    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">bean </span><span style="color: #ff0000;">id</span><span style="color: #0000ff;">="b"</span><span style="color: #ff0000;"> class</span><span style="color: #0000ff;">="com.hncboy.corejava.reflection.A"</span><span style="color: #ff0000;"> factory-method</span><span style="color: #0000ff;">="createBInstance"</span><span style="color: #0000ff;">/&gt;</span>

    <span style="color: #008000;">&lt;!--</span><span style="color: #008000;"> 创建方式3：实例工厂创建，调用实例 a 的 createBObj 方法来创建名为 c 的对象放入容器 </span><span style="color: #008000;">--&gt;</span>
    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">bean </span><span style="color: #ff0000;">id</span><span style="color: #0000ff;">="c"</span><span style="color: #ff0000;"> factory-bean</span><span style="color: #0000ff;">="a"</span><span style="color: #ff0000;"> factory-method</span><span style="color: #0000ff;">="createCInstance"</span><span style="color: #0000ff;">/&gt;</span>

<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">beans</span><span style="color: #0000ff;">&gt;</span></pre>
</div>
<h2 class="md-end-block md-heading"><span class="md-plain">4.3 添加 BeanConfig</span></h2>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">/**</span><span style="color: #008000;">
 * 存放 bean 的基本信息
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> BeanConfig {

    </span><span style="color: #0000ff;">private</span><span style="color: #000000;"> String id;
    </span><span style="color: #0000ff;">private</span><span style="color: #000000;"> String clazz;
    </span><span style="color: #0000ff;">private</span><span style="color: #000000;"> String factoryMethod;
    </span><span style="color: #0000ff;">private</span><span style="color: #000000;"> String factoryBean;
    
    </span><span style="color: #008000;">/*</span><span style="color: #008000;"> getter、setter 省略 </span><span style="color: #008000;">*/</span><span style="color: #000000;">
}</span></pre>
</div>
<h2 class="md-end-block md-heading"><span class="md-plain">4.4 添加 IOCContainer</span></h2>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">/**</span><span style="color: #008000;">
 * 定义 map 存放 map
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> IOCContainer {

    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span> Map&lt;String, Object&gt; container = <span style="color: #0000ff;">new</span> HashMap&lt;&gt;<span style="color: #000000;">();

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> putBean(String id, Object object) {
        container.put(id, object);
    }

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span><span style="color: #000000;"> Object getBean(String id) {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> container.get(id);
    }
}</span></pre>
</div>
<h2 class="md-end-block md-heading"><span class="md-plain">4.5 添加 Init </span></h2>
<p class="md-end-block md-p"><span class="md-plain">创建方式1：无参构造器创建。bean 的内容包括 id 和 clazz</span></p>
<p class="md-end-block md-p"><span class="md-plain">创建方式2：静态工厂创建。bean 的内容包括 id 和 factory-method</span></p>
<p class="md-end-block md-p"><span class="md-plain">创建方式3：实例工厂创建。bean 的内容包括 id，factory-bean 和 factory-method</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Init {
​
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> main(String[] args) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> Exception {
        List</span>&lt;BeanConfig&gt; beanConfigs =<span style="color: #000000;"> parseXmlToBeanConfig();
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 将解析的 BeanConfig 进行实例化</span>
        <span style="color: #0000ff;">for</span><span style="color: #000000;"> (BeanConfig beanConfig : beanConfigs) {
            </span><span style="color: #0000ff;">if</span> (beanConfig.getClazz() != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
                Class</span>&lt;?&gt; clazz =<span style="color: #000000;"> Class.forName(beanConfig.getClazz());
                </span><span style="color: #0000ff;">if</span> (beanConfig.getFactoryMethod() != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
                    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 创建方式2：静态工厂创建</span>
                    Method method =<span style="color: #000000;"> clazz.getDeclaredMethod(beanConfig.getFactoryMethod());
                    IOCContainer.putBean(beanConfig.getId(), method.invoke(</span><span style="color: #0000ff;">null</span><span style="color: #000000;">));
                } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 创建方式1：无参构造器创建</span>
<span style="color: #000000;">                    IOCContainer.putBean(beanConfig.getId(), clazz.newInstance());
                }
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (beanConfig.getId() != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
                </span><span style="color: #008000;">//</span><span style="color: #008000;"> 创建方式3：实例工厂创建</span>
                Object object =<span style="color: #000000;"> IOCContainer.getBean(beanConfig.getFactoryBean());
                Method method </span>=<span style="color: #000000;"> object.getClass().getDeclaredMethod(beanConfig.getFactoryMethod());
                IOCContainer.putBean(beanConfig.getId(), method.invoke(object));
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                System.out.println(</span>"缺少配置，无法创建对象！"<span style="color: #000000;">);
            }
        }
    }
​
    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 模拟解析 XML 中的 bean
     *
     * </span><span style="color: #808080;">@return</span>
     <span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span> List&lt;BeanConfig&gt;<span style="color: #000000;"> parseXmlToBeanConfig() {
        List</span>&lt;BeanConfig&gt; beanConfigs = <span style="color: #0000ff;">new</span> ArrayList&lt;&gt;<span style="color: #000000;">();
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 模拟无参构造器创建对象</span>
        BeanConfig beanConfig1 = <span style="color: #0000ff;">new</span><span style="color: #000000;"> BeanConfig();
        beanConfig1.setId(</span>"a"<span style="color: #000000;">);
        beanConfig1.setClazz(</span>"com.hncboy.corejava.reflection.A"<span style="color: #000000;">);
        beanConfigs.add(beanConfig1);
​
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 模拟静态工厂创建对象</span>
        BeanConfig beanConfig2 = <span style="color: #0000ff;">new</span><span style="color: #000000;"> BeanConfig();
        beanConfig2.setId(</span>"b"<span style="color: #000000;">);
        beanConfig2.setClazz(</span>"com.hncboy.corejava.reflection.A"<span style="color: #000000;">);
        beanConfig2.setFactoryMethod(</span>"createBInstance"<span style="color: #000000;">);
        beanConfigs.add(beanConfig2);
​
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 模拟实例工厂创建对象</span>
        BeanConfig beanConfig3 = <span style="color: #0000ff;">new</span><span style="color: #000000;"> BeanConfig();
        beanConfig3.setId(</span>"c"<span style="color: #000000;">);
        beanConfig3.setFactoryBean(</span>"a"<span style="color: #000000;">);
        beanConfig3.setFactoryMethod(</span>"createCInstance"<span style="color: #000000;">);
        beanConfigs.add(beanConfig3);
​
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> beanConfigs;
    }
}</span></pre>
</div>
<p class="md-end-block md-p"><span class="md-plain">运行结果如下：</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #000000;">调用 A 的无参构造器
调用 A 的静态方法 createBInstance
调用 A 的实例方法 createCInstance</span></pre>
</div>
<blockquote>
<p class="md-end-block md-p md-focus"><span class="md-link md-expand"><a href="https://www.jianshu.com/p/607ff4e79a13"><span class="md-plain">Java反射完全解析</span></a></span></p>
<p class="md-end-block md-p"><span class=" md-link"><span class="md-plain"><a href="https://www.sczyh30.com/posts/Java/java-reflection-1/">深入解析Java反射</a></span></span>​</p>
</blockquote>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>