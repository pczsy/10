<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修webpack入门指南（基于webpack v4.41.2）' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>webpack入门指南（基于webpack v4.41.2）</center></div><div class='banquan'>原文出处:本文由博客园博主Eric_同学提供。<br/>
原文连接:https://www.cnblogs.com/chinaeric/p/11991085.html</div><br>
    <p><span style="font-family: 'Microsoft YaHei';">2019年12月5日初稿</span>，目前webpack已经更新到v4.41.2，本文正是基于该版本，在windows8.1操作系统下进行的demo编译，适用于想入门webpack的前端开发人员。</p>
<p>webpack官方使用指南（<a href="https://www.webpackjs.com/guides/getting-started/" target="_blank"><span style="color: #ff9900;">参考1</span></a>）：<a href="https://www.webpackjs.com/guides/getting-started/">https://www.webpackjs.com/guides/getting-started/</a></p>
<p>本文参考（<a href="https://segmentfault.com/a/1190000006178770?utm_source=tag-newest#comment-area" target="_blank"><span style="color: #ff9900;">参考2</span></a>）：<a href="https://segmentfault.com/a/1190000006178770?utm_source=tag-newest#comment-area">https://segmentfault.com/a/1190000006178770?utm_source=tag-newest#comment-area</a></p>
<h1>一、使用webpack之前的准备工作</h1>
<p>在开始之前，请确保安装了 node.js的最新版本。这里给大家推荐<a href="https://www.cnblogs.com/zhouyu2017/p/6485265.html">https://www.cnblogs.com/zhouyu2017/p/6485265.html</a>，大家可以通过这篇文章来安装node.js并进行环境变量配置。</p>
<h1>二、开始使用webpack</h1>
<h2>1、创建练习文件夹，本人将该文件夹命名为webpackTest(根目录)，并通过CMD进入该文件夹下</h2>
<h2>2、创建package.json文件及安装webpack</h2>
<p>a、在根目录下创建package.json文件，这是一个标准的npm说明文件，里面蕴含了丰富的信息，包括当前项目的依赖模块，自定义的脚本任务等等。在终端中使用npm init -y命令可以自动创建这个package.json文件.</p>
<p>命令：npm init -y</p>
<p>运行结果：</p>
<p><img src="./images/webpack入门指南（基于webpack v4.41.2）0.png" alt="" /></p>
<p>&nbsp;目录结构：</p>
<p><img src="./images/webpack入门指南（基于webpack v4.41.2）1.png" alt="" /></p>
<p>&nbsp;代码内容：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;">package.json</span>
<span style="color: #000000;">{
  </span>"name": "webpackTest"<span style="color: #000000;">,
  </span>"version": "1.0.0"<span style="color: #000000;">,
  </span>"description": ""<span style="color: #000000;">,
  </span>"main": "index.js"<span style="color: #000000;">,
  </span>"scripts"<span style="color: #000000;">: {
    </span>"test": "echo \"Error: no test specified\" &amp;&amp; exit 1"<span style="color: #000000;">
  },
  </span>"keywords"<span style="color: #000000;">: [],
  </span>"author": ""<span style="color: #000000;">,
  </span>"license": "ISC"<span style="color: #000000;">
}</span></pre>
</div>
<p><span style="font-family: 'Microsoft YaHei';">b、创建完成package.json之后安装webpack，按照官方推荐使用局部（本地）安装，这里安装最新版本（此时最新版本为v4.41.2，当你看到这篇文章时，其版本可能又已经更新，你可以通过npm install --save-dev webpack@4.41.2来下载该版本），其中webpack-cli工具用于在命令行中运行 webpack。</span></p>
<p><span style="font-family: 'Microsoft YaHei';">命令：npm install webpack webpack-cli&nbsp;--save-dev</span></p>
<p><span style="font-family: 'Microsoft YaHei';">运行结果：</span></p>
<p><span style="font-family: 'Microsoft YaHei';"><img src="./images/webpack入门指南（基于webpack v4.41.2）2.png" alt="" /></span></p>
<p>&nbsp;</p>
<p><span style="font-family: 'Microsoft YaHei';">目录结构：</span></p>
<p><img src="./images/webpack入门指南（基于webpack v4.41.2）3.png" alt="" /></p>
<h2>&nbsp;3、初始文件设置</h2>
<p>在根目录下创建两个文件夹src、dist，src文件夹用来存放原始数据和我们将写的JavaScript模块，dist文件夹用来存放之后供浏览器读取的文件（包括使用webpack打包生成的js文件以及一个index.html文件）。接下来，再创建3个文件：</p>
<p>index.html--放入dist文件夹中</p>
<p>style.css--放入src文件夹中</p>
<p>test.js--放入main文件夹中</p>
<p>目录结构：</p>
<p><img src="./images/webpack入门指南（基于webpack v4.41.2）4.png" alt="" /></p>
<p>&nbsp;在index.html文件中写入最基础的html代码，它在这里目的在于引入打包后的js文件（这里我们先把之后打包后的js文件命名为bundle.js，之后我们还会详细讲述），代码如下：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">&lt;!--</span><span style="color: #008000;"> index.html </span><span style="color: #008000;">--&gt;</span>
<span style="color: #0000ff;">&lt;!</span><span style="color: #ff00ff;">DOCTYPE html</span><span style="color: #0000ff;">&gt;</span>
<span style="color: #0000ff;">&lt;</span><span style="color: #800000;">html </span><span style="color: #ff0000;">lang</span><span style="color: #0000ff;">="en"</span><span style="color: #0000ff;">&gt;</span>
<span style="color: #0000ff;">&lt;</span><span style="color: #800000;">head</span><span style="color: #0000ff;">&gt;</span>
    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">meta </span><span style="color: #ff0000;">charset</span><span style="color: #0000ff;">="UTF-8"</span><span style="color: #0000ff;">&gt;</span>
    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">meta </span><span style="color: #ff0000;">name</span><span style="color: #0000ff;">="viewport"</span><span style="color: #ff0000;"> content</span><span style="color: #0000ff;">="width=device-width, initial-scale=1.0"</span><span style="color: #0000ff;">&gt;</span>
    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">meta </span><span style="color: #ff0000;">http-equiv</span><span style="color: #0000ff;">="X-UA-Compatible"</span><span style="color: #ff0000;"> content</span><span style="color: #0000ff;">="ie=edge"</span><span style="color: #0000ff;">&gt;</span>
    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">title</span><span style="color: #0000ff;">&gt;</span>Webpack Sample Project<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">title</span><span style="color: #0000ff;">&gt;</span>
<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">head</span><span style="color: #0000ff;">&gt;</span>
<span style="color: #0000ff;">&lt;</span><span style="color: #800000;">body</span><span style="color: #0000ff;">&gt;</span>
    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">div </span><span style="color: #ff0000;">id</span><span style="color: #0000ff;">="root"</span><span style="color: #0000ff;">&gt;&lt;/</span><span style="color: #800000;">div</span><span style="color: #0000ff;">&gt;</span>
    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">script </span><span style="color: #ff0000;">type</span><span style="color: #0000ff;">="text/javascript"</span><span style="color: #ff0000;"> src</span><span style="color: #0000ff;">="bundle.js"</span><span style="color: #0000ff;">&gt;&lt;/</span><span style="color: #800000;">script</span><span style="color: #0000ff;">&gt;</span>
<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">body</span><span style="color: #0000ff;">&gt;</span>
<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">html</span><span style="color: #0000ff;">&gt;</span></pre>
</div>
<p>在test.js中定义一个返回包含&ldquo;Hello WebPack!&rdquo;文本的html元素的函数,并依据CommonJS规范导出这个函数为一个模块，代码如下：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;"> test.js</span>
module.exports = <span style="color: #0000ff;">function</span><span style="color: #000000;">() {
    </span><span style="color: #0000ff;">var</span> testCon = document.createElement("div"<span style="color: #000000;">);
    testCon.textContent </span>= "Hello WebPack!"<span style="color: #000000;">;
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> testCon;
};</span></pre>
</div>
<p><code>main.js</code>文件中我们写入下述代码，用以把testCon模块返回的节点插入页面，代码如下：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;">main.js </span>
const testContent = require("./test.js"<span style="color: #000000;">);
document.querySelector(</span>"#root").appendChild(testContent());</pre>
</div>
<h2>4、正式使用webpack</h2>
<p>在终端根目录下输入以下命令：</p>
<p>npx webpack src/main.js --output dist/bundle.js</p>
<p>运行结果：</p>
<p>&nbsp;<img src="./images/webpack入门指南（基于webpack v4.41.2）5.png" alt="" /></p>
<p>可以看出webpack同时编译了main.js和test.js，并且注意下面的目录结构，dist文件夹中已经自动生成了编译之后的输出文件bundle.js。</p>
<p>目录结构：</p>
<p><img src="./images/webpack入门指南（基于webpack v4.41.2）6.png" alt="" /></p>
<p>页面结果：</p>
<p><img src="./images/webpack入门指南（基于webpack v4.41.2）7.png" alt="" />&nbsp;</p>
<p>此时，我们已经通过webpack打包了一个文件。</p>
<h2>5、通过配置文件使用webpack</h2>
<p>在 webpack 4 中，可以无须任何配置使用，然而大多数项目会需要很复杂的设置，这就是为什么 webpack 仍然要支持 配置文件。这比在终端中手动输入大量命令要高效的多，所以我们需要创建一个取代以上使用 CLI 选项方式的配置文件，该配置文件其实也是一个简单的JavaScript模块，我们可以把所有的与打包相关的信息放在里面。</p>
<p>继续上面的例子来说明如何写这个配置文件，在当前练习文件夹的根目录下新建一个名为webpack.config.js的文件，我们在其中写入如下所示的简单配置代码，目前的配置主要涉及到的内容是入口文件路径和打包后文件的存放路径，内容具体如下：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;"> webpack.config.js</span>
module.exports =<span style="color: #000000;"> {
    entry:  __dirname </span>+ "/src/main.js",<span style="color: #008000;">//</span><span style="color: #008000;">唯一入口文件</span>
<span style="color: #000000;">    output: {
      path: __dirname </span>+ "/dist",<span style="color: #008000;">//</span><span style="color: #008000;">打包后的文件存放的地方</span>
      filename: "bundle.js"<span style="color: #008000;">//</span><span style="color: #008000;">打包后输出文件的文件名</span>
<span style="color: #000000;">    }
}</span></pre>
</div>
<p>注：&ldquo;__dirname&rdquo;是node.js中的一个全局变量，它指向当前执行脚本所在的目录。</p>
<p>有了这个配置之后，再打包文件，只需在终端里运行npx webpack --config webpack.config.js命令就可以了，这条命令会自动引用webpack.config.js文件中的配置选项。</p>
<p>命令：npx webpack --config webpack.config.js</p>
<p>运行结果：</p>
<p><img src="./images/webpack入门指南（基于webpack v4.41.2）8.png" alt="" /></p>
<h2>&nbsp;6、更便捷的执行打包任务：NPM脚本（NPM Scripts）</h2>
<p>考虑到用 CLI 这种方式来运行本地的 webpack 不是特别方便，我们可以设置一个快捷方式。在&nbsp;<em>package.json</em>&nbsp;添加一个&nbsp;NPM脚本（NPM Scripts）"build":"webpack"或者"start":"webpack"，这里我们使用前者，代码如下：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #000000;">{
  </span>"name": "webpackTest"<span style="color: #000000;">,
  </span>"version": "1.0.0"<span style="color: #000000;">,
  </span>"description": ""<span style="color: #000000;">,
  </span>"main": "index.js"<span style="color: #000000;">,
  </span>"scripts"<span style="color: #000000;">: {
    </span>"test": "echo \"Error: no test specified\" &amp;&amp; exit 1"<span style="color: #000000;">,<br />　　 "start": "webpack",
    </span><span style="color: #0000ff;">"build": "webpack"</span><span style="color: #000000;">
  },
  </span>"keywords"<span style="color: #000000;">: [],
  </span>"author": ""<span style="color: #000000;">,
  </span>"license": "ISC"<span style="color: #000000;">,
  </span>"devDependencies"<span style="color: #000000;">: {
    </span>"webpack": "^4.41.2"<span style="color: #000000;">,
    </span>"webpack-cli": "^3.3.10"<span style="color: #000000;">
  }
}</span></pre>
</div>
<p>npm的start命令是一个特殊的脚本名称，其特殊性表现在，在命令行中使用npm start就可以执行其对于的命令，如果对应的此脚本名称不是start，想要在命令行中运行时，需要这样用npm run {script name}如npm run build，我们在命令行中输入npm run build试试，输出结果如下：</p>
<p><img src="./images/webpack入门指南（基于webpack v4.41.2）9.png" alt="" /></p>
<p>现在只需要使用npm run build就可以打包文件了。</p>
<p>webpack的功能不止于此，我们还可以通过对配置文件的配置方式指定 loader 规则(loader rules)、插件(plugins)、解析选项(resolve options)，以及许多其他增强功能。</p>
<h2>7、生成source maps(使调试更容易)</h2>
<p>开发总是离不开调试，方便的调试能极大的提高开发效率，不过有时候通过打包后的文件，你是不容易找到出错了的地方，对应的你写的代码的位置的，source maps就是来帮我们解决这个问题的。</p>
<p>通过简单的配置，webpack就可以在打包时为我们生成的source maps，这为我们提供了一种对应编译文件和源文件的方法，使得编译后的代码可读性更高，也更容易调试。在webpack的配置文件中配置source maps，需要配置devtool，它有以下四种不同的配置选项（本文的<a href="https://segmentfault.com/a/1190000006178770?utm_source=tag-newest#comment-area" target="_blank"><span style="color: #ff9900;">参考2</span></a>已经介绍过，这里不再赘述），在小到中型项目开发环境中我们对webpack.config.js文件这样配置：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;"> webpack.config.js</span>
module.exports =<span style="color: #000000;"> {
    <span style="color: #0000ff;">devtool: </span></span><span style="color: #0000ff;">'eval-source-map'</span><span style="color: #000000;"><span style="color: #0000ff;">,</span>
    entry:  __dirname </span>+ "/src/main.js",<span style="color: #008000;">//</span><span style="color: #008000;">唯一入口文件</span>
<span style="color: #000000;">    output: {
      path: __dirname </span>+ "/dist",<span style="color: #008000;">//</span><span style="color: #008000;">打包后的文件存放的地方</span>
      filename: "bundle.js"<span style="color: #008000;">//</span><span style="color: #008000;">打包后输出文件的文件名</span>
<span style="color: #000000;">    }
}</span></pre>
</div>
<h2>8、使用webpack构建本地服务器</h2>
<p>我们可以基于node.js构建一个webpack提供的一个可选的本地开发服务器，这样浏览器监听代码的修改，并自动刷新显示修改后的结果。该服务器是一个单独的组件，在webpack中进行配置之前需要单独安装它作为项目依赖：</p>
<p>命令：npm install --save-dev webpack-dev-server</p>
<p>运行结果：</p>
<p><img src="./images/webpack入门指南（基于webpack v4.41.2）10.png" alt="" /></p>
<p>更改配置文件webpack.config.js：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;"> webpack.config.js</span>
module.exports =<span style="color: #000000;"> {
    devtool: </span>'eval-source-map'<span style="color: #000000;">,
    entry:  __dirname </span>+ "/src/main.js",<span style="color: #008000;">//</span><span style="color: #008000;">唯一入口文件</span>
<span style="color: #000000;">    output: {
      path: __dirname </span>+ "/dist",<span style="color: #008000;">//</span><span style="color: #008000;">打包后的文件存放的地方</span>
      filename: "bundle.js"<span style="color: #008000;">//</span><span style="color: #008000;">打包后输出文件的文件名</span>
<span style="color: #000000;">    },
    devServer: {
        contentBase: </span>"./dist",<span style="color: #008000;">//</span><span style="color: #008000;">设置本地服务器所加载的页面所在的目录</span>
        port:"8082",<span style="color: #008000;">//</span><span style="color: #008000;">设置默认监听端口为8082，如果省略，默认为&rdquo;8080&ldquo;</span>
        historyApiFallback: <span style="color: #0000ff;">true</span>,<span style="color: #008000;">//</span><span style="color: #008000;">不跳转，在开发单页应用时非常有用，它依赖于HTML5 history API，如果设置为true，所有的跳转将指向index.html</span>
        inline: <span style="color: #0000ff;">true</span><span style="color: #008000;">//</span><span style="color: #008000;">是否实时刷新</span>
<span style="color: #000000;">    }
}</span></pre>
</div>
<p>在package.json中的scripts对象中添加如下命令"server":&nbsp;"webpack-dev-server&nbsp;--open"，用以开启本地服务器：</p>
<div class="cnblogs_code">
<pre><code>"scripts"<span style="color: #000000;">: {
    </span>"test": "echo \"Error: no test specified\" &amp;&amp; exit 1"<span style="color: #000000;">,<br />　　 "start": "webpack",
    </span>"build": "webpack"<span style="color: #000000;">,
    </span><span style="color: #0000ff;">"server": "webpack-dev-server --open"</span><span style="color: #000000;">
}</span></pre>
</div>
<p>在终端中输入npm run server 即可在本地的8082端口查看结果：</p>
<p>命令：npm run server</p>
<p>运行结果：</p>
<p><img src="./images/webpack入门指南（基于webpack v4.41.2）11.png" alt="" /></p>
<p>页面结果：</p>
<p><img src="./images/webpack入门指南（基于webpack v4.41.2）12.png" alt="" /></p>
<h2>&nbsp;9、loader</h2>
<p>loade<em>r</em>让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。</p>
<p>本质上，webpack loader 将所有类型的文件，转换为应用程序的依赖图（和最终的 bundle）可以直接引用的模块。比如说分析转换scss为css，或者把下一代的JS文件（ES6，ES7)转换为现代浏览器兼容的JS文件，对React的开发而言，合适的Loaders可以把React的中用到的JSX文件转换为JS文件。</p>
<p>注意：loader 能够import导入任何类型的模块（例如&nbsp;<code>.css</code>&nbsp;文件），这是 webpack 特有的功能，其他打包程序或任务执行器的可能并不支持。这种语言扩展是有很必要的，因为这可以使开发人员创建出更准确的依赖关系图。</p>
<p>Loaders需要单独安装并且需要在webpack.config.js中的modules关键字下进行配置，Loaders的配置包括以下几方面：</p>
<ul>
<li>test：一个用以匹配loaders所处理文件的拓展名的正则表达式（必须）</li>
<li><span style="font-family: 'Microsoft YaHei';">loader：loader的名称（必须）</span></li>
<li><span style="font-family: 'Microsoft YaHei';">include/exclude:手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）</span></li>
<li><span style="font-family: 'Microsoft YaHei';">query：为loaders提供额外的设置选项（可选）</span></li>
</ul>
<p><span style="font-family: 'Microsoft YaHei';">在配置loader之前，我们把test.js里的问候消息放在一个单独的JSON文件里,并通过合适的配置使test.js可以读取该JSON文件的值，各文件修改后的代码如下：</span></p>
<p><span style="font-family: 'Microsoft YaHei';">在src文件夹中创建带有问候信息的JSON文件，命名为config.json:</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #000000;">{
    </span>"testText":"Hello WebPack!"<span style="color: #000000;">
}</span></pre>
</div>
<p>更新后的test.js：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;">test.js</span>
<span style="color: #0000ff;">var</span> config = require('./config.json'<span style="color: #000000;">);
module.exports </span>= <span style="color: #0000ff;">function</span><span style="color: #000000;">() {
    </span><span style="color: #0000ff;">var</span> testCon = document.createElement("div"<span style="color: #000000;">);
    testCon.textContent </span>=<span style="color: #000000;"> config.testText;
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> testCon;
};</span></pre>
</div>
<h2>10、Babel的安装与配置</h2>
<p>Babel其实是一个编译JavaScript的平台，它可以编译代码帮你达到以下目的：</p>
<ul>
<li>让你能使用最新的JavaScript代码（ES6，ES7...），而不用管新标准是否被当前使用的浏览器完全支持</li>
<li>让你能使用基于JavaScript进行了拓展的语言，比如React的JSX</li>
<li>...</li>
</ul>
<p>Babel其实是几个模块化的包，其核心功能位于称为babel-core的npm包中，webpack可以把其不同的包整合在一起使用，对于每一个你需要的功能或拓展，你都需要安装单独的包（用得最多的是解析Es6的babel-preset-es2015包和解析JSX的babel-preset-react包）。</p>
<p>我们先来一次性（npm可以一次性安装多个依赖模块，模块之间用空格隔开）安装这些依赖包：</p>
<p>命令：</p>
<p>npm install --save-dev babel-core babel-loader@7.1.5 babel-preset-es2015 babel-preset-react</p>
<p>注意：默认babel-loader最新8.0+版本的话会产生冲突，这里采用7.1.5版本</p>
<p>运行结果（这是修改babel-loder版本之前的运行结果）：</p>
<p><img src="./images/webpack入门指南（基于webpack v4.41.2）13.png" alt="" /></p>
<p>在webpack.config.js中配置Babel的方法如下:</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;"> webpack.config.js</span>
module.exports =<span style="color: #000000;"> {
    devtool: </span>'eval-source-map'<span style="color: #000000;">,
    entry:  __dirname </span>+ "/src/main.js",<span style="color: #008000;">//</span><span style="color: #008000;">唯一入口文件</span>
<span style="color: #000000;">    output: {
      path: __dirname </span>+ "/dist",<span style="color: #008000;">//</span><span style="color: #008000;">打包后的文件存放的地方</span>
      filename: "bundle.js"<span style="color: #008000;">//</span><span style="color: #008000;">打包后输出文件的文件名</span>
<span style="color: #000000;">    },
    devServer: {
        contentBase: </span>"./dist",<span style="color: #008000;">//</span><span style="color: #008000;">设置本地服务器所加载的页面所在的目录</span>
        port:"8082",<span style="color: #008000;">//</span><span style="color: #008000;">设置默认监听端口，如果省略，默认为&rdquo;8080&ldquo;</span>
        historyApiFallback: <span style="color: #0000ff;">true</span>,<span style="color: #008000;">//</span><span style="color: #008000;">不跳转，在开发单页应用时非常有用，它依赖于HTML5 history API，如果设置为true，所有的跳转将指向index.html</span>
        inline: <span style="color: #0000ff;">true</span><span style="color: #008000;">//</span><span style="color: #008000;">是否实时刷新</span>
<span style="color: #000000;">    },
    module: {
        rules: [
            {
                test: </span>/(\.jsx|\.js)$/<span style="color: #000000;">,
                use: {
                    loader: </span>"babel-loader"<span style="color: #000000;">,
                    options: {
                        presets: [
                            </span>"es2015", "react"<span style="color: #000000;">
                        ]
                    }
                },
                exclude: </span>/node_modules/<span style="color: #000000;">
            }
        ]
    }
}</span></pre>
</div>
<p>现在你的webpack的配置已经允许你使用ES6以及JSX的语法了，继续用上面的例子进行测试，不过这次我们会使用React，记得先安装 React 和 React-DOM：</p>
<p>命令：npm install --save react react-dom</p>
<p>运行结果：</p>
<p><img src="./images/webpack入门指南（基于webpack v4.41.2）14.png" alt="" /></p>
<p>接下来我们使用ES6的语法，更新test.js并返回一个React组件:</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;">test.js</span>
import React, {Component} from 'react'<span style="color: #000000;">
import config from </span>'./config.json'<span style="color: #000000;">;

class TestCon extends Component{
    render() {
        </span><span style="color: #0000ff;">return</span> (&lt;div&gt;{config.testText}&lt;/div&gt;);
<span style="color: #000000;">    }
}
export </span><span style="color: #0000ff;">default</span> TestCon;</pre>
</div>
<p>修改main.js如下，使用ES6的模块定义和渲染Greeter模块:</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;"> main.js</span>
import React from 'react'<span style="color: #000000;">;
import {render} from </span>'react-dom'<span style="color: #000000;">;
import TestCon from </span>'./test'<span style="color: #000000;">;

render(</span>&lt;TestCon /&gt;, document.getElementById('root'));</pre>
</div>
<p>重新使用npm run build打包:</p>
<p><img src="./images/webpack入门指南（基于webpack v4.41.2）15.png" alt="" /></p>
<p>&nbsp;打包成功，浏览器和之前显示的内容一样：</p>
<p><img src="./images/webpack入门指南（基于webpack v4.41.2）16.png" alt="" /></p>
<p>&nbsp;</p>
<h2>&nbsp;11、一切皆模块，资源管理</h2>
<p>Webpack有一个不可不说的优点，它把所有的文件都都当做模块处理，JavaScript代码，CSS和fonts以及图片等等通过合适的loader都可以被处理。接下来我们将以css为例进行操作。</p>
<p>webpack提供两个工具处理样式表，css-loader和 style-loader，二者处理的任务不同，css-loader使你能够使用类似@import和url(...)的方法实现require()的功能，style-loader将所有的计算后的样式加入页面中，二者组合在一起使你能够把样式表嵌入webpack打包后的JS文件中。继续上面的例子：</p>
<p>命令：npm install --save-dev style-loader css-loader</p>
<p>运行结果：</p>
<p><img src="./images/webpack入门指南（基于webpack v4.41.2）17.png" alt="" /></p>
<p>&nbsp;在webpack.config.js的module中添加如下代码：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;"> webpack.config.js</span>
module.exports =<span style="color: #000000;"> {
    devtool: </span>'eval-source-map'<span style="color: #000000;">,
    entry:  __dirname </span>+ "/src/main.js",<span style="color: #008000;">//</span><span style="color: #008000;">唯一入口文件</span>
<span style="color: #000000;">    output: {
      path: __dirname </span>+ "/dist",<span style="color: #008000;">//</span><span style="color: #008000;">打包后的文件存放的地方</span>
      filename: "bundle.js"<span style="color: #008000;">//</span><span style="color: #008000;">打包后输出文件的文件名</span>
<span style="color: #000000;">    },
    devServer: {
        contentBase: </span>"./dist",<span style="color: #008000;">//</span><span style="color: #008000;">设置本地服务器所加载的页面所在的目录</span>
        port:"8082",<span style="color: #008000;">//</span><span style="color: #008000;">设置默认监听端口，如果省略，默认为&rdquo;8080&ldquo;</span>
        historyApiFallback: <span style="color: #0000ff;">true</span>,<span style="color: #008000;">//</span><span style="color: #008000;">不跳转，在开发单页应用时非常有用，它依赖于HTML5 history API，如果设置为true，所有的跳转将指向index.html</span>
        inline: <span style="color: #0000ff;">true</span><span style="color: #008000;">//</span><span style="color: #008000;">是否实时刷新</span>
<span style="color: #000000;">    },
    module: {
        rules: [{
            test: </span>/(\.jsx|\.js)$/<span style="color: #000000;">,
            use: {
                loader: </span>"babel-loader"<span style="color: #000000;">,
                options: {
                    presets: [
                        </span>"es2015", "react"<span style="color: #000000;">
                    ]
                }
            },
            exclude: </span>/node_modules/<span style="color: #000000;">
        },{
            <span style="color: #0000ff;">test: </span></span><span style="color: #0000ff;">/\.css$/,
            use: [{
                loader: "style-loader"
            },{
                loader: "css-loader"</span><span style="color: #000000;"><span style="color: #0000ff;">
            }]</span>
        }]
    }
}</span></pre>
</div>
<p>请注意这里对同一个文件引入多个loader的方法。</p>
<p>接下来，在src文件夹里创建一个名字为"main.css"的文件，对一些元素设置样式：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">/*</span><span style="color: #008000;"> main.css </span><span style="color: #008000;">*/</span><span style="color: #800000;">
*</span>{<span style="color: #ff0000;">
    padding</span>:<span style="color: #0000ff;"> 0px</span>;<span style="color: #ff0000;">
    margin</span>:<span style="color: #0000ff;"> 0px</span>;<span style="color: #ff0000;">
    font-size</span>:<span style="color: #0000ff;"> 16px</span>;<span style="color: #ff0000;">
    font-family</span>:<span style="color: #0000ff;">'幼圆', 'Times New Roman', Times, serif</span>;<span style="color: #ff0000;">
    color</span>:<span style="color: #0000ff;"> #333</span>;<span style="color: #ff0000;">
    list-style</span>:<span style="color: #0000ff;"> none</span>;
}<span style="color: #800000;">
html,body</span>{<span style="color: #ff0000;">
    width</span>:<span style="color: #0000ff;"> 100%</span>;<span style="color: #ff0000;">
    height</span>:<span style="color: #0000ff;"> 100%</span>;
}</pre>
</div>
<p>我们这里例子中用到的<code>webpack</code>只有单一的入口，其它的模块需要通过import，require，url等与入口文件建立其关联，为了让webpack能找到&rdquo;main.css&ldquo;文件，我们把它导入&rdquo;main.js &ldquo;中，如下：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;"> main.js</span>
import React from 'react'<span style="color: #000000;">;
import {render} from </span>'react-dom'<span style="color: #000000;">;
import TestCon from </span>'./test'<span style="color: #000000;">;
<span style="color: #0000ff;">import </span></span><span style="color: #0000ff;">'./main.css'</span><span style="color: #000000;"><span style="color: #0000ff;">;</span>

render(</span>&lt;TestCon /&gt;, document.getElementById('root'));</pre>
</div>
<p>在终端该项目根目录下输入命令npm run build：</p>
<p>运行结果：</p>
<p><img src="./images/webpack入门指南（基于webpack v4.41.2）18.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;页面结果：</p>
<p><img src="./images/webpack入门指南（基于webpack v4.41.2）19.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;可以看到，样式已经渲染成功。接下来，咱们继续看一个更加真实的css模块实践。</p>
<h3>Css module</h3>
<p>在过去的一些年里，JavaScript通过一些新的语言特性，更好的工具以及更好的实践方法（比如说模块化）发展得非常迅速。模块使得开发者把复杂的代码转化为小的，干净的，依赖声明明确的单元，配合优化工具，依赖管理和加载管理可以自动完成。不过，前端的另外一部分，CSS发展就相对慢一些，大多的样式表却依旧巨大且充满了全局类名，维护和修改都非常困难。</p>
<p>被称为Css module的技术意在把JS的模块化思想带入CSS中来，通过CSS模块，所有的类名，动画名默认都只作用于当前模块。Webpack对CSS模块化提供了非常好的支持，只需要在CSS loader中进行简单配置即可，然后就可以直接把CSS的类名传递到组件的代码中，这样做有效避免了全局污染。具体的代码如下：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;"> webpack.config.js</span>
module.exports =<span style="color: #000000;"> {
    &middot;&middot;&middot;&middot;&middot;&middot;
    module: {
        rules: [{
            test: </span>/(\.jsx|\.js)$/<span style="color: #000000;">,
            use: {
                loader: </span>"babel-loader"<span style="color: #000000;">,
                options: {
                    presets: [
                        </span>"es2015", "react"<span style="color: #000000;">
                    ]
                }
            },
            exclude: </span>/node_modules/<span style="color: #000000;">
        },{
            test: </span>/\.css$/<span style="color: #000000;">,
            use: [{
                loader: </span>"style-loader"<span style="color: #000000;">
            },{
                loader: </span>"css-loader"<span style="color: #000000;">,
                options: {
                    modules: </span><span style="color: #0000ff;">true</span><span style="color: #008000;">//</span><span style="color: #008000;"> 指定启用css modules</span>
<span style="color: #000000;">                }
            }]
        }]
    }
}</span></pre>
</div>
<p>我们在src文件夹下创建一个test.css文件来进行一下测试:</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">/*</span><span style="color: #008000;"> test.css </span><span style="color: #008000;">*/</span><span style="color: #800000;">
.root </span>{<span style="color: #ff0000;">
    background-color</span>:<span style="color: #0000ff;"> red</span>;<span style="color: #ff0000;">
    padding</span>:<span style="color: #0000ff;"> 10px</span>;<span style="color: #ff0000;">
    border</span>:<span style="color: #0000ff;"> 1px solid #999</span>;
}</pre>
</div>
<p>导入.root到test.js中：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;">test.js</span>
import React, {Component} from 'react'<span style="color: #000000;">
import config from </span>'./config.json'<span style="color: #000000;">;
import styles from </span>'./test.css';<span style="color: #008000;">//</span><span style="color: #008000;">导入</span>
<span style="color: #000000;">
class TestCon extends Component{
    render() {
        </span><span style="color: #0000ff;">return</span> (&lt;div className={styles.root}&gt;{config.testText}&lt;/div&gt;);//使用cssModule添加类名的方法
<span style="color: #000000;">    }
}
export </span><span style="color: #0000ff;">default</span> TestCon;</pre>
</div>
<p>这样的话，就可以放心使用了，相同的类名也不会造成不同组件之间的污染。</p>
<p>命令：npm run build</p>
<p>运行结果：</p>
<p><img src="./images/webpack入门指南（基于webpack v4.41.2）20.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;页面结果：</p>
<p><img src="./images/webpack入门指南（基于webpack v4.41.2）21.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3>&nbsp;CSS预处理器</h3>
<p>Sass和Less之类的预处理器是对原生CSS的拓展，它们允许你使用类似于variables，nesting，mixins，inheritance等不存在于CSS中的特性来写CSS，CSS预处理器可以这些特殊类型的语句转化为浏览器可识别的CSS语句，以下是常用的CSS 处理loaders：<code><br /></code></p>
<ul>
<li>Less Loader</li>
<li>Sass Loader</li>
<li>Stylus Loader</li>
</ul>
<p>&nbsp;不过其实也存在一个CSS的处理平台-Post-Css，它可以帮助你的CSS实现更多的功能。下面我们举例来说如何使用PostCSS，我们使用PostCSS来为CSS代码自动添加适应不同浏览器的CSS前缀。</p>
<p>首先安装postcss-loader&nbsp;和autoprefixer&nbsp;（自动添加前缀的插件）</p>
<p>命令：npm install --save-dev postcss-loader autoprefixer</p>
<p>运行结果：</p>
<p><img src="./images/webpack入门指南（基于webpack v4.41.2）22.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;接下来，接下来，在webpack配置文件webpack.config.js中添加postcss-loader，在根目录新建postcss.config.js：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;"> webpack.config.js</span>
module.exports =<span style="color: #000000;"> {
    &middot;&middot;&middot;&middot;&middot;&middot;
    module: {
        rules: [{
            test: </span>/(\.jsx|\.js)$/<span style="color: #000000;">,
            use: {
                loader: </span>"babel-loader"<span style="color: #000000;">,
                options: {
                    presets: [
                        </span>"es2015", "react"<span style="color: #000000;">
                    ]
                }
            },
            exclude: </span>/node_modules/<span style="color: #000000;">
        },{
            test: </span>/\.css$/<span style="color: #000000;">,
            use: [{
                loader: </span>"style-loader"<span style="color: #000000;">
            },{
                loader: </span>"css-loader"<span style="color: #000000;">,
                options: {
                    modules: </span><span style="color: #0000ff;">true</span><span style="color: #008000;">//</span><span style="color: #008000;"> 指定启用css modules</span>
<span style="color: #000000;">                }
            },{
                loader: </span>"postcss-loader"<span style="color: #000000;">
            }]
        }]
    }
}</span></pre>
</div>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;"> postcss.config.js</span>
module.exports =<span style="color: #000000;"> {
    plugins: [
        require(</span>'autoprefixer'<span style="color: #000000;">)
    ]
}</span></pre>
</div>
<p>目录结构：</p>
<p><img src="./images/webpack入门指南（基于webpack v4.41.2）23.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;运行命令：npm run build</p>
<p>运行结果：</p>
<p><img src="./images/webpack入门指南（基于webpack v4.41.2）24.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;至此，本文已经谈论了处理JS的Babel和处理CSS的PostCSS的基本用法，它们其实也是两个单独的平台，配合webpack可以很好的发挥它们的作用。接下来介绍Webpack中另一个非常重要的功能-Plugins。</p>
<h2 id="item-0-7">12、插件（Plugins）</h2>
<p>插件（Plugins）是用来拓展Webpack功能的，它们会在整个构建过程中生效，执行相关的任务。Loaders和Plugins常常被弄混，但是他们其实是完全不同的东西，可以这么来说，loaders是在打包构建过程中用来处理源文件的（JSX，Scss，Less..），一次处理一个，插件并不直接操作单个文件，它直接对整个构建过程其作用。Webpack有很多内置插件，同时也有很多第三方插件，可以让我们完成更加丰富的功能。</p>
<h3>使用插件的方法</h3>
<p>要使用某个插件，我们需要通过npm安装它，然后要做的就是在webpack的配置文件webpack.config.js中的plugins关键字部分添加该插件的一个实例（plugins是一个数组）继续上面的例子，我们添加了一个给打包后代码添加版权声明的插件。</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;"> webpack.config.js</span>
const webpack = require('webpack');<br />module.exports =<span style="color: #000000;"> {
    &middot;&middot;&middot;&middot;&middot;&middot;
    module: {
        &middot;&middot;&middot;&middot;&middot;&middot;
    },
    plugins: [
        </span><span style="color: #0000ff;">new</span> webpack.BannerPlugin('版权所有，翻版必究'<span style="color: #000000;">)
    ]
}</span></pre>
</div>
<p>通过这个插件，打包后的JS文件显示如下：</p>
<p>&nbsp;<img src="./images/webpack入门指南（基于webpack v4.41.2）25.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;这就是webpack插件的基础用法了，下面给大家推荐几个常用的插件。</p>
<h3>HtmlWebpackPlugin</h3>
<p>这个插件的作用是依据一个简单的index.html模板，生成一个自动引用你打包后的JS文件的新index.html。这在每次生成的js文件名称不同时非常有用（比如添加了hash值）。</p>
<p>安装命令：npm install --save-dev html-webpack-plugin</p>
<p>运行结果：</p>
<p><img src="./images/webpack入门指南（基于webpack v4.41.2）26.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;这个插件自动完成了我们之前手动做的一些事情，在正式使用之前需要对一直以来的项目结构做一些更改：</p>
<ol>
<li>移除dist文件夹，利用此插件，index.html文件会自动生成，此外CSS已经通过前面的操作打包到JS中了</li>
<li>在src目录下，创建一个index.tmpl.html一个index.tmpl.html文件模板，这个模板包含title等必须元素，在编译过程中，插件会依据此模板生成最终的html页面，会自动添加所依赖的 css, js，favicon等文件，index.tmpl.html中的模板源代码如下：
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">&lt;!--</span><span style="color: #008000;"> index.tmpl.html </span><span style="color: #008000;">--&gt;</span>
<span style="color: #0000ff;">&lt;!</span><span style="color: #ff00ff;">DOCTYPE html</span><span style="color: #0000ff;">&gt;</span>
<span style="color: #0000ff;">&lt;</span><span style="color: #800000;">html </span><span style="color: #ff0000;">lang</span><span style="color: #0000ff;">="en"</span><span style="color: #0000ff;">&gt;</span>
<span style="color: #0000ff;">&lt;</span><span style="color: #800000;">head</span><span style="color: #0000ff;">&gt;</span>
    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">meta </span><span style="color: #ff0000;">charset</span><span style="color: #0000ff;">="UTF-8"</span><span style="color: #0000ff;">&gt;</span>
    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">meta </span><span style="color: #ff0000;">name</span><span style="color: #0000ff;">="viewport"</span><span style="color: #ff0000;"> content</span><span style="color: #0000ff;">="width=device-width, initial-scale=1.0"</span><span style="color: #0000ff;">&gt;</span>
    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">meta </span><span style="color: #ff0000;">http-equiv</span><span style="color: #0000ff;">="X-UA-Compatible"</span><span style="color: #ff0000;"> content</span><span style="color: #0000ff;">="ie=edge"</span><span style="color: #0000ff;">&gt;</span>
    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">title</span><span style="color: #0000ff;">&gt;</span>Webpack Sample Project<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">title</span><span style="color: #0000ff;">&gt;</span>
<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">head</span><span style="color: #0000ff;">&gt;</span>
<span style="color: #0000ff;">&lt;</span><span style="color: #800000;">body</span><span style="color: #0000ff;">&gt;</span>
    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">div </span><span style="color: #ff0000;">id</span><span style="color: #0000ff;">="root"</span><span style="color: #0000ff;">&gt;&lt;/</span><span style="color: #800000;">div</span><span style="color: #0000ff;">&gt;</span>
<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">body</span><span style="color: #0000ff;">&gt;</span>
<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">html</span><span style="color: #0000ff;">&gt;</span></pre>
</div>
</li>
<li>更新webpack的配置文件，新建一个build文件夹用来存放最终的输出文件：
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;"> webpack.config.js</span>
const webpack = require('webpack'<span style="color: #000000;">);
const HtmlWebpackPlugin </span>= require('html-webpack-plugin'<span style="color: #000000;">);
module.exports </span>=<span style="color: #000000;"> {
    devtool: </span>'eval-source-map'<span style="color: #000000;">,
    entry:  __dirname </span>+ "/src/main.js",<span style="color: #008000;">//</span><span style="color: #008000;">唯一入口文件</span>
<span style="color: #000000;">    output: {
      path: __dirname </span>+ "/build",<span style="color: #008000;">//</span><span style="color: #008000;">打包后的文件存放的地方</span>
      filename: "bundle.js"<span style="color: #008000;">//</span><span style="color: #008000;">打包后输出文件的文件名</span>
<span style="color: #000000;">    },
    devServer: {
        contentBase: </span>"./dist",<span style="color: #008000;">//</span><span style="color: #008000;">设置本地服务器所加载的页面所在的目录</span>
        port:"8082",<span style="color: #008000;">//</span><span style="color: #008000;">设置默认监听端口，如果省略，默认为&rdquo;8080&ldquo;</span>
        historyApiFallback: <span style="color: #0000ff;">true</span>,<span style="color: #008000;">//</span><span style="color: #008000;">不跳转，在开发单页应用时非常有用，它依赖于HTML5 history API，如果设置为true，所有的跳转将指向index.html</span>
        inline: <span style="color: #0000ff;">true</span><span style="color: #008000;">//</span><span style="color: #008000;">是否实时刷新</span>
<span style="color: #000000;">    },
    module: {
        rules: [{
            test: </span>/(\.jsx|\.js)$/<span style="color: #000000;">,
            use: {
                loader: </span>"babel-loader"<span style="color: #000000;">,
                options: {
                    presets: [
                        </span>"es2015", "react"<span style="color: #000000;">
                    ]
                }
            },
            exclude: </span>/node_modules/<span style="color: #000000;">
        },{
            test: </span>/\.css$/<span style="color: #000000;">,
            use: [{
                loader: </span>"style-loader"<span style="color: #000000;">
            },{
                loader: </span>"css-loader"<span style="color: #000000;">,
                options: {
                    modules: </span><span style="color: #0000ff;">true</span><span style="color: #008000;">//</span><span style="color: #008000;"> 指定启用css modules</span>
<span style="color: #000000;">                }
            },{
                loader: </span>"postcss-loader"<span style="color: #000000;">
            }]
        }]
    },
    plugins: [
        </span><span style="color: #0000ff;">new</span> webpack.BannerPlugin('版权所有，翻版必究'<span style="color: #000000;">),
        </span><span style="color: #0000ff;">new</span><span style="color: #000000;"> HtmlWebpackPlugin({
            template: __dirname </span>+ "/src/index.tmpl.html"<span style="color: #008000;">//</span><span style="color: #008000;">new 一个这个插件的实例，并传入相关的参数</span>
<span style="color: #000000;">        })
    ]
}</span></pre>
</div>
<p>再次执行npm run build你会发现，build文件夹下面生成了bundle.js和index.html。目录结构如下：</p>
</li>
</ol>
<p>　　　　<img src="./images/webpack入门指南（基于webpack v4.41.2）27.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3>Hot Module Replacement</h3>
<p>Hot Module Replacement（HMR）也是webpack里很有用的一个插件，它允许你在修改组件代码后，自动刷新实时预览修改后的效果。在webpack中实现HMR也很简单，只需要做两项配置：</p>
<ol>
<li>在webpack配置文件中添加HMR插件</li>
<li>在Webpack Dev Server中添加&ldquo;hot&rdquo;参数</li>
</ol>
<p>不过配置完这些后，JS模块其实还是不能自动热加载的，还需要在你的JS模块中执行一个Webpack提供的API才能实现热加载，虽然这个API不难使用，但是如果是React模块，使用我们已经熟悉的Babel可以更方便的实现功能热加载。</p>
<p>整理下我们的思路，具体实现方法如下：</p>
<ul>
<li>babel和webpack是独立的工具</li>
<li>二者可以一起工作</li>
<li>二者都可以通过插件拓展功能</li>
<li>HMR是一个webpack插件，它让你能浏览器中实时观察模块修改后的效果，但是如果你想让它工作，需要对模块进行额外的配额</li>
<li>Babel有一个叫做react-transform-hrm的插件，可以在不对React模块进行额外的配置的前提下让HMR正常工作</li>
</ul>
<p>还是继续上例来实际看看如何配置:</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;"> webpack.config.js</span>
const webpack = require('webpack'<span style="color: #000000;">);
const HtmlWebpackPlugin </span>= require('html-webpack-plugin'<span style="color: #000000;">);
module.exports </span>=<span style="color: #000000;"> {
    devtool: </span>'eval-source-map'<span style="color: #000000;">,
    entry:  __dirname </span>+ "/src/main.js",<span style="color: #008000;">//</span><span style="color: #008000;">唯一入口文件</span>
<span style="color: #000000;">    output: {
      path: __dirname </span>+ "/build",<span style="color: #008000;">//</span><span style="color: #008000;">打包后的文件存放的地方</span>
      filename: "bundle.js"<span style="color: #008000;">//</span><span style="color: #008000;">打包后输出文件的文件名</span>
<span style="color: #000000;">    },
    devServer: {
        contentBase: </span>"./dist",<span style="color: #008000;">//</span><span style="color: #008000;">设置本地服务器所加载的页面所在的目录</span>
        port:"8082",<span style="color: #008000;">//</span><span style="color: #008000;">设置默认监听端口，如果省略，默认为&rdquo;8080&ldquo;</span>
        historyApiFallback: <span style="color: #0000ff;">true</span>,<span style="color: #008000;">//</span><span style="color: #008000;">不跳转，在开发单页应用时非常有用，它依赖于HTML5 history API，如果设置为true，所有的跳转将指向index.html</span>
        inline: <span style="color: #0000ff;">true</span>,<span style="color: #008000;">//</span><span style="color: #008000;">是否实时刷新</span>
        hot: <span style="color: #0000ff;">true</span><span style="color: #000000;">,
    },
    module: {
        rules: [{
            test: </span>/(\.jsx|\.js)$/<span style="color: #000000;">,
            use: {
                loader: </span>"babel-loader"<span style="color: #000000;">
            },
            exclude: </span>/node_modules/<span style="color: #000000;">
        },{
            test: </span>/\.css$/<span style="color: #000000;">,
            use: [{
                loader: </span>"style-loader"<span style="color: #000000;">
            },{
                loader: </span>"css-loader"<span style="color: #000000;">,
                options: {
                    modules: </span><span style="color: #0000ff;">true</span><span style="color: #008000;">//</span><span style="color: #008000;"> 指定启用css modules</span>
<span style="color: #000000;">                }
            },{
                loader: </span>"postcss-loader"<span style="color: #000000;">
            }]
        }]
    },
    plugins: [
        </span><span style="color: #0000ff;">new</span> webpack.BannerPlugin('版权所有，翻版必究'<span style="color: #000000;">),
        </span><span style="color: #0000ff;">new</span><span style="color: #000000;"> HtmlWebpackPlugin({
            template: __dirname </span>+ "/src/index.tmpl.html"<span style="color: #008000;">//</span><span style="color: #008000;">new 一个这个插件的实例，并传入相关的参数</span>
<span style="color: #000000;">        }),
        </span><span style="color: #0000ff;">new</span> webpack.HotModuleReplacementPlugin()<span style="color: #008000;">//</span><span style="color: #008000;">热加载插件</span>
<span style="color: #000000;">    ]
}</span></pre>
</div>
<p>安装react-transform-hrm:</p>
<p>命令：npm install --save-dev babel-plugin-react-transform react-transform-hmr</p>
<p>在根目录下新建.babelrc，配置Babel：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;">.babelrc</span>
<span style="color: #000000;">{
    </span>"presets"<span style="color: #000000;">: [
        </span>"es2015", "react"<span style="color: #000000;">
    ],
    </span>"env"<span style="color: #000000;">: {
        </span>"development"<span style="color: #000000;">: {
            </span>"plugins": [["react-transform"<span style="color: #000000;">, {
                </span>"transforms"<span style="color: #000000;">: [{
                    </span>"transform": "react-transform-hmr"<span style="color: #000000;">,
                    </span>"imports": ["react"<span style="color: #000000;">],
                    </span>"locals": ["module"<span style="color: #000000;">]
                }]
            }]]
        }
    }
}</span></pre>
</div>
<p>现在当你使用React时，可以热加载模块了,每次保存就能在浏览器上看到更新内容。</p>
<h2 id="item-0-8">13、产品阶段的构建</h2>
<p>目前为止，我们已经使用webpack构建了一个完整的开发环境。但是在产品阶段，可能还需要对打包的文件进行额外的处理，比如说优化，压缩，缓存以及分离CSS和JS。</p>
<p>对于复杂的项目来说，需要复杂的配置，这时候分解配置文件为多个小的文件可以使得事情井井有条，以上面的例子来说，我们创建一个webpack.production.config.js的文件，在里面加上基本的配置,它和原始的webpack.config.js很像，如下：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;"> webpack.production.config.js</span>
const webpack = require('webpack'<span style="color: #000000;">);
const HtmlWebpackPlugin </span>= require('html-webpack-plugin'<span style="color: #000000;">);
module.exports </span>=<span style="color: #000000;"> {
    devtool: </span>'null', <span style="color: #008000;">//</span><span style="color: #008000;">注意修改了这里，这能大大压缩我们的打包代码</span>
    entry:  __dirname + "/src/main.js",<span style="color: #008000;">//</span><span style="color: #008000;">唯一入口文件</span>
<span style="color: #000000;">    output: {
      path: __dirname </span>+ "/build",<span style="color: #008000;">//</span><span style="color: #008000;">打包后的文件存放的地方</span>
      filename: "bundle.js"<span style="color: #008000;">//</span><span style="color: #008000;">打包后输出文件的文件名</span>
<span style="color: #000000;">    },
    devServer: {
        contentBase: </span>"./dist",<span style="color: #008000;">//</span><span style="color: #008000;">设置本地服务器所加载的页面所在的目录</span>
        port:"8082",<span style="color: #008000;">//</span><span style="color: #008000;">设置默认监听端口，如果省略，默认为&rdquo;8080&ldquo;</span>
        historyApiFallback: <span style="color: #0000ff;">true</span>,<span style="color: #008000;">//</span><span style="color: #008000;">不跳转，在开发单页应用时非常有用，它依赖于HTML5 history API，如果设置为true，所有的跳转将指向index.html</span>
        inline: <span style="color: #0000ff;">true</span>,<span style="color: #008000;">//</span><span style="color: #008000;">是否实时刷新</span>
        hot: <span style="color: #0000ff;">true</span><span style="color: #000000;">,
    },
    module: {
        rules: [{
            test: </span>/(\.jsx|\.js)$/<span style="color: #000000;">,
            use: {
                loader: </span>"babel-loader"<span style="color: #000000;">
            },
            exclude: </span>/node_modules/<span style="color: #000000;">
        }, {
            test: </span>/\.css$/<span style="color: #000000;">,
            use: ExtractTextPlugin.extract({
                fallback: </span>"style-loader"<span style="color: #000000;">,
                use: [{
                    loader: </span>"css-loader"<span style="color: #000000;">,
                    options: {
                        modules: </span><span style="color: #0000ff;">true</span><span style="color: #000000;">
                    }
                }, {
                    loader: </span>"postcss-loader"<span style="color: #000000;">
                }],
            })
        }]
    },
    plugins: [
        </span><span style="color: #0000ff;">new</span> webpack.BannerPlugin('版权所有，翻版必究'<span style="color: #000000;">),
        </span><span style="color: #0000ff;">new</span><span style="color: #000000;"> HtmlWebpackPlugin({
            template: __dirname </span>+ "/src/index.tmpl.html"<span style="color: #008000;">//</span><span style="color: #008000;">new 一个这个插件的实例，并传入相关的参数</span>
<span style="color: #000000;">        }),
        </span><span style="color: #0000ff;">new</span> webpack.HotModuleReplacementPlugin() <span style="color: #008000;">//</span><span style="color: #008000;">热加载插件</span>
<span style="color: #000000;">    ],
};</span></pre>
</div>
<p>package.json进行如下修改：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #000000;">{
  </span>"name": "webpackTest"<span style="color: #000000;">,
  </span>"version": "1.0.0"<span style="color: #000000;">,
  </span>"description": ""<span style="color: #000000;">,
  </span>"main": "index.js"<span style="color: #000000;">,
  </span>"scripts"<span style="color: #000000;">: {
    </span>"test": "echo \"Error: no test specified\" &amp;&amp; exit 1"<span style="color: #000000;">,
    </span>"start": "webpack"<span style="color: #000000;">,
    </span><span style="color: #0000ff;">"build": "set NODE_ENV=production &amp;&amp; webpack --config ./webpack.production.config.js --progress",
    </span>"server": "webpack-dev-server --open"<span style="color: #000000;">
  },
  </span>"keywords"<span style="color: #000000;">: [],
  </span>"author": ""<span style="color: #000000;">,
  </span>"license": "ISC"<span style="color: #000000;">,
  </span>"devDependencies"<span style="color: #000000;">: {
    </span>"autoprefixer": "^9.7.3"<span style="color: #000000;">,
    </span>"babel-core": "^6.26.3"<span style="color: #000000;">,
    </span>"babel-loader": "^7.1.5"<span style="color: #000000;">,
    </span>"babel-plugin-react-transform": "^3.0.0"<span style="color: #000000;">,
    </span>"babel-preset-es2015": "^6.24.1"<span style="color: #000000;">,
    </span>"babel-preset-react": "^6.24.1"<span style="color: #000000;">,
    </span>"css-loader": "^3.3.0"<span style="color: #000000;">,
    </span>"html-webpack-plugin": "^3.2.0"<span style="color: #000000;">,
    </span>"postcss-loader": "^3.0.0"<span style="color: #000000;">,
    </span>"react-transform-hmr": "^1.0.4"<span style="color: #000000;">,
    </span>"style-loader": "^1.0.1"<span style="color: #000000;">,
    </span>"webpack": "^4.41.2"<span style="color: #000000;">,
    </span>"webpack-cli": "^3.3.10"<span style="color: #000000;">,
    </span>"webpack-dev-server": "^3.9.0"<span style="color: #000000;">
  },
  </span>"dependencies"<span style="color: #000000;">: {
    </span>"react": "^16.12.0"<span style="color: #000000;">,
    </span>"react-dom": "^16.12.0"<span style="color: #000000;">
  }
}</span></pre>
</div>
<p>接下先不要进行打包，上述的webpack.production.config.js中的样式模块中使用了ExtractTextPlugin，所以我们需要对插件进行优化。</p>
<h3>优化插件</h3>
<p>webpack提供了一些在发布阶段非常有用的优化插件，它们大多来自于webpack社区，可以通过npm安装，通过以下插件可以完成产品发布阶段所需的功能：</p>
<ul>
<li>OccurenceOrderPlugin：为组件OccurenceOrderPlugin分配ID，通过这个插件webpack可以分析和优先考虑使用最多的模块，并为它们分配最小的ID</li>
<li>UglifyJsPlugin：压缩JS代码</li>
<li>ExtractTextPlugin：分离CSS和JS文件</li>
</ul>
<p>我们继续用例子来看看如何添加它们，OccurenceOrder 是内置插件，你需要做的只是安装其它非内置插件：</p>
<p>命令：npm install --save-dev extract-text-webpack-plugin@4.0.0-beta.0 uglifyjs-webpack-plugin</p>
<p>在配置文件webpack.production.config.js的plugins后引用它们:</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;"> webpack.production.config.js</span>
const webpack = require('webpack'<span style="color: #000000;">);
const HtmlWebpackPlugin </span>= require('html-webpack-plugin'<span style="color: #000000;">);
const ExtractTextPlugin </span>= require('extract-text-webpack-plugin'<span style="color: #000000;">);
const UglifyJsPlugin </span>= require('uglifyjs-webpack-plugin'<span style="color: #000000;">);
module.exports </span>=<span style="color: #000000;"> {
    devtool: </span>'null', <span style="color: #008000;">//</span><span style="color: #008000;">注意修改了这里，这能大大压缩我们的打包代码</span>
    entry:  __dirname + "/src/main.js",<span style="color: #008000;">//</span><span style="color: #008000;">唯一入口文件</span>
<span style="color: #000000;">    output: {
      path: __dirname </span>+ "/build",<span style="color: #008000;">//</span><span style="color: #008000;">打包后的文件存放的地方</span>
      filename: "bundle.js"<span style="color: #008000;">//</span><span style="color: #008000;">打包后输出文件的文件名</span>
<span style="color: #000000;">    },
    devServer: {
        contentBase: </span>"./dist",<span style="color: #008000;">//</span><span style="color: #008000;">设置本地服务器所加载的页面所在的目录</span>
        port:"8082",<span style="color: #008000;">//</span><span style="color: #008000;">设置默认监听端口，如果省略，默认为&rdquo;8080&ldquo;</span>
        historyApiFallback: <span style="color: #0000ff;">true</span>,<span style="color: #008000;">//</span><span style="color: #008000;">不跳转，在开发单页应用时非常有用，它依赖于HTML5 history API，如果设置为true，所有的跳转将指向index.html</span>
        inline: <span style="color: #0000ff;">true</span>,<span style="color: #008000;">//</span><span style="color: #008000;">是否实时刷新</span>
        hot: <span style="color: #0000ff;">true</span><span style="color: #000000;">,
    },
    module: {
        rules: [{
            test: </span>/(\.jsx|\.js)$/<span style="color: #000000;">,
            use: {
                loader: </span>"babel-loader"<span style="color: #000000;">
            },
            exclude: </span>/node_modules/<span style="color: #000000;">
        }, {
            test: </span>/\.css$/<span style="color: #000000;">,
            use: [{
                loader: </span>"style-loader"<span style="color: #000000;">
            },{
                loader: </span>"css-loader"<span style="color: #000000;">,
                options: {
                    modules: </span><span style="color: #0000ff;">true</span><span style="color: #008000;">//</span><span style="color: #008000;"> 指定启用css modules</span>
<span style="color: #000000;">                }
            },{
                loader: </span>"postcss-loader"<span style="color: #000000;">
            }]
        }]
    },
    plugins: [
        </span><span style="color: #0000ff;">new</span> webpack.BannerPlugin('版权所有，翻版必究'<span style="color: #000000;">),
        </span><span style="color: #0000ff;">new</span><span style="color: #000000;"> HtmlWebpackPlugin({
            template: __dirname </span>+ "/src/index.tmpl.html"<span style="color: #008000;">//</span><span style="color: #008000;">new 一个这个插件的实例，并传入相关的参数</span>
<span style="color: #000000;">        }),
        </span><span style="color: #0000ff;">new</span><span style="color: #000000;"> webpack.optimize.OccurrenceOrderPlugin(),
        </span><span style="color: #0000ff;">new</span> ExtractTextPlugin("style.css"<span style="color: #000000;">)
    ],
    optimization: {</span><span style="color: #008000;">//</span><span style="color: #008000;">压缩js</span>
<span style="color: #000000;">        minimizer: [
            </span><span style="color: #0000ff;">new</span><span style="color: #000000;"> UglifyJsPlugin({
                uglifyOptions: {
                    compress: </span><span style="color: #0000ff;">false</span><span style="color: #000000;">
                }
            })
        ]
    }
};</span></pre>
</div>
<p>此时执行npm run build可以看见代码是被压缩后的：</p>
<p>运行结果：</p>
<p><img src="./images/webpack入门指南（基于webpack v4.41.2）28.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;压缩后的bundle.js:</p>
<p><img src="./images/webpack入门指南（基于webpack v4.41.2）29.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3>&nbsp;缓存</h3>
<p>缓存无处不在，使用缓存的最好方法是保证你的文件名和文件内容是匹配的（内容改变，名称相应改变）。webpack可以把一个哈希值添加到打包的文件名中，使用方法如下,添加特殊的字符串混合体（[name], [id] and [hash]）到输出文件名前：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;"> webpack.production.config.js</span>
const webpack = require('webpack'<span style="color: #000000;">);
const HtmlWebpackPlugin </span>= require('html-webpack-plugin'<span style="color: #000000;">);
const ExtractTextPlugin </span>= require('extract-text-webpack-plugin'<span style="color: #000000;">);
const UglifyJsPlugin </span>= require('uglifyjs-webpack-plugin'<span style="color: #000000;">);
module.exports </span>=<span style="color: #000000;"> {
    devtool: </span>'null', <span style="color: #008000;">//</span><span style="color: #008000;">注意修改了这里，这能大大压缩我们的打包代码</span>
    entry:  __dirname + "/src/main.js",<span style="color: #008000;">//</span><span style="color: #008000;">唯一入口文件</span>
<span style="color: #000000;">    output: {
      path: __dirname </span>+ "/build",<span style="color: #008000;">//</span><span style="color: #008000;">打包后的文件存放的地方</span>
      <span style="color: #0000ff;">filename: "bundle-[hash].js"</span><span style="color: #008000;">//</span><span style="color: #008000;">打包后输出文件的文件名</span>
<span style="color: #000000;">    },
&middot;&middot;&middot;&middot;&middot;&middot;
};</span></pre>
</div>
<p>打包：npm run build</p>
<p>运行结果：</p>
<p><img src="./images/webpack入门指南（基于webpack v4.41.2）30.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;目录结构：</p>
<p><img src="./images/webpack入门指南（基于webpack v4.41.2）31.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3>&nbsp;去除<code>build</code>文件中的残余文件</h3>
<p>添加了hash之后，会导致改变文件内容后重新打包时，文件名不同而内容越来越多，因此这里介绍另外一个很好用的插件clean-webpack-plugin。</p>
<p>安装命令：npm&nbsp;install&nbsp;--save-dev clean-webpack-plugin&nbsp;</p>
<p>运行结果：</p>
<p><img src="./images/webpack入门指南（基于webpack v4.41.2）32.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;在配置文件的webpack.production.config.js中做相应配置：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;"> webpack.production.config.js</span>
const webpack = require('webpack'<span style="color: #000000;">);
const HtmlWebpackPlugin </span>= require('html-webpack-plugin'<span style="color: #000000;">);
const ExtractTextPlugin </span>= require('extract-text-webpack-plugin'<span style="color: #000000;">);
const UglifyJsPlugin </span>= require('uglifyjs-webpack-plugin'<span style="color: #000000;">);
<span style="color: #0000ff;">const { CleanWebpackPlugin } </span></span><span style="color: #0000ff;">= require('clean-webpack-plugin'</span><span style="color: #000000;"><span style="color: #0000ff;">);</span>
module.exports </span>=<span style="color: #000000;"> {
    &middot;&middot;&middot;&middot;&middot;&middot;
    plugins: [
        </span><span style="color: #0000ff;">new</span> webpack.BannerPlugin('版权所有，翻版必究'<span style="color: #000000;">),
        </span><span style="color: #0000ff;">new</span><span style="color: #000000;"> HtmlWebpackPlugin({
            template: __dirname </span>+ "/src/index.tmpl.html"<span style="color: #008000;">//</span><span style="color: #008000;">new 一个这个插件的实例，并传入相关的参数</span>
<span style="color: #000000;">        }),
        </span><span style="color: #0000ff;">new</span><span style="color: #000000;"> webpack.optimize.OccurrenceOrderPlugin(),
        </span><span style="color: #0000ff;">new</span> ExtractTextPlugin("style.css"<span style="color: #000000;">),
        </span><span style="color: #0000ff;">new</span><span style="color: #000000;"><span style="color: #0000ff;"> CleanWebpackPlugin()</span>
    ],
    &middot;&middot;&middot;&middot;&middot;&middot;
};</span></pre>
</div>
<h1>三、总结</h1>
<p>本文主要是参考网友<a href="https://segmentfault.com/u/zhangwang" target="_blank">zhangwang&nbsp;</a>的<a href="https://segmentfault.com/a/1190000006178770?utm_source=tag-newest#comment-area" target="_blank">参考2</a>这篇文章的，有些内容该参考文章中写的比我的详细一些，我相当于是按照这位网友的步骤，重新把坑又踩了一遍。下面我会把容易出坑的地方在给大家总结一下：</p>
<p>1、正式使用webpack</p>
<p>命令：npx webpack src/main.js --output dist/bundle.js</p>
<p>该命令适用于webpack4.x</p>
<p>2、Babel的安装与配置</p>
<ol>
<li>babel-loader@8+会与当前的webpack版本冲突，推荐使用babel-loader@7.1.5</li>
<li>babel-preset-es2015和babel-preset-env很有意思，大家可以研究下</li>
</ol>
<p>3、一切皆模块，资源管理 css module</p>
<p>把css-loader版本降到2.1.1之后，可以指定css的类名格式</p>
<p>卸载（删除）命令：npm uninstalll --save-dev css-loader</p>
<p>下载命令：&nbsp;npm installl --save-dev css-loader@2.1.1</p>
<p>4、产品构建阶段：</p>
<ol>
<li>package.json下scripts脚本build值，Windows下设置为"set&nbsp;NODE_ENV=production&nbsp;&amp;&amp;&nbsp;webpack&nbsp;--config&nbsp;./webpack.production.config.js&nbsp;--progress"</li>
<li>优化插件UglifyJsPlugin，webpack4+已经不是内置的，需要npm install。</li>
<li>extract-text-webpack-plugin@4.0.0-beta.0，使用这个版本，兼容webpack4+</li>
<li>去除<code>build</code>文件中的残余文件，引入定义方式为const { CleanWebpackPlugin } = require('clean-webpack-plugin')，不要用const&nbsp; CleanWebpackPlugin&nbsp; = require('clean-webpack-plugin')，并注意plugins。</li>
</ol>

</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>