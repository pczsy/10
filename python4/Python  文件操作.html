<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修Python  文件操作' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>Python  文件操作</center></div><div class='banquan'>原文出处:本文由博客园博主chenhongyong提供。<br/>
原文连接:https://www.cnblogs.com/chy18883701161/p/11298029.html</div><br>
    <p>&nbsp;</p>
<h2>使用os模块操作文件本身</h2>
<table style="height: 858px; width: 800px;" border="0">
<tbody>
<tr>
<td>
<h3 style="text-align: left;">函数　　　　　　　　　　　　</h3>
</td>
<td>
<h3>描述</h3>
</td>
</tr>
<tr>
<td>
<p>os.unlink(filePath)</p>
</td>
<td>
<p>删除文件</p>
</td>
</tr>
<tr>
<td>
<p>os.remove(filePath)</p>
</td>
<td>
<p>同上</p>
</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>
<p>os.rmdir(dirPath)</p>
</td>
<td>
<p>删除文件夹，必须要是空文件夹才能删除</p>
</td>
</tr>
<tr>
<td>
<p>os.removedirs(dirPath)</p>
</td>
<td>
<p>&nbsp;同上</p>
</td>
</tr>
<tr>
<td>
<p>&nbsp;</p>
</td>
<td>
<p>&nbsp;</p>
</td>
</tr>
<tr>
<td>
<p>os.rename(oldPath,newPath)</p>
</td>
<td>
<p>重命名文件、文件夹。要求2个路径只有文件名部分不同，其余要相同。若目标已存在，会报错。</p>
</td>
</tr>
<tr>
<td>
<p>os.renames(oldPath,newPath)</p>
</td>
<td>
<p>同上</p>
</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>
<p>os.mkdir(dirPath)</p>
</td>
<td>
<p>创建文件夹。如果文件夹已存在，会报错；如果前面的路径不存在，会报错。</p>
</td>
</tr>
<tr>
<td>
<p>os.makedirs(dirPath)</p>
</td>
<td>
<p>递归创建文件夹。如果前面的路径不存在，会自动创建。</p>
</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>
<p>os.listdir(dirPath)</p>
</td>
<td>
<p>列出该文件夹下的所有子文件夹，以列表形式返回。只列出子文件夹，不会列出文件、后代文件夹。可用于遍历。</p>
</td>
</tr>
<tr>
<td>
<p>&nbsp;</p>
</td>
<td>
<p>&nbsp;</p>
</td>
</tr>
<tr>
<td>
<p>os.chdir(dirPath)</p>
</td>
<td>
<p>&nbsp;切换到指定目录</p>
</td>
</tr>
<tr>
<td>
<p>os.getcwd()</p>
</td>
<td>
<p>&nbsp;获取当前目录（注意是目录）的绝对路径。</p>
<p>如果之前用chdir()切换了路径，此函数得到的是目标路径。</p>
</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>
<p>os.path.getsize(filePath)　　　　　　　　　　</p>
</td>
<td>
<p>返回文件大小（字节数）</p>
</td>
</tr>
<tr>
<td>
<p>os.path.exists(path)</p>
</td>
<td>
<p>检测文件|文件夹是否存在，返回bool值。</p>
<p>这2个方法是path子模块的方法。</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>没有新建文件的方法，但可以通过打开文件来新建文件：打开文件时指定打开模式是&nbsp; 文件不存在时自动创建的模式，这样就能新建文件了。</p>
<p>path均为路径，字符串形式。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>使用os模块实现文件读写</h2>
<table style="height: 745px; width: 832px;" border="0">
<tbody>
<tr>
<td>
<h3>函数</h3>
</td>
<td>
<h3>描述</h3>
</td>
</tr>
<tr>
<td>
<p>os.open(filePath,mode)　　　　　　　　　　　　　　</p>
</td>
<td>
<p>打开文件,返回文件描述符（常用fd表示）。常用的mode：</p>
<ul>
<li>
<p>os.O_RDONLY:&nbsp;只读</p>
</li>
<li>
<p>os.O_WRONLY:&nbsp;只写</p>
</li>
<li>
<p>os.O_RDWR :&nbsp;读写</p>
</li>
<li>
<p>os.O_APPEND:&nbsp;追加</p>
</li>
<li>
<p>os.O_CREAT: 新建然后打开</p>
</li>
<li>
<p>os.O_FSYNC :&nbsp;同步写入</p>
</li>
</ul>
</td>
</tr>
<tr>
<td><span class="pln">os<span class="pun">.<span class="pln">fdopen<span class="pun">(<span class="pln">fd<span class="pun">,<span class="pln"> <span class="pun">[,<span class="pln"> mode<span class="pun">[,<span class="pln"> bufsize<span class="pun">]]);</span><span class="pun">　　　　　　　　&nbsp; &nbsp;&nbsp;</span></span></span></span></span></span></span></span></span></span></span></span></td>
<td>
<p>此方法是内置函数open()&nbsp;的别名。</p>
<p>mode&nbsp;-- 可选，和 Python 内置的 open()函数的mode参数一样，可以是r,w,a,r+,w+,a+...</p>
<p>bufsize<strong>&nbsp;</strong>-- 可选，指定返回的文件对象是否带缓冲：bufsize=0，表示没有带缓冲；bufsize=1，表示该文件对象是行缓冲的；bufsize=正数，表示使用一个指定大小的缓冲冲，单位为byte，但是这个大小不是精确的；bufsize=负数，表示使用一个系统默认大小的缓冲，缺省时使用系统默认大小的缓冲。</p>
</td>
</tr>
<tr>
<td>
<p>&nbsp;</p>
<p class="prettyprint prettyprinted"><span class="pln">os<span class="pun">.<span class="pln">read<span class="pun">(<span class="pln">fd<span class="pun">,<span class="pln">n<span class="pun">)</span></span></span></span></span></span></span></span></p>
</td>
<td>
<p>&nbsp;fd：文件描述符，n:最多读取的字节数</p>
<p>返回读取到的字符串</p>
</td>
</tr>
<tr>
<td>
<p>&nbsp;</p>
<p class="prettyprint prettyprinted"><span class="pln">os<span class="pun">.<span class="pln">write<span class="pun">(<span class="pln">fd<span class="pun">,<span class="pln"> bytes<span class="pun">)</span></span></span></span></span></span></span></span></p>
</td>
<td>
<p>写入一个字符串。返回实际写入字符串的长度。</p>
<p>要以字节、字节数组的形式写入。</p>
<p>示例：bytes("ok","utf-8")&nbsp; &nbsp;将字符串转换为字节</p>
</td>
</tr>
<tr>
<td>
<p class="prettyprint prettyprinted"><span class="pln">os<span class="pun">.<span class="pln">lseek<span class="pun">(<span class="pln">fd<span class="pun">,<span class="pln"> pos<span class="pun">,<span class="pln"> how<span class="pun">)</span></span></span></span></span></span></span></span></span></span></p>
</td>
<td>
<p>设置文件指针的当前位置。</p>
<p>第三个参数是参考点，SEEK_SET 或 0 表示文件头; SEEK_CUR或 1 表示当前位置; os.SEEK_END或2表示文件尾。</p>
<p>第二个参数制定相对参考点的偏移量</p>
</td>
</tr>
<tr>
<td>
<p>&nbsp;os.close(fd)</p>
</td>
<td>
<p>&nbsp;关闭文件</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3>写入示例：</h3>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">import</span><span style="color: #000000;"> os
fd</span>=os.open(<span style="color: #800000;">"</span><span style="color: #800000;">1.txt</span><span style="color: #800000;">"</span><span style="color: #000000;">,os.O_RDWR)
os.write(fd,bytes(</span><span style="color: #800000;">"hello</span><span style="color: #800000;">\nworld</span><span style="color: #800000;">"</span>,<span style="color: #800000;">"</span><span style="color: #800000;">utf-8</span><span style="color: #800000;">"</span><span style="color: #000000;">))
os.close(fd)</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3>读取示例：</h3>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">import</span><span style="color: #000000;"> os
fd</span>=os.open(<span style="color: #800000;">"</span><span style="color: #800000;">1.txt</span><span style="color: #800000;">"</span><span style="color: #000000;">,os.O_RDWR)
bytes</span>=os.read(fd,1024)  <span style="color: #008000;">#</span><span style="color: #008000;">返回的是字节形式</span>
<span style="color: #0000ff;">print</span>(bytes.decode(<span style="color: #800000;">"</span><span style="color: #800000;">utf-8</span><span style="color: #800000;">"</span>))    <span style="color: #008000;">#</span><span style="color: #008000;">解码，将读取到的字节转换为字符串</span>
os.close(fd)</pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>使用python的内置函数实现文件读写</h2>
<h3>使用open()函数打开文件，创建文件对象</h3>
<div class="cnblogs_code">
<pre><code>f=open(file[, mode])</pre>
</div>
<p>&nbsp;</p>
<p>mode常用的值：</p>
<table class="reference" style="height: 608px; width: 695px;">
<tbody>
<tr><th>模式&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</th><th>描述</th></tr>
<tr>
<td>
<p>r</p>
</td>
<td>
<p>只读。缺省mode时默认为r。以r开头的：指针放在文件头，若文件不存在，会报错。</p>
</td>
</tr>
<tr>
<td>
<p>rb</p>
</td>
<td>
<p>只读，打开二进制文件。</p>
</td>
</tr>
<tr>
<td>
<p>r+</p>
</td>
<td>
<p>读写</p>
</td>
</tr>
<tr>
<td>
<p>rb+</p>
</td>
<td>
<p>读写，打开二进制文件</p>
</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>
<p>w</p>
</td>
<td>
<p>只写。以w开头的：指针放在文件头，如果文件不存在，会自动创建。</p>
</td>
</tr>
<tr>
<td>
<p>wb</p>
</td>
<td>
<p>只写，打开二进制文件</p>
</td>
</tr>
<tr>
<td>
<p>w+</p>
</td>
<td>
<p>读写</p>
</td>
</tr>
<tr>
<td>
<p>wb+</p>
</td>
<td>
<p>读写，打开二进制文件</p>
</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>
<p>a</p>
</td>
<td>
<p>追加。以a开头的：指针放在文件尾，如果文件不存在，会自动创建。</p>
</td>
</tr>
<tr>
<td>
<p>ab</p>
</td>
<td>
<p>追加，打开二进制文件</p>
</td>
</tr>
<tr>
<td>
<p>a+</p>
</td>
<td>
<p>追加，可读写。</p>
</td>
</tr>
<tr>
<td>
<p>ab+</p>
</td>
<td>
<p>追加，可读写，打开二进制文件</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>写不是先清空原有内容，再写入，而是直接覆盖。</p>
<p>比如原来的内容是&ldquo;hello wolrd&rdquo;，写入一个&ldquo;ok&rdquo;，变为&ldquo;okllo world&rdquo;。</p>
<p>写入的内容比原来的长，才会覆盖完。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3>file 对象</h3>
<p>使用open()打开文件后，会返回一个file对象，表示文件本身。 file 对象常用的方法：</p>
<table class="reference" style="height: 680px; width: 782px;">
<tbody>
<tr><th>函数　　　　　　</th><th style="text-align: left;">描述</th></tr>
<tr>
<td>
<p>file.flush()</p>
</td>
<td>
<p>把内部缓冲区的数据立刻写入文件</p>
</td>
</tr>
<tr>
<td>
<p>file.close()</p>
</td>
<td>
<p>&nbsp;关闭文件</p>
</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>
<p>file.read([size])</p>
</td>
<td>
<p>读取指定的字节数，缺省size或size为负数时，会读取所有内容。</p>
<p>如果是文本文件，返回读取的字符串（如果读取到的是空串，说明已到文件尾）；如果是二进制文件，返回读取到的字节。</p>
</td>
</tr>
<tr>
<td>
<p>file.readline()</p>
</td>
<td>
<p>读取一行，以字符串（如果读取到的是空串，说明已到文件尾）或字节形式返回。</p>
</td>
</tr>
<tr>
<td>
<p>file.readlines()</p>
</td>
<td>
<p>读取所有行，以字符串列表或字节列表形式返回。</p>
</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>
<p>file.write(str)</p>
</td>
<td>
<p>&nbsp;写入一个字符串，返回实际写入的字符数（注意是字符数）</p>
</td>
</tr>
<tr>
<td>
<p>file.writelines(list|tuple)　　　　　　　　</p>
</td>
<td>
<p>写入一个字符串列表|元组，元素必须是字符串。</p>
<p>写完一个元素后，会在后面接着写，不会自动换行。如果要换行，需要自己加"\n"</p>
</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>
<p>file.tell()</p>
</td>
<td>
<p>返回文件指针的当前位置（从文件头开始的字节数）</p>
</td>
</tr>
<tr>
<td>
<p>file.seek(offset[, whence])　　&nbsp;&nbsp;</p>
</td>
<td>
<p>设置文件指针的当前位置。</p>
<p>offset表示偏移量，int型，默认以字符为单位。</p>
<p>whence表示参考点,有3个可用的值：</p>
<p>0&nbsp; &nbsp;文件头</p>
<p>1&nbsp; &nbsp;当前位置（默认）</p>
<p>2&nbsp; &nbsp; 文件尾</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>读|写的时候，文件指针会自动后移。</p>
<p>如果以文本文件的方式打开（不带b），则读取时返回字符串|字符串列表，写入时只能写入字符串。</p>
<p>如果以二进制的形式打开（带b），则读取时返回字节，写入时可以写入任何类型（底层都是字节）。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3>读取示例：</h3>
<div class="cnblogs_code">
<pre><code>f=open(<span style="color: #800000;">"</span><span style="color: #800000;">1.txt</span><span style="color: #800000;">"</span>,<span style="color: #800000;">"</span><span style="color: #800000;">r+</span><span style="color: #800000;">"</span><span style="color: #000000;">)
</span><span style="color: #008000;">#</span><span style="color: #008000;">str=f.read(1024)  #读指定的字节数</span><span style="color: #008000;">
#</span><span style="color: #008000;">str=f.readline()  #读一行</span>
str=f.readlines()  <span style="color: #008000;">#</span><span style="color: #008000;">全读完，作为列表返回，一行一个元素</span>
<span style="color: #0000ff;">print</span><span style="color: #000000;">(str)
f.close()</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3>写入示例：</h3>
<div class="cnblogs_code">
<pre><code>f=open(<span style="color: #800000;">"</span><span style="color: #800000;">1.txt</span><span style="color: #800000;">"</span>,<span style="color: #800000;">"</span><span style="color: #800000;">r+</span><span style="color: #800000;">"</span><span style="color: #000000;">)
f.write(</span><span style="color: #800000;">"</span><span style="color: #800000;">hello</span><span style="color: #800000;">"</span>)   <span style="color: #008000;">#</span><span style="color: #008000;">从头开始覆盖（不是先清空原有内容，再写入，是直接从头开始写，可能覆盖不完）</span>
f.close()</pre>
</div>
<p>&nbsp;</p>
<h3>&nbsp;</h3>
<h3>&nbsp;</h3>
<p>&nbsp;</p>
<h2>pickle 模块</h2>
<p>pickle模块可以实现数据的序列化和反序列化。</p>
<p>&nbsp;</p>
<h3>1、序列化：将数据存储到文件中</h3>
<div class="cnblogs_code">
<pre><code>pickle.dump(对象|变量|值, 文件对象)</pre>
</div>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">import</span><span style="color: #000000;"> pickle
file</span>=open(<span style="color: #800000;">"</span><span style="color: #800000;">1.txt</span><span style="color: #800000;">"</span>,<span style="color: #800000;">"</span><span style="color: #800000;">wb</span><span style="color: #800000;">"</span><span style="color: #000000;">)
str</span>=<span style="color: #800000;">"</span><span style="color: #800000;">hello</span><span style="color: #800000;">"</span><span style="color: #000000;">
list</span>=[1,2,3<span style="color: #000000;">]
pickle.dump(</span><span style="color: #800000;">"</span><span style="color: #800000;">ok</span><span style="color: #800000;">"</span><span style="color: #000000;">,file)  
pickle.dump(str,file)  #可同时序列化多个数据
pickle.dump(</span>1,file)  <span style="color: #008000;">#</span><span style="color: #008000;">需要以二进制形式打开文件。以文本文件形式打开，只能写入字符串类型，不能写入其他类型。</span>
<span style="color: #000000;">pickle.dump(list,file)
file.close()</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3 class="prettyprint prettyprinted"><span class="pln">2、反序列化：从文件中读取数据，将数据还原</span></h3>
<div class="cnblogs_code">
<pre><code>x = pickle.load(文件对象)</pre>
</div>
<pre class="prettyprint prettyprinted"><span class="pln"><span class="pun"><span class="pln"><span class="pun"><span class="pln"><span class="pun"><span class="pln"><span class="pun">&nbsp;</span></span></span></span></span></span></span></span></pre>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">import</span><span style="color: #000000;"> pickle
file</span>=open(<span style="color: #800000;">"</span><span style="color: #800000;">1.txt</span><span style="color: #800000;">"</span>,<span style="color: #800000;">"</span><span style="color: #800000;">rb</span><span style="color: #800000;">"</span>)   <span style="color: #008000;">#</span><span style="color: #008000;">如果只有字符串，可以以文本文件形式打开；如果有其他类型的，就必须以二进制形式打开，否则反序列化会出错</span>
a=<span style="color: #000000;">pickle.load(file)  
b</span>=<span style="color: #000000;">pickle.load(file)
c</span>=<span style="color: #000000;">pickle.load(file)
d</span>=<span style="color: #000000;">pickle.load(file)
</span><span style="color: #0000ff;">print</span>(a,b,c,d)    <span style="color: #008000;">#</span><span style="color: #008000;">ok hello 1 [1, 2, 3]   反序列化的顺序和序列化的顺序一致</span>
file.close()</pre>
</div>
<p>&nbsp;</p>
<pre class="prettyprint prettyprinted"></pre>
<div class="example">&nbsp;</div>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>