<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修python装饰器' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>python装饰器</center></div><div class='banquan'>原文出处:本文由博客园博主wind1234567提供。<br/>
原文连接:https://www.cnblogs.com/addswanmei/p/11215197.html</div><br>
    <p>1.什么是装饰器</p>
<p>　　装饰器(Decorators)是 Python 的一个重要部分。装饰器本质是函数（具有特定功能的函数），装饰器的功能就是装饰其他函数，也就是为其他函数添加一些附属功能。</p>
<p>2.装饰器原则</p>
<p>　　a.不能修改被装饰函数的源代码。</p>
<p>　　b.不能修改被装饰函数的调用方式。（装饰器对于被装饰函数来说是透明的）</p>
<p>3.预备知识：</p>
<p>　　a.函数即&ldquo;变量&rdquo;。</p>
<p>　　b.高阶函数</p>
<p>　　　　（1）把一个函数名当做实参传递给另一个函数</p>
<p>　　　　（2）返回值中包含函数名。</p>
<p>　　c.嵌套函数</p>
<p>　　装饰器=高阶函数+嵌套函数</p>
<p>4.实例</p>
<p><span style="background-color: #ffffff;">　　假设我们现在有两个函数。</span></p>
<pre><code><span style="background-color: #ffffff; color: #0000ff;"><strong>def a():　　　　　　　　</strong></span><br /><span style="background-color: #ffffff; color: #0000ff;"><strong>    print("aaa")</strong></span><br /><span style="background-color: #ffffff; color: #0000ff;"><strong>def b():</strong></span><br /><span style="background-color: #ffffff; color: #0000ff;"><strong>    print("bbb")</strong></span><br /><span style="background-color: #ffffff; color: #0000ff;"><strong>a()</strong></span><br /><span style="background-color: #ffffff; color: #0000ff;"><strong>b()</strong></span><br /><br /><strong><span style="color: #ff0000;">输出结果</span></strong>分别是aaa和bbb　　　　　　　　　　</pre>
<hr />
<pre><code>　　如果我们要给两个函数添加打印日志的功能该怎么做呢？可以是下面这种做法。<br /><span style="color: #0000ff; background-color: #ffffff;">　　<strong>def a():</strong></span><br /><strong><span style="color: #0000ff; background-color: #ffffff;">　　　　　print("aaa")</span></strong><br /><strong><span style="color: #0000ff; background-color: #ffffff;">　　　　　print("打印日志")</span></strong></pre>
<pre><code><span style="color: #0000ff; background-color: #ffffff;"><strong>　　def b():</strong><br /><strong>    　　　print("bbb")</strong><br /><strong>    　　　print("打印日志")</strong><br /></span>　　<strong><span style="color: #ff0000;">执行结果</span></strong>为：<br />　　<span style="background-color: #ffffff; color: #0000ff;"><strong><span style="text-decoration: underline;"><em>aaa
</em></span>　　<span style="text-decoration: underline;"><em>打印日志
</em></span>　　<span style="text-decoration: underline;"><em>bbb
</em></span>　　</strong></span><span style="text-decoration: underline;"><em><span style="background-color: #ffffff; color: #0000ff; text-decoration: underline;"><strong>打印日志</strong></span><br /></em></span></pre>
<hr />
<pre><code>　　但是在实际的生产环境中，a和b函数正在运行一些功能，那我们如何通过不修改其源代码的情况下给它增加打印日志的功能呢？<br />　　我们可以通过高阶函数来对其进行装饰。<br />　　<br />　　　<strong><span style="color: #0000ff; background-color: #ffffff;">def decorators(func): </span></strong><br /><strong><span style="color: #0000ff; background-color: #ffffff;">　　　　　　func（）</span></strong><br /><strong><span style="color: #0000ff; background-color: #ffffff;">　　　　　　print("打印日志")</span></strong><br /><strong><span style="color: #0000ff; background-color: #ffffff;">　　　　　　return func</span></strong><br /><strong><span style="color: #0000ff; background-color: #ffffff;">　　　def a():<br />　　　　　　<em id="__mceDel"><em id="__mceDel"><em id="__mceDel">print("aaa")<br />　　　</em></em></em><em id="__mceDel"><em id="__mceDel"><em id="__mceDel"><em id="__mceDel"><em id="__mceDel">def b():<br />　　　　　　</em></em></em></em></em><em id="__mceDel"><em id="__mceDel"><em id="__mceDel"><em id="__mceDel"><em id="__mceDel"><em id="__mceDel">print("bbb")</em></em></em></em></em></em></span></strong></pre>
<pre><code><strong><span style="color: #0000ff; background-color: #ffffff;"><em id="__mceDel"><em id="__mceDel"><em id="__mceDel"><em id="__mceDel"><em id="__mceDel"><em id="__mceDel">　　a = decorators(a)<br />　　b = decorators(b)<br /></em></em></em></em></em></em>　　a()</span></strong><br /><strong><span style="color: #0000ff; background-color: #ffffff;">　　b()<br /></span></strong>　　如上，我们可以通过高阶函数来对其进行装饰，但是有点小问题，它的运行结果并不是我们想要的。<strong><span style="color: #ff0000;">其运行结果如下；</span></strong><br />　　<strong><span style="color: #0000ff; background-color: #ffffff;"><span style="text-decoration: underline;"><em>aaa
</em></span></span></strong>　　<strong><span style="color: #0000ff; background-color: #ffffff;"><span style="text-decoration: underline;"><em>打印日志
</em></span></span></strong>　　<strong><span style="color: #0000ff; background-color: #ffffff;"><span style="text-decoration: underline;"><em>bbb
</em></span></span></strong>　　<strong><span style="color: #0000ff; background-color: #ffffff;"><span style="text-decoration: underline;"><em>打印日志
</em></span></span></strong>　　<strong><span style="color: #0000ff; background-color: #ffffff;"><span style="text-decoration: underline;"><em>aaa
</em></span></span></strong>　　<strong><span style="color: #0000ff; background-color: #ffffff;"><span style="text-decoration: underline;"><em>bbb</em></span><br /></span></strong>　　</pre>
<hr />
<pre><code>　　因为<strong><span style="color: #ff0000;">函数装饰器由高阶函数和嵌套函数组成</span></strong>，所以我们可以对如上代码进行一定的修改。</pre>
<pre><code><span style="background-color: #ffffff;"><strong><span style="color: #0000ff;">def decorators(func):</span></strong></span><br /><span style="background-color: #ffffff;"><strong><span style="color: #0000ff;">    def decorators_():</span></strong></span><br /><span style="background-color: #ffffff;"><strong><span style="color: #0000ff;">        func()</span></strong></span><br /><span style="background-color: #ffffff;"><strong><span style="color: #0000ff;">        print("打印日志")</span></strong></span><br /><span style="background-color: #ffffff;"><strong><span style="color: #0000ff;">    return decorators_</span></strong></span><br /><span style="background-color: #ffffff;"><strong><span style="color: #0000ff;">def a():</span></strong></span><br /><span style="background-color: #ffffff;"><strong><span style="color: #0000ff;">    print("aaa")</span></strong></span><br /><span style="background-color: #ffffff;"><strong><span style="color: #0000ff;">def b():</span></strong></span><br /><span style="background-color: #ffffff;"><strong><span style="color: #0000ff;">    print("bbb")</span></strong></span><br /><span style="background-color: #ffffff;"><strong><span style="color: #0000ff;">a = decorators(a)</span></strong></span><br /><span style="background-color: #ffffff;"><strong><span style="color: #0000ff;">b = decorators(b)</span></strong></span><br /><span style="background-color: #ffffff;"><strong><span style="color: #0000ff;">a()</span></strong></span><br /><span style="background-color: #ffffff;"><strong><span style="color: #0000ff;">b()</span></strong></span><br />如上我们在decorators函数中嵌套了一个函数，嵌套的函数来执行装饰效果。<strong><span style="color: #ff0000;">执行结果如下：</span></strong><br /><span style="text-decoration: underline; color: #0000ff;"><em><strong>aaa
打印日志
bbb
打印日志</strong></em></span><br /><br /></pre>
<hr />
<pre><code>　　如上代码实现了简单的装饰器的效果。但是在调用执行的时候，需要先调用装饰器，然后将装饰器执行的结果返回来，再调用执行。这样显得很是麻烦。<br />python中提供了&ldquo;@语法糖&rdquo;，可以让我们省略装饰器返回的执行结果的重新赋值。也就是可以省略如上代码中的<strong><span style="color: #0000ff;">a = decorators(a)和</span></strong><em id="__mceDel"><span><strong><span style="color: #0000ff;">b = decorators(b)</span></strong></span></em>。代码如下</pre>
<pre><code><strong><span style="color: #0000ff;">def decorators(func):</span></strong><br /><strong><span style="color: #0000ff;">    def decorators_():</span></strong><br /><strong><span style="color: #0000ff;">        func()</span></strong><br /><strong><span style="color: #0000ff;">        print("打印日志")</span></strong><br /><strong><span style="color: #0000ff;">    return decorators_</span></strong><br /><strong><span style="color: #0000ff;">@decorators</span></strong><br /><strong><span style="color: #0000ff;">def a():</span></strong><br /><strong><span style="color: #0000ff;">    print("aaa")</span></strong><br /><strong><span style="color: #0000ff;">@decorators</span></strong><br /><strong><span style="color: #0000ff;">def b():</span></strong><br /><strong><span style="color: #0000ff;">    print("bbb")</span></strong><br /><strong><span style="color: #0000ff;">a()</span></strong><br /><strong><span style="color: #0000ff;">b()</span></strong><br />上述代码的<strong><span style="color: #ff0000;">执行结果如下：</span></strong><br /><strong><span style="text-decoration: underline; color: #0000ff;"><em>aaa
打印日志
bbb
打印日志<br /></em></span></strong></pre>
<hr />
<pre><code>但是有时候我们的函数是有参数的，因为<strong><span style="color: #0000ff;">@decorators</span></strong>，本质上等于<span style="color: #ff0000;">a = decorators_（a）</span>，所以我们在传参数的时候，只需要将参数传递给decorators_这个函数就行。修改后代码如下:</pre>
<pre><code><br /><strong><span style="color: #0000ff; background-color: #ffffff;">def decorators(func):</span></strong><br /><strong><span style="color: #0000ff; background-color: #ffffff;">    def decorators_(*args,**kwargs):</span></strong><br /><strong><span style="color: #0000ff; background-color: #ffffff;">        func(*args,**kwargs)</span></strong><br /><strong><span style="color: #0000ff; background-color: #ffffff;">        print("打印日志")</span></strong><br /><strong><span style="color: #0000ff; background-color: #ffffff;">    return decorators_</span></strong><br /><strong><span style="color: #0000ff; background-color: #ffffff;">@decorators</span></strong><br /><strong><span style="color: #0000ff; background-color: #ffffff;">def a(parameter_1,parameter_2):</span></strong><br /><strong><span style="color: #0000ff; background-color: #ffffff;">    print("aaa",parameter_1,parameter_2)</span></strong><br /><strong><span style="color: #0000ff; background-color: #ffffff;">@decorators</span></strong><br /><strong><span style="color: #0000ff; background-color: #ffffff;">def b(parameter_1,parameter_2):</span></strong><br /><strong><span style="color: #0000ff; background-color: #ffffff;">    print("bbb",parameter_1,parameter_2)</span></strong><br /><strong><span style="color: #0000ff; background-color: #ffffff;">a("aaa",3333)</span></strong><br /><strong><span style="color: #0000ff; background-color: #ffffff;">b("bbb",4444)</span></strong><br />如上，<strong><span style="color: #ff0000;">运行结果为：</span></strong></pre>
<p>　　<span style="text-decoration: underline;"><em><strong><span style="color: #0000ff; text-decoration: underline;">aaa aaa 3333</span></strong></em></span><br />　　<span style="text-decoration: underline;"><em><strong><span style="color: #0000ff; text-decoration: underline;">打印日志</span></strong></em></span><br />　　<span style="text-decoration: underline;"><em><strong><span style="color: #0000ff; text-decoration: underline;">bbb bbb 4444</span></strong></em></span><br />　　<span style="text-decoration: underline;"><em><strong><span style="color: #0000ff; text-decoration: underline;">打印日志</span></strong></em></span></p>
<p>如上，我们便完成了基本的装饰器。</p>
<p><strong><span style="color: #ff0000;">装饰器的工作原理</span></strong>：以上述代码为例，首先查看我们的decorators函数，它接受一个参数，也就是函数名，在decorators内部又嵌套了一个函数decorators_，该函数接受由被修饰函数传进来的参数，然后再调用被修饰函数，然后再执行打印日志（也就是修饰器的功能），decorators函数的返回值其实就是decorators_。</p>
<p>　　再来看我们的被修饰函数，以a（）为例，当python解释器遇到@decorators时，就会去调用执行decorators函数，@decorators相当于前面说的<em id="__mceDel" style="font-family: 'Courier New'; font-size: 12px;">a = decorators_（a）。</em>然后经过decorators_的修饰后，decorators的返回值赋值给了a，此时a是已经被修饰过了的，此时的a指向了decorators的内嵌函数decorators_的地址，然后我们再执行a（）就是相当于调用的是decorators.decorators_，执行完成后，便完成了对a（）函数的修饰。</p>
<hr />
<p>&nbsp;</p>
<pre><code>类装饰器</pre>
<pre><code><br /><strong><span style="color: #0000ff; background-color: #ffffff;">class Test(object):</span></strong><br /><strong><span style="color: #0000ff; background-color: #ffffff;">    def __init__(self, func):</span></strong><br /><strong><span style="color: #0000ff; background-color: #ffffff;">        print('test init')</span></strong><br /><strong><span style="color: #0000ff; background-color: #ffffff;">        print('func name is %s ' % func.__name__)</span></strong><br /><strong><span style="color: #0000ff; background-color: #ffffff;">        self.__func = func</span></strong><br />        <br /><strong><span style="color: #0000ff; background-color: #ffffff;">    def __call__(self, *args, **kwargs):</span></strong><br /><strong><span style="color: #0000ff; background-color: #ffffff;">        print('打印日志')</span></strong><br /><strong><span style="color: #0000ff; background-color: #ffffff;">        self.__func()</span></strong><br /><strong><span style="color: #0000ff; background-color: #ffffff;">@Test</span></strong><br /><strong><span style="color: #0000ff; background-color: #ffffff;">def test():</span></strong><br /><strong><span style="color: #0000ff; background-color: #ffffff;">    print("aaa")</span></strong><br /><strong><span style="color: #0000ff; background-color: #ffffff;">test()</span></strong><br /><strong><span style="color: #ff0000;">执行结果如下：</span></strong></pre>
<p>　　test init<br />　　func name is test <br />　　打印日志<br />　　aaa</p>
<pre><code><br /><br /><br /></pre>
<pre><code><br /><br /><br /></pre>
<pre><code>　　<br />　　</pre>
<pre><code>　　<span style="text-decoration: underline;"><em><br /></em></span></pre>
<pre><code></pre>
<p>&nbsp;</p>
<p>　　</p>
<p>&nbsp;</p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>