<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修继承' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>继承</center></div><div class='banquan'>原文出处:本文由博客园博主626提供。<br/>
原文连接:https://www.cnblogs.com/fengqiang626/p/11309623.html</div><br>
    <div class="toc">
    <p class="toc-title">目录</p>
    <div class="toc-list">
        <ul>
        <li><a href="#什么面向对象的继承">1.什么面向对象的继承？</a></li>
        <li><a href="#继承的分类">2.继承的分类</a></li>
        <li><a href="#单继承">3.单继承</a><ul>
        <li><a href="#类名对象执行父类方法">3.1 类名，对象执行父类方法</a></li>
        <li><a href="#执行顺序">3.2 执行顺序</a></li>
        <li><a href="#同时执行类以及父类方法">3.3同时执行类以及父类方法</a></li>
        </ul></li>
        <li><a href="#多继承">4.多继承</a><ul>
        <li><a href="#经典类的多继承">4.1经典类的多继承</a></li>
        </ul></li>
        </ul>
    </div>
</div>
<h2 id="什么面向对象的继承">1.什么面向对象的继承？</h2>
<p>比较官方的说法就是：</p>
<p>继承（英语：inheritance）是面向对象软件技术当中的一个概念。如果一个类别A“继承自”另一个类别B，就把这个A称为“B的子类别”，而把B称为“A的父类别”也可以称“B是A的超类”。继承可以使得子类别具有父类别的各种属性和方法，而不需要再次编写相同的代码。</p>
<p>那么用一个例子来看一下继承：</p>
<pre><code><code>class Person:
    def __init__(self,name,sex,age):
        self.name = name
        self.age = age
        self.sex = sex

class Cat:
    def __init__(self,name,sex,age):
        self.name = name
        self.age = age
        self.sex = sex

class Dog:
    def __init__(self,name,sex,age):
        self.name = name
        self.age = age
        self.sex = sex

# 继承的用法：
class Aniaml(object):
    def __init__(self,name,sex,age):
            self.name = name
            self.age = age
            self.sex = sex

class Person(Aniaml):
    pass

class Cat(Aniaml):
    pass

class Dog(Aniaml):
    pass</code></pre>
<p>继承的有点也是显而易见的：</p>
<p>1，增加了类的耦合性（耦合性不宜多，宜精）。</p>
<p>2，减少了重复代码。</p>
<p>3，使得代码更加规范化，合理化。</p>
<h2 id="继承的分类">2.继承的分类</h2>
<p>就向上面的例子：</p>
<p>Aminal 叫做父类,基类,超类。<br />
Person Cat Dog: 子类，派生类。<br />
继承：可以分<strong>单继承，多继承</strong>。</p>
<p>这里需要补充一下python中类的种类（继承需要）：</p>
<p>在python2x版本中存在两种类.：<br />
　　⼀个叫<strong>经典类</strong>. 在python2.2之前. ⼀直使⽤的是经典类. 经典类在基类的根如果什么都不写.<br />
　　⼀个叫<strong>新式类</strong>. 在python2.2之后出现了新式类. 新式类的特点是基类的根是object类。<br />
python3x版本中只有一种类：<br />
python3中使⽤的都是<strong>新式类</strong>. 如果基类谁都不继承. 那这个类会默认继承 object</p>
<h2 id="单继承">3.单继承</h2>
<h3 id="类名对象执行父类方法">3.1 类名，对象执行父类方法</h3>
<p><strong>类名，对象分别调用父类方法</strong></p>
<pre><code><code>class Aniaml(object):
    type_name = &#39;动物类&#39;

    def __init__(self,name,sex,age):
            self.name = name
            self.age = age
            self.sex = sex

    def eat(self):
        print(self)
        print(&#39;吃东西&#39;)

class Person(Aniaml):
    pass

class Cat(Aniaml):
    pass

class Dog(Aniaml):
    pass
# 类名：
print(Person.type_name)  # 可以调用父类的属性，方法。
Person.eat(111)
print(Person.type_name)

# 对象：
# 实例化对象
p1 = Person(&#39;春哥&#39;,&#39;男&#39;,18)
print(p1.__dict__)
# 对象执行类的父类的属性，方法。
print(p1.type_name)
p1.type_name = &#39;666&#39;
print(p1)
p1.eat()</code></pre>
<h3 id="执行顺序">3.2 执行顺序</h3>
<pre><code><code>class Aniaml(object):
    type_name = &#39;动物类&#39;
    def __init__(self,name,sex,age):
            self.name = name
            self.age = age
            self.sex = sex

    def eat(self):
        print(self)
        print(&#39;吃东西&#39;)

class Person(Aniaml):
    
    def eat(self):
        print(&#39;%s 吃饭&#39;%self.name)
        
class Cat(Aniaml):
    pass

class Dog(Aniaml):
    pass

p1 = Person(&#39;barry&#39;,&#39;男&#39;,18)
# 实例化对象时必须执行__init__方法,类中没有，从父类找，父类没有，从object类中找。
p1.eat()
# 先要执行自己类中的eat方法，自己类没有才能执行父类中的方法。</code></pre>
<p>执行顺序</p>
<h3 id="同时执行类以及父类方法">3.3同时执行类以及父类方法</h3>
<p>方法一：</p>
<p>如果想执行父类的func方法，这个方法并且子类中夜用，那么就在子类的方法中写上：</p>
<p>父类.func(对象,其他参数)</p>
<p>举例说明：</p>
<pre><code><code>class Aniaml(object):
    type_name = &#39;动物类&#39;
    def __init__(self,name,sex,age):
            self.name = name
            self.age = age
            self.sex = sex

    def eat(self):
        print(&#39;吃东西&#39;)

class Person(Aniaml):
    def __init__(self,name,sex,age,mind):
        &#39;&#39;&#39;
        self = p1
        name = &#39;春哥&#39;
        sex = &#39;laddboy&#39;
        age = 18
        mind = &#39;有思想&#39;
        &#39;&#39;&#39;
        # Aniaml.__init__(self,name,sex,age)  # 方法一
        self.mind = mind

    def eat(self):
        super().eat()
        print(&#39;%s 吃饭&#39;%self.name)
class Cat(Aniaml):
    pass

class Dog(Aniaml):
    pass

# 方法一： Aniaml.__init__(self,name,sex,age)
# p1 = Person(&#39;春哥&#39;,&#39;laddboy&#39;,18,&#39;有思想&#39;)
# print(p1.__dict__)

# 对于方法一如果不理解：
# def func(self):
#     print(self)
# self = 3
# func(self)</code></pre>
<p>方法二：</p>
<p>利用super，super().func(参数)</p>
<pre><code><code>class Aniaml(object):
    type_name = &#39;动物类&#39;
    def __init__(self,name,sex,age):
            self.name = name
            self.age = age
            self.sex = sex

    def eat(self):
        print(&#39;吃东西&#39;)

class Person(Aniaml):
    def __init__(self,name,sex,age,mind):
        &#39;&#39;&#39;
        self = p1
        name = &#39;春哥&#39;
        sex = &#39;laddboy&#39;
        age = 18
        mind = &#39;有思想&#39;
        &#39;&#39;&#39;
        # super(Person,self).__init__(name,sex,age)  # 方法二
        super().__init__(name,sex,age)  # 方法二
        self.mind = mind

    def eat(self):
        super().eat()
        print(&#39;%s 吃饭&#39;%self.name)
class Cat(Aniaml):
    pass

class Dog(Aniaml):
    pass
# p1 = Person(&#39;春哥&#39;,&#39;laddboy&#39;,18,&#39;有思想&#39;)
# print(p1.__dict__)</code></pre>
<p>单继承练习题：</p>
<pre><code><code># 1
class Base:
    def __init__(self, num):
        self.num = num
    def func1(self):
        print(self.num)

class Foo(Base):
    pass
obj = Foo(123)
obj.func1() # 123 运⾏的是Base中的func1  

# 2      
class Base:
    def __init__(self, num):
        self.num = num
    def func1(self):
        print(self.num)
class Foo(Base):
    def func1(self):
        print(&quot;Foo. func1&quot;, self.num)
obj = Foo(123)
obj.func1() # Foo. func1 123 运⾏的是Foo中的func1       

# 3         
class Base:
    def __init__(self, num):
        self.num = num
    def func1(self):
        print(self.num)
class Foo(Base):
    def func1(self):
        print(&quot;Foo. func1&quot;, self.num)
obj = Foo(123)
obj.func1() # Foo. func1 123 运⾏的是Foo中的func1     
# 4
class Base:
    def __init__(self, num):
        self.num = num
    def func1(self):
        print(self.num)
        self.func2()
    def func2(self):
        print(&quot;Base.func2&quot;)
class Foo(Base):
    def func2(self):
    print(&quot;Foo.func2&quot;)
obj = Foo(123)
obj.func1() # 123 Foo.func2 func1是Base中的 func2是⼦类中的 
# 再来
class Base:
    def __init__(self, num):
        self.num = num
    def func1(self):
        print(self.num)
        self.func2()
    def func2(self):
        print(111, self.num)
class Foo(Base):
    def func2(self):
        print(222, self.num)
lst = [Base(1), Base(2), Foo(3)]
for obj in lst:
    obj.func2() # 111 1 | 111 2 | 222 3

# 再来
class Base:
    def __init__(self, num):
        self.num = num
    def func1(self):
        print(self.num)
        self.func2()
    def func2(self):
        print(111, self.num)
class Foo(Base):
    def func2(self):
        print(222, self.num)
lst = [Base(1), Base(2), Foo(3)]
for obj in lst:
 obj.func1() # 那笔来吧. 好好算
                          </code></pre>
<h2 id="多继承">4.多继承</h2>
<pre><code><code>class ShenXian: # 神仙
    def fei(self):
        print(&quot;神仙都会⻜&quot;)
class Monkey: # 猴
    def chitao(self):
        print(&quot;猴⼦喜欢吃桃⼦&quot;)
class SunWukong(ShenXian, Monkey): # 孙悟空是神仙, 同时也是⼀只猴
    pass
sxz = SunWukong() # 孙悟空
sxz.chitao() # 会吃桃⼦
sxz.fei() # 会⻜</code></pre>
<p>　　此时, 孙悟空是⼀只猴⼦, 同时也是⼀个神仙. 那孙悟空继承了这两个类. 孙悟空⾃然就可以执⾏这两个类中的⽅法. 多继承⽤起来简单. 也很好理解. 但是多继承中, 存在着这样⼀个问题. 当两个⽗类中出现了重名⽅法的时候. 这时该怎么办呢? 这时就涉及到如何查找⽗类⽅法的这么⼀个问题.即MRO(method resolution order) 问题. 在python中这是⼀个很复杂的问题. 因为在不同的python版本中使⽤的是不同的算法来完成MRO的.</p>
<p>这里需要补充一下python中类的种类（继承需要）：</p>
<p>在python2x版本中存在两种类.：<br />
　　⼀个叫<strong>经典类</strong>. 在python2.2之前. ⼀直使⽤的是经典类. 经典类在基类的根如果什么都不写.<br />
　　⼀个叫<strong>新式类</strong>. 在python2.2之后出现了新式类. 新式类的特点是基类的根是object类。<br />
python3x版本中只有一种类：<br />
python3中使⽤的都是<strong>新式类</strong>. 如果基类谁都不继承. 那这个类会默认继承 object</p>
<h3 id="经典类的多继承">4.1经典类的多继承</h3>
<p>虽然在python3中已经不存在经典类了. 但是经典类的MRO最好还是学⼀学. 这是⼀种树形结构遍历的⼀个最直接的案例. 在python的继承体系中. 我们可以把类与类继承关系化成⼀个树形结构的图. 来, 上代码:</p>
<pre><code><code>class A:
    pass
class B(A):
    pass
class C(A):
    pass
class D(B, C):
    pass
class E:
    pass
class F(D, E):
    pass
class G(F, D):
    pass
class H:
    pass
class Foo(H, G):
    pass</code></pre>
<p>代码示例</p>
<p>对付这种mro画图就可以：</p>
<p><img src="./images/继承0.png" /></p>
<p>继承关系图已经有了. 那如何进⾏查找呢? 记住⼀个原则. 在经典类中采⽤的是深度优先，遍历⽅案. 什么是深度优先. 就是⼀条路走到头. 然后再回来. 继续找下⼀个.</p>
<p><img src="./images/继承1.png" /></p>
<p>图中每个圈都是准备要送鸡蛋的住址. 箭头和⿊线表⽰线路. 那送鸡蛋的顺序告诉你入⼝在最下⾯R. 并且必须从左往右送. 那怎么送呢?</p>
<p><img src="./images/继承2.png" /></p>
<p>如图. 肯定是按照123456这样的顺序来送. 那这样的顺序就叫深度优先遍历. ⽽如果是142356呢? 这种被称为⼴度优先遍历. 好了. 深度优先就说这么多. 那么上⾯那个图怎么找的呢? MRO是什么呢? 很简单. 记住. 从头开始. 从左往右. ⼀条路跑到头, 然后回头. 继续⼀条路跑到头. 就是经典类的MRO算法.</p>
<p>类的MRO: Foo-&gt; H -&gt; G -&gt; F -&gt; E -&gt; D -&gt; B -&gt; A -&gt; C. 你猜对了么?</p>
<h4 id="新式类的多继承">4.2新式类的多继承</h4>
<p><strong>4.2.1 mro序列</strong></p>
<p>MRO是一个有序列表L，在类被创建时就计算出来。<br />
通用计算公式为：</p>
<pre><code><code>mro(Child(Base1，Base2)) = [ Child ] + merge( mro(Base1), mro(Base2), [ Base1, Base2] )（其中Child继承自Base1, Base2）</code></pre>
<p>如果继承至一个基类：class B(A)<br />
这时B的mro序列为</p>
<pre><code><code>mro( B ) = mro( B(A) )
= [B] + merge( mro(A) + [A] )
= [B] + merge( [A] + [A] )
= [B,A]</code></pre>
<p>如果继承至多个基类：class B(A1, A2, A3 …)<br />
这时B的mro序列</p>
<pre><code><code>mro(B) = mro( B(A1, A2, A3 …) )
= [B] + merge( mro(A1), mro(A2), mro(A3) ..., [A1, A2, A3] )
= ...</code></pre>
<p>计算结果为列表，列表中至少有一个元素即类自己，如上述示例[A1,A2,A3]。merge操作是C3算法的核心。</p>
<p><strong>4.2.2. 表头和表尾</strong><br />
表头：<br />
　　列表的第一个元素</p>
<p>表尾：<br />
　　列表中表头以外的元素集合（可以为空）</p>
<p>示例<br />
　　列表：[A, B, C]<br />
　　表头是A，表尾是B和C</p>
<p><strong>4.2.3. 列表之间的+操作</strong><br />
+操作：</p>
<p>[A] + [B] = [A, B]<br />
（以下的计算中默认省略）<br />
---------------------</p>
<p>merge操作示例：</p>
<pre><code><code>&#39;&#39;&#39;
如计算merge( [E,O], [C,E,F,O], [C] )
有三个列表 :

1 merge不为空，取出第一个列表列表①的表头E，进行判断                              
   各个列表的表尾分别是[O], [E,F,O]，E在这些表尾的集合中，因而跳过当前当前列表
2 取出列表②的表头C，进行判断
   C不在各个列表的集合中，因而将C拿出到merge外，并从所有表头删除
   merge( [E,O], [C,E,F,O], [C]) = [C] + merge( [E,O], [E,F,O] )
3 进行下一次新的merge操作 ......
--------------------- 
&#39;&#39;&#39;</code></pre>
<p><img src="./images/继承3.png" /></p>
<p>计算mro(A)方式：</p>
<pre><code><code>mro(A) = mro( A(B,C) )

原式= [A] + merge( mro(B),mro(C),[B,C] )

  mro(B) = mro( B(D,E) )
         = [B] + merge( mro(D), mro(E), [D,E] )  # 多继承
         = [B] + merge( [D,O] , [E,O] , [D,E] )  # 单继承mro(D(O))=[D,O]
         = [B,D] + merge( [O] , [E,O]  ,  [E] )  # 拿出并删除D
         = [B,D,E] + merge([O] ,  [O])
         = [B,D,E,O]

  mro(C) = mro( C(E,F) )
         = [C] + merge( mro(E), mro(F), [E,F] )
         = [C] + merge( [E,O] , [F,O] , [E,F] )
         = [C,E] + merge( [O] , [F,O]  ,  [F] )  # 跳过O，拿出并删除
         = [C,E,F] + merge([O] ,  [O])
         = [C,E,F,O]

原式= [A] + merge( [B,D,E,O], [C,E,F,O], [B,C])
    = [A,B] + merge( [D,E,O], [C,E,F,O],   [C])
    = [A,B,D] + merge( [E,O], [C,E,F,O],   [C])  # 跳过E
    = [A,B,D,C] + merge([E,O],  [E,F,O])
    = [A,B,D,C,E] + merge([O],    [F,O])  # 跳过O
    = [A,B,D,C,E,F] + merge([O],    [O])
    = [A,B,D,C,E,F,O]
--------------------- </code></pre>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>