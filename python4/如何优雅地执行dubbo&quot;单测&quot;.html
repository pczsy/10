<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修如何优雅地执行dubbo&quot;单测&quot;' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>如何优雅地执行dubbo&quot;单测&quot;</center></div><div class='banquan'>原文出处:本文由博客园博主luoxn28提供。<br/>
原文连接:https://www.cnblogs.com/luoxn28/p/12081203.html</div><br>
    <p><img src="./images/如何优雅地执行dubbo&quot;单测&quot;0.png" alt="" /></p>
<p>很多小伙伴所在的公司是基于Dubbo来构建技术栈的，日常开发中必不可少要写dubbo单测（单元测试），如果单测数据依赖已有的外部dubbo服务，一般是mock数据，如果数据比较复杂，其实mock数据也是一个不小的工作量。那有没有更好的单测方式来代替我们完成&rdquo;mock&ldquo;数据功能呢，这时可以借助dubbo telnet功能，获取真实数据用在单测中使用。</p>
<blockquote>
<p>本文会先讨论如何使用基于dubbo telnet的代理工具类（DubboTelnetProxy），然后再讨论下mockito+DubboTelnetProxy如何进行多层次的单测，最后分析下如何让单测变得更加智能（比如自动注入等）。（<em>ps：关于dubbo和mockito这里就不展开讨论了，具体可以参考对应资料~</em>）</p>
</blockquote>
<h2 id="h1dubbo">1 Dubbo单测现状</h2>
<p>dubbo单测其实和非dubbo单测的流程是一样的，初始化待测试类和单测上下文，打桩然后调用，最后检查返回结果。比如我们常用mockito来跑单测，其简单的示例如下：</p>
<pre><code><code><span class="hljs-keyword">public&nbsp;<span class="hljs-class"><span class="hljs-keyword">class&nbsp;<span class="hljs-title">DubboAppContextFilterTest&nbsp;<span class="hljs-keyword">extends&nbsp;<span class="hljs-title">BaseTest&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">private&nbsp;DubboAppContextFilter&nbsp;filter&nbsp;=&nbsp;<span class="hljs-keyword">new&nbsp;DubboAppContextFilter();<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-meta">@Before<br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">public&nbsp;<span class="hljs-keyword">void&nbsp;<span class="hljs-title">setUp<span class="hljs-params">()&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cleanUpAll();<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-meta">@After<br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">public&nbsp;<span class="hljs-keyword">void&nbsp;<span class="hljs-title">cleanUp<span class="hljs-params">()&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cleanUpAll();<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-meta">@Test<br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">public&nbsp;<span class="hljs-keyword">void&nbsp;<span class="hljs-title">testInvokeApplicationKey<span class="hljs-params">()&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Invoker&nbsp;invoker&nbsp;=&nbsp;mock(Invoker.class);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Invocation&nbsp;invocation&nbsp;=&nbsp;mock(Invocation.class);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;URL&nbsp;url&nbsp;=&nbsp;URL.valueOf(<span class="hljs-string">"test://test:111/test?application=serviceA");<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;when(invoker.getUrl()).thenReturn(url);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;filter.invoke(invoker,&nbsp;invocation);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;verify(invoker).invoke(invocation);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;application&nbsp;=&nbsp;RpcContext.getContext().getAttachment(DubboUtils.SENTINEL_DUBBO_APPLICATION_KEY);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assertEquals(<span class="hljs-string">"serviceA",&nbsp;application);<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />}<br /></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<blockquote>
<p>上面代码copy于sentinel的单元测试代码。</p>
</blockquote>
<h2 id="h2dubbotelnetproxy">2 DubboTelnetProxy</h2>
<p>在dubbo服务机器上，我们可以使用telnet连接dubbo服务，然后执行invoke命令来手动调用dubbo接口并获取结果，DubboTelnetProxy就是将这一系列的手动操作按照dubbo telnet格式固化到代码中。在具体讨论DubboTelnetProxy之前，先看下其有哪些功能，DubboTelnetProxy特点：</p>
<ul>
<li>基于telnet的dubbo代理工具类，可用于本地单测中；</li>
<li>直接使用telnet指定ip+port进行连接，无需更多的dubbo相关配置，使用便捷；</li>
<li>可动态配置ip+port信息。</li>
</ul>
<p>话不多说，先看下<code>DubboTelnetProxy</code>代码实现：</p>
<pre><code><code><span class="hljs-meta">@AllArgsConstructor(access&nbsp;=&nbsp;AccessLevel.PRIVATE)<br /><span class="hljs-keyword">public&nbsp;<span class="hljs-class"><span class="hljs-keyword">class&nbsp;<span class="hljs-title">DubboTelnetProxy&nbsp;<span class="hljs-keyword">implements&nbsp;<span class="hljs-title">MethodInterceptor&nbsp;{<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">private&nbsp;String&nbsp;ip;<br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">private&nbsp;Integer&nbsp;port;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-meta">@Override<br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">public&nbsp;Object&nbsp;<span class="hljs-title">intercept<span class="hljs-params">(Object&nbsp;obj,&nbsp;Method&nbsp;method,&nbsp;Object[]&nbsp;params,&nbsp;MethodProxy&nbsp;proxy)&nbsp;<span class="hljs-keyword">throws&nbsp;Throwable&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if&nbsp;(<span class="hljs-string">"toString".equals(method.getName()))&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return&nbsp;obj.getClass().getName();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TelnetClient&nbsp;telnetClient&nbsp;=&nbsp;<span class="hljs-keyword">new&nbsp;TelnetClient();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;telnetClient.setConnectTimeout((<span class="hljs-keyword">int)&nbsp;TimeUnit.SECONDS.toMillis(<span class="hljs-number">5));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;telnetClient.connect(ip,&nbsp;port);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">try&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InputStream&nbsp;in&nbsp;=&nbsp;telnetClient.getInputStream();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PrintStream&nbsp;out&nbsp;=&nbsp;<span class="hljs-keyword">new&nbsp;PrintStream(telnetClient.getOutputStream());<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;1.&nbsp;发送dubbo&nbsp;telnet请求<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringBuffer&nbsp;request&nbsp;=&nbsp;<span class="hljs-keyword">new&nbsp;StringBuffer(<span class="hljs-string">"invoke&nbsp;");<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request.append(method.getDeclaringClass().getTypeName()).append(<span class="hljs-string">".");<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request.append(method.getName()).append(<span class="hljs-string">"(");<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request.append(StringUtils.join(Arrays.stream(params).map(JSON::toJSONString).collect(Collectors.toList()),&nbsp;<span class="hljs-string">",")).append(<span class="hljs-string">")");<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;out.println(request.toString());<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;out.flush();<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;2.&nbsp;结果处理<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">int&nbsp;len&nbsp;=&nbsp;<span class="hljs-number">0;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">byte[]&nbsp;buffer&nbsp;=&nbsp;<span class="hljs-keyword">new&nbsp;<span class="hljs-keyword">byte[<span class="hljs-number">512];<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;result&nbsp;=&nbsp;<span class="hljs-string">"";<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">while&nbsp;(!result.contains(StringUtils.LF)&nbsp;&amp;&amp;&nbsp;(len&nbsp;=&nbsp;in.read(buffer))&nbsp;&gt;&nbsp;<span class="hljs-number">0)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;+=&nbsp;<span class="hljs-keyword">new&nbsp;String(ArrayUtils.subarray(buffer,&nbsp;<span class="hljs-number">0,&nbsp;len));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;StringUtils.substringBefore(result,&nbsp;StringUtils.LF);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if&nbsp;(StringUtils.isBlank(result)&nbsp;||&nbsp;!result.startsWith(<span class="hljs-string">"{"))&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">throw&nbsp;<span class="hljs-keyword">new&nbsp;RuntimeException(result);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;3.&nbsp;反序列化<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return&nbsp;JSON.parseObject(result,&nbsp;method.getGenericReturnType());<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="hljs-keyword">finally&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;telnetClient.disconnect();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">/**<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;mockDubboIpPortFormat：配置格式为&nbsp;&nbsp;-Dmock.dubbo.%s=127.0.0.1:8080，%s为当前dubbo接口的名字，class.getSimpleName()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/<br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">private&nbsp;<span class="hljs-keyword">final&nbsp;<span class="hljs-keyword">static&nbsp;String&nbsp;mockDubboIpPortPrefix&nbsp;=&nbsp;<span class="hljs-string">"mock.dubbo.";<br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">public&nbsp;<span class="hljs-keyword">final&nbsp;<span class="hljs-keyword">static&nbsp;String&nbsp;mockDubboIpPortFormat&nbsp;=&nbsp;mockDubboIpPortPrefix&nbsp;+&nbsp;<span class="hljs-string">"%s";<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">/**<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;dubbo&nbsp;telnet建造者<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/<br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">public&nbsp;<span class="hljs-keyword">static&nbsp;<span class="hljs-class"><span class="hljs-keyword">class&nbsp;<span class="hljs-title">Builder&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">final&nbsp;<span class="hljs-keyword">static&nbsp;String&nbsp;DEFAULT_IP&nbsp;=&nbsp;<span class="hljs-string">"127.0.0.1";<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">final&nbsp;<span class="hljs-keyword">static&nbsp;Integer&nbsp;DEFAULT_PORT&nbsp;=&nbsp;<span class="hljs-number">20880;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">/**<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;创建dubbo&nbsp;telnet代理<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">public&nbsp;<span class="hljs-keyword">static&nbsp;&lt;T&gt;&nbsp;<span class="hljs-function">T&nbsp;<span class="hljs-title">enhance<span class="hljs-params">(Class&lt;T&gt;&nbsp;clazz)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return&nbsp;enhance(clazz,&nbsp;<span class="hljs-keyword">null,&nbsp;<span class="hljs-keyword">null);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">public&nbsp;<span class="hljs-keyword">static&nbsp;&lt;T&gt;&nbsp;<span class="hljs-function">T&nbsp;<span class="hljs-title">enhance<span class="hljs-params">(Class&lt;T&gt;&nbsp;clazz,&nbsp;String&nbsp;ip)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return&nbsp;enhance(clazz,&nbsp;ip,&nbsp;<span class="hljs-keyword">null);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">public&nbsp;<span class="hljs-keyword">static&nbsp;&lt;T&gt;&nbsp;<span class="hljs-function">T&nbsp;<span class="hljs-title">enhance<span class="hljs-params">(Class&lt;T&gt;&nbsp;clazz,&nbsp;Integer&nbsp;port)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return&nbsp;enhance(clazz,&nbsp;<span class="hljs-keyword">null,&nbsp;port);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-meta">@SuppressWarnings(<span class="hljs-string">"unchecked")<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">public&nbsp;<span class="hljs-keyword">static&nbsp;&lt;T&gt;&nbsp;<span class="hljs-function">T&nbsp;<span class="hljs-title">enhance<span class="hljs-params">(Class&lt;T&gt;&nbsp;object,&nbsp;String&nbsp;ip,&nbsp;Integer&nbsp;port)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;优先尝试从properties解析ip:port配置<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;ipPort&nbsp;=&nbsp;System.getProperties().getProperty(String.format(mockDubboIpPortFormat,&nbsp;object.getSimpleName()));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if&nbsp;(StringUtils.isNotEmpty(ipPort))&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String[]&nbsp;array&nbsp;=&nbsp;StringUtils.split(ipPort,&nbsp;<span class="hljs-string">",");<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ip&nbsp;=&nbsp;array[<span class="hljs-number">0];<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;port&nbsp;=&nbsp;Integer.valueOf(array[<span class="hljs-number">1]);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enhancer&nbsp;enhancer&nbsp;=&nbsp;<span class="hljs-keyword">new&nbsp;Enhancer();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enhancer.setSuperclass(object);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enhancer.setCallback(<span class="hljs-keyword">new&nbsp;DubboTelnetProxy(ObjectUtils.defaultIfNull(ip,&nbsp;DEFAULT_IP),&nbsp;ObjectUtils.defaultIfNull(port,&nbsp;DEFAULT_PORT)));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return&nbsp;(T)&nbsp;enhancer.create();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />}<br /></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<p>DubboTelnetProxy的实现原理是使用cglib生成dubbo facade接口代理类，然后在代理类按照dubbo telnet格式拼接请求参数，最后获取返回结果并反序列化返回给应用程序。上述代码不足点是：目前每次dubbo调用都会新建telnet连接，对于单测来说是OK的，后续如果用于本地压测或者调用频繁测试场景，考虑复用连接或者使用netty client bootstrap方式避免每次都新建连接。</p>
<h3 id="h21">2.1 使用示例</h3>
<p>手动/自动指定dubbo服务IP地址：</p>
<pre><code><code><span class="hljs-meta">@Test<br /><span class="hljs-function"><span class="hljs-keyword">public&nbsp;<span class="hljs-keyword">void&nbsp;<span class="hljs-title">test<span class="hljs-params">()&nbsp;{<br />&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;OrderQueryService为dubbo服务的一个API接口<br />&nbsp;&nbsp;System.setProperty(<span class="hljs-string">"mock.dubbo.OrderQueryService",&nbsp;<span class="hljs-string">"127.0.0.1:20880");<br /><br />&nbsp;&nbsp;OrderQueryService&nbsp;orderQueryService1&nbsp;=&nbsp;DubboTelnetProxy.Builder.enhance(OrderQueryService.class);<br />&nbsp;&nbsp;OrderQueryService&nbsp;orderQueryService2&nbsp;=&nbsp;DubboTelnetProxy.Builder.enhance(OrderQueryService.class,&nbsp;<span class="hljs-string">"127.0.0.1");<br />&nbsp;&nbsp;OrderQueryService&nbsp;orderQueryService3&nbsp;=&nbsp;DubboTelnetProxy.Builder.enhance(OrderQueryService.class,&nbsp;<span class="hljs-string">"127.0.0.1",&nbsp;<span class="hljs-number">20880);<br /><br />&nbsp;&nbsp;OrderDTO&nbsp;result&nbsp;=&nbsp;orderQueryService1.query(<span class="hljs-string">"订单号");<br />&nbsp;&nbsp;System.out.println(result);<br />}<br /></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<h2 id="h3dubbotelnetproxymockito">3 DubboTelnetProxy + mockito自动注入</h2>
<p>日常开发中，可以使用mockito进行单测，保证代码质量。在mockito中，如果想让某个DubboTelnetProxy代理类注入到待测试中，可使用FieldUtils工具类进行属性注入。</p>
<p>使用DubboTelnetProxy + mockito示例如下：</p>
<pre><code><code><span class="hljs-meta">@RunWith(MockitoJUnitRunner.class)<br /><span class="hljs-keyword">public&nbsp;<span class="hljs-class"><span class="hljs-keyword">class&nbsp;<span class="hljs-title">DemoServiceClientTest&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-meta">@InjectMocks<br />&nbsp;&nbsp;&nbsp;&nbsp;DemoServiceClient&nbsp;demoServiceClient;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-meta">@Before<br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">public&nbsp;<span class="hljs-keyword">void&nbsp;<span class="hljs-title">before<span class="hljs-params">()&nbsp;<span class="hljs-keyword">throws&nbsp;IllegalAccessException&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FieldUtils.writeField(demoServiceClient,&nbsp;<span class="hljs-string">"demoServiceFacade",<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DubboTelnetProxy.Builder.enhance(DemoServiceFacade.class),&nbsp;<span class="hljs-keyword">true);<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-meta">@Test<br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">public&nbsp;<span class="hljs-keyword">void&nbsp;<span class="hljs-title">hello<span class="hljs-params">()&nbsp;<span class="hljs-keyword">throws&nbsp;IllegalAccessException&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;调用远程服务，DubboTelnetProxy方式<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;demoServiceClient.hello(<span class="hljs-string">"world");<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;如果需要打桩，则使用Mock类<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DemoServiceFacade&nbsp;demoServiceFacade&nbsp;=&nbsp;Mockito.mock(DemoServiceFacade.class);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mockito.when(demoServiceFacade.hello(<span class="hljs-string">"world")).thenReturn(<span class="hljs-string">"zzz");<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FieldUtils.writeField(demoServiceClient,&nbsp;<span class="hljs-string">"demoServiceFacade",&nbsp;demoServiceFacade,&nbsp;<span class="hljs-keyword">true);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Assert.assertEquals(demoServiceClient.hello(<span class="hljs-string">"world"),&nbsp;<span class="hljs-string">"zzz");<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />}<br /><br /><span class="hljs-meta">@Component<br /><span class="hljs-keyword">public&nbsp;<span class="hljs-class"><span class="hljs-keyword">class&nbsp;<span class="hljs-title">DemoServiceClient&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-meta">@Resource<br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">private&nbsp;DemoServiceFacade&nbsp;demoServiceFacade;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">public&nbsp;String&nbsp;<span class="hljs-title">hello<span class="hljs-params">(String&nbsp;world)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return&nbsp;demoServiceFacade.hello(world);<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />}<br /><br /><span class="hljs-comment">//&nbsp;dubbo&nbsp;api<br /><span class="hljs-keyword">public&nbsp;<span class="hljs-class"><span class="hljs-keyword">interface&nbsp;<span class="hljs-title">DemoServiceFacade&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function">String&nbsp;<span class="hljs-title">hello<span class="hljs-params">(String&nbsp;world);<br />}<br /></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<h3 id="h31">3.1 如何自动注入</h3>
<p>要实现DubboTelnetProxy的自动注入，首先判断出来待测试类中的哪些属性需要构造DubboTelnetProxy或者对应实例，一般情况下如果属性是非本工程内的接口类型，就可以认为是dubbo api接口，进行构造DubboTelnetProxy并注入；如果属性是本工程内的接口类型，则在本工程内查找对应的实现类进行反射方式的属性注入（可使用org.reflections包中的Reflections工具类来获取接口下所有实现类）；如果属性是普通类，则直接反射构建对象注入即可，伪代码如下：</p>
<pre><code><code><span class="hljs-comment">/**<br />&nbsp;*&nbsp;默认的dubbo属性构造器，如果是非本工程内属性类型并且是接口类型，直接进行DubboTelnetProxy构建<br />&nbsp;*/<br /><span class="hljs-keyword">public&nbsp;<span class="hljs-keyword">static&nbsp;Function&lt;Field,&nbsp;Object&gt;&nbsp;DEFAULT_DUBBO_FC&nbsp;=&nbsp;field&nbsp;-&gt;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">try&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">assert&nbsp;Objects.nonNull(targetContext.get());<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Class&nbsp;fieldClass&nbsp;=&nbsp;field.getType();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if&nbsp;(fieldClass.isInterface())&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;本工程内的加载其实现类，非本工程内的按照DubboTelnetProxy构建<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if&nbsp;(!isSameProjectPath(targetContext.get().getClass(),&nbsp;fieldClass))&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return&nbsp;DubboTelnetProxy.Builder.enhance(fieldClass);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="hljs-keyword">else&nbsp;<span class="hljs-keyword">if&nbsp;(fieldClass.getSimpleName().endsWith(<span class="hljs-string">"Dao"))&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return&nbsp;Mockito.mock(fieldClass);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="hljs-keyword">else&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;packagePath&nbsp;=&nbsp;fieldClass.getPackage().getName()&nbsp;+&nbsp;<span class="hljs-string">".impl.";<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return&nbsp;Class.forName(packagePath&nbsp;+&nbsp;fieldClass.getSimpleName()&nbsp;+&nbsp;<span class="hljs-string">"Impl").newInstance();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="hljs-keyword">else&nbsp;<span class="hljs-keyword">if&nbsp;(isSameProjectPath(targetContext.get().getClass(),&nbsp;fieldClass))&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return&nbsp;fieldClass.newInstance();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="hljs-keyword">else&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;非工程内的类直接mock掉<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return&nbsp;Mockito.mock(fieldClass);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="hljs-keyword">catch&nbsp;(Exception&nbsp;e)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.err.println(<span class="hljs-string">"DEFAULT_DUBBO_FC&nbsp;发生异常&nbsp;field="&nbsp;+&nbsp;field);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.exit(-<span class="hljs-number">1);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return&nbsp;<span class="hljs-keyword">null;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />};<br /></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<p>针对待注入类有多个层次，比如测试类A中属性b类型是B，B中属性c类型是C等，那么在自动注入类A的所有属性时，需要递归进行，直至所有子类型的属性都构建完毕，示例伪代码如下：</p>
<pre><code><code><span class="hljs-function"><span class="hljs-keyword">void&nbsp;<span class="hljs-title">doWithFieldsInternal<span class="hljs-params">(@NonNull&nbsp;Object&nbsp;target,&nbsp;@Nullable&nbsp;Function&lt;Field,&nbsp;Object&gt;&nbsp;fc,&nbsp;@Nullable&nbsp;Boolean&nbsp;recursive)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">assert&nbsp;!(target&nbsp;<span class="hljs-keyword">instanceof&nbsp;Class);<br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;默认fc回调直接调用默认无参构造方法<br />&nbsp;&nbsp;&nbsp;&nbsp;fc&nbsp;=&nbsp;ObjectUtils.defaultIfNull(fc,&nbsp;DEFAULT_FC);<br />&nbsp;&nbsp;&nbsp;&nbsp;recursive&nbsp;=&nbsp;ObjectUtils.defaultIfNull(recursive,&nbsp;<span class="hljs-keyword">false);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;List&lt;Object&gt;&nbsp;fieldList&nbsp;=&nbsp;<span class="hljs-keyword">new&nbsp;ArrayList&lt;&gt;();<br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">do&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object&nbsp;finalTarget&nbsp;=&nbsp;target;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Function&lt;Field,&nbsp;Object&gt;&nbsp;finalFc&nbsp;=&nbsp;fc;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ReflectionUtils.doWithFields(finalTarget.getClass(),&nbsp;field&nbsp;-&gt;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object&nbsp;value&nbsp;=&nbsp;finalFc.apply(field));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DubboReflectionUtils.setField(finalTarget,&nbsp;field,&nbsp;value);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if&nbsp;(Objects.nonNull(value)&nbsp;&amp;&amp;&nbsp;DEFAULT_FF.matches(field))&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fieldList.add(value);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;filterField&nbsp;-&gt;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;默认只注入非基本类型并且为null的属性<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return&nbsp;DEFAULT_FF.matches(filterField)&nbsp;&amp;&amp;&nbsp;DubboReflectionUtils.isNullFieldValue(finalTarget,&nbsp;filterField);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});<br />&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="hljs-keyword">while&nbsp;(recursive&nbsp;&amp;&amp;&nbsp;!fieldList.isEmpty()&nbsp;&amp;&amp;&nbsp;Objects.nonNull(target&nbsp;=&nbsp;fieldList.remove(<span class="hljs-number">0)));<br />}<br /></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<h3 id="h32">3.2 如何让自动注入更易用</h3>
<p>上述示例中的自动注入是程序会递归注入待测试类中的所有属性，但还是需要在代码中先调用要"自动注入"的代码，为了更易用，可以使用注解方式来自动注入被注解修饰的所有类或者属性，类似于在Spring中对类属性配置了<code>@Resource</code>之后，Spring在容器启动过程中会自动对该属性注入对应示例，开发者无需关注。</p>
<blockquote>
<p>关于如何实现mockito+DubboTelnetProxy的注解方式自动注入，笔者就不在赘述，感兴趣的小伙伴可以参考3.1中的实现思路自行实现。</p>
</blockquote>
<p>说道注解，其实想实现针对某些注解执行一些特定逻辑（比如执行自动注入），可以在两种阶段对其处理，如下所示：</p>
<ul>
<li>编译处理阶段：比如设置Java的注解处理器，一般是继承<code>AbstractProcessor</code>来实现特定业务逻辑，其主要的处理逻辑就是扫描、评估和处理注解的代码，以及生产 Java 文件。比如lombok中的<code>@Setter</code>注解就是要产生对应属性的setter方法；</li>
<li>容器启动阶段：这里的容器是业务程序自己定义的容器，比如Spring的IoC容器，在容器启动过程中针对注解进行处理，首先获取注解对应的属性，然后从容器中获取属性对应的实例通过反射将其注入即可。</li>
</ul>
<p>以上两种自动注入方式在实现都是OK的，前者在编译阶段后者在运行时，不过后者由于在运行时起作用，因此灵活性更大。</p>
<p>&nbsp;</p>
<p><em><strong>&nbsp;推荐阅读&nbsp;</strong></em></p>
<ul class="list-paddingleft-2">
<li>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzIwNTI2ODY5OA==&amp;mid=2649938653&amp;idx=1&amp;sn=fdea2581582fad78da34cab4c867457e&amp;chksm=8f350968b842807e4d1355913d8ab190dced390982d4cf74980c2a73a4d0e7f7d409bca9b279&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="0" data-linktype="2">Java nio 空轮询bug到底是什么</a></p>
</li>
<li>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzIwNTI2ODY5OA==&amp;mid=2649938607&amp;idx=1&amp;sn=7e17607eb5a537f7734631030d289351&amp;chksm=8f35091ab842800cc88e928fdedd763334c4e6c4c2f750bfc2a04499d41a629740c2f16e78d4&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="0" data-linktype="2">程序员必看| mockito原理浅析</a></p>
</li>
<li>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzIwNTI2ODY5OA==&amp;mid=2649938597&amp;idx=1&amp;sn=f646f74287c43aeedb3670029cca80e5&amp;chksm=8f350910b84280060218acc59b2200381cd33fac2c1cf6cf64068dcfd79407babfc8175e23c5&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="0" data-linktype="2">Java常见几种动态代理的对比</a></p>
</li>
</ul>
<p><br />欢迎小伙伴<strong>关注【TopCoder】</strong>阅读更多精彩好文。</p>
<p><img src="./images/如何优雅地执行dubbo&quot;单测&quot;1.png" alt="" width="577" height="273" /></p>
<p>&nbsp;</p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>