<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修Python—推导式' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>Python—推导式</center></div><div class='banquan'>原文出处:本文由博客园博主__风提供。<br/>
原文连接:https://www.cnblogs.com/malinqing/p/11288237.html</div><br>
    <h3 id="推导式">推导式</h3>
<p>推导式：comprehensions（又称解析式），是Python的一种独有特性，相当于语法糖的存在，推导式是可以从一个数据序列构建另一个新的数据序列的结构体。<br />
共有三种推导，在Python2和3中都有支持：</p>
<ul>
<li><strong>列表(list)推导式</strong></li>
<li><strong>集合(set)推导式</strong></li>
<li><strong>字典(dict)推导式</strong></li>
</ul>
<hr />
<h3 id="列表推导式-randint">列表推导式 randint</h3>
<p>基本格式： <code>变量名 = [expression1 for variable in sequence[, if expression2]]</code><br />
<strong>expression1</strong> : 列表生成元素表达式，可以是有返回值的函数。<br />
<strong>for variable in sequence</strong> : 迭代sequence将variable传入expression1。<br />
<strong>if expresiion2</strong> : 可选，根据条件过滤。<br />
 <br />
1.<strong>最基本的列表推导式</strong></p>
<pre><code><code>&gt;&gt;&gt; arr = [i for i in range(5)]
&gt;&gt;&gt; arr
[0, 1, 2, 3, 4]</code></pre>
<p>2.<strong>附带运算的列表推导式</strong></p>
<pre><code><code>&gt;&gt;&gt; arr = [i**2 for i in range(5)]
&gt;&gt;&gt; arr
[0, 1, 4, 9, 16]
&gt;&gt;&gt; arr = [pow(i, 2) for i in range(5)]
&gt;&gt;&gt; arr
[0, 1, 4, 9, 16]
&gt;&gt;&gt; arr = [pow(i, 2) if i%2==0 else -pow(i, 2) for i in range(5)]
&gt;&gt;&gt; arr
[0, -1, 4, -9, 16]</code></pre>
<p>3.<strong>附带条件的列表推导式</strong></p>
<pre><code><code>&gt;&gt;&gt; arr = [i for i in range(10) if i &lt; 5]
&gt;&gt;&gt; arr
[0, 1, 2, 3, 4]</code></pre>
<p>4.<strong>多重循环的列表推导式</strong></p>
<pre><code><code>&gt;&gt;&gt; list_ = [[1, 2], [3, 4], [5, 6]]
&gt;&gt;&gt; arr = [i for sub_list in list_ for i in sub_list]
&gt;&gt;&gt; arr
[1, 2, 3, 4, 5, 6]</code></pre>
<pre><code><code>&gt;&gt;&gt; arr = [x+y for x in range(5) for y in range(2)]
&gt;&gt;&gt; arr
[0, 1, 1, 2, 2, 3, 3, 4, 4, 5]
#  0     1     2     3     4
# 0 1  0 1  0 1  0 1  0 1
# 0 1  1 2  2 3  3 4  4 5</code></pre>
<p>5.<strong>更多用法</strong></p>
<pre><code><code>&gt;&gt;&gt; dict_ = {&#39;P&#39;:&#39;y&#39;, &#39;t&#39;:&#39;h&#39;, &#39;o&#39;:&#39;n&#39;}
&gt;&gt;&gt; arr = [k+v for k,v in dict_.items()]
&gt;&gt;&gt; arr
[&#39;Py&#39;, &#39;th&#39;, &#39;on&#39;]
&gt;&gt;&gt; from random import randint
&gt;&gt;&gt; arr = [randint(1, 5) for i in range(5)]
&gt;&gt;&gt; arr
[3, 2, 3, 2, 1]</code></pre>
<hr />
<h3 id="集合推导式">集合推导式</h3>
<p>与列表推导式差不多一样，只不过是将[ ]换为{ }</p>
<pre><code><code>set_ = {x+y for x in range(5) for y in range(3)}
&gt;&gt;&gt; set_
{0, 1, 2, 3, 4, 5, 6}
&gt;&gt;&gt; set_ = {k+v for k,v in dict_.items()}
&gt;&gt;&gt; set_
{&#39;on&#39;, &#39;Py&#39;, &#39;th&#39;}</code></pre>
<hr />
<h3 id="字典推导式">字典推导式</h3>
<p><code>变量名 = {表达式 for 临时变量 in 可迭代内容}</code><br />
 </p>
<pre><code><code>&gt;&gt;&gt; new_dict = {i:pow(i, 2) for i in range(5)}
&gt;&gt;&gt; new_dict
{0: 0, 1: 1, 2: 4, 3: 9, 4: 16}</code></pre>
<pre><code><code>&gt;&gt;&gt; new_dict = {x:&#39;Python&#39;.index(x) for x in &#39;Python&#39;}
&gt;&gt;&gt; new_dict
{&#39;P&#39;: 0, &#39;y&#39;: 1, &#39;t&#39;: 2, &#39;h&#39;: 3, &#39;o&#39;: 4, &#39;n&#39;: 5}
&gt;&gt;&gt; </code></pre>
<pre><code><code>&gt;&gt;&gt; dict_ = {&#39;P&#39;:&#39;y&#39;, &#39;t&#39;:&#39;h&#39;, &#39;o&#39;:&#39;n&#39;}
&gt;&gt;&gt; new_dict = {v:k for k,v in dict_.items()}
&gt;&gt;&gt; new_dict
{&#39;y&#39;: &#39;P&#39;, &#39;h&#39;: &#39;t&#39;, &#39;n&#39;: &#39;o&#39;}</code></pre>
<pre><code><code>&gt;&gt;&gt; dict_ = {&#39;a&#39;: 10, &#39;b&#39;: 20, &#39;A&#39;: 3, &#39;C&#39;: 7, &#39;d&#39;: 5, &#39;x&#39;: 2, &#39;X&#39;: 4, &#39;y&#39;: 8}
&gt;&gt;&gt; new_dict = {k.upper(): dict_.get(k.lower(), 0) + dict_.get(k.upper(), 0) for k in dict_.keys() if k in &#39;aAbcDxy&#39;}
&gt;&gt;&gt; new_dict
{&#39;A&#39;: 13, &#39;B&#39;: 20, &#39;X&#39;: 6, &#39;Y&#39;: 8}</code></pre>
<hr />
<h3 id="为什么元组不可以用推导式">为什么元组不可以用推导式</h3>
<p><strong>Python中，将( )用于了生成器，将列表推导式的[ ]改成( )即可得到生成器。</strong></p>
<pre><code><code>&gt;&gt;&gt; gener = (i for i in range(5))
&gt;&gt;&gt; type(gener)
&lt;class &#39;generator&#39;&gt;
&gt;&gt;&gt; gener
&lt;generator object &lt;genexpr&gt; at 0x00000179ECB01BA0&gt;
&gt;&gt;&gt; [i for i in gener]
[0, 1, 2, 3, 4]
&gt;&gt;&gt; [i for i in gener]
[]</code></pre>
<p><strong>不过可以通过类型强制性转换，将生成器转换为对应的类型数据</strong></p>
<pre><code><code>&gt;&gt;&gt; gener = (i for i in range(5))
&gt;&gt;&gt; list(gener)
[0, 1, 2, 3, 4]
&gt;&gt;&gt; gener = (i for i in range(5))
&gt;&gt;&gt; tuple(gener)
(0, 1, 2, 3, 4)
&gt;&gt;&gt; gener = (i for i in range(5))
&gt;&gt;&gt; set(gener)
{0, 1, 2, 3, 4}</code></pre>

</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>