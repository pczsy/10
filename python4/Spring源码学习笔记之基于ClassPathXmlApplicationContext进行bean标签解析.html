<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修Spring源码学习笔记之基于ClassPathXmlApplicationContext进行bean标签解析' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>Spring源码学习笔记之基于ClassPathXmlApplicationContext进行bean标签解析</center></div><div class='banquan'>原文出处:本文由博客园博主城序猿提供。<br/>
原文连接:https://www.cnblogs.com/cheng21553516/p/12032881.html</div><br>
    <p>&nbsp;bean 标签在spring的配置文件中, 是非常重要的一个标签, 即便现在boot项目比较流行, 但是还是有必要理解bean标签的解析流程,有助于我们进行</p>
<p>&nbsp;基于注解配置, 也知道各个标签的作用,以及是怎样被spring识别的, 以及配置的时候需要注意的点.</p>
<p>传统的spring项目,spring内部启动的方式是基于ClassPathXmlApplicationContext启动的:</p>
<div class="cnblogs_code">
<pre><code><span style="color: #000000;">@Test
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> test1() {<br />        <span style="color: #339966;">//传入spring的配置文件路径</span>
        ApplicationContext classPathXmlApplicationContext </span>= <span style="color: #0000ff;">new</span> ClassPathXmlApplicationContext("spring.xml"<span style="color: #000000;">);
        
        System.out.println(</span>""<span style="color: #000000;">);
    }<br /><br /><span style="color: #339966;">// 调用有参构造,设置spring配置文件的位置</span></span></pre>
<pre><code>  public ClassPathXmlApplicationContext(String configLocation) throws BeansException {<br />   this(new String[] {configLocation}, true, null);<br />  }<br /><br /><span style="color: #339966;">//进一步跟进</span><br />public ClassPathXmlApplicationContext(</pre>
<pre><code><em>      String[] configLocations, boolean refresh, @Nullable ApplicationContext parent)<br />      throws BeansException {<br />   <span style="color: #339966;">// 此处parent 为null</span> <br />   super(parent);<br /><br />   <span style="color: #339966;">//创建解析器，解析configLocations</span><br />   setConfigLocations(configLocations);<br />   // refresh = true <br />   if (refresh) {<br />      <span style="color: #339966;">//刷新spring容器,bean标签的核心方法</span><br />      refresh();<br />   }<br />}<br /><br /><span style="color: #339966;">//进一步跟进refresh 方法</span><br /></em></pre>
<pre><code>public Collection&lt;ApplicationListener&lt;?&gt;&gt; getApplicationListeners() {<br />   return this.applicationListeners;<br />}<br /><br /><span style="color: #339966;">/*</span><br /><span style="color: #339966;"> * 该方法是spring容器初始化的核心方法。是spring容器初始化的核心流程，是一个典型的父类模板设计模式的运用</span><br /><span style="color: #339966;"> *    根据不同的上下文对象，会掉到不同的上下文对象子类方法中</span><br /><span style="color: #339966;"> *</span><br /><span style="color: #339966;"> * 核心上下文子类有：</span><br /><span style="color: #339966;"> * ClassPathXmlApplicationContext</span><br /><span style="color: #339966;"> * FileSystemXmlApplicationContext</span><br /><span style="color: #339966;"> * AnnotationConfigApplicationContext</span><br /><span style="color: #339966;"> * EmbeddedWebApplicationContext(springboot)</span><br /><span style="color: #339966;"> *</span><br /><span style="color: #339966;"> * 方法重要程度：</span><br /><span style="color: #339966;"> *  0：不重要，可以不看</span><br /><span style="color: #339966;"> *  1：一般重要，可看可不看</span><br /><span style="color: #339966;"> *  5：非常重要，一定要看</span><br /><span style="color: #339966;"> * */</span><br />@Override<br />public void refresh() throws BeansException, IllegalStateException {<br />   synchronized (this.startupShutdownMonitor) {<br />     <span style="color: #339966;"> //为容器初始化做准备，重要程度：0</span><br />      // Prepare this context for refreshing.<br />      prepareRefresh();<br /><br />     <span style="color: #339966;"> /*</span><br /><span style="color: #339966;">         重要程度：5</span><br /><br /><span style="color: #339966;">        1、创建BeanFactory对象</span><br /><span style="color: #339966;">      * 2、xml解析</span><br /><span style="color: #339966;">      *  传统标签解析：bean、import等</span><br /><span style="color: #339966;">      *  自定义标签解析 如：&lt;context:component-scan base-package="com.xiangxue.jack"/&gt;</span><br /><span style="color: #339966;">      *  自定义标签解析流程：</span><br /><span style="color: #339966;">      *     a、根据当前解析标签的头信息找到对应的namespaceUri</span><br /><span style="color: #339966;">      *     b、加载spring所以jar中的spring.handlers文件。并建立映射关系</span><br /><span style="color: #339966;">      *     c、根据namespaceUri从映射关系中找到对应的实现了NamespaceHandler接口的类</span><br /><span style="color: #339966;">      *     d、调用类的init方法，init方法是注册了各种自定义标签的解析类</span><br /><span style="color: #339966;">      *     e、根据namespaceUri找到对应的解析类，然后调用paser方法完成标签解析</span><br /><span style="color: #339966;">      *</span><br /><span style="color: #339966;">      * 3、把解析出来的xml标签封装成BeanDefinition对象</span><br /><span style="color: #339966;">      * */</span><br />      // Tell the subclass to refresh the internal bean factory.<br />      <span style="color: #339966;">//<strong>此处创建bean 工厂, 解析bean 标签以及处理 component-scan 标签的核心方法</strong></span><br />      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();<br /><br />      // Prepare the bean factory for use in this context.<br />      prepareBeanFactory(beanFactory);<br /><br />      try {<br />         // Allows post-processing of the bean factory in context subclasses.<br />         postProcessBeanFactory(beanFactory);<br /><br />         // Invoke factory processors registered as beans in the context.<br />         invokeBeanFactoryPostProcessors(beanFactory);<br /><br />         // Register bean processors that intercept bean creation.<br />         registerBeanPostProcessors(beanFactory);<br /><br />         // Initialize message source for this context.<br />         initMessageSource();<br /><br />         // Initialize event multicaster for this context.<br />         initApplicationEventMulticaster();<br /><br />         // Initialize other special beans in specific context subclasses.<br />         onRefresh();<br /><br />         // Check for listener beans and register them.<br />         registerListeners();<br /><br />         // Instantiate all remaining (non-lazy-init) singletons.<br />         finishBeanFactoryInitialization(beanFactory);<br /><br />         // Last step: publish corresponding event.<br />         finishRefresh();<br />      }<br /><br />      catch (BeansException ex) {<br />         if (logger.isWarnEnabled()) {<br />            logger.warn("Exception encountered during context initialization - " +<br />                  "cancelling refresh attempt: " + ex);<br />         }<br /><br />         // Destroy already created singletons to avoid dangling resources.<br />         destroyBeans();<br /><br />         // Reset 'active' flag.<br />         cancelRefresh(ex);<br /><br />         // Propagate exception to caller.<br />         throw ex;<br />      }<br /><br />      finally {<br />         // Reset common introspection caches in Spring's core, since we<br />         // might not ever need metadata for singleton beans anymore...<br />         resetCommonCaches();<br />      }<br />   }<br />}<br /><br /><span style="color: #339966;">//进一步跟进创建bean工厂的方法obtainFreshBeanFactory,研究bean 标签的解析逻辑</span></pre>
<pre><code>protected ConfigurableListableBeanFactory obtainFreshBeanFactory() {</pre>
<pre><code><em><span style="color: #339966;">   //核心方法，必须读，重要程度：5</span><br />   refreshBeanFactory();<br />   return getBeanFactory();<br />}<br /><br /></em></pre>
</div>
<p>&nbsp;</p>
<pre><code><em>//再一步跟进</em><em>refreshBeanFactory 方法<br /> 跟到这里,我们发现分叉了, 有 多个实现类, 那么是跟哪一个呢?<br /><img src="./images/Spring源码学习笔记之基于ClassPathXmlApplicationContext进行bean标签解析0.png" alt="" /></em></pre>
<pre><code><em>这个是使我们看一下类的继承关系图<br /><img src="./images/Spring源码学习笔记之基于ClassPathXmlApplicationContext进行bean标签解析1.png" alt="" /></em></pre>
<p>&nbsp;</p>
<p>&nbsp;很明显这个时候我们再次跟进的时候需要看的跟的就是org.springframework.context.support.AbstractRefreshableApplicationContext#refreshBeanFactory ,我们再次跟踪</p>
<div class="cnblogs_code">
<pre><code><span style="color: #000000;">    @Override
    </span><span style="color: #0000ff;">protected</span> <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">void</span> refreshBeanFactory() <span style="color: #0000ff;">throws</span><span style="color: #000000;"> BeansException {

        </span><span style="color: #339966;">//</span><span style="color: #008000;"><span style="color: #339966;">如果BeanFactory不为空，则清除BeanFactory和里面的实例</span><br /></span>        <span style="color: #339966;">// 由于我们的容器刚启动,所以这里自然也是false</span>
        <span style="color: #0000ff;">if</span><span style="color: #000000;"> (hasBeanFactory()) {
            destroyBeans();
            closeBeanFactory();
        }
        </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">创建DefaultListableBeanFactory</span>
            DefaultListableBeanFactory beanFactory =<span style="color: #000000;"> createBeanFactory();<br />           
            beanFactory.setSerializationId(getId());

            </span><span style="color: #008000;">//</span><span style="color: #008000;">设置是否可以循环依赖 allowCircularReferences
            </span><span style="color: #008000;">//</span><span style="color: #008000;">是否允许使用相同名称重新注册不同的bean实现.</span>
<span style="color: #000000;">            customizeBeanFactory(beanFactory);

            </span><span style="color: #008000;">//</span><span style="color: #008000;">解析xml，并把xml中的标签封装成BeanDefinition对象</span>
<span style="color: #000000;">            loadBeanDefinitions(beanFactory);
            </span><span style="color: #0000ff;">synchronized</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.beanFactoryMonitor) {
                </span><span style="color: #0000ff;">this</span>.beanFactory =<span style="color: #000000;"> beanFactory;
            }
        }
        </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (IOException ex) {
            </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> ApplicationContextException("I/O error parsing bean definition source for " +<span style="color: #000000;"> getDisplayName(), ex);
        }
    }<br /><br /><br /><span style="color: #339966;">// 进一步跟进spring容器加载beandefinition对象的过程</span></span></pre>
<pre><code>@Override<br />protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException {<br />   // Create a new XmlBeanDefinitionReader for the given BeanFactory.<br />   <span style="color: #339966;">//创建xml的解析器，这里是一个委托模式</span><br />   XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);<br /><br />   // Configure the bean definition reader with this context's<br />   // resource loading environment.<br />   beanDefinitionReader.setEnvironment(this.getEnvironment());<br /><br />   <span style="color: #339966;">//这里传一个this进去，因为ApplicationContext是实现了ResourceLoader接口的</span><br />   beanDefinitionReader.setResourceLoader(this);<br />   beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));<br /><br />   // Allow a subclass to provide custom initialization of the reader,<br />   // then proceed with actually loading the bean definitions.<br />   initBeanDefinitionReader(beanDefinitionReader);<br /><br />   <span style="color: #339966;">//主要看这个方法  重要程度 5</span><br />   loadBeanDefinitions(beanDefinitionReader);<br />}</pre>
<pre><code><span style="color: #000000;">&nbsp;</span></pre>
</div>
<p>&nbsp;</p>
<p>设置资源加载器设置了this 对象象,这是因为当前对象是.AbstractRefreshableApplicationContext,继承自DefaultResourceLoader,</p>
<p>而DefaultResourceLoader 实现了Resourloader 接口</p>
<p><img src="./images/Spring源码学习笔记之基于ClassPathXmlApplicationContext进行bean标签解析2.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>接着上面的源码,进一步跟进核心方法loadBeanDefinitions :</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;"><span style="color: #339966;"> //这里需要我们回忆一下我们最初的构造器,参数是设置到 configLocation 里面去了,所以这里设置核心关注点在从configLocations 中解析xml文件,解析bean标签</span><br />protected</span> <span style="color: #0000ff;">void</span> loadBeanDefinitions(XmlBeanDefinitionReader reader) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> BeansException, IOException {
        Resource[] configResources </span>=<span style="color: #000000;"> getConfigResources();
        </span><span style="color: #0000ff;">if</span> (configResources != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
            reader.loadBeanDefinitions(configResources);
        }
        </span><span style="color: #008000;">//</span><span style="color: #008000;">获取需要加载的xml配置文件</span>
        String[] configLocations =<span style="color: #000000;"> getConfigLocations();
        </span><span style="color: #0000ff;">if</span> (configLocations != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
            reader.loadBeanDefinitions(configLocations);
        }
    }<br /><br /><span style="color: #339966;">//进一步跟进</span></span><span style="color: #339966;">loadBeanDefinitions(String args) 这个方法</span></pre>
<pre><code>@Override<br />public int loadBeanDefinitions(String... locations) throws BeanDefinitionStoreException {</pre>
<pre><code><em><em>   Assert.notNull(locations, "Location array must not be null");<br />   int count = 0;<br />   <span style="color: #339966;">//配置文件有多个，加载多个配置文件</span><br />   for (String location : locations) {<br />     <span style="color: #339966;">//这里的数量是beandefination的数量</span><br />      count += loadBeanDefinitions(location);<br />   }<br />   return count;<br />}<br /><br /><span style="color: #339966;">//再进一步跟进</span><br /></em></em></pre>
<pre><code>@Override<br />public int loadBeanDefinitions(String location) throws BeanDefinitionStoreException {<br />   return loadBeanDefinitions(location, null);<br />}<br /><br /><span style="color: #339966;">//在进一步跟进</span></pre>
<pre><code>public int loadBeanDefinitions(String location, @Nullable Set&lt;Resource&gt; actualResources) throws BeanDefinitionStoreException {<br />   ResourceLoader resourceLoader = getResourceLoader();<br />   if (resourceLoader == null) {<br />      throw new BeanDefinitionStoreException(<br />            "Cannot load bean definitions from location [" + location + "]: no ResourceLoader available");<br />   }<br />   <br />   if (resourceLoader instanceof ResourcePatternResolver) {<br />      // Resource pattern matching available.<br />      try {<br />         <span style="color: #339966;">//把字符串类型的xml文件路径，形如：classpath*:user/**/*-context.xml,转换成Resource对象类型，其实就是用流</span><br /><span style="color: #339966;">         //的方式加载配置文件，然后封装成Resource对象，不重要，可以不看</span><br />         Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);<br /><br />        <span style="color: #339966;"> //主要看这个方法 ** 重要程度 5</span><br />         int count = loadBeanDefinitions(resources);<br />         if (actualResources != null) {<br />            Collections.addAll(actualResources, resources);<br />         }<br />         if (logger.isTraceEnabled()) {<br />            logger.trace("Loaded " + count + " bean definitions from location pattern [" + location + "]");<br />         }<br />         return count;<br />      }<br />      catch (IOException ex) {<br />         throw new BeanDefinitionStoreException(<br />               "Could not resolve bean definition resource pattern [" + location + "]", ex);<br />      }<br />   }<br />   else {<br />      // Can only load single resources by absolute URL.<br />      Resource resource = resourceLoader.getResource(location);<br />      int count = loadBeanDefinitions(resource);<br />      if (actualResources != null) {<br />         actualResources.add(resource);<br />      }<br />      if (logger.isTraceEnabled()) {<br />         logger.trace("Loaded " + count + " bean definitions from location [" + location + "]");<br />      }<br />      return count;<br />   }<br />}<br /><br /> <span style="color: #339966;">// 再进一步跟踪loadBeanDefinitions 方法</span></pre>
<pre><code>public int loadBeanDefinitions(String location, @Nullable Set&lt;Resource&gt; actualResources) throws BeanDefinitionStoreException {<br />   ResourceLoader resourceLoader = getResourceLoader();<br />   if (resourceLoader == null) {<br />      throw new BeanDefinitionStoreException(<br />            "Cannot load bean definitions from location [" + location + "]: no ResourceLoader available");<br />   }<br /><br />   if (resourceLoader instanceof ResourcePatternResolver) {<br />      // Resource pattern matching available.<br />      try {<br />        <span style="color: #339966;"> //把字符串类型的xml文件路径，形如：classpath*:user/**/*-context.xml,转换成Resource对象类型，其实就是用流</span><br /><span style="color: #339966;">         //的方式加载配置文件，然后封装成Resource对象，不重要，可以不看</span><br />         Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);<br /><br />         <span style="color: #339966;">//主要看这个方法 ** 重要程度 5</span><br />         int count = loadBeanDefinitions(resources);<br />         if (actualResources != null) {<br />            Collections.addAll(actualResources, resources);<br />         }<br />         if (logger.isTraceEnabled()) {<br />            logger.trace("Loaded " + count + " bean definitions from location pattern [" + location + "]");<br />         }<br />         return count;<br />      }<br />      catch (IOException ex) {<br />         throw new BeanDefinitionStoreException(<br />               "Could not resolve bean definition resource pattern [" + location + "]", ex);<br />      }<br />   }<br />   else {<br />      // Can only load single resources by absolute URL.<br />      Resource resource = resourceLoader.getResource(location);<br />      int count = loadBeanDefinitions(resource);<br />      if (actualResources != null) {<br />         actualResources.add(resource);<br />      }<br />      if (logger.isTraceEnabled()) {<br />         logger.trace("Loaded " + count + " bean definitions from location [" + location + "]");<br />      }<br />      return count;<br />   }<br />}<br /><br /><span style="color: #339966;">// 进一步跟踪loadBeanDefinitions(resources) 方法</span></pre>
</div>
<p>由于代码很深, 跟着跟着很有可能就跟丢了,这个时候debug 一下:</p>
<p><img src="./images/Spring源码学习笔记之基于ClassPathXmlApplicationContext进行bean标签解析3.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>那么我们继续</p>
<pre><code>// 进一步跟踪<em>loadBeanDefinitions(resources) 方法<br /></em></pre>
<div class="cnblogs_code">
<pre><code><span style="color: #000000;">   @Override
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span> loadBeanDefinitions(Resource... resources) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> BeanDefinitionStoreException {
        Assert.notNull(resources, </span>"Resource array must not be null"<span style="color: #000000;">);
        </span><span style="color: #0000ff;">int</span> count = 0<span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (Resource resource : resources) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">模板设计模式，调用到子类中的方法</span>
            count +=<span style="color: #000000;"> loadBeanDefinitions(resource);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> count;
    }</span><span style="color: #000000;"><br /><br /><span style="color: #339966;">// 再 进一步跟踪</span><br />@Override<br /></span>public int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException {</pre>
<pre><code><span style="color: #339966;">   //EncodedResource带编码的对Resource对象的封装</span><br />   return loadBeanDefinitions(new EncodedResource(resource));<br />}<br /><br /><br />public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException {<br />   Assert.notNull(encodedResource, "EncodedResource must not be null");<br />   if (logger.isTraceEnabled()) {<br />      logger.trace("Loading XML bean definitions from " + encodedResource);<br />   }<br /><br />   Set&lt;EncodedResource&gt; currentResources = this.resourcesCurrentlyBeingLoaded.get();<br />   if (currentResources == null) {<br />      currentResources = new HashSet&lt;&gt;(4);<br />      this.resourcesCurrentlyBeingLoaded.set(currentResources);<br />   }<br />   if (!currentResources.add(encodedResource)) {<br />      throw new BeanDefinitionStoreException(<br />            "Detected cyclic loading of " + encodedResource + " - check your import definitions!");<br />   }<br />   try {<br />      <span style="color: #339966;">//获取Resource对象中的xml文件流对象</span><br />      InputStream inputStream = encodedResource.getResource().getInputStream();<br />      try {<br />        <span style="color: #339966;"> //InputSource是jdk中的sax xml文件解析对象</span><br />         InputSource inputSource = new InputSource(inputStream);<br />         if (encodedResource.getEncoding() != null) {<br />            inputSource.setEncoding(encodedResource.getEncoding());<br />         }<br />         <span style="color: #339966;">//主要看这个方法 **  重要程度 5</span><br /><span style="color: #339966;">         // 这里才是真正开始解析,封装beanDifination对象</span><br />         return doLoadBeanDefinitions(inputSource, encodedResource.getResource());<br />      }<br />      finally {<br />         inputStream.close();<br />      }<br />   }<br />   catch (IOException ex) {<br />      throw new BeanDefinitionStoreException(<br />            "IOException parsing XML document from " + encodedResource.getResource(), ex);<br />   }<br />   finally {<br />      currentResources.remove(encodedResource);<br />      if (currentResources.isEmpty()) {<br />         this.resourcesCurrentlyBeingLoaded.remove();<br />      }<br />   }<br />}</pre>
<pre><code><span style="color: #000000;"><br /><span style="color: #339966;">//进一步跟踪如下</span><br /><span style="color: #339966;">// 加载xml,解析document,将其中的元素封装为beandefinition 并注册</span><br /></span>protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)</pre>
<pre><code><em>      throws BeanDefinitionStoreException {<br /><br />   try {<br />      <span style="color: #339966;">//把inputSource 封装成Document文件对象，这是jdk的API</span><br />      Document doc = doLoadDocument(inputSource, resource);<br /><br />      <span style="color: #339966;">//主要看这个方法，根据解析出来的document对象，拿到里面的标签元素封装成BeanDefinition</span><br />      int count = registerBeanDefinitions(doc, resource);<br />      if (logger.isDebugEnabled()) {<br />         logger.debug("Loaded " + count + " bean definitions from " + resource);<br />      }<br />      return count;<br />   }<br />   catch (BeanDefinitionStoreException ex) {<br />      throw ex;<br />   }<br />   catch (SAXParseException ex) {<br />      throw new XmlBeanDefinitionStoreException(resource.getDescription(),<br />            "Line " + ex.getLineNumber() + " in XML document from " + resource + " is invalid", ex);<br />   }<br />   catch (SAXException ex) {<br />      throw new XmlBeanDefinitionStoreException(resource.getDescription(),<br />            "XML document from " + resource + " is invalid", ex);<br />   }<br />   catch (ParserConfigurationException ex) {<br />      throw new BeanDefinitionStoreException(resource.getDescription(),<br />            "Parser configuration exception parsing XML from " + resource, ex);<br />   }<br />   catch (IOException ex) {<br />      throw new BeanDefinitionStoreException(resource.getDescription(),<br />            "IOException parsing XML document from " + resource, ex);<br />   }<br />   catch (Throwable ex) {<br />      throw new BeanDefinitionStoreException(resource.getDescription(),<br />            "Unexpected exception parsing XML document from " + resource, ex);<br />   }<br />}<br /><br /><span style="color: #339966;">//进一步跟踪源代码</span><br /><span style="color: #339966;">// 创建reader 读取document,并将其封装为 beandefination,以及并注册</span><br /></em>public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException {</pre>
<pre><code><em><span style="color: #339966;">   //又来一记委托模式，BeanDefinitionDocumentReader委托这个类进行document的解析</span><br />   BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();<br />   int countBefore = getRegistry().getBeanDefinitionCount();<br />   <span style="color: #339966;">//主要看这个方法，createReaderContext(resource) XmlReaderContext上下文，封装了XmlBeanDefinitionReader对象</span><br />   documentReader.registerBeanDefinitions(doc, createReaderContext(resource));<br />   return getRegistry().getBeanDefinitionCount() - countBefore;<br />}<br /><br /><span style="color: #339966;">其中部分调用方法简单做一下分析</span><br /></em></pre>
<pre><code>//public XmlReaderContext createReaderContext(Resource resource) {<br />//   return new XmlReaderContext(resource, this.problemReporter, this.eventListener,<br />                                     <span style="color: #339966;"> //获取命名空间解析器,后续用来判断是否默认的名称空间, 针对不同的名称空间进行处理</span><br />//         this.sourceExtractor, this, getNamespaceHandlerResolver());<br />//}<br /><br /><span style="color: #339966;">// 回到主流程进行进一步分析,以及跟踪</span></pre>
<pre><code>@Override<br />public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) {<br />   this.readerContext = readerContext;<br />   <span style="color: #339966;">//主要看这个方法，把root节点传进去</span><br />   doRegisterBeanDefinitions(doc.getDocumentElement());<br />}<br /><br /><span style="color: #339966;">// 此时传入的元素为根元素</span><br />protected void doRegisterBeanDefinitions(Element root) {</pre>
<pre><code><em>   // Any nested &lt;beans&gt; elements will cause recursion in this method. In<br />   // order to propagate and preserve &lt;beans&gt; default-* attributes correctly,<br />   // keep track of the current (parent) delegate, which may be null. Create<br />   // the new (child) delegate with a reference to the parent for fallback purposes,<br />   // then ultimately reset this.delegate back to its original (parent) reference.<br />   // this behavior emulates a stack of delegates without actually necessitating one.<br /></em></pre>
<pre><code>//创建BeanDefinitionParser 的委托类,并进行默认属性的的设置<br />// 如果bean的属性没有设置,则使用默认值得默认属性  <br /><em>  BeanDefinitionParserDelegate parent = this.delegate;<br /></em><em id="__mceDel"><em>     this.delegate = createDelegate(getReaderContext(), root, parent);</em></em></pre>
<pre><code><em id="__mceDel"><em id="__mceDel"><em><br />   <span style="color: #339966;">//判断是否默认的命名空间的依据是否是beans开始的,开始的则是默认的命名空间 否则就不是</span><br />   if (this.delegate.isDefaultNamespace(root)) {<br />      String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);<br />      if (StringUtils.hasText(profileSpec)) {<br />         String[] specifiedProfiles = StringUtils.tokenizeToStringArray(<br />               profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);<br />         // We cannot use Profiles.of(...) since profile expressions are not supported<br />         // in XML config. See SPR-12458 for details.<br />         if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) {<br />            if (logger.isDebugEnabled()) {<br />               logger.debug("Skipped XML bean definition file due to specified profiles [" + profileSpec +<br />                     "] not matching: " + getReaderContext().getResource());<br />            }<br />            return;<br />         }<br />      }<br />   }<br /><br />   <span style="color: #339966;">// 前置处理</span><br />   preProcessXml(root);<br /><br />   <span style="color: #339966;">//主要看这个方法，标签具体解析过程</span><br />   parseBeanDefinitions(root, this.delegate);<br /><br />   <span style="color: #339966;">// 后置处理 模板设计模式 , springmvc 中的interceptor</span><br />   postProcessXml(root);<br /><br />   this.delegate = parent;<br />}</em><br /></em></em></pre>
</div>
<pre><code><em id="__mceDel">&nbsp;</em></pre>
<p>&nbsp;在这里我们需要留意一下创建解析方法,其中有做默认属性的处理</p>
<p><img src="./images/Spring源码学习笔记之基于ClassPathXmlApplicationContext进行bean标签解析4.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><img src="./images/Spring源码学习笔记之基于ClassPathXmlApplicationContext进行bean标签解析5.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><img src="./images/Spring源码学习笔记之基于ClassPathXmlApplicationContext进行bean标签解析6.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;">开始解析元素, 根据命名空间是否默认命名空间,解析方式不一样
</span><span style="color: #008000;">//</span><span style="color: #008000;"> 其中涉及到bean 解析的其实是两种都有设计到, bean 标签没带前缀,为默认命名空
</span><span style="color: #008000;">//</span><span style="color: #008000;"> 开启注解的&lt;context:component-scan= "basepacakge "&gt; 非默认的命名空间
</span><span style="color: #008000;">//</span><span style="color: #008000;"> 我们的bean 标签不属于自定义标签</span>
<span style="color: #0000ff;">protected</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {
   </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (delegate.isDefaultNamespace(root)) {
      NodeList nl </span>=<span style="color: #000000;"> root.getChildNodes();
      </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 0; i &lt; nl.getLength(); i++<span style="color: #000000;">) {
         Node node </span>=<span style="color: #000000;"> nl.item(i);
         </span><span style="color: #0000ff;">if</span> (node <span style="color: #0000ff;">instanceof</span><span style="color: #000000;"> Element) {
            Element ele </span>=<span style="color: #000000;"> (Element) node;
            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (delegate.isDefaultNamespace(ele)) {

               </span><span style="color: #008000;">//</span><span style="color: #008000;">默认标签解析</span>
<span style="color: #000000;">               parseDefaultElement(ele, delegate);
            }
            </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {

               </span><span style="color: #008000;">//</span><span style="color: #008000;">自定义标签解析</span>
<span style="color: #000000;">               delegate.parseCustomElement(ele);
            }
         }
      }
   }
   </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
      delegate.parseCustomElement(root);
   }
}

</span><span style="color: #008000;">//</span><span style="color: #008000;">这里我们先跟踪bean 基于xml的bean 标签解析
</span><span style="color: #008000;">//</span><span style="color: #008000;"> bean 标签属于默认标签</span>
<span style="color: #0000ff;">private</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) {
   </span><span style="color: #008000;">//</span><span style="color: #008000;">import标签解析  重要程度 1 ，可看可不看</span>
   <span style="color: #0000ff;">if</span><span style="color: #000000;"> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) {
      importBeanDefinitionResource(ele);
   }
   </span><span style="color: #008000;">//</span><span style="color: #008000;">alias标签解析 别名标签  重要程度 1 ，可看可不看</span>
   <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span><span style="color: #000000;"> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) {
      processAliasRegistration(ele);
   }
   </span><span style="color: #339966;">//bean标签，重要程度  5，必须看
   </span><span style="color: #008000;">//</span><span style="color: #008000;"> 如果是bean 标签,则进步解析为beanDefinition 对象</span>
   <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span><span style="color: #000000;"> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {
      processBeanDefinition(ele, delegate);
   }
   </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span><span style="color: #000000;"> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) {
      </span><span style="color: #008000;">//</span><span style="color: #008000;"> recurse</span>
<span style="color: #000000;">      doRegisterBeanDefinitions(ele);
   }
}<br /><br /><span style="color: #339966;">//解析bean 标签并封装成beandefinitionHolder  对象</span></span></pre>
<pre><code>protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {<br />   <span style="color: #339966;">//重点看这个方法，重要程度 5 ，解析document，封装成BeanDefinition</span><br />   BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);<br />   if (bdHolder != null) {<br /><br />      <span style="color: #339966;">//该方法功能不重要，设计模式重点看一下，装饰者设计模式，加上SPI设计思想</span><br />      bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);<br />      try {<br /><br />         <span style="color: #339966;">//完成document到BeanDefinition对象转换后，对BeanDefinition对象进行缓存注册</span><br />         // Register the final decorated instance.<br />         BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());<br />      }<br />      catch (BeanDefinitionStoreException ex) {<br />         getReaderContext().error("Failed to register bean definition with name '" +<br />               bdHolder.getBeanName() + "'", ele, ex);<br />      }<br />      // Send registration event.<br />      getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));<br />   }<br />}<br /><br /><span style="color: #339966;">//进一步跟踪</span></pre>
<pre><code>@Nullable<br />public BeanDefinitionHolder parseBeanDefinitionElement(Element ele) {<br />   return parseBeanDefinitionElement(ele, null);<br />}<br /><br /><br /></pre>
<pre><code><span style="color: #339966;">//进一步跟踪</span></pre>
<pre><code>@Nullable<br />public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, @Nullable BeanDefinition containingBean) {<br />   String id = ele.getAttribute(ID_ATTRIBUTE);<br />   String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);<br /><br />   List&lt;String&gt; aliases = new ArrayList&lt;&gt;();<br />   if (StringUtils.hasLength(nameAttr)) {<br />      String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);<br />      aliases.addAll(Arrays.asList(nameArr));<br />   }<br /><br />   String beanName = id;<br />   <span style="color: #339966;">// 当bean 为空, 并且 别名不为空的情况下, 取第一个别名作为bean的别名</span><br />   if (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) {<br />      beanName = aliases.remove(0);<br />      if (logger.isTraceEnabled()) {<br />         logger.trace("No XML 'id' specified - using '" + beanName +<br />               "' as bean name and " + aliases + " as aliases");<br />      }<br />   }<br /><br />  <span style="color: #339966;"> //检查beanName是否重复</span><br />   if (containingBean == null) {<br />      checkNameUniqueness(beanName, aliases, ele);<br />   }<br /><br />   <span style="color: #339966;">// 核心方法.解析元素封装为beandefinition对象</span><br />   AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);<br />   if (beanDefinition != null) {<br />      if (!StringUtils.hasText(beanName)) {<br />         try {<br />            if (containingBean != null) {<br />               beanName = BeanDefinitionReaderUtils.generateBeanName(<br />                     beanDefinition, this.readerContext.getRegistry(), true);<br />            }<br />            else {<br />               <span style="color: #339966;">// 如果即没有name 属性也没有id 属性,此时bean没有名称</span><br /><span style="color: #339966;">               // 这里生成beanName </span><br /><span style="color: #339966;">              // xml 方式的beanName 为 全限定命名#数字 如果 com.test.Student#0</span><br />               beanName = this.readerContext.generateBeanName(beanDefinition);<br />               // Register an alias for the plain bean class name, if still possible,<br />               // if the generator returned the class name plus a suffix.<br />               // This is expected for Spring 1.2/2.0 backwards compatibility.<br />               String beanClassName = beanDefinition.getBeanClassName();<br />               if (beanClassName != null &amp;&amp;<br />                     beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;<br />                     !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) {<br />                  aliases.add(beanClassName);<br />               }<br />            }<br />            if (logger.isTraceEnabled()) {<br />               logger.trace("Neither XML 'id' nor 'name' specified - " +<br />                     "using generated bean name [" + beanName + "]");<br />            }<br />         }<br />         catch (Exception ex) {<br />            error(ex.getMessage(), ele);<br />            return null;<br />         }<br />      }<br />      String[] aliasesArray = StringUtils.toStringArray(aliases);<br />      return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);<br />   }<br /><br />   return null;<br />}<br /><br /><span style="color: #339966;">//进一步跟踪封装成为beanDefinition对象的全过程</span></pre>
<pre><code>public AbstractBeanDefinition parseBeanDefinitionElement(<br />      Element ele, String beanName, @Nullable BeanDefinition containingBean) {<br /><br />   this.parseState.push(new BeanEntry(beanName));<br /><br />   String className = null;<br />  <span style="color: #339966;"> // 获取class 属性</span><br />   if (ele.hasAttribute(CLASS_ATTRIBUTE)) {<br />      className = ele.getAttribute(CLASS_ATTRIBUTE).trim();<br />   }<br />   <span style="color: #339966;">// 获取parent 属性</span><br />   String parent = null;<br />   if (ele.hasAttribute(PARENT_ATTRIBUTE)) {<br />      parent = ele.getAttribute(PARENT_ATTRIBUTE);<br />   }<br /><br />   try {<br />     <span style="color: #339966;"> //创建GenericBeanDefinition对象</span><br /><span style="color: #339966;">      // 这里的beandefinition 对象是</span><em id="__mceDel"><span style="color: #339966;">GenericBeanDefinition</span>  <br /></em><em id="__mceDel"><em id="__mceDel">     AbstractBeanDefinition bd = createBeanDefinition(className, parent);</em></em></pre>
<pre><code><em><em><span style="color: #339966;">      //解析bean标签的属性，并把解析出来的属性设置到BeanDefinition对象中</span><br />      parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);<br />      bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));<br /><br />      <span style="color: #339966;">//解析bean中的meta标签</span><br />      parseMetaElements(ele, bd);<br /><br />      <span style="color: #339966;">//解析bean中的lookup-method标签  重要程度：2，可看可不看</span><br />      parseLookupOverrideSubElements(ele, bd.getMethodOverrides());<br /><br />      <span style="color: #339966;">//解析bean中的replaced-method标签  重要程度：2，可看可不看</span><br />      parseReplacedMethodSubElements(ele, bd.getMethodOverrides());<br /><br />      <span style="color: #339966;">//解析bean中的constructor-arg标签  重要程度：2，可看可不看</span><br />      parseConstructorArgElements(ele, bd);<br /><br />      <span style="color: #339966;">//解析bean中的property标签  重要程度：2，可看可不看</span><br />      parsePropertyElements(ele, bd);<br /><br />      <span style="color: #339966;">//可以不看，用不到</span><br />      parseQualifierElements(ele, bd);<br /><br />      bd.setResource(this.readerContext.getResource());<br />      bd.setSource(extractSource(ele));<br /><br />      return bd;<br />   }<br />   catch (ClassNotFoundException ex) {<br />      error("Bean class [" + className + "] not found", ele, ex);<br />   }<br />   catch (NoClassDefFoundError err) {<br />      error("Class that bean class [" + className + "] depends on not found", ele, err);<br />   }<br />   catch (Throwable ex) {<br />      error("Unexpected failure during bean definition parsing", ele, ex);<br />   }<br />   finally {<br />      this.parseState.pop();<br />   }<br /><br />   return null;<br />}<br /><br /><br /><span style="color: #339966;">// 属性解析的逻辑</span></em></em></pre>
<pre><code>public AbstractBeanDefinition parseBeanDefinitionAttributes(Element ele, String beanName,<br />      @Nullable BeanDefinition containingBean, AbstractBeanDefinition bd) {<br /><br />   if (ele.hasAttribute(SINGLETON_ATTRIBUTE)) {<br />      error("Old 1.x 'singleton' attribute in use - upgrade to 'scope' declaration", ele);<br />   }<br />  <span style="color: #339966;"> // 解析scope 属性</span><br />   else if (ele.hasAttribute(SCOPE_ATTRIBUTE)) {<br />      bd.setScope(ele.getAttribute(SCOPE_ATTRIBUTE));<br />   }<br />   else if (containingBean != null) {<br />      // Take default from containing bean in case of an inner bean definition.<br />      bd.setScope(containingBean.getScope());<br />   }<br />   <span style="color: #339966;">// 解析abstract 属性</span><br />   if (ele.hasAttribute(ABSTRACT_ATTRIBUTE)) {<br />      bd.setAbstract(TRUE_VALUE.equals(ele.getAttribute(ABSTRACT_ATTRIBUTE)));<br />   }<br />   <br />  <span style="color: #339966;">// 从解析委托类中获取默认属性值lazy_init</span><br />   String lazyInit = ele.getAttribute(LAZY_INIT_ATTRIBUTE);<br />   if (DEFAULT_VALUE.equals(lazyInit)) {<br />      lazyInit = this.defaults.getLazyInit();<br />   }<br />   bd.setLazyInit(TRUE_VALUE.equals(lazyInit));<br /><br />   String autowire = ele.getAttribute(AUTOWIRE_ATTRIBUTE);<br />   bd.setAutowireMode(getAutowireMode(autowire));<br />   <span style="color: #339966;">// depends-on 属性</span><br />   if (ele.hasAttribute(DEPENDS_ON_ATTRIBUTE)) {<br />      String dependsOn = ele.getAttribute(DEPENDS_ON_ATTRIBUTE);<br />      bd.setDependsOn(StringUtils.tokenizeToStringArray(dependsOn, MULTI_VALUE_ATTRIBUTE_DELIMITERS));<br />   }<br /><br />   String autowireCandidate = ele.getAttribute(AUTOWIRE_CANDIDATE_ATTRIBUTE);<br />   if ("".equals(autowireCandidate) || DEFAULT_VALUE.equals(autowireCandidate)) {<br />      String candidatePattern = this.defaults.getAutowireCandidates();<br />      if (candidatePattern != null) {<br />         String[] patterns = StringUtils.commaDelimitedListToStringArray(candidatePattern);<br />         bd.setAutowireCandidate(PatternMatchUtils.simpleMatch(patterns, beanName));<br />      }<br />   }<br />   else {<br />      bd.setAutowireCandidate(TRUE_VALUE.equals(autowireCandidate));<br />   }<br /><br />   <span style="color: #339966;">//这个primary 属性</span><br />   if (ele.hasAttribute(PRIMARY_ATTRIBUTE)) {<br />      bd.setPrimary(TRUE_VALUE.equals(ele.getAttribute(PRIMARY_ATTRIBUTE)));<br />   }<br /><br />    <span style="color: #339966;">// init-method 属性</span><br />   if (ele.hasAttribute(INIT_METHOD_ATTRIBUTE)) {<br />      String initMethodName = ele.getAttribute(INIT_METHOD_ATTRIBUTE);<br />      bd.setInitMethodName(initMethodName);<br />   }<br />   else if (this.defaults.getInitMethod() != null) {<br />      bd.setInitMethodName(this.defaults.getInitMethod());<br />      bd.setEnforceInitMethod(false);<br />   }<br /><br />  <span style="color: #339966;"> //destory-method</span> <br />   if (ele.hasAttribute(DESTROY_METHOD_ATTRIBUTE)) {<br />      String destroyMethodName = ele.getAttribute(DESTROY_METHOD_ATTRIBUTE);<br />      bd.setDestroyMethodName(destroyMethodName);<br />   }<br />   else if (this.defaults.getDestroyMethod() != null) {<br />      bd.setDestroyMethodName(this.defaults.getDestroyMethod());<br />      bd.setEnforceDestroyMethod(false);<br />   }<br /><br />  <span style="color: #339966;"> //factory-method</span> <br />   if (ele.hasAttribute(FACTORY_METHOD_ATTRIBUTE)) {<br />      bd.setFactoryMethodName(ele.getAttribute(FACTORY_METHOD_ATTRIBUTE));<br />   }<br />   <span style="color: #339966;">//factory-bean 属性</span><br />   if (ele.hasAttribute(FACTORY_BEAN_ATTRIBUTE)) {<br />      bd.setFactoryBeanName(ele.getAttribute(FACTORY_BEAN_ATTRIBUTE));<br />   }<br /><br />   return bd;<br />}<br /><br /><span style="color: #339966;">//到此,spring 解析bean 标签基本完后,我们在回过去看bean标签解析完成后,做了什么处理</span><br /><span style="color: #339966;">//beandefinition 解析完成后,注册到bean 注册中心中去,后续实例化的时候再去取用</span></pre>
<pre><code>public static void registerBeanDefinition(<br />      BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)<br />      throws BeanDefinitionStoreException {<br /><br />   // Register bean definition under primary name.<br />   String beanName = definitionHolder.getBeanName();<br /><br />   <span style="color: #339966;">//完成BeanDefinition的注册，重点看，重要程度 5</span><br />   registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());<br /><br />   <span style="color: #339966;">//建立别名和 id的映射，这样就可以根据别名获取到id</span><br />   // Register aliases for bean name, if any.<br />   String[] aliases = definitionHolder.getAliases();<br />   if (aliases != null) {<br />      for (String alias : aliases) {<br />         registry.registerAlias(beanName, alias);<br />      }<br />   }<br />}<br /><br /><span style="color: #339966;">// 注册beandefinitionholder 到bean 注册中心中</span></pre>
<pre><code>public static void registerBeanDefinition(<br />      BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)<br />      throws BeanDefinitionStoreException {<br /><br />   // Register bean definition under primary name.<br />   String beanName = definitionHolder.getBeanName();<br /><br />   <span style="color: #339966;">//完成BeanDefinition的注册，重点看，重要程度 5</span><br />   registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());<br /><br />   <span style="color: #339966;">//建立别名和 id的映射，这样就可以根据别名获取到id</span><br />   // Register aliases for bean name, if any.<br />   String[] aliases = definitionHolder.getAliases();<br />   if (aliases != null) {<br />      for (String alias : aliases) {<br />         registry.registerAlias(beanName, alias);<br />      }<br />   }<br />}</pre>
</div>
<p>&nbsp;</p>
<p>至此,bean 标签的解析流程基本结束, 如果用流程图表示整个过程的话,整个过程的整体流程如图所示:</p>
<p><img src="./images/Spring源码学习笔记之基于ClassPathXmlApplicationContext进行bean标签解析7.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><strong>后续会继续完善开启注解扫描部分的讲解.即&lt;context:component-scan="basepackage"&gt; 标签的解析流程.</strong></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<pre><code></pre>
<p>&nbsp;</p>
<pre><code><em id="__mceDel"><br /><br /><br /><br /><br /></em></pre>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>