<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修内置函数 Ⅱ' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>内置函数 Ⅱ</center></div><div class='banquan'>原文出处:本文由博客园博主626提供。<br/>
原文连接:https://www.cnblogs.com/fengqiang626/p/11225667.html</div><br>
    <div class="toc">
    <p class="toc-title">目录</p>
    <div class="toc-list">
        <ul>
        <li><a href="#匿名函数">1. 匿名函数</a><ul>
        <li><a href="#匿名函数顾名思义就是没有名字的函数">1.1匿名函数，顾名思义就是没有名字的函数</a></li>
        <li><a href="#语法">1.2语法:</a></li>
        </ul></li>
        <li><a href="#内置函数">2. 内置函数Ⅱ</a><ul>
        <li><a href="#print-屏幕输出">2.1print() 屏幕输出。</a></li>
        <li><a href="#list-将一个可迭代对象转换成列表">2.2list() 将一个可迭代对象转换成列表</a></li>
        <li><a href="#tuple-将一个可迭代对象转换成元组">2.3tuple() 将一个可迭代对象转换成元组</a></li>
        <li><a href="#dict-通过相应的方式创建字典">2.4dict() 通过相应的方式创建字典</a></li>
        <li><a href="#abs-返回绝对值">2.5abs() 返回绝对值</a></li>
        <li><a href="#sum-求和">2.6sum() 求和</a></li>
        <li><a href="#min-求最小值">2.7min() 求最小值</a></li>
        <li><a href="#max-最大值与最小值用法相同">2.8max() 最大值与最小值用法相同</a></li>
        <li><a href="#zip-拉链方法">2.9zip() 拉链方法</a></li>
        <li><a href="#format格式转换">2.10format格式转换</a></li>
        <li><a href="#reversed">2.11reversed()</a></li>
        <li><a href="#sorted排序函数">2.12sorted排序函数</a></li>
        <li><a href="#filter筛选过滤">2.13filter筛选过滤</a></li>
        <li><a href="#map映射">2.14map映射</a></li>
        <li><a href="#reduce">2.15reduce</a></li>
        </ul></li>
        </ul>
    </div>
</div>
<h2 id="匿名函数">1. 匿名函数</h2>
<h3 id="匿名函数顾名思义就是没有名字的函数">1.1匿名函数，顾名思义就是没有名字的函数</h3>
<p><strong>现在有一个需求：你们写一个函数，此函数接收两个int参数，返回和值。</strong></p>
<pre><code><code>def func(a,b):
    return a+b
print(func(3,4))</code></pre>
<p><strong>那么接下来我们用匿名函数完成上面的需求：</strong></p>
<pre><code><code>func = lambda a,b: a+b
print(func(3, 4))  # 7</code></pre>
<h3 id="语法">1.2语法:</h3>
<p>　　<strong>函数名 = lambda 参数:返回值</strong></p>
<p>​ <strong>1）此函数不是没有名字，他是有名字的，他的名字就是你给其设置的变量，比如func</strong></p>
<p>​ <strong>2）lambda 是定义匿名函数的关键字，相当于函数的def</strong></p>
<p>​ <strong>3）lambda 后面直接加形参，形参加多少都可以，只要用逗号隔开就行</strong></p>
<pre><code><code>func = lambda a,b,*args,sex= &#39;alex&#39;,c,**kwargs: kwargs
print(func(3, 4,c=666,name=&#39;alex&#39;))  # {&#39;name&#39;: &#39;alex&#39;}
# 所有类型的形参都可以加，但是一般使用匿名函数只是加位置参数，其他的用不到。</code></pre>
<p>​ <strong>4）返回值在冒号之后设置，返回值和正常的函数一样,可以是任意数据类型</strong></p>
<p>​ <strong>5）匿名函数不管多复杂.只能写一行.且逻辑结束后直接返回数据</strong></p>
<p><strong>写匿名函数：接收一个可切片的数据，返回索引为0与2的对应的元素(元组形式)</strong></p>
<pre><code><code>func = lambda x:(x[0],x[2])
print(func(&#39;afafasd&#39;))</code></pre>
<p><strong>写匿名函数：接收两个int参数，将较大的数据返回</strong></p>
<pre><code><code>func = lambda x,y: x if x &gt; y else y
print(func(3,100))</code></pre>
<h2 id="内置函数">2. 内置函数Ⅱ</h2>
<h3 id="print-屏幕输出">2.1print() 屏幕输出。</h3>
<pre><code><code>&#39;&#39;&#39; 源码分析
def print(self, *args, sep=&#39; &#39;, end=&#39;\n&#39;, file=None): # known special case of print
    &quot;&quot;&quot;
    print(value, ..., sep=&#39; &#39;, end=&#39;\n&#39;, file=sys.stdout, flush=False)
    file:  默认是输出到屏幕，如果设置为文件句柄，输出到文件
    sep:   打印多个值之间的分隔符，默认为空格
    end:   每一次打印的结尾，默认为换行符
    flush: 立即把内容输出到流文件，不作缓存
    &quot;&quot;&quot;
&#39;&#39;&#39;
print(111,222,333,sep=&#39;*&#39;)  # 111*222*333

print(111,end=&#39;&#39;)
print(222)  #两行的结果 111222

f = open(&#39;log&#39;,&#39;w&#39;,encoding=&#39;utf-8&#39;)
print(&#39;写入文件&#39;,fle=f,flush=True)</code></pre>
<h3 id="list-将一个可迭代对象转换成列表">2.2list() 将一个可迭代对象转换成列表</h3>
<h3 id="tuple-将一个可迭代对象转换成元组">2.3tuple() 将一个可迭代对象转换成元组</h3>
<h3 id="dict-通过相应的方式创建字典">2.4dict() 通过相应的方式创建字典</h3>
<pre><code><code>list
l1 = list(&#39;abcd&#39;)
print(l1)  # [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]
tu1 = tuple(&#39;abcd&#39;)
print(tu1)  # (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;)</code></pre>
<h3 id="abs-返回绝对值">2.5abs() 返回绝对值</h3>
<pre><code><code>i = -5
print(abs(i))  # 5</code></pre>
<h3 id="sum-求和">2.6sum() 求和</h3>
<pre><code><code>print(sum([1,2,3]))
print(sum((1,2,3),100))</code></pre>
<h3 id="min-求最小值">2.7min() 求最小值</h3>
<pre><code><code>print(min([1,2,3]))  # 返回此序列最小值

ret = min([1,2,-5,],key=abs)  # 按照绝对值的大小，返回此序列最小值
print(ret)
# 加key是可以加函数名，min自动会获取传入函数中的参数的每个元素，然后通过你设定的返回值比较大小，返回最小的传入的那个参数。
print(min(1,2,-5,6,-3,key=lambda x:abs(x)))  # 可以设置很多参数比较大小
dic = {&#39;a&#39;:3,&#39;b&#39;:2,&#39;c&#39;:1}
print(min(dic,key=lambda x:dic[x]))

# x为dic的key，lambda的返回值（即dic的值进行比较）返回最小的值对应的键</code></pre>
<h3 id="max-最大值与最小值用法相同">2.8max() 最大值与最小值用法相同</h3>
<h3 id="zip-拉链方法">2.9zip() 拉链方法</h3>
<p><strong>函数用于将可迭代的对象作为参数,将对象中对应的元素打包成一个个元组,然后返回由这些元祖组成的内容,如果各个迭代器的元素个数不一致,则按照长度最短的返回</strong></p>
<pre><code><code>lst1 = [1,2,3]

lst2 = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;]

lst3 = (11,12,13,14,15)

for i in zip(lst1,lst2,lst3):

    print(i)

# 结果:

(1, &#39;a&#39;, 11)

(2, &#39;b&#39;, 12)

(3, &#39;c&#39;, 13)</code></pre>
<h3 id="format格式转换">2.10format格式转换</h3>
<pre><code><code>print(format(13,&#39;b&#39;)) # 转换成二进制
print(format(13,&#39;08b&#39;)) #转换成二进制一共是8位

print(format(13,&#39;d&#39;)) # 转换成十进制
print(format(13,&#39;o&#39;)) # 转换成八进制
print(format(13,&#39;x&#39;)) # 转换成十六进制

print(format(13,&quot;^20&quot;)) # 占用20位,内容居中显示
print(format(13,&quot;&gt;20&quot;)) # 左对齐20位
print(format(13,&quot;&lt;20&quot;)) # 右对齐20位</code></pre>
<h3 id="reversed">2.11reversed()</h3>
<p><strong>将一个序列翻转, 返回翻转序列的迭代器 reversed 示例</strong></p>
<pre><code><code>l = reversed(&#39;你好&#39;)  # l 获取到的是一个生成器
print(list(l))
ret = reversed([1, 4, 3, 7, 9])
print(list(ret))  # [9, 7, 3, 4, 1]</code></pre>
<h3 id="sorted排序函数">2.12sorted排序函数</h3>
<pre><code><code># 语法:sorted(iterable,key=None,reverse=False)

# iterable : 可迭代对象

# key: 排序规则(排序函数),在sorted内部会将可迭代对象中的每一个元素传递给这个函数的参数.根据函数运算的结果进行排序

# reverse :是否是倒序,True 倒序 False 正序

lst = [1,3,2,5,4]
lst2 = sorted(lst)
print(lst)    #原列表不会改变
print(lst2)   #返回的新列表是经过排序的


lst3 = sorted(lst,reverse=True)
print(lst3)   #倒叙

结果:
[1, 3, 2, 5, 4]
[1, 2, 3, 4, 5]
[5, 4, 3, 2, 1]

# # 字典使用sorted排序

dic = {1:&#39;a&#39;,3:&#39;c&#39;,2:&#39;b&#39;}
print(sorted(dic))   # 字典排序返回的就是排序后的key

结果:
[1,2,3]

# 和函数组合使用

# 定义一个列表,然后根据一元素的长度排序
lst = [&#39;天龙八部&#39;,&#39;西游记&#39;,&#39;红楼梦&#39;,&#39;三国演义&#39;]

# 计算字符串的长度
def func(s):
    return len(s)
print(sorted(lst,key=func))

# 结果:
# [&#39;西游记&#39;, &#39;红楼梦&#39;, &#39;天龙八部&#39;, &#39;三国演义&#39;]


# 和lambda组合使用

lst = [&#39;天龙八部&#39;,&#39;西游记&#39;,&#39;红楼梦&#39;,&#39;三国演义&#39;]

print(sorted(lst,key=lambda s:len(s)))

结果:
[&#39;西游记&#39;, &#39;红楼梦&#39;, &#39;天龙八部&#39;, &#39;三国演义&#39;]


lst = [{&#39;id&#39;:1,&#39;name&#39;:&#39;alex&#39;,&#39;age&#39;:18},
    {&#39;id&#39;:2,&#39;name&#39;:&#39;wusir&#39;,&#39;age&#39;:17},
    {&#39;id&#39;:3,&#39;name&#39;:&#39;taibai&#39;,&#39;age&#39;:16},]

# 按照年龄对学生信息进行排序

print(sorted(lst,key=lambda e:e[&#39;age&#39;]))

结果:
[{&#39;id&#39;: 3, &#39;name&#39;: &#39;taibai&#39;, &#39;age&#39;: 16}, {&#39;id&#39;: 2, &#39;name&#39;: &#39;wusir&#39;, &#39;age&#39;: 17}, {&#39;id&#39;: 1, &#39;name&#39;: &#39;alex&#39;, &#39;age&#39;: 18}]</code></pre>
<h3 id="filter筛选过滤">2.13filter筛选过滤</h3>
<pre><code><code># 语法: filter(function,iterable)

# function: 用来筛选的函数,在filter中会自动的把iterable中的元素传递给function,然后根据function返回的True或者False来判断是否保留此项数据

# iterable:可迭代对象

lst = [{&#39;id&#39;:1,&#39;name&#39;:&#39;alex&#39;,&#39;age&#39;:18},
        {&#39;id&#39;:1,&#39;name&#39;:&#39;wusir&#39;,&#39;age&#39;:17},
        {&#39;id&#39;:1,&#39;name&#39;:&#39;taibai&#39;,&#39;age&#39;:16},]

ls = filter(lambda e:e[&#39;age&#39;] &gt; 16,lst)

print(list(ls))

# 结果:
[{&#39;id&#39;: 1, &#39;name&#39;: &#39;alex&#39;, &#39;age&#39;: 18},
 {&#39;id&#39;: 1, &#39;name&#39;: &#39;wusir&#39;, &#39;age&#39;: 17}]</code></pre>
<h3 id="map映射">2.14map映射</h3>
<pre><code><code># 映射函数

# 语法: map(function,iterable) 可以对可迭代对象中的每一个元素进映射,分别取执行function

# 计算列表中每个元素的平方,返回新列表

lst = [1,2,3,4,5]

def func(s):

    return  s*s

mp = map(func,lst)

print(mp)

print(list(mp))

# 改写成lambda

lst = [1,2,3,4,5]

print(list(map(lambda s:s*s,lst)))

# 计算两个列表中相同位置的数据的和

lst1 = [1, 2, 3, 4, 5]

lst2 = [2, 4, 6, 8, 10]

print(list(map(lambda x, y: x+y, lst1, lst2)))
# 结果:
[3, 6, 9, 12, 15]</code></pre>
<h3 id="reduce">2.15reduce</h3>
<pre><code><code># from functools import reduce
def func(x,y):
    return x + y

# reduce 的使用方式:
# reduce(函数名,可迭代对象)  # 这两个参数必须都要有,缺一个不行

ret = reduce(func,[3,4,5,6,7])
print(ret)  # 结果 25
# reduce的作用是先把列表中的前俩个元素取出计算出一个值然后临时保存着,
# 接下来用这个临时保存的值和列表中第三个元素进行计算,求出一个新的值将最开始
# 临时保存的值覆盖掉,然后在用这个新的临时值和列表中第四个元素计算.依次类推

# 注意:我们放进去的可迭代对象没有更改
# 以上这个例子我们使用sum就可以完全的实现了.我现在有[1,2,3,4]想让列表中的数变成1234,就要用到reduce了.
# 普通函数版
from functools import reduce
def func(x,y):

    return x * 10 + y
    # 第一次的时候 x是1 y是2  x乘以10就是10,然后加上y也就是2最终结果是12然后临时存储起来了
    # 第二次的时候x是临时存储的值12 x乘以10就是 120 然后加上y也就是3最终结果是123临时存储起来了
    # 第三次的时候x是临时存储的值123 x乘以10就是 1230 然后加上y也就是4最终结果是1234然后返回了

l = reduce(func,[1,2,3,4])
print(l)

# 匿名函数版
l = reduce(lambda x,y:x*10+y,[1,2,3,4])
print(l)

# 在Python2.x版本中recude是直接 import就可以的, Python3.x版本中需要从functools这个包中导入

# 龟叔本打算将 lambda 和 reduce 都从全局名字空间都移除, 舆论说龟叔不喜欢lambda 和 reduce

# 最后lambda没删除是因为和一个人给龟叔写了好多封,进行交流然后把lambda保住了.</code></pre>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>