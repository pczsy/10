<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修Python IO model' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>Python IO model</center></div><div class='banquan'>原文出处:本文由博客园博主feel_different提供。<br/>
原文连接:https://www.cnblogs.com/bind/p/11507956.html</div><br>
    <h1>1、 事件驱动模型</h1>
<p>传统线性模式编程：开始---&gt;代码块A---&gt;代码块B---&gt;代码块C---&gt;结束</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('eaa1bfa3-139a-4ef0-9037-19d7309cbd52')"><img id="code_img_closed_eaa1bfa3-139a-4ef0-9037-19d7309cbd52" class="code_img_closed" src="./images/Python IO model0.png" alt="" /><img id="code_img_opened_eaa1bfa3-139a-4ef0-9037-19d7309cbd52" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('eaa1bfa3-139a-4ef0-9037-19d7309cbd52',event)" src="./images/Python IO model1.png" alt="" />
<div id="cnblogs_code_open_eaa1bfa3-139a-4ef0-9037-19d7309cbd52" class="cnblogs_code_hide">
<pre><code><span style="color: #008080;">  1</span> 每一个代码块里是完成各种各样事情的代码，但编程者知道代码块A,B,C,D...的执行顺序，唯一能够改变这个流程的是数据。输入不同的数据，根据条件语句判断，流程或许就改为A---&gt;C---&gt;E...---&gt;结束。每一次程序运行顺序或许都不同，但它的控制流程是由输入数据和你编写的程序决定的。如果你知道这个程序当前的运行状态（包括输入数据和程序本身），那你就知道接下来甚至一直到结束它的运行流程。</pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>事件驱动型程序模型：开始---&gt;初始化---&gt;等待</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('83b87fd3-d639-4f23-bfc3-a227d6599ef8')"><img id="code_img_closed_83b87fd3-d639-4f23-bfc3-a227d6599ef8" class="code_img_closed" src="./images/Python IO model0.png" alt="" /><img id="code_img_opened_83b87fd3-d639-4f23-bfc3-a227d6599ef8" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('83b87fd3-d639-4f23-bfc3-a227d6599ef8',event)" src="./images/Python IO model1.png" alt="" />
<div id="cnblogs_code_open_83b87fd3-d639-4f23-bfc3-a227d6599ef8" class="cnblogs_code_hide">
<pre><code><span style="color: #008080;">  1</span> 与传统编程模式不同，事件驱动程序在启动之后，就在那等待被事件触发。传统编程下也有&ldquo;等待&rdquo;的时候，比如在代码块D中，你定义了一个input()，需要用户输入数据。但这与下面的等待不同，传统编程的&ldquo;等待&rdquo;，比如input()，你作为程序编写者是知道或者强制用户输入某个东西的，或许是数字，或许是文件名称，如果用户输入错误，你还需要提醒他，并请他重新输入。事件驱动程序的等待则是完全不知道，也不强制用户输入或者干什么。只要某一事件发生，那程序就会做出相应的&ldquo;反应&rdquo;。这些事件包括：输入信息、鼠标、敲击键盘上某个键还有系统内部定时器触发。</pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<h2><strong>1.1论事件驱动模型</strong></h2>
<p>有以下几种服务器处理模型:</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;">  1</span> 每收到一个请求，创建一个新的进程，来处理该请求；
<span style="color: #008080;">  2</span> 每收到一个请求，创建一个新的线程，来处理该请求；
<span style="color: #008080;">  3</span> 每收到一个请求，放入一个事件列表，让主进程通过非阻塞I/O方式来处理</pre>
</div>
<div class="cnblogs_code" onclick="cnblogs_code_show('5a62a727-2fa0-4c72-8d5e-d0290e5aa5b5')"><img id="code_img_closed_5a62a727-2fa0-4c72-8d5e-d0290e5aa5b5" class="code_img_closed" src="./images/Python IO model0.png" alt="" /><img id="code_img_opened_5a62a727-2fa0-4c72-8d5e-d0290e5aa5b5" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('5a62a727-2fa0-4c72-8d5e-d0290e5aa5b5',event)" src="./images/Python IO model1.png" alt="" />
<div id="cnblogs_code_open_5a62a727-2fa0-4c72-8d5e-d0290e5aa5b5" class="cnblogs_code_hide">
<pre><code><span style="color: #008080;">  1</span> <span style="color: #0000ff;">&lt;</span>!DOCTYPE html<span style="color: #0000ff;">&gt;</span>
<span style="color: #008080;">  2</span> <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">html</span> <span style="color: #ff0000;">lang</span>=<span style="color: #0000ff;">"en"</span><span style="color: #0000ff;">&gt;</span>
<span style="color: #008080;">  3</span> <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">head</span><span style="color: #0000ff;">&gt;</span>
<span style="color: #008080;">  4</span>     <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">meta</span> <span style="color: #ff0000;">charset</span>=<span style="color: #0000ff;">"UTF-8"</span><span style="color: #0000ff;">&gt;</span>
<span style="color: #008080;">  5</span>     <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">title</span><span style="color: #0000ff;">&gt;</span>Title<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">title</span><span style="color: #0000ff;">&gt;</span>
<span style="color: #008080;">  6</span> 
<span style="color: #008080;">  7</span> <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">head</span><span style="color: #0000ff;">&gt;</span>
<span style="color: #008080;">  8</span> <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">body</span><span style="color: #0000ff;">&gt;</span>
<span style="color: #008080;">  9</span> 
<span style="color: #008080;"> 10</span> <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">p</span> <span style="color: #ff0000;">onclick</span>=<span style="color: #0000ff;">"fun()"</span><span style="color: #0000ff;">&gt;</span>点我呀<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">p</span><span style="color: #0000ff;">&gt;</span>
<span style="color: #008080;"> 11</span> 
<span style="color: #008080;"> 12</span> 
<span style="color: #008080;"> 13</span> <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">script</span> <span style="color: #ff0000;">type</span>=<span style="color: #0000ff;">"text/javascript"</span><span style="color: #0000ff;">&gt;</span>
<span style="color: #008080;"> 14</span>     function fun() {
<span style="color: #008080;"> 15</span>           alert('hello')
<span style="color: #008080;"> 16</span>     }
<span style="color: #008080;"> 17</span> <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">script</span><span style="color: #0000ff;">&gt;</span>
<span style="color: #008080;"> 18</span> <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">body</span><span style="color: #0000ff;">&gt;</span>
<span style="color: #008080;"> 19</span> 
<span style="color: #008080;"> 20</span> <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">html</span><span style="color: #0000ff;">&gt;</span></pre>
</div>
<span class="cnblogs_code_collapse">事件驱动之鼠标点击事件注册</span></div>
<p>&nbsp;</p>
<p><span style="background-color: #cccccc;">在UI编程中，有两种方式获得鼠标点击：</span></p>
<h6><span style="font-size: small;">1、创建一个线程循环检测是否有鼠标点击</span></h6>
<div class="cnblogs_code" onclick="cnblogs_code_show('27f256b1-2cf9-43d2-bcc7-d05654759b66')"><img id="code_img_closed_27f256b1-2cf9-43d2-bcc7-d05654759b66" class="code_img_closed" src="./images/Python IO model0.png" alt="" /><img id="code_img_opened_27f256b1-2cf9-43d2-bcc7-d05654759b66" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('27f256b1-2cf9-43d2-bcc7-d05654759b66',event)" src="./images/Python IO model1.png" alt="" />
<div id="cnblogs_code_open_27f256b1-2cf9-43d2-bcc7-d05654759b66" class="cnblogs_code_hide">
<pre><code><span style="color: #008080;">  1</span> 
<span style="color: #008080;">  2</span>     1、CPU资源浪费，可能鼠标点击的频率非常小，但是扫描线程还是会一直循环检测，这会造成很多的CPU资源浪费；如果扫描鼠标点击的接口是阻塞的呢？
<span style="color: #008080;">  3</span>     2、如果是堵塞的，又会出现下面这样的问题，如果我们不但要扫描鼠标点击，还要扫描键盘是否按下，由于扫描鼠标时被堵塞了，那么可能永远不会去扫描键盘；
<span style="color: #008080;">  4</span>     3、如果一个循环需要扫描的设备非常多，这又会引来响应时间的问题；
<span style="color: #008080;">  5</span>     所以，该方式是非常不好的。</pre>
</div>
<span class="cnblogs_code_collapse">缺点</span></div>
<h6><span style="font-size: small;">2、 事件驱动模型</span>&nbsp;</h6>
<div class="cnblogs_code" onclick="cnblogs_code_show('57c5509e-de1e-4bd6-99e2-d628864be36a')"><img id="code_img_closed_57c5509e-de1e-4bd6-99e2-d628864be36a" class="code_img_closed" src="./images/Python IO model0.png" alt="" /><img id="code_img_opened_57c5509e-de1e-4bd6-99e2-d628864be36a" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('57c5509e-de1e-4bd6-99e2-d628864be36a',event)" src="./images/Python IO model1.png" alt="" />
<div id="cnblogs_code_open_57c5509e-de1e-4bd6-99e2-d628864be36a" class="cnblogs_code_hide">
<pre><code><span style="color: #008080;">  1</span> 1、有一个事件（消息）队列；
<span style="color: #008080;">  2</span> 2、鼠标按下时，往这个队列中增加一个点击事件（消息）；
<span style="color: #008080;">  3</span> 3、有个循环，不断从队列取出事件，根据不同的事件，调用不同的函数，如onClick()、onKeyDown()等；
<span style="color: #008080;">  4</span> 4、事件（消息）一般都各自保存各自的处理函数指针，这样，每个消息都有独立的处理函数；</pre>
</div>
<span class="cnblogs_code_collapse">思路</span></div>
<p><img title="" src="./images/Python IO model10.png" alt="这里写图片描述" /></p>
<p><strong>事件驱动编程是一种编程范式，这里程序的执行流由外部事件来决定。它的特点是包含一个事件循环，当外部事件发生时使用回调机制来触发相应的处理</strong>。</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('2303f507-2907-4a92-9a15-6d4b5e1147a3')"><img id="code_img_closed_2303f507-2907-4a92-9a15-6d4b5e1147a3" class="code_img_closed" src="./images/Python IO model0.png" alt="" /><img id="code_img_opened_2303f507-2907-4a92-9a15-6d4b5e1147a3" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('2303f507-2907-4a92-9a15-6d4b5e1147a3',event)" src="./images/Python IO model1.png" alt="" />
<div id="cnblogs_code_open_2303f507-2907-4a92-9a15-6d4b5e1147a3" class="cnblogs_code_hide">
<pre><code><span style="color: #008080;">  1</span> 1.要理解事件驱动和程序，就需要与非事件驱动的程序进行比较。实际上，现代的程序大多是事件驱动的，比如多线程的程序，肯定是事件驱动的。早期则存在许多非事件驱动的程序，这样的程序，在需要等待某个条件触发时，会不断地检查这个条件，直到条件满足，这是很浪费cpu时间的。而事件驱动的程序，则有机会释放cpu从而进入睡眠态（注意是有机会，当然程序也可自行决定不释放cpu），当事件触发时被操作系统唤醒，这样就能更加有效地使用cpu.
<span style="color: #008080;">  2</span> 2.再说什么是事件驱动的程序。一个典型的事件驱动的程序，就是一个死循环，并以一个线程的形式存在，这个死循环包括两个部分，第一个部分是按照一定的条件接收并选择一个要处理的事件，第二个部分就是事件的处理过程。程序的执行过程就是选择事件和处理事件，而当没有任何事件触发时，程序会因查询事件队列失败而进入睡眠状态，从而释放cpu。
<span style="color: #008080;">  3</span> 3.事件驱动的程序，必定会直接或者间接拥有一个事件队列，用于存储未能及时处理的事件。
<span style="color: #008080;">  4</span> 4.事件驱动的程序的行为，完全受外部输入的事件控制，所以，事件驱动的系统中，存在大量这种程序，并以事件作为主要的通信方式。
<span style="color: #008080;">  5</span> 5.事件驱动的程序，还有一个最大的好处，就是可以按照一定的顺序处理队列中的事件，而这个顺序则是由事件的触发顺序决定的，这一特性往往被用于保证某些过程的原子化。
<span style="color: #008080;">  6</span> 6.目前windows,linux,nucleus,vxworks都是事件驱动的，只有一些单片机可能是非事件驱动的。
<span style="color: #008080;">  7</span> 事件驱动的监听事件是由操作系统调用的cpu来完成的</pre>
</div>
<span class="cnblogs_code_collapse">事件驱动注解</span></div>
<h1>2、IO多路复用</h1>
<p>IO多路复用就是实现事件驱动的情况下IO的自动阻塞的切换，比如socketserver，多个客户端连接，单线程下实现并发效果，就叫多路复用。</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('1eb5a754-9aa1-4c7b-94b8-1bce85513d74')"><img id="code_img_closed_1eb5a754-9aa1-4c7b-94b8-1bce85513d74" class="code_img_closed" src="./images/Python IO model0.png" alt="" /><img id="code_img_opened_1eb5a754-9aa1-4c7b-94b8-1bce85513d74" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('1eb5a754-9aa1-4c7b-94b8-1bce85513d74',event)" src="./images/Python IO model1.png" alt="" />
<div id="cnblogs_code_open_1eb5a754-9aa1-4c7b-94b8-1bce85513d74" class="cnblogs_code_hide">
<pre><code><span style="color: #008080;">  1</span> 下图展示了随着时间的推移，这三种模式下程序所做的工作。这个程序有3个任务需要完成，每个任务都在等待I/O操作时阻塞自身。阻塞在I/O操作上所花费的时间已经用灰色框标示出来了。通过回调函数可以确定IO操作完了切回去 。
<span style="color: #008080;">  2</span> </pre>
</div>
<span class="cnblogs_code_collapse">用协程实现的IO阻塞自动切换</span></div>
<h2>2.1概念准备</h2>
<ol>
<li>用户空间和内核空间
<div class="cnblogs_code" onclick="cnblogs_code_show('12891251-7858-4226-9290-f6151ed62b97')"><img id="code_img_closed_12891251-7858-4226-9290-f6151ed62b97" class="code_img_closed" src="./images/Python IO model0.png" alt="" /><img id="code_img_opened_12891251-7858-4226-9290-f6151ed62b97" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('12891251-7858-4226-9290-f6151ed62b97',event)" src="./images/Python IO model1.png" alt="" />
<div id="cnblogs_code_open_12891251-7858-4226-9290-f6151ed62b97" class="cnblogs_code_hide">
<pre><code><span style="color: #008080;">  1</span> 现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。
<span style="color: #008080;">  2</span> 操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。
<span style="color: #008080;">  3</span> 为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。
<span style="color: #008080;">  4</span> 针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。</pre>
</div>
<span class="cnblogs_code_collapse">用户空间与内核空间</span></div>
</li>
<li>进程切换
<div class="cnblogs_code" onclick="cnblogs_code_show('b96b4464-e65a-4769-b3c4-c8d1a7df34da')"><img id="code_img_closed_b96b4464-e65a-4769-b3c4-c8d1a7df34da" class="code_img_closed" src="./images/Python IO model0.png" alt="" /><img id="code_img_opened_b96b4464-e65a-4769-b3c4-c8d1a7df34da" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('b96b4464-e65a-4769-b3c4-c8d1a7df34da',event)" src="./images/Python IO model1.png" alt="" />
<div id="cnblogs_code_open_b96b4464-e65a-4769-b3c4-c8d1a7df34da" class="cnblogs_code_hide">
<pre><code><span style="color: #008080;">  1</span> 为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换，这种切换是由操作系统来完成的。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。
<span style="color: #008080;">  2</span> 从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：
<span style="color: #008080;">  3</span> 
<span style="color: #008080;">  4</span> 保存处理机上下文，包括程序计数器和其他寄存器。
<span style="color: #008080;">  5</span> 
<span style="color: #008080;">  6</span> 更新PCB信息。
<span style="color: #008080;">  7</span> 
<span style="color: #008080;">  8</span> 把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。
<span style="color: #008080;">  9</span> 
<span style="color: #008080;"> 10</span> 选择另一个进程执行，并更新其PCB。
<span style="color: #008080;"> 11</span> 
<span style="color: #008080;"> 12</span> 更新内存管理的数据结构。
<span style="color: #008080;"> 13</span> 
<span style="color: #008080;"> 14</span> 恢复处理机上下文。
<span style="color: #008080;"> 15</span> 注：总而言之就是很耗资源的</pre>
</div>
<span class="cnblogs_code_collapse">进程切换</span></div>
</li>
<li>进程的阻塞
<div class="cnblogs_code" onclick="cnblogs_code_show('28578ff1-82b3-4689-8e0a-bf2740693f8c')"><img id="code_img_closed_28578ff1-82b3-4689-8e0a-bf2740693f8c" class="code_img_closed" src="./images/Python IO model0.png" alt="" /><img id="code_img_opened_28578ff1-82b3-4689-8e0a-bf2740693f8c" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('28578ff1-82b3-4689-8e0a-bf2740693f8c',event)" src="./images/Python IO model1.png" alt="" />
<div id="cnblogs_code_open_28578ff1-82b3-4689-8e0a-bf2740693f8c" class="cnblogs_code_hide">
<pre><code><span style="color: #008080;">  1</span> 正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。当进程进入阻塞状态，是不占用CPU资源的。</pre>
</div>
<span class="cnblogs_code_collapse">进程阻塞</span></div>
</li>
<li>文件描述符
<div class="cnblogs_code" onclick="cnblogs_code_show('6a86e7e2-d57c-4307-bc45-4da872d65a57')"><img id="code_img_closed_6a86e7e2-d57c-4307-bc45-4da872d65a57" class="code_img_closed" src="./images/Python IO model0.png" alt="" /><img id="code_img_opened_6a86e7e2-d57c-4307-bc45-4da872d65a57" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('6a86e7e2-d57c-4307-bc45-4da872d65a57',event)" src="./images/Python IO model1.png" alt="" />
<div id="cnblogs_code_open_6a86e7e2-d57c-4307-bc45-4da872d65a57" class="cnblogs_code_hide">
<pre><code><span style="color: #008080;">  1</span> 文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。
<span style="color: #008080;">  2</span> 文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。</pre>
</div>
<span class="cnblogs_code_collapse">文件描述符</span></div>
</li>
<li>缓存 I/O</li>
</ol>
<div class="cnblogs_code" onclick="cnblogs_code_show('72fa0b9a-f6ed-46af-ac2c-2f24475492ac')"><img id="code_img_closed_72fa0b9a-f6ed-46af-ac2c-2f24475492ac" class="code_img_closed" src="./images/Python IO model0.png" alt="" /><img id="code_img_opened_72fa0b9a-f6ed-46af-ac2c-2f24475492ac" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('72fa0b9a-f6ed-46af-ac2c-2f24475492ac',event)" src="./images/Python IO model1.png" alt="" />
<div id="cnblogs_code_open_72fa0b9a-f6ed-46af-ac2c-2f24475492ac" class="cnblogs_code_hide">
<pre><code><span style="color: #008080;">  1</span> 缓存 I/O 又被称作标准 I/O，大多数文件系统的默认 I/O 操作都是缓存 I/O。在 Linux 的缓存 I/O 机制中，操作系统会将 I/O 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。用户空间没法直接访问内核空间的，内核态到用户态的数据拷贝</pre>
</div>
<span class="cnblogs_code_collapse">缓存 I/O</span></div>
<p>缓存 I/O 的缺点：</p>
<p>数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。</p>
<h2>2.2四种常用的 IO Model</h2>
<p>对于一个network IO，它涉及到两个系统对象，</p>
<p>一个是调用这个IO的process (or thread)，</p>
<p>另一个就是系统内核(kernel)。</p>
<p>以read举例,当一个read操作发生时，它会经历两个阶段：<br /> 1 等待数据准备 (Waiting for the data to be ready)<br /> 2 将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)<br /><span style="background-color: #ffc000; color: #2f2f2f;">IO Model的区别就是在两个阶段上各有不同的情况。</span></p>
<h3>blocking IO （阻塞IO）</h3>
<div class="cnblogs_code" onclick="cnblogs_code_show('e8030c02-d81a-4aba-b5b8-409955bfbf32')"><img id="code_img_closed_e8030c02-d81a-4aba-b5b8-409955bfbf32" class="code_img_closed" src="./images/Python IO model0.png" alt="" /><img id="code_img_opened_e8030c02-d81a-4aba-b5b8-409955bfbf32" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('e8030c02-d81a-4aba-b5b8-409955bfbf32',event)" src="./images/Python IO model1.png" alt="" />
<div id="cnblogs_code_open_e8030c02-d81a-4aba-b5b8-409955bfbf32" class="cnblogs_code_hide">
<pre><code><span style="color: #008080;">  1</span> 在linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样：
<span style="color: #008080;">  2</span> 
<span style="color: #008080;">  3</span> 
<span style="color: #008080;">  4</span>       当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据。对于network io来说，很多时候数据在一开始还没有到达（比如，还没有收到一个完整的UDP包），这个时候kernel就要等待足够的数据到来。而在用户进程这边，整个进程会被阻塞。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。
<span style="color: #008080;">  5</span> 所以，blocking IO的特点就是在IO执行的两个阶段都被block了。</pre>
</div>
<span class="cnblogs_code_collapse">阻塞IO</span></div>
<h3>non-blocking IO（非阻塞IO）</h3>
<div class="cnblogs_code" onclick="cnblogs_code_show('fa529ab3-8a3a-42a5-8776-5031aca3464f')"><img id="code_img_closed_fa529ab3-8a3a-42a5-8776-5031aca3464f" class="code_img_closed" src="./images/Python IO model0.png" alt="" /><img id="code_img_opened_fa529ab3-8a3a-42a5-8776-5031aca3464f" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('fa529ab3-8a3a-42a5-8776-5031aca3464f',event)" src="./images/Python IO model1.png" alt="" />
<div id="cnblogs_code_open_fa529ab3-8a3a-42a5-8776-5031aca3464f" class="cnblogs_code_hide">
<pre><code><span style="color: #008080;">  1</span> linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子：
<span style="color: #008080;">  2</span> 
<span style="color: #008080;">  3</span>       从图中可以看出，当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。
<span style="color: #008080;">  4</span> 所以，用户进程其实是需要不断的主动询问kernel数据好了没有。
<span style="color: #008080;">  5</span> 
<span style="color: #008080;">  6</span>  注意：
<span style="color: #008080;">  7</span> 
<span style="color: #008080;">  8</span>       在网络IO时候，非阻塞IO也会进行recvform系统调用，检查数据是否准备好，与阻塞IO不一样，&rdquo;非阻塞将大的整片时间的阻塞分成N多的小的阻塞, 所以进程不断地有机会 &lsquo;被&rsquo; CPU光顾&rdquo;。即每次recvform系统调用之间，cpu的权限还在进程手中，这段时间是可以做其他事情的，
<span style="color: #008080;">  9</span> 
<span style="color: #008080;"> 10</span>       也就是说非阻塞的recvform系统调用调用之后，进程并没有被阻塞，内核马上返回给进程，如果数据还没准备好，此时会返回一个error。进程在返回之后，可以干点别的事情，然后再发起recvform系统调用。重复上面的过程，循环往复的进行recvform系统调用。这个过程通常被称之为轮询。轮询检查内核数据，直到数据准备好，再拷贝数据到进程，进行数据处理。需要注意，拷贝数据整个过程，进程仍然是属于阻塞的状态。</pre>
</div>
<span class="cnblogs_code_collapse">非阻塞IO</span></div>
<div class="cnblogs_code" onclick="cnblogs_code_show('cc0408a0-c3a8-48d9-9c6c-76b754fb103a')"><img id="code_img_closed_cc0408a0-c3a8-48d9-9c6c-76b754fb103a" class="code_img_closed" src="./images/Python IO model0.png" alt="" /><img id="code_img_opened_cc0408a0-c3a8-48d9-9c6c-76b754fb103a" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('cc0408a0-c3a8-48d9-9c6c-76b754fb103a',event)" src="./images/Python IO model1.png" alt="" />
<div id="cnblogs_code_open_cc0408a0-c3a8-48d9-9c6c-76b754fb103a" class="cnblogs_code_hide">
<pre><code><span style="color: #008080;">  1</span> <span style="color: #0000ff;">import</span> <span style="color: #0000ff;">time</span>
<span style="color: #008080;">  2</span> <span style="color: #0000ff;">import</span> socket
<span style="color: #008080;">  3</span> sk = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
<span style="color: #008080;">  4</span> sk.setsockopt
<span style="color: #008080;">  5</span> sk.bind(('127.0.0.1',6667))
<span style="color: #008080;">  6</span> sk.listen(5)
<span style="color: #008080;">  7</span> sk.setblocking(False)
<span style="color: #008080;">  8</span> while True:
<span style="color: #008080;">  9</span>     try:
<span style="color: #008080;"> 10</span>         <span style="color: #0000ff;">print</span> ('waiting client connection .......')
<span style="color: #008080;"> 11</span>         connection,address = sk.accept()   # 进程主动轮询
<span style="color: #008080;"> 12</span>         <span style="color: #0000ff;">print</span>("<span style="color: #8b0000;">+++</span>",address)
<span style="color: #008080;"> 13</span>         client_messge = connection.recv(1024)
<span style="color: #008080;"> 14</span>         <span style="color: #0000ff;">print</span>(str(client_messge,'utf8'))
<span style="color: #008080;"> 15</span>         connection.<span style="color: #0000ff;">close</span>()
<span style="color: #008080;"> 16</span>     except Exception as e:
<span style="color: #008080;"> 17</span>         <span style="color: #0000ff;">print</span> (e)
<span style="color: #008080;"> 18</span>         <span style="color: #0000ff;">time</span>.sleep(4)
<span style="color: #008080;"> 19</span> 
<span style="color: #008080;"> 20</span> #############################client
<span style="color: #008080;"> 21</span> 
<span style="color: #008080;"> 22</span> <span style="color: #0000ff;">import</span> <span style="color: #0000ff;">time</span>
<span style="color: #008080;"> 23</span> <span style="color: #0000ff;">import</span> socket
<span style="color: #008080;"> 24</span> sk = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
<span style="color: #008080;"> 25</span> 
<span style="color: #008080;"> 26</span> while True:
<span style="color: #008080;"> 27</span>     sk.connect(('127.0.0.1',6667))
<span style="color: #008080;"> 28</span>     <span style="color: #0000ff;">print</span>("<span style="color: #8b0000;">hello</span>")
<span style="color: #008080;"> 29</span>     sk.sendall(bytes("<span style="color: #8b0000;">hello</span>","<span style="color: #8b0000;">utf8</span>"))
<span style="color: #008080;"> 30</span>     <span style="color: #0000ff;">time</span>.sleep(2)
<span style="color: #008080;"> 31</span>     break</pre>
</div>
<span class="cnblogs_code_collapse">code</span></div>
<div class="cnblogs_code" onclick="cnblogs_code_show('79dc2956-57ae-4894-9e0a-44f5a04c1f02')"><img id="code_img_closed_79dc2956-57ae-4894-9e0a-44f5a04c1f02" class="code_img_closed" src="./images/Python IO model0.png" alt="" /><img id="code_img_opened_79dc2956-57ae-4894-9e0a-44f5a04c1f02" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('79dc2956-57ae-4894-9e0a-44f5a04c1f02',event)" src="./images/Python IO model1.png" alt="" />
<div id="cnblogs_code_open_79dc2956-57ae-4894-9e0a-44f5a04c1f02" class="cnblogs_code_hide">
<pre><code><span style="color: #008080;">  1</span> 优点：能够在等待任务完成的时间里干其他活了（包括提交其他任务，也就是 &ldquo;后台&rdquo; 可以有多个任务在同时执行）。
<span style="color: #008080;">  2</span> 
<span style="color: #008080;">  3</span> 　　缺点：任务完成的响应延迟增大了，因为每过一段时间才去轮询一次read操作，而任务可能在两次轮询之间的任意时间完成。这会导致整体数据吞吐量的降低。</pre>
</div>
<span class="cnblogs_code_collapse">优点与缺点</span></div>
<p>&nbsp;</p>
<h3>IO multiplexing（IO多路复用）</h3>
<div class="cnblogs_code" onclick="cnblogs_code_show('e7caeece-95b8-4042-b79f-1b1b4a04f706')"><img id="code_img_closed_e7caeece-95b8-4042-b79f-1b1b4a04f706" class="code_img_closed" src="./images/Python IO model0.png" alt="" /><img id="code_img_opened_e7caeece-95b8-4042-b79f-1b1b4a04f706" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('e7caeece-95b8-4042-b79f-1b1b4a04f706',event)" src="./images/Python IO model1.png" alt="" />
<div id="cnblogs_code_open_e7caeece-95b8-4042-b79f-1b1b4a04f706" class="cnblogs_code_hide">
<pre><code><span style="color: #008080;">  1</span> IO multiplexing，也称这种IO方式为event driven IO。select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select/epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。它的流程如图：
<span style="color: #008080;">  2</span> 
<span style="color: #008080;">  3</span>       当用户进程调用了select，那么整个进程会被block，而同时，kernel会&ldquo;监视&rdquo;所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。
<span style="color: #008080;">  4</span> 这个图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。（多说一句。所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）
<span style="color: #008080;">  5</span> 在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。
<span style="color: #008080;">  6</span> 
<span style="color: #008080;">  7</span> 注意1：select函数返回结果中如果有文件可读了，那么进程就可以通过调用accept()或recv()来让kernel将位于内核中准备到的数据copy到用户区。
<span style="color: #008080;">  8</span> 
<span style="color: #008080;">  9</span> 注意2: select的优势在于可以处理多个连接，不适用于单个连接</pre>
</div>
<span class="cnblogs_code_collapse">IO多路复用</span></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp; 在非阻塞code中，轮询的主语是进程，而&ldquo;后台&rdquo; 可能有多个任务在同时进行，人们就想到了循环查询多个任务的完成状态，只要有任何一个任务完成，就去处理它。不过，这个监听的重任通过调用select等函数交给了内核去做。IO多路复用有两个特别的系统调用select、poll、epoll函数。select调用是内核级别的，select轮询相对非阻塞的轮询的区别在于&mdash;前者可以等待多个socket，能实现同时对多个IO端口进行监听，当其中任何一个socket的数据准好了，就能返回进行可读，然后进程再进行recvfrom系统调用，将数据由内核拷贝到用户进程，当然这个过程是阻塞的。</p>
<pre><code></pre>
<div class="cnblogs_code" onclick="cnblogs_code_show('5d7873d9-5d28-4348-a5fc-134674a06e30')"><img id="code_img_closed_5d7873d9-5d28-4348-a5fc-134674a06e30" class="code_img_closed" src="./images/Python IO model0.png" alt="" /><img id="code_img_opened_5d7873d9-5d28-4348-a5fc-134674a06e30" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('5d7873d9-5d28-4348-a5fc-134674a06e30',event)" src="./images/Python IO model1.png" alt="" />
<div id="cnblogs_code_open_5d7873d9-5d28-4348-a5fc-134674a06e30" class="cnblogs_code_hide">
<pre><code><span style="color: #008080;">  1</span> import socket
<span style="color: #008080;">  2</span> import select
<span style="color: #008080;">  3</span> sk=socket.socket()
<span style="color: #008080;">  4</span> sk.bind(("127.0.0.1",9904))
<span style="color: #008080;">  5</span> sk.listen(5)
<span style="color: #008080;">  6</span> 
<span style="color: #008080;">  7</span> while True:
<span style="color: #008080;">  8</span>     r,w,e=select.select([sk,],[],[],5)#input,output,errput,每隔5s监听input
<span style="color: #008080;">  9</span> 
<span style="color: #008080;"> 10</span>     for i in r:#[sk,]
<span style="color: #008080;"> 11</span> 
<span style="color: #008080;"> 12</span>         # conn,add=i.accept()
<span style="color: #008080;"> 13</span>         #print(conn)
<span style="color: #008080;"> 14</span>         print("hello")
<span style="color: #008080;"> 15</span> 	#sk为server socket对象
<span style="color: #008080;"> 16</span> 	#conn为客户端连接的通道
<span style="color: #008080;"> 17</span> 
<span style="color: #008080;"> 18</span>     print('&gt;&gt;&gt;&gt;&gt;&gt;')
<span style="color: #008080;"> 19</span> 
<span style="color: #008080;"> 20</span> #*************************client
<span style="color: #008080;"> 21</span> import socket
<span style="color: #008080;"> 22</span> 
<span style="color: #008080;"> 23</span> sk=socket.socket()
<span style="color: #008080;"> 24</span> 
<span style="color: #008080;"> 25</span> sk.connect(("127.0.0.1",9904))
<span style="color: #008080;"> 26</span> 
<span style="color: #008080;"> 27</span> while 1:
<span style="color: #008080;"> 28</span>     inp=input("&gt;&gt;").strip()
<span style="color: #008080;"> 29</span>     sk.send(inp.encode("utf8"))
<span style="color: #008080;"> 30</span>     data=sk.recv(1024)
<span style="color: #008080;"> 31</span>     print(data.decode("utf8"))</pre>
</div>
<span class="cnblogs_code_collapse">code</span></div>
<p>&nbsp;</p>
<h3>Asynchronous I/O（异步IO）</h3>
<div class="cnblogs_code" onclick="cnblogs_code_show('1f2c32c8-f195-4f60-b725-24aa7df6bc30')"><img id="code_img_closed_1f2c32c8-f195-4f60-b725-24aa7df6bc30" class="code_img_closed" src="./images/Python IO model0.png" alt="" /><img id="code_img_opened_1f2c32c8-f195-4f60-b725-24aa7df6bc30" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('1f2c32c8-f195-4f60-b725-24aa7df6bc30',event)" src="./images/Python IO model1.png" alt="" />
<div id="cnblogs_code_open_1f2c32c8-f195-4f60-b725-24aa7df6bc30" class="cnblogs_code_hide">
<pre><code><span style="color: #008080;">  1</span> linux下的asynchronous IO用得很少。流程如下：
<span style="color: #008080;">  2</span> 
<span style="color: #008080;">  3</span> 
<span style="color: #008080;">  4</span> 用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。</pre>
</div>
<span class="cnblogs_code_collapse">异步IO</span></div>
<p>总结：</p>
<p>1、blocking和non-blocking的区别？</p>
<p>调用blocking IO会一直block住对应的进程直到操作完成，而non-blocking IO在kernel还准备数据的情况下会立刻返回。</p>
<p>2、synchronous IO 和 asynchronous IO的区别？</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('638b5440-8f82-45a0-adab-9d8d4ece6419')"><img id="code_img_closed_638b5440-8f82-45a0-adab-9d8d4ece6419" class="code_img_closed" src="./images/Python IO model0.png" alt="" /><img id="code_img_opened_638b5440-8f82-45a0-adab-9d8d4ece6419" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('638b5440-8f82-45a0-adab-9d8d4ece6419',event)" src="./images/Python IO model1.png" alt="" />
<div id="cnblogs_code_open_638b5440-8f82-45a0-adab-9d8d4ece6419" class="cnblogs_code_hide">
<pre><code><span style="color: #008080;">  1</span>  A synchronous I/O operation causes the requesting process to be blocked until that I/O operationcompletes;
<span style="color: #008080;">  2</span>  An asynchronous I/O operation does not cause the requesting process to be blocked;</pre>
</div>
<span class="cnblogs_code_collapse">两者的定义</span></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 两者的区别就在于synchronous IO做&rdquo;IO operation&rdquo;的时候会将process阻塞。<span style="color: #ff0000;">按照这个定义，之前所述的blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。</span></p>
<p><span style="color: #ff0000;">&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: #000000;">表面上看，non</span>-blocking IO并没有被block啊。而定义中所指的&rdquo;IO operation&rdquo;是指真实的IO操作，就是例子中的recvfrom这个system call。non-blocking IO在执行recvfrom这个system call的时候，如果kernel的数据没有准备好，这时候不会block进程。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; 但是，当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内，进程是被block的。而asynchronous IO则不一样，当进程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('9ee87774-b971-4d32-b52f-cfaf4446f354')"><img id="code_img_closed_9ee87774-b971-4d32-b52f-cfaf4446f354" class="code_img_closed" src="./images/Python IO model0.png" alt="" /><img id="code_img_opened_9ee87774-b971-4d32-b52f-cfaf4446f354" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('9ee87774-b971-4d32-b52f-cfaf4446f354',event)" src="./images/Python IO model1.png" alt="" />
<div id="cnblogs_code_open_9ee87774-b971-4d32-b52f-cfaf4446f354" class="cnblogs_code_hide">
<pre><code><span style="color: #008080;">  1</span> 各个IO Model的比较如图所示：
<span style="color: #008080;">  2</span> 
<span style="color: #008080;">  3</span> 
<span style="color: #008080;">  4</span>       经过上面的介绍，会发现non-blocking IO和asynchronous IO的区别还是很明显的。在non-blocking IO中，虽然进程大部分时间都不会被block，但是它仍然要求进程去主动的check，并且当数据准备完成以后，也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存。而asynchronous IO则完全不同。它就像是用户进程将整个IO操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。
<span style="color: #008080;">  5</span> 
<span style="color: #008080;">  6</span> 五种IO模型比较：
<span style="color: #008080;">  7</span> 
<span style="color: #008080;">  8</span> 
<span style="color: #008080;">  9</span> </pre>
</div>
<span class="cnblogs_code_collapse">IO模型比较</span></div>
<h3><strong>sellect、poll、epoll&nbsp; 模块介绍</strong></h3>
<div class="cnblogs_code" onclick="cnblogs_code_show('9cda5430-5331-4647-80a0-23c2cf668f46')"><img id="code_img_closed_9cda5430-5331-4647-80a0-23c2cf668f46" class="code_img_closed" src="./images/Python IO model0.png" alt="" /><img id="code_img_opened_9cda5430-5331-4647-80a0-23c2cf668f46" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('9cda5430-5331-4647-80a0-23c2cf668f46',event)" src="./images/Python IO model1.png" alt="" />
<div id="cnblogs_code_open_9cda5430-5331-4647-80a0-23c2cf668f46" class="cnblogs_code_hide">
<pre><code><span style="color: #008080;">  1</span> select最早于1983年出现在4.2BSD中，它通过一个select()系统调用来监视多个文件描述符的数组，当select()返回后，该数组中就绪的文件描述符便会被内核修改标志位，使得进程可以获得这些文件描述符从而进行后续的读写操作。
<span style="color: #008080;">  2</span> select目前几乎在所有的平台上支持
<span style="color: #008080;">  3</span> 
<span style="color: #008080;">  4</span> select的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，不过可以通过修改宏定义甚至重新编译内核的方式提升这一限制。
<span style="color: #008080;">  5</span> 
<span style="color: #008080;">  6</span> 另外，select()所维护的存储大量文件描述符的数据结构，随着文件描述符数量的增大，其复制的开销也线性增长。同时，由于网络响应时间的延迟使得大量TCP连接处于非活跃状态，但调用select()会对所有socket进行一次线性扫描，所以这也浪费了一定的开销。</pre>
</div>
<span class="cnblogs_code_collapse">select</span></div>
<p>文件描述符是linux中的概念。也就是常说的句柄，当accept或recv调用时即向系统发出recvfrom请求时：</p>
<p>&nbsp;&nbsp;&nbsp; (1)&nbsp; 如果内核缓冲区没有数据－－－&gt;等待－－－&gt;数据到了内核缓冲区，转到用户进程缓冲区；</p>
<p>&nbsp;&nbsp;&nbsp; (2) 如果先用<span style="background-color: #ffc000;">select</span>监听到某个文件描述符对应的内核缓冲区有了数据，当我们再调用accept或recv时，直接将数据转到用户缓冲区。</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('c7d637bf-9900-487d-8244-f18106fb1ca5')"><img id="code_img_closed_c7d637bf-9900-487d-8244-f18106fb1ca5" class="code_img_closed" src="./images/Python IO model0.png" alt="" /><img id="code_img_opened_c7d637bf-9900-487d-8244-f18106fb1ca5" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('c7d637bf-9900-487d-8244-f18106fb1ca5',event)" src="./images/Python IO model1.png" alt="" />
<div id="cnblogs_code_open_c7d637bf-9900-487d-8244-f18106fb1ca5" class="cnblogs_code_hide">
<pre><code><span style="color: #008080;">  1</span> #***********************server.py
<span style="color: #008080;">  2</span> import socket
<span style="color: #008080;">  3</span> import select
<span style="color: #008080;">  4</span> sk=socket.socket()
<span style="color: #008080;">  5</span> sk.bind(("127.0.0.1",8801))
<span style="color: #008080;">  6</span> sk.listen(5)
<span style="color: #008080;">  7</span> inputs=[sk,]
<span style="color: #008080;">  8</span> while True:
<span style="color: #008080;">  9</span>     r,w,e=select.select(inputs,[],[],5)
<span style="color: #008080;"> 10</span>     print(len(r))
<span style="color: #008080;"> 11</span> 
<span style="color: #008080;"> 12</span>     for obj in r:
<span style="color: #008080;"> 13</span>         if obj==sk:
<span style="color: #008080;"> 14</span>             conn,add=obj.accept()
<span style="color: #008080;"> 15</span>             print(conn)
<span style="color: #008080;"> 16</span>             inputs.append(conn)
<span style="color: #008080;"> 17</span>         else:
<span style="color: #008080;"> 18</span>             data_byte=obj.recv(1024)
<span style="color: #008080;"> 19</span>             print(str(data_byte,'utf8'))
<span style="color: #008080;"> 20</span>             inp=input('回答%s号客户&gt;&gt;&gt;'%inputs.index(obj))
<span style="color: #008080;"> 21</span>             obj.sendall(bytes(inp,'utf8'))
<span style="color: #008080;"> 22</span> 
<span style="color: #008080;"> 23</span>     print('&gt;&gt;',r)
<span style="color: #008080;"> 24</span> 
<span style="color: #008080;"> 25</span> #***********************client.py
<span style="color: #008080;"> 26</span> 
<span style="color: #008080;"> 27</span> import socket
<span style="color: #008080;"> 28</span> sk=socket.socket()
<span style="color: #008080;"> 29</span> sk.connect(('127.0.0.1',8801))
<span style="color: #008080;"> 30</span> 
<span style="color: #008080;"> 31</span> while True:
<span style="color: #008080;"> 32</span>     inp=input("&gt;&gt;&gt;&gt;")
<span style="color: #008080;"> 33</span>     sk.sendall(bytes(inp,"utf8"))
<span style="color: #008080;"> 34</span>     data=sk.recv(1024)
<span style="color: #008080;"> 35</span>     print(str(data,'utf8'))</pre>
</div>
<span class="cnblogs_code_collapse">Server端并发聊天</span></div>
<div class="cnblogs_code" onclick="cnblogs_code_show('038175e3-4330-4665-82d8-d31ae05ff61d')"><img id="code_img_closed_038175e3-4330-4665-82d8-d31ae05ff61d" class="code_img_closed" src="./images/Python IO model0.png" alt="" /><img id="code_img_opened_038175e3-4330-4665-82d8-d31ae05ff61d" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('038175e3-4330-4665-82d8-d31ae05ff61d',event)" src="./images/Python IO model1.png" alt="" />
<div id="cnblogs_code_open_038175e3-4330-4665-82d8-d31ae05ff61d" class="cnblogs_code_hide">
<pre><code><span style="color: #008080;">  1</span> #linux：
<span style="color: #008080;">  2</span> 
<span style="color: #008080;">  3</span> if not data_byte:
<span style="color: #008080;">  4</span>             inputs.remove(obj)
<span style="color: #008080;">  5</span>             continue
<span style="color: #008080;">  6</span> 
<span style="color: #008080;">  7</span> #win
<span style="color: #008080;">  8</span> 
<span style="color: #008080;">  9</span> 
<span style="color: #008080;"> 10</span> try:
<span style="color: #008080;"> 11</span>       data_byte=obj.recv(1024)
<span style="color: #008080;"> 12</span>       print(str(data_byte,'utf8'))
<span style="color: #008080;"> 13</span>       inp=input('回答%s号客户&gt;&gt;&gt;'%inputs.index(obj))
<span style="color: #008080;"> 14</span>       obj.sendall(bytes(inp,'utf8'))
<span style="color: #008080;"> 15</span> except Exception:
<span style="color: #008080;"> 16</span>       inputs.remove(obj)
<span style="color: #008080;"> 17</span> 
<span style="color: #008080;"> 18</span> </pre>
</div>
<span class="cnblogs_code_collapse">client端退出与异常处理</span></div>
<p>select属于水平触发</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('3a7746ee-b4ce-4457-9b4a-94f6cbfe574c')"><img id="code_img_closed_3a7746ee-b4ce-4457-9b4a-94f6cbfe574c" class="code_img_closed" src="./images/Python IO model0.png" alt="" /><img id="code_img_opened_3a7746ee-b4ce-4457-9b4a-94f6cbfe574c" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('3a7746ee-b4ce-4457-9b4a-94f6cbfe574c',event)" src="./images/Python IO model1.png" alt="" />
<div id="cnblogs_code_open_3a7746ee-b4ce-4457-9b4a-94f6cbfe574c" class="cnblogs_code_hide">
<pre><code><span style="color: #008080;">  1</span> # 在linux的IO多路复用中有水平触发,边缘触发两种模式,这两种模式的区别如下:
<span style="color: #008080;">  2</span> #
<span style="color: #008080;">  3</span> # 水平触发:如果文件描述符已经就绪可以非阻塞的执行IO操作了,此时会触发通知.允许在任意时刻重复检测IO的状态,
<span style="color: #008080;">  4</span> # 没有必要每次描述符就绪后尽可能多的执行IO.select,poll就属于水平触发.
<span style="color: #008080;">  5</span> #
<span style="color: #008080;">  6</span> # 边缘触发:如果文件描述符自上次状态改变后有新的IO活动到来,此时会触发通知.在收到一个IO事件通知后要尽可能
<span style="color: #008080;">  7</span> # 多的执行IO操作,因为如果在一次通知中没有执行完IO那么就需要等到下一次新的IO活动到来才能获取到就绪的描述
<span style="color: #008080;">  8</span> # 符.信号驱动式IO就属于边缘触发.
<span style="color: #008080;">  9</span> #
<span style="color: #008080;"> 10</span> # epoll既可以采用水平触发,也可以采用边缘触发.
<span style="color: #008080;"> 11</span> #
<span style="color: #008080;"> 12</span> # 大家可能还不能完全了解这两种模式的区别,我们可以举例说明:一个管道收到了1kb的数据,epoll会立即返回,此时
<span style="color: #008080;"> 13</span> # 读了512字节数据,然后再次调用epoll.这时如果是水平触发的,epoll会立即返回,因为有数据准备好了.如果是边
<span style="color: #008080;"> 14</span> # 缘触发的不会立即返回,因为此时虽然有数据可读但是已经触发了一次通知,在这次通知到现在还没有新的数据到来,
<span style="color: #008080;"> 15</span> # 直到有新的数据到来epoll才会返回,此时老的数据和新的数据都可以读取到(当然是需要这次你尽可能的多读取).
<span style="color: #008080;"> 16</span> 
<span style="color: #008080;"> 17</span> 
<span style="color: #008080;"> 18</span> # 下面我们还从电子的角度来解释一下:
<span style="color: #008080;"> 19</span> #
<span style="color: #008080;"> 20</span> #     水平触发:也就是只有高电平(1)或低电平(0)时才触发通知,只要在这两种状态就能得到通知.上面提到的只要
<span style="color: #008080;"> 21</span> # 有数据可读(描述符就绪)那么水平触发的epoll就立即返回.
<span style="color: #008080;"> 22</span> #
<span style="color: #008080;"> 23</span> #     边缘触发:只有电平发生变化(高电平到低电平,或者低电平到高电平)的时候才触发通知.上面提到即使有数据
<span style="color: #008080;"> 24</span> # 可读,但是没有新的IO活动到来,epoll也不会立即返回.
<span style="color: #008080;"> 25</span> 
<span style="color: #008080;"> 26</span> 水平触发和边缘触发</pre>
</div>
<span class="cnblogs_code_collapse">IO多路复用的触发方式</span></div>
<p>&nbsp;</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('94f5a8fe-6fdf-4957-b3bf-c77366ab3da5')"><img id="code_img_closed_94f5a8fe-6fdf-4957-b3bf-c77366ab3da5" class="code_img_closed" src="./images/Python IO model0.png" alt="" /><img id="code_img_opened_94f5a8fe-6fdf-4957-b3bf-c77366ab3da5" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('94f5a8fe-6fdf-4957-b3bf-c77366ab3da5',event)" src="./images/Python IO model1.png" alt="" />
<div id="cnblogs_code_open_94f5a8fe-6fdf-4957-b3bf-c77366ab3da5" class="cnblogs_code_hide">
<pre><code><span style="color: #008080;">  1</span> # 首先我们来定义流的概念，一个流可以是文件，socket，pipe等等可以进行I/O操作的内核对象。
<span style="color: #008080;">  2</span> # 不管是文件，还是套接字，还是管道，我们都可以把他们看作流。
<span style="color: #008080;">  3</span> # 之后我们来讨论I/O的操作，通过read，我们可以从流中读入数据；通过write，我们可以往流写入数据。现在假
<span style="color: #008080;">  4</span> # 定一个情形，我们需要从流中读数据，但是流中还没有数据，（典型的例子为，客户端要从socket读如数据，但是
<span style="color: #008080;">  5</span> # 服务器还没有把数据传回来），这时候该怎么办？
<span style="color: #008080;">  6</span> # 阻塞。阻塞是个什么概念呢？比如某个时候你在等快递，但是你不知道快递什么时候过来，而且你没有别的事可以干
<span style="color: #008080;">  7</span> # （或者说接下来的事要等快递来了才能做）；那么你可以去睡觉了，因为你知道快递把货送来时一定会给你打个电话
<span style="color: #008080;">  8</span> # （假定一定能叫醒你）。
<span style="color: #008080;">  9</span> # 非阻塞忙轮询。接着上面等快递的例子，如果用忙轮询的方法，那么你需要知道快递员的手机号，然后每分钟给他挂
<span style="color: #008080;"> 10</span> # 个电话：&ldquo;你到了没？&rdquo;
<span style="color: #008080;"> 11</span> # 很明显一般人不会用第二种做法，不仅显很无脑，浪费话费不说，还占用了快递员大量的时间。
<span style="color: #008080;"> 12</span> # 大部分程序也不会用第二种做法，因为第一种方法经济而简单，经济是指消耗很少的CPU时间，如果线程睡眠了，
<span style="color: #008080;"> 13</span> # 就掉出了系统的调度队列，暂时不会去瓜分CPU宝贵的时间片了。
<span style="color: #008080;"> 14</span> #
<span style="color: #008080;"> 15</span> # 为了了解阻塞是如何进行的，我们来讨论缓冲区，以及内核缓冲区，最终把I/O事件解释清楚。缓冲区的引入是为
<span style="color: #008080;"> 16</span> # 了减少频繁I/O操作而引起频繁的系统调用（你知道它很慢的），当你操作一个流时，更多的是以缓冲区为单位进
<span style="color: #008080;"> 17</span> # 行操作，这是相对于用户空间而言。对于内核来说，也需要缓冲区。
<span style="color: #008080;"> 18</span> # 假设有一个管道，进程A为管道的写入方，Ｂ为管道的读出方。
<span style="color: #008080;"> 19</span> # 假设一开始内核缓冲区是空的，B作为读出方，被阻塞着。然后首先A往管道写入，这时候内核缓冲区由空的状态变
<span style="color: #008080;"> 20</span> # 到非空状态，内核就会产生一个事件告诉Ｂ该醒来了，这个事件姑且称之为&ldquo;缓冲区非空&rdquo;。
<span style="color: #008080;"> 21</span> # 但是&ldquo;缓冲区非空&rdquo;事件通知B后，B却还没有读出数据；且内核许诺了不能把写入管道中的数据丢掉这个时候，Ａ写
<span style="color: #008080;"> 22</span> # 入的数据会滞留在内核缓冲区中，如果内核也缓冲区满了，B仍未开始读数据，最终内核缓冲区会被填满，这个时候
<span style="color: #008080;"> 23</span> # 会产生一个I/O事件，告诉进程A，你该等等（阻塞）了，我们把这个事件定义为&ldquo;缓冲区满&rdquo;。
<span style="color: #008080;"> 24</span> # 假设后来Ｂ终于开始读数据了，于是内核的缓冲区空了出来，这时候内核会告诉A，内核缓冲区有空位了，你可以从
<span style="color: #008080;"> 25</span> # 长眠中醒来了，继续写数据了，我们把这个事件叫做&ldquo;缓冲区非满&rdquo;
<span style="color: #008080;"> 26</span> # 也许事件Y1已经通知了A，但是A也没有数据写入了，而Ｂ继续读出数据，知道内核缓冲区空了。这个时候内核就告
<span style="color: #008080;"> 27</span> # 诉B，你需要阻塞了！，我们把这个时间定为&ldquo;缓冲区空&rdquo;。
<span style="color: #008080;"> 28</span> # 这四个情形涵盖了四个I/O事件，缓冲区满，缓冲区空，缓冲区非空，缓冲区非满（注都是说的内核缓冲区，且这四
<span style="color: #008080;"> 29</span> # 个术语都是我生造的，仅为解释其原理而造）。这四个I/O事件是进行阻塞同步的根本。（如果不能理解&ldquo;同步&rdquo;是
<span style="color: #008080;"> 30</span> # 什么概念，请学习操作系统的锁，信号量，条件变量等任务同步方面的相关知识）。
<span style="color: #008080;"> 31</span> #
<span style="color: #008080;"> 32</span> # 然后我们来说说阻塞I/O的缺点。但是阻塞I/O模式下，一个线程只能处理一个流的I/O事件。如果想要同时处理多
<span style="color: #008080;"> 33</span> # 个流，要么多进程(fork)，要么多线程(pthread_create)，很不幸这两种方法效率都不高。
<span style="color: #008080;"> 34</span> # 于是再来考虑非阻塞忙轮询的I/O方式，我们发现我们可以同时处理多个流了（把一个流从阻塞模式切换到非阻塞
<span style="color: #008080;"> 35</span> # 模式再此不予讨论）：
<span style="color: #008080;"> 36</span> # while true {
<span style="color: #008080;"> 37</span> # for i in stream[]; {
<span style="color: #008080;"> 38</span> # if i has data
<span style="color: #008080;"> 39</span> # read until unavailable
<span style="color: #008080;"> 40</span> # }
<span style="color: #008080;"> 41</span> # }
<span style="color: #008080;"> 42</span> # 我们只要不停的把所有流从头到尾问一遍，又从头开始。这样就可以处理多个流了，但这样的做法显然不好，因为
<span style="color: #008080;"> 43</span> # 如果所有的流都没有数据，那么只会白白浪费CPU。这里要补充一点，阻塞模式下，内核对于I/O事件的处理是阻
<span style="color: #008080;"> 44</span> # 塞或者唤醒，而非阻塞模式下则把I/O事件交给其他对象（后文介绍的select以及epoll）处理甚至直接忽略。
<span style="color: #008080;"> 45</span> #
<span style="color: #008080;"> 46</span> # 为了避免CPU空转，可以引进了一个代理（一开始有一位叫做select的代理，后来又有一位叫做poll的代理，不
<span style="color: #008080;"> 47</span> # 过两者的本质是一样的）。这个代理比较厉害，可以同时观察许多流的I/O事件，在空闲的时候，会把当前线程阻
<span style="color: #008080;"> 48</span> # 塞掉，当有一个或多个流有I/O事件时，就从阻塞态中醒来，于是我们的程序就会轮询一遍所有的流（于是我们可
<span style="color: #008080;"> 49</span> # 以把&ldquo;忙&rdquo;字去掉了）。代码长这样:
<span style="color: #008080;"> 50</span> # while true {
<span style="color: #008080;"> 51</span> # select(streams[])
<span style="color: #008080;"> 52</span> # for i in streams[] {
<span style="color: #008080;"> 53</span> # if i has data
<span style="color: #008080;"> 54</span> # read until unavailable
<span style="color: #008080;"> 55</span> # }
<span style="color: #008080;"> 56</span> # }
<span style="color: #008080;"> 57</span> # 于是，如果没有I/O事件产生，我们的程序就会阻塞在select处。但是依然有个问题，我们从select那里仅仅知
<span style="color: #008080;"> 58</span> # 道了，有I/O事件发生了，但却并不知道是那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，
<span style="color: #008080;"> 59</span> # 找出能读出数据，或者写入数据的流，对他们进行操作。
<span style="color: #008080;"> 60</span> # 但是使用select，我们有O(n)的无差别轮询复杂度，同时处理的流越多，每一次无差别轮询时间就越长。再次
<span style="color: #008080;"> 61</span> # 说了这么多，终于能好好解释epoll了
<span style="color: #008080;"> 62</span> # epoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll之会把哪个流发生了怎样的I/O事件通知我
<span style="color: #008080;"> 63</span> # 们。此时我们对这些流的操作都是有意义的。
<span style="color: #008080;"> 64</span> # 在讨论epoll的实现细节之前，先把epoll的相关操作列出：
<span style="color: #008080;"> 65</span> # epoll_create 创建一个epoll对象，一般epollfd = epoll_create()
<span style="color: #008080;"> 66</span> # epoll_ctl （epoll_add/epoll_del的合体），往epoll对象中增加/删除某一个流的某一个事件
<span style="color: #008080;"> 67</span> # 比如
<span style="color: #008080;"> 68</span> # epoll_ctl(epollfd, EPOLL_CTL_ADD, socket, EPOLLIN);//有缓冲区内有数据时epoll_wait返回
<span style="color: #008080;"> 69</span> # epoll_ctl(epollfd, EPOLL_CTL_DEL, socket, EPOLLOUT);//缓冲区可写入时epoll_wait返回
<span style="color: #008080;"> 70</span> # epoll_wait(epollfd,...)等待直到注册的事件发生
<span style="color: #008080;"> 71</span> # （注：当对一个非阻塞流的读写发生缓冲区满或缓冲区空，write/read会返回-1，并设置errno=EAGAIN。
<span style="color: #008080;"> 72</span> # 而epoll只关心缓冲区非满和缓冲区非空事件）。
<span style="color: #008080;"> 73</span> # 一个epoll模式的代码大概的样子是：
<span style="color: #008080;"> 74</span> # while true {
<span style="color: #008080;"> 75</span> # active_stream[] = epoll_wait(epollfd)
<span style="color: #008080;"> 76</span> # for i in active_stream[] {
<span style="color: #008080;"> 77</span> # read or write till unavailable
<span style="color: #008080;"> 78</span> # }
<span style="color: #008080;"> 79</span> # }
<span style="color: #008080;"> 80</span> 
<span style="color: #008080;"> 81</span> 
<span style="color: #008080;"> 82</span> # 举个例子:
<span style="color: #008080;"> 83</span> #    select:
<span style="color: #008080;"> 84</span> #          班里三十个同学在考试,谁先做完想交卷都要通过按钮来活动,他按按钮作为老师的我桌子上的灯就会变红.
<span style="color: #008080;"> 85</span> #          一旦灯变红,我(select)我就可以知道有人交卷了,但是我并不知道谁交的,所以,我必须跟个傻子似的轮询
<span style="color: #008080;"> 86</span> #          地去问:嘿,是你要交卷吗?然后我就可以以这种效率极低地方式找到要交卷的学生,然后把它的卷子收上来.
<span style="color: #008080;"> 87</span> #
<span style="color: #008080;"> 88</span> #
<span style="color: #008080;"> 89</span> #    epoll:
<span style="color: #008080;"> 90</span> #         这次再有人按按钮,我这不光灯会亮,上面还会显示要交卷学生的名字.这样我就可以直接去对应学生那收卷就
<span style="color: #008080;"> 91</span> #         好了.当然,同时可以有多人交卷.</pre>
</div>
<span class="cnblogs_code_collapse">select与epoll</span></div>
<p>&nbsp;</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('d45dde8e-d3c9-4f23-9eee-32221042c758')"><img id="code_img_closed_d45dde8e-d3c9-4f23-9eee-32221042c758" class="code_img_closed" src="./images/Python IO model0.png" alt="" /><img id="code_img_opened_d45dde8e-d3c9-4f23-9eee-32221042c758" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('d45dde8e-d3c9-4f23-9eee-32221042c758',event)" src="./images/Python IO model1.png" alt="" />
<div id="cnblogs_code_open_d45dde8e-d3c9-4f23-9eee-32221042c758" class="cnblogs_code_hide">
<pre><code><span style="color: #008080;">  1</span> 直到Linux2.6才出现了由内核直接支持的实现方法，那就是epoll。被公认为Linux2.6下性能最好的多路I/O就绪通知方法。windows不支持
<span style="color: #008080;">  2</span> 
<span style="color: #008080;">  3</span> 没有最大文件描述符数量的限制。
<span style="color: #008080;">  4</span> 比如100个连接，有两个活跃了，epoll会告诉用户这两个两个活跃了，直接取就ok了，而select是循环一遍。
<span style="color: #008080;">  5</span> 
<span style="color: #008080;">  6</span> （了解）epoll可以同时支持水平触发和边缘触发（Edge Triggered，只告诉进程哪些文件描述符刚刚变为就绪状态，它只说一遍，如果我们没有采取行动，那么它将不会再次告知，这种方式称为边缘触发），理论上边缘触发的性能要更高一些，但是代码实现相当复杂。
<span style="color: #008080;">  7</span> 另一个本质的改进在于epoll采用基于事件的就绪通知方式。在select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而epoll事先通过epoll_ctl()来注册一个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait()时便得到通知。
<span style="color: #008080;">  8</span> 
<span style="color: #008080;">  9</span> 所以市面上上见到的所谓的异步IO，比如nginx、Tornado、等，我们叫它异步IO，实际上是IO多路复用。</pre>
</div>
<span class="cnblogs_code_collapse">epoll</span></div>
<p>&nbsp;</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('03d07fce-1e3f-4c2b-a9a0-f7b5bc9a023f')"><img id="code_img_closed_03d07fce-1e3f-4c2b-a9a0-f7b5bc9a023f" class="code_img_closed" src="./images/Python IO model0.png" alt="" /><img id="code_img_opened_03d07fce-1e3f-4c2b-a9a0-f7b5bc9a023f" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('03d07fce-1e3f-4c2b-a9a0-f7b5bc9a023f',event)" src="./images/Python IO model1.png" alt="" />
<div id="cnblogs_code_open_03d07fce-1e3f-4c2b-a9a0-f7b5bc9a023f" class="cnblogs_code_hide">
<pre><code><span style="color: #008080;">  1</span> 它和select在本质上没有多大差别，但是poll没有最大文件描述符数量的限制。
<span style="color: #008080;">  2</span> 一般也不用它，相当于过渡阶段</pre>
</div>
<span class="cnblogs_code_collapse">poll</span></div>
<p>&nbsp;</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('d376318f-7060-41eb-99d2-0a7b8bf9bbe0')"><img id="code_img_closed_d376318f-7060-41eb-99d2-0a7b8bf9bbe0" class="code_img_closed" src="./images/Python IO model0.png" alt="" /><img id="code_img_opened_d376318f-7060-41eb-99d2-0a7b8bf9bbe0" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('d376318f-7060-41eb-99d2-0a7b8bf9bbe0',event)" src="./images/Python IO model1.png" alt="" />
<div id="cnblogs_code_open_d376318f-7060-41eb-99d2-0a7b8bf9bbe0" class="cnblogs_code_hide">
<pre><code><span style="color: #008080;">  1</span> #_*_coding:utf-8_*_
<span style="color: #008080;">  2</span> 
<span style="color: #008080;">  3</span> 
<span style="color: #008080;">  4</span> import select
<span style="color: #008080;">  5</span> import socket
<span style="color: #008080;">  6</span> import sys
<span style="color: #008080;">  7</span> import queue
<span style="color: #008080;">  8</span> 
<span style="color: #008080;">  9</span> # Create a TCP/IP socket
<span style="color: #008080;"> 10</span> server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
<span style="color: #008080;"> 11</span> server.setblocking(False)
<span style="color: #008080;"> 12</span> 
<span style="color: #008080;"> 13</span> # Bind the socket to the port
<span style="color: #008080;"> 14</span> server_address = ('localhost', 10000)
<span style="color: #008080;"> 15</span> print(sys.stderr, 'starting up on %s port %s' % server_address)
<span style="color: #008080;"> 16</span> server.bind(server_address)
<span style="color: #008080;"> 17</span> 
<span style="color: #008080;"> 18</span> # Listen for incoming connections
<span style="color: #008080;"> 19</span> server.listen(5)
<span style="color: #008080;"> 20</span> 
<span style="color: #008080;"> 21</span> # Sockets from which we expect to read
<span style="color: #008080;"> 22</span> inputs = [ server ]
<span style="color: #008080;"> 23</span> 
<span style="color: #008080;"> 24</span> # Sockets to which we expect to write
<span style="color: #008080;"> 25</span> outputs = [ ]
<span style="color: #008080;"> 26</span> 
<span style="color: #008080;"> 27</span> message_queues = {}
<span style="color: #008080;"> 28</span> while inputs:
<span style="color: #008080;"> 29</span> 
<span style="color: #008080;"> 30</span>     # Wait for at least one of the sockets to be ready for processing
<span style="color: #008080;"> 31</span>     print( '\nwaiting for the next event')
<span style="color: #008080;"> 32</span>     readable, writable, exceptional = select.select(inputs, outputs, inputs)
<span style="color: #008080;"> 33</span>     # Handle inputs
<span style="color: #008080;"> 34</span>     for s in readable:
<span style="color: #008080;"> 35</span> 
<span style="color: #008080;"> 36</span>         if s is server:
<span style="color: #008080;"> 37</span>             # A "readable" server socket is ready to accept a connection
<span style="color: #008080;"> 38</span>             connection, client_address = s.accept()
<span style="color: #008080;"> 39</span>             print('new connection from', client_address)
<span style="color: #008080;"> 40</span>             connection.setblocking(False)
<span style="color: #008080;"> 41</span>             inputs.append(connection)
<span style="color: #008080;"> 42</span> 
<span style="color: #008080;"> 43</span>             # Give the connection a queue for data we want to send
<span style="color: #008080;"> 44</span>             message_queues[connection] = queue.Queue()
<span style="color: #008080;"> 45</span>         else:
<span style="color: #008080;"> 46</span>             data = s.recv(1024)
<span style="color: #008080;"> 47</span>             if data:
<span style="color: #008080;"> 48</span>                 # A readable client socket has data
<span style="color: #008080;"> 49</span>                 print(sys.stderr, 'received "%s" from %s' % (data, s.getpeername()) )
<span style="color: #008080;"> 50</span>                 message_queues[s].put(data)
<span style="color: #008080;"> 51</span>                 # Add output channel for response
<span style="color: #008080;"> 52</span>                 if s not in outputs:
<span style="color: #008080;"> 53</span>                     outputs.append(s)
<span style="color: #008080;"> 54</span>             else:
<span style="color: #008080;"> 55</span>                 # Interpret empty result as closed connection
<span style="color: #008080;"> 56</span>                 print('closing', client_address, 'after reading no data')
<span style="color: #008080;"> 57</span>                 # Stop listening for input on the connection
<span style="color: #008080;"> 58</span>                 if s in outputs:
<span style="color: #008080;"> 59</span>                     outputs.remove(s)  #既然客户端都断开了，我就不用再给它返回数据了，所以这时候如果这个客户端的连接对象还在outputs列表中，就把它删掉
<span style="color: #008080;"> 60</span>                 inputs.remove(s)    #inputs中也删除掉
<span style="color: #008080;"> 61</span>                 s.close()           #把这个连接关闭掉
<span style="color: #008080;"> 62</span> 
<span style="color: #008080;"> 63</span>                 # Remove message queue
<span style="color: #008080;"> 64</span>                 del message_queues[s]
<span style="color: #008080;"> 65</span>     # Handle outputs
<span style="color: #008080;"> 66</span>     for s in writable:
<span style="color: #008080;"> 67</span>         try:
<span style="color: #008080;"> 68</span>             next_msg = message_queues[s].get_nowait()
<span style="color: #008080;"> 69</span>         except queue.Empty:
<span style="color: #008080;"> 70</span>             # No messages waiting so stop checking for writability.
<span style="color: #008080;"> 71</span>             print('output queue for', s.getpeername(), 'is empty')
<span style="color: #008080;"> 72</span>             outputs.remove(s)
<span style="color: #008080;"> 73</span>         else:
<span style="color: #008080;"> 74</span>             print( 'sending "%s" to %s' % (next_msg, s.getpeername()))
<span style="color: #008080;"> 75</span>             s.send(next_msg)
<span style="color: #008080;"> 76</span>     # Handle "exceptional conditions"
<span style="color: #008080;"> 77</span>     for s in exceptional:
<span style="color: #008080;"> 78</span>         print('handling exceptional condition for', s.getpeername() )
<span style="color: #008080;"> 79</span>         # Stop listening for input on the connection
<span style="color: #008080;"> 80</span>         inputs.remove(s)
<span style="color: #008080;"> 81</span>         if s in outputs:
<span style="color: #008080;"> 82</span>             outputs.remove(s)
<span style="color: #008080;"> 83</span>         s.close()
<span style="color: #008080;"> 84</span> 
<span style="color: #008080;"> 85</span>         # Remove message queue
<span style="color: #008080;"> 86</span>         del message_queues[s]</pre>
</div>
<span class="cnblogs_code_collapse">延申</span></div>
<p>&nbsp;</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('6c542198-e404-4b9f-bb51-55d25fd02ba3')"><img id="code_img_closed_6c542198-e404-4b9f-bb51-55d25fd02ba3" class="code_img_closed" src="./images/Python IO model0.png" alt="" /><img id="code_img_opened_6c542198-e404-4b9f-bb51-55d25fd02ba3" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('6c542198-e404-4b9f-bb51-55d25fd02ba3',event)" src="./images/Python IO model1.png" alt="" />
<div id="cnblogs_code_open_6c542198-e404-4b9f-bb51-55d25fd02ba3" class="cnblogs_code_hide">
<pre><code><span style="color: #008080;">  1</span> # select 模拟一个socket server，注意socket必须在非阻塞情况下才能实现IO多路复用。
<span style="color: #008080;">  2</span> # 接下来通过例子了解select 是如何通过单进程实现同时处理多个非阻塞的socket连接的。
<span style="color: #008080;">  3</span> #server端
<span style="color: #008080;">  4</span> 
<span style="color: #008080;">  5</span> 
<span style="color: #008080;">  6</span> import select
<span style="color: #008080;">  7</span> import socket
<span style="color: #008080;">  8</span> import queue
<span style="color: #008080;">  9</span> 
<span style="color: #008080;"> 10</span> server = socket.socket()
<span style="color: #008080;"> 11</span> server.bind(('localhost',9000))
<span style="color: #008080;"> 12</span> server.listen(1000)
<span style="color: #008080;"> 13</span> 
<span style="color: #008080;"> 14</span> server.setblocking(False)  # 设置成非阻塞模式，accept和recv都非阻塞
<span style="color: #008080;"> 15</span> # 这里如果直接 server.accept() ，如果没有连接会报错，所以有数据才调他们
<span style="color: #008080;"> 16</span> # BlockIOError：[WinError 10035] 无法立即完成一个非阻塞性套接字操作。
<span style="color: #008080;"> 17</span> msg_dic = {}
<span style="color: #008080;"> 18</span> inputs = [server,]  # 交给内核、select检测的列表。
<span style="color: #008080;"> 19</span> # 必须有一个值，让select检测，否则报错提供无效参数。
<span style="color: #008080;"> 20</span> # 没有其他连接之前，自己就是个socket，自己就是个连接，检测自己。活动了说明有链接
<span style="color: #008080;"> 21</span> outputs = []  # 你往里面放什么，下一次就出来了
<span style="color: #008080;"> 22</span> 
<span style="color: #008080;"> 23</span> while True:
<span style="color: #008080;"> 24</span>     readable, writeable, exceptional = select.select(inputs, outputs, inputs)  # 定义检测
<span style="color: #008080;"> 25</span>     #新来连接                                        检测列表         异常（断开）
<span style="color: #008080;"> 26</span>     # 异常的也是inputs是： 检测那些连接的存在异常
<span style="color: #008080;"> 27</span>     print(readable,writeable,exceptional)
<span style="color: #008080;"> 28</span>     for r in readable:
<span style="color: #008080;"> 29</span>         if r is server:  # 有数据，代表来了一个新连接
<span style="color: #008080;"> 30</span>             conn, addr = server.accept()
<span style="color: #008080;"> 31</span>             print("来了个新连接",addr)
<span style="color: #008080;"> 32</span>             inputs.append(conn)  # 把连接加到检测列表里，如果这个连接活动了，就说明数据来了
<span style="color: #008080;"> 33</span>             # inputs = [server.conn] # 【conn】只返回活动的连接，但怎么确定是谁活动了
<span style="color: #008080;"> 34</span>             # 如果server活动，则来了新连接，conn活动则来数据
<span style="color: #008080;"> 35</span>             msg_dic[conn] = queue.Queue()  # 初始化一个队列，后面存要返回给这个客户端的数据
<span style="color: #008080;"> 36</span>         else:
<span style="color: #008080;"> 37</span>             try :
<span style="color: #008080;"> 38</span>                 data = r.recv(1024)  # 注意这里是r，而不是conn，多个连接的情况
<span style="color: #008080;"> 39</span>                 print("收到数据",data)
<span style="color: #008080;"> 40</span>                 # r.send(data) # 不能直接发，如果客户端不收，数据就没了
<span style="color: #008080;"> 41</span>                 msg_dic[r].put(data)  # 往里面放数据
<span style="color: #008080;"> 42</span>                 outputs.append(r)  # 放入返回的连接队列里
<span style="color: #008080;"> 43</span>             except ConnectionResetError as e:
<span style="color: #008080;"> 44</span>                 print("客户端断开了",r)
<span style="color: #008080;"> 45</span>                 if r in outputs:
<span style="color: #008080;"> 46</span>                     outputs.remove(r) #清理已断开的连接
<span style="color: #008080;"> 47</span>                 inputs.remove(r) #清理已断开的连接
<span style="color: #008080;"> 48</span>                 del msg_dic[r] ##清理已断开的连接
<span style="color: #008080;"> 49</span> 
<span style="color: #008080;"> 50</span>     for w in writeable:  # 要返回给客户端的连接列表
<span style="color: #008080;"> 51</span>         data_to_client = msg_dic[w].get()  # 在字典里取数据
<span style="color: #008080;"> 52</span>         w.send(data_to_client)  # 返回给客户端
<span style="color: #008080;"> 53</span>         outputs.remove(w)  # 删除这个数据，确保下次循环的时候不返回这个已经处理完的连接了。
<span style="color: #008080;"> 54</span> 
<span style="color: #008080;"> 55</span>     for e in exceptional:  # 如果连接断开，删除连接相关数据
<span style="color: #008080;"> 56</span>         if e in outputs:
<span style="color: #008080;"> 57</span>             outputs.remove(e)
<span style="color: #008080;"> 58</span>         inputs.remove(e)
<span style="color: #008080;"> 59</span>         del msg_dic[e]
<span style="color: #008080;"> 60</span> 
<span style="color: #008080;"> 61</span> 
<span style="color: #008080;"> 62</span> #*************************client
<span style="color: #008080;"> 63</span> import socket
<span style="color: #008080;"> 64</span> client = socket.socket()
<span style="color: #008080;"> 65</span> 
<span style="color: #008080;"> 66</span> client.connect(('localhost', 9000))
<span style="color: #008080;"> 67</span> 
<span style="color: #008080;"> 68</span> while True:
<span style="color: #008080;"> 69</span>     cmd = input('&gt;&gt;&gt; ').strip()
<span style="color: #008080;"> 70</span>     if len(cmd) == 0 : continue
<span style="color: #008080;"> 71</span>     client.send(cmd.encode('utf-8'))
<span style="color: #008080;"> 72</span>     data = client.recv(1024)
<span style="color: #008080;"> 73</span>     print(data.decode())
<span style="color: #008080;"> 74</span> 
<span style="color: #008080;"> 75</span> client.close()</pre>
</div>
<span class="cnblogs_code_collapse">延申1</span></div>
<div class="cnblogs_code" onclick="cnblogs_code_show('2d5cb714-9ba0-4e22-b5f4-533c5c76111c')"><img id="code_img_closed_2d5cb714-9ba0-4e22-b5f4-533c5c76111c" class="code_img_closed" src="./images/Python IO model0.png" alt="" /><img id="code_img_opened_2d5cb714-9ba0-4e22-b5f4-533c5c76111c" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('2d5cb714-9ba0-4e22-b5f4-533c5c76111c',event)" src="./images/Python IO model1.png" alt="" />
<div id="cnblogs_code_open_2d5cb714-9ba0-4e22-b5f4-533c5c76111c" class="cnblogs_code_hide">
<pre><code><span style="color: #008080;">  1</span> import selectors
<span style="color: #008080;">  2</span> import socket
<span style="color: #008080;">  3</span> 
<span style="color: #008080;">  4</span> sel = selectors.DefaultSelector()
<span style="color: #008080;">  5</span> 
<span style="color: #008080;">  6</span> def accept(sock, mask):
<span style="color: #008080;">  7</span>     conn, addr = sock.accept()  # Should be ready
<span style="color: #008080;">  8</span>     print('accepted', conn, 'from', addr)
<span style="color: #008080;">  9</span>     conn.setblocking(False)
<span style="color: #008080;"> 10</span>     sel.register(conn, selectors.EVENT_READ, read)
<span style="color: #008080;"> 11</span> 
<span style="color: #008080;"> 12</span> def read(conn, mask):
<span style="color: #008080;"> 13</span>     data = conn.recv(1000)  # Should be ready
<span style="color: #008080;"> 14</span>     if data:
<span style="color: #008080;"> 15</span>         print('echoing', repr(data), 'to', conn)
<span style="color: #008080;"> 16</span>         conn.send(data)  # Hope it won't block
<span style="color: #008080;"> 17</span>     else:
<span style="color: #008080;"> 18</span>         print('closing', conn)
<span style="color: #008080;"> 19</span>         sel.unregister(conn)
<span style="color: #008080;"> 20</span>         conn.close()
<span style="color: #008080;"> 21</span> 
<span style="color: #008080;"> 22</span> sock = socket.socket()
<span style="color: #008080;"> 23</span> sock.bind(('localhost', 1234))
<span style="color: #008080;"> 24</span> sock.listen(100)
<span style="color: #008080;"> 25</span> sock.setblocking(False)
<span style="color: #008080;"> 26</span> sel.register(sock, selectors.EVENT_READ, accept)
<span style="color: #008080;"> 27</span> 
<span style="color: #008080;"> 28</span> while True:
<span style="color: #008080;"> 29</span>     events = sel.select()
<span style="color: #008080;"> 30</span>     for key, mask in events:
<span style="color: #008080;"> 31</span> 	 callback = key.data
<span style="color: #008080;"> 32</span>         callback(key.fileobj, mask)</pre>
</div>
<span class="cnblogs_code_collapse">selectors</span></div>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>