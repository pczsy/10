<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修Python中线程的使用' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>Python中线程的使用</center></div><div class='banquan'>原文出处:本文由博客园博主纪宇-年华提供。<br/>
原文连接:https://www.cnblogs.com/jiyu-hlzy/p/11798565.html</div><br>
    <p>并发：多个任务同一时间段进行</p>
<p>并行：多个任务同一时刻进行</p>
<p>&nbsp;</p>
<p><span style="font-size: 18px;">线程的实现</span></p>
<p><span style="font-size: 16px;">线程模块</span></p>
<p>Python通过两个标准库_thread 和threading，提供对线程的支持 , threading对_thread进行了封装</p>
<p>因此在实际的使用中我们一般都是使用threading</p>
<p>threading模块中提供了Thread , Lock , RLock , Condition等组件</p>
<p>&nbsp;</p>
<p><span style="font-size: 16px;">Thread类</span></p>
<p>　　　　　　　　常用参数</p>
<p>target 　　表示调用对象，即子线程要执行的任务</p>
<p>name&nbsp; 　&nbsp; 子线程的名称</p>
<p>args&nbsp; 　　 传入target函数中的位置参数,是一个元组，参数后必须加逗号</p>
<p>　　　　　　　　常用实例方法</p>
<p>Thread.run (self)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;　　　　　　 &nbsp;线程启动时运行的方法,由该方法调用target参数所指定的函数</p>
<p>Thread.start (self)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;　　　　　　启动进程，start方法就是去帮你调用run方法</p>
<p>Thread.terminate (self)&nbsp; &nbsp; &nbsp; &nbsp; 　　　　&nbsp;&nbsp;强制终止线程</p>
<p>Thread.join (self, timeout=None)&nbsp; &nbsp; 　&nbsp; 阻塞调用，主线程进行等待</p>
<p>Thread.setDaemon (self，daemonic)&nbsp; 将子线程设置为守护线程</p>
<p>Thread.getName(self，name)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 　获取线程名称</p>
<p>Thread.setName (self，name )&nbsp; &nbsp; &nbsp; &nbsp; 　设置线程名称</p>
<p>&nbsp;</p>
<p><span style="font-size: 16px;">创建线程</span></p>
<p>实例Thread类</p>
<p><img src="./images/Python中线程的使用0.png" alt="" /></p>
<p><img src="./images/Python中线程的使用1.png" alt="" /></p>
<p>继承Thread类</p>
<p><span style="font-size: 18px;"><img src="./images/Python中线程的使用2.png" alt="" /></span></p>
<p><span style="font-size: 18px;"><img src="./images/Python中线程的使用3.png" alt="" /></span></p>
<p>&nbsp;</p>
<p><span style="font-size: 16px;">Join &amp; setDaemon</span></p>
<p>主线程 : 当一个程序启动时 , 就有一个线程开始运行 , 该线程通常叫做程序的主线程</p>
<p>子线程 : 因为程序是开始时就执行的 , 如果你需要再创建线程 , 那么创建的线程就是这个主线程的子线程</p>
<p>主线程的重要性体现在两方面 :&nbsp;</p>
<p>1. 是产生其他子线程的线程&nbsp;</p>
<p>2. 通常它必须最后完成执行比如执行各种关闭操作</p>
<p>join : 阻塞调用程序 , 直到调用join () 方法的线程执行结束, 才会继续往下执行</p>
<p><img src="./images/Python中线程的使用4.png" alt="" /></p>
<p><img src="./images/Python中线程的使用5.png" alt="" /></p>
<p>setDaemon() 与 join() 基本上是相对的 , join会等子线程执行完毕 ; 而setDaemon则不会等，主线程结束，则全部结束</p>
<p><span style="font-size: 18px;"><img src="./images/Python中线程的使用6.png" alt="" /></span></p>
<p><img src="./images/Python中线程的使用7.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="font-size: 18px;">线程通信</span></p>
<p><span style="font-size: 16px;">锁</span></p>
<p>在多线程中 , 所有变量对于所有线程都是共享的&nbsp;</p>
<p>因此 , 线程之间共享数据最大的危险在于多个线程同时修改一个变量 , 那就乱套了</p>
<p>所以我们需要互斥锁 , 来锁住数据</p>
<p>&nbsp;</p>
<p><span style="font-size: 16px;">线程间全局变量的共享</span></p>
<p>因为线程属于同一个进程，因此它们之间共享内存区域，所以全局变量是公共的</p>
<p>&nbsp;</p>
<p><span style="font-size: 16px;">共享内存间存在竞争问题</span></p>
<p>在这里进行原子操作（取值、运算、赋值）的时候切换到了其它线程，一个线程还没赋值，另外的线程就已经给它赋值了，然后又切回来继续赋值</p>
<p><span style="font-size: 18px;"><img src="./images/Python中线程的使用8.png" alt="" /></span></p>
<p><img src="./images/Python中线程的使用9.png" alt="" /></p>
<p>&nbsp;</p>
<p><span style="font-size: 16px;">使用锁来控制共享资源的访问</span></p>
<p>加锁：Lock对象.acquire()</p>
<p>解锁：Lock对象.release()</p>
<p><img src="./images/Python中线程的使用10.png" alt="" /></p>
<p><img src="./images/Python中线程的使用11.png" alt="" /></p>
<p>&nbsp;</p>
<p><span style="font-size: 16px;">队列的基本概念</span></p>
<p>一个入口，一个出口，先入先出（FIFO）</p>
<p>&nbsp;</p>
<p><span style="font-size: 16px;">线程安全队列、操作一览</span></p>
<p>入队： put(item)</p>
<p>出队： get()</p>
<p>测试空： empty()</p>
<p>测试满： full()</p>
<p>队列长度： qsize()</p>
<p>任务结束： task_done()</p>
<p>等待完成： join()</p>
<p><img src="./images/Python中线程的使用12.png" alt="" /></p>
<p><img src="./images/Python中线程的使用13.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="font-size: 18px;">线程池</span></p>
<p><span style="font-size: 16px;">池的概念</span></p>
<p>主线程：相当于生产者，只管向线程池提交任务，并不关心线程池是如何执行任务的，因此，也不关心是哪一个线程执行的这个任务</p>
<p>线程池：相当于消费者，负责接收任务，并将任务分配到一个空闲的线程中去执行</p>
<p>&nbsp;</p>
<p><span style="font-size: 16px;">线程池的简单实现</span></p>
<p><img src="./images/Python中线程的使用14.png" alt="" /></p>
<p><img src="./images/Python中线程的使用15.png" alt="" /></p>
<p><span style="font-size: 16px;">python内置线程池</span></p>
<p><img src="./images/Python中线程的使用16.png" alt="" /></p>
<p>&nbsp;</p>
<p><span style="font-size: 16px;">池的其他操作</span></p>
<p>操作一： close - 关闭提交通道，不允许再提交任务</p>
<p>操作二： terminate - 中止进程池，中止所有任务&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>