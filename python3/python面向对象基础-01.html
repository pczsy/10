<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修python面向对象基础-01' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>python面向对象基础-01</center></div><div class='banquan'>原文出处:本文由博客园博主suwanbin提供。<br/>
原文连接:https://www.cnblogs.com/suwanbin/p/11240814.html</div><br>
    <h1>面向对象（OOP）基本概念</h1>
<h2>前言</h2>
<div class="cnblogs_code" onclick="cnblogs_code_show('ad32746e-1e7c-41db-ab91-c4cb19d4504d')"><img id="code_img_closed_ad32746e-1e7c-41db-ab91-c4cb19d4504d" class="code_img_closed" src="./images/python面向对象基础-010.png" alt="" /><img id="code_img_opened_ad32746e-1e7c-41db-ab91-c4cb19d4504d" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('ad32746e-1e7c-41db-ab91-c4cb19d4504d',event)" src="./images/python面向对象基础-011.png" alt="" />
<div id="cnblogs_code_open_ad32746e-1e7c-41db-ab91-c4cb19d4504d" class="cnblogs_code_hide">
<pre><code>话说三国时期曹军于官渡大败袁绍,酒席之间,曹操诗兴大发,吟道:喝酒唱歌,人生真爽! 众将直呼:<span style="color: #800000;">"</span><span style="color: #800000;">丞相好诗</span><span style="color: #800000;">"</span><span style="color: #000000;">,于是命印刷工匠刻板印刷以流传天下;

待工匠刻板完成,交与曹操一看,曹操感觉不妥,说道:</span><span style="color: #800000;">"</span><span style="color: #800000;">喝酒唱歌,此话太俗,应改为'对酒当歌'较好</span><span style="color: #800000;">"</span><span style="color: #000000;">,于是名工匠重新刻板,当时还没有出现活字印刷术,如果样板要改,只能重新刻板,工匠眼看连夜刻版之工，彻底白费，心中叫苦不迭。可也只得照办。

版样再次出来请曹操过目，曹操细细一品，觉得还是不好，说&rdquo;人生真爽太过直接，应该改问语才够意境，因此应改为&lsquo;对酒当歌，人生几何？&rsquo;&ldquo;，于是....

在活字印刷术还没出现之前，如果版样有改动，只能重新雕刻。而且在印刷完成后，这个样板就失去了它的价值，如果需要其他样板只能重新雕刻。而活字印刷术的出现就大大改善了印刷技术。如上例&rdquo;喝酒唱歌，人生真爽&ldquo;，如果用活字印刷，只需要改四个字就可，其余工作都未白做。岂不快哉!!

活字印刷也反应了OOP。当要改动时，只需要修改部分，此为 可维护；当这些字用完后，并非就完全没有价值了，它完全可以在后来的印刷中重复使用，此乃 可复用；此诗若要加字，只需另刻字加入即可，这就是 可扩展；字的排列可以横排，也可以竖排，此是 灵活性好。</span></pre>
</div>
<span class="cnblogs_code_collapse">曹操吟诗工匠刻录的故事（转载）</span></div>
<div class="cnblogs_code" onclick="cnblogs_code_show('5f81e9f2-9534-43eb-8441-0dd6d0db679f')"><img id="code_img_closed_5f81e9f2-9534-43eb-8441-0dd6d0db679f" class="code_img_closed" src="./images/python面向对象基础-010.png" alt="" /><img id="code_img_opened_5f81e9f2-9534-43eb-8441-0dd6d0db679f" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('5f81e9f2-9534-43eb-8441-0dd6d0db679f',event)" src="./images/python面向对象基础-011.png" alt="" />
<div id="cnblogs_code_open_5f81e9f2-9534-43eb-8441-0dd6d0db679f" class="cnblogs_code_hide">
<pre><code><span style="color: #008000;">#</span><span style="color: #008000;"> 上述案列反应了面向对象的优点,即可维护性高,扩展性强,复用性高! </span><span style="color: #008000;">
#</span><span style="color: #008000;">   这些特点非常适用于用户需求变化频繁的互联网应用程序,这是学习面向对象的重要原因</span><span style="color: #008000;">
#</span><span style="color: #008000;">   但是面向对象设计的程序需涉及类与对象,相应的复杂度会提高!</span><span style="color: #008000;">
#</span> <span style="color: #008000;">
#</span><span style="color: #008000;"> 并非所有程序都需要较高的扩展性,例如系统内核,一旦编写完成,基本不会再修改,使用面向过程来设计则更适用</span></pre>
</div>
<span class="cnblogs_code_collapse">小结</span></div>
<h2>面向对象</h2>
<p>面向对象：&nbsp;<span class="cnblogs_code"><span style="color: #008000;">#</span><span style="color: #008000;"> 是一种编程思想，是前辈们总结的编程经验，指导程序员如何编写出更好的程序</span></span>&nbsp;</p>
<p>核心：&nbsp;<span class="cnblogs_code"><span style="color: #008000;">#</span><span style="color: #008000;"> 对象</span></span>&nbsp;</p>
<p>程序就是一系列对象的集合，程序员负责调度控制这些对象来交互着完成任务 在面向对象中程序员的角度发生了改变，从具体的操作者变成了指挥者。</p>
<p>强调：对象不是凭空产生的，需要我们自己设计</p>
<h3>面向对象的优缺点</h3>
<div class="cnblogs_code">
<pre><code><span style="color: #800000;">'''</span><span style="color: #800000;"> 
    优点：
        1.可扩展性高
        2.灵活性高
        3.重用性高

    缺点：
        1.程序的复杂度提高了
        2.无法准确预知结果
</span><span style="color: #800000;">'''</span></pre>
</div>
<p>使用场景：&nbsp;<span class="cnblogs_code"><span style="color: #008000;">#</span><span style="color: #008000;"> 对扩展性要求较高的程序，通常是直接面向用户的，例如qq 微信</span></span>&nbsp;</p>
<p>注意点：&nbsp;<span class="cnblogs_code"><span style="color: #008000;">#</span><span style="color: #008000;"> 不是所有的程序都要采用面向对象，要根据实际需求来选择</span></span>&nbsp;</p>
<p>面向对象的两大核心：&nbsp;<span class="cnblogs_code"><span style="color: #008000;">#</span><span style="color: #008000;"> 类与对象</span></span>&nbsp;</p>
<h3>类</h3>
<div class="cnblogs_code">
<pre><code><span style="color: #800000;">'''</span><span style="color: #800000;">
  类即类型、类别，是一种 抽象概念
      是一系列具备相同特征和相同行为的对象的集合 
</span><span style="color: #800000;">'''</span> </pre>
</div>
<h3>对象</h3>
<div class="cnblogs_code">
<pre><code><span style="color: #800000;">'''</span><span style="color: #800000;">
    对象就是具体存在的某个事物，具备自己的特征和行为
        对象就是特征和技能的结合体
</span><span style="color: #800000;">'''</span></pre>
</div>
<h3>类和对象的关系</h3>
<div class="cnblogs_code">
<pre><code><span style="color: #800000;">'''</span><span style="color: #800000;">
    类包含一系列对象
    对象属于某个类
    
    在现实中先有对象再有类，程序中先有类再有对象
        我们必须先告诉计算机这类的对象有什么特征有什么行为
</span><span style="color: #800000;">'''</span></pre>
</div>
<p>结论：&nbsp;<span class="cnblogs_code"><span style="color: #008000;">#</span><span style="color: #008000;"> 在面向对象编程时，第一步需要考虑需要什么样的对象，对象具备什么样的特征和行为，从而根据这些信息总结出需要的类</span></span>&nbsp;</p>
<h1>用面向对象思想编程</h1>
<h2>类的定义语法及类名书写规范</h2>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span><span style="color: #000000;"> 类的名称:
    </span><span style="color: #008000;">#</span><span style="color: #008000;"> 类中的内容，描述属性和技能</span>
    <span style="color: #008000;">#</span><span style="color: #008000;"> 描述属性用变量</span>
    <span style="color: #008000;">#</span><span style="color: #008000;"> 描述行为用函数</span>

<span style="color: #800000;">'''</span><span style="color: #800000;">
    类名书写规范：
        1.见名知意
        2.名称是大驼峰式（驼峰就是单词首字母大写，大驼峰就是第一个字母大写，小驼峰是第一个字母小写）
        3.其他规范与变量大致相同
</span><span style="color: #800000;">'''</span></pre>
</div>
<h2>属性</h2>
<div class="cnblogs_code">
<pre><code><span style="color: #800000;">'''</span><span style="color: #800000;">
属性可以写在类中
类中的属性，是对象公共的

也可以写在对象中
对象中的属性，每个对象独特的（不一样的）

如果类和对象中存在同样的属性，先访问对象，如果没有再访问类
</span><span style="color: #800000;">'''</span></pre>
</div>
<h2>属性的增删改查</h2>
<div class="cnblogs_code">
<pre><code><span style="color: #800000;">'''</span><span style="color: #800000;">
增加属性
    对象变量名称.属性名称 = 属性值
    egon.male = 'male'
删除属性
    del 对象的变量名称.属性名称
    del egon.male
修改属性    
    对象.属性 = 新的值
查看所有属性，访问的是对象的所有属性
    对象.__dict__  --&gt; dict 可以访问调用者自身的名称空间

访问他的类
    对象.__class__ 返回类
</span><span style="color: #800000;">'''</span></pre>
</div>
<div class="cnblogs_code" onclick="cnblogs_code_show('f171f655-5696-4997-a409-f4483db4c865')"><img id="code_img_closed_f171f655-5696-4997-a409-f4483db4c865" class="code_img_closed" src="./images/python面向对象基础-010.png" alt="" /><img id="code_img_opened_f171f655-5696-4997-a409-f4483db4c865" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('f171f655-5696-4997-a409-f4483db4c865',event)" src="./images/python面向对象基础-011.png" alt="" />
<div id="cnblogs_code_open_f171f655-5696-4997-a409-f4483db4c865" class="cnblogs_code_hide">
<pre><code><span style="color: #0000ff;">class</span><span style="color: #000000;"> Student:
    </span><span style="color: #800000;">'''</span><span style="color: #800000;">
    这是Student类的注释
    </span><span style="color: #800000;">'''</span>
    <span style="color: #0000ff;">def</span> <span style="color: #800080;">__init__</span><span style="color: #000000;">(self, name):
        self.name </span>=<span style="color: #000000;"> name


</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> TeachOfOldBoy:
    company </span>= <span style="color: #800000;">'</span><span style="color: #800000;">oldboy</span><span style="color: #800000;">'</span>

    <span style="color: #0000ff;">def</span> <span style="color: #800080;">__init__</span><span style="color: #000000;">(self, name):
        self.name </span>=<span style="color: #000000;"> name


</span><span style="color: #008000;">#</span><span style="color: #008000;"> ---------- 对象新增、修改、查看、删除属性 -------------</span>
xuzhaolong = Student(<span style="color: #800000;">'</span><span style="color: #800000;">xzl</span><span style="color: #800000;">'</span><span style="color: #000000;">)
</span><span style="color: #0000ff;">print</span>(xuzhaolong.name)  <span style="color: #008000;">#</span><span style="color: #008000;"> 对象.属性 --&gt; 访问对象的属性</span><span style="color: #008000;">
#</span><span style="color: #008000;"> xzl</span><span style="color: #008000;">
#</span><span style="color: #008000;"> print(xuzhaolong.age)  # 访问不存在的属性会报错'Student' object has no attribute 'age'</span>
xuzhaolong.age = 18  <span style="color: #008000;">#</span><span style="color: #008000;"> 对象.属性 = 值 --&gt; 为对象添加新属性</span>
<span style="color: #0000ff;">print</span><span style="color: #000000;">(xuzhaolong.age)
</span><span style="color: #008000;">#</span><span style="color: #008000;"> 18</span>
xuzhaolong.age = 28  <span style="color: #008000;">#</span><span style="color: #008000;"> 对象.属性 = 新值 --&gt; 修改属性的值（如果该对象已有此属性）</span>
<span style="color: #0000ff;">print</span><span style="color: #000000;">(xuzhaolong.age)
</span><span style="color: #008000;">#</span><span style="color: #008000;"> 28</span>
<span style="color: #0000ff;">del</span> xuzhaolong.age   <span style="color: #008000;">#</span><span style="color: #008000;"> 删除对象的属性</span><span style="color: #008000;">
#</span><span style="color: #008000;"> print(xuzhaolong.age)  # 会报错，属性已被删除，类中（属性的查找顺序：对象--&gt;父类--&gt;...如果还有父类，其他父类...--&gt;Object）没有这个属性，AttributeError: 'Student' object has no attribute 'age'</span>

<span style="color: #0000ff;">print</span>(TeachOfOldBoy.<span style="color: #800080;">__dict__</span>)  <span style="color: #008000;">#</span><span style="color: #008000;"> __dict__查看调用者的名称空间里的名字</span><span style="color: #008000;">
#</span><span style="color: #008000;"> {'__module__': '__main__', 'company': 'oldboy', '__init__': &lt;function TeachOfOldBoy.__init__ at 0x0000026D1AC8A9D8&gt;, '__dict__': &lt;attribute '__dict__' of 'TeachOfOldBoy' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'TeachOfOldBoy' objects&gt;, '__doc__': None}</span>
<span style="color: #0000ff;">print</span>(xuzhaolong.<span style="color: #800080;">__dict__</span><span style="color: #000000;">)
</span><span style="color: #008000;">#</span><span style="color: #008000;"> {'name': 'xzl', 'age': 28}</span>

<span style="color: #008000;">#</span><span style="color: #008000;"> ---------- __class__ 查看调用者所属类型（python里类也是一种数据类型） -------------</span>
<span style="color: #0000ff;">print</span>(TeachOfOldBoy.<span style="color: #800080;">__class__</span>)  <span style="color: #008000;">#</span><span style="color: #008000;"> __class__ 查看调用者所属类</span><span style="color: #008000;">
#</span><span style="color: #008000;"> &lt;class 'type'&gt;</span>
<span style="color: #0000ff;">print</span>(xuzhaolong.<span style="color: #800080;">__class__</span><span style="color: #000000;">)
</span><span style="color: #008000;">#</span><span style="color: #008000;"> &lt;class '__main__.Student'&gt;</span>

<span style="color: #008000;">#</span><span style="color: #008000;"> ---------- __doc__ 查看调用者的注释  -------------</span>
<span style="color: #0000ff;">print</span>(TeachOfOldBoy.<span style="color: #800080;">__doc__</span>)  <span style="color: #008000;">#</span><span style="color: #008000;"> __doc__ 查看调用者的注释</span><span style="color: #008000;">
#</span><span style="color: #008000;"> None</span>
<span style="color: #0000ff;">print</span>(Student.<span style="color: #800080;">__doc__</span>)  <span style="color: #008000;">#</span><span style="color: #008000;"> __doc__ 查看调用者所属类的注释</span><span style="color: #008000;">
#
#</span><span style="color: #008000;">     这是Student类的注释</span><span style="color: #008000;">
#
</span><span style="color: #0000ff;">print</span>(xuzhaolong.<span style="color: #800080;">__doc__</span>)  <span style="color: #008000;">#</span><span style="color: #008000;"> __doc__ 查看调用者所属类的注释</span><span style="color: #008000;">
#
#</span><span style="color: #008000;">     这是Student类的注释</span><span style="color: #008000;">
#
</span>
<span style="color: #008000;">#</span><span style="color: #008000;"> ------------ 类中的属性与对象 -----------------</span>
egon = TeachOfOldBoy(<span style="color: #800000;">'</span><span style="color: #800000;">egon</span><span style="color: #800000;">'</span><span style="color: #000000;">)
</span><span style="color: #0000ff;">print</span><span style="color: #000000;">(egon.company)
</span><span style="color: #008000;">#</span><span style="color: #008000;"> oldboy</span>
egon.company = <span style="color: #800000;">'</span><span style="color: #800000;">OldBoy</span><span style="color: #800000;">'</span>
<span style="color: #0000ff;">print</span>(egon.company)  <span style="color: #008000;">#</span><span style="color: #008000;"> 修改对象的继承的属性不影响类中的属性</span><span style="color: #008000;">
#</span><span style="color: #008000;"> OldBoy</span>
<span style="color: #0000ff;">print</span><span style="color: #000000;">(TeachOfOldBoy.company)
</span><span style="color: #008000;">#</span><span style="color: #008000;"> oldboy</span></pre>
</div>
<span class="cnblogs_code_collapse">代码体现</span></div>
<p>属性的查找顺序：&nbsp;<span class="cnblogs_code"><span style="color: #008000;">#</span><span style="color: #008000;"> 属性的查找顺序：先找自己的，再找类的，再父类。。。。一直往上找到object，再没有就报错</span></span>&nbsp;</p>
<h2>对象初始化__inint__</h2>
<div class="cnblogs_code">
<pre><code><span style="color: #800000;">'''</span><span style="color: #800000;">
__init__方法
    特点
        1.当实例化对象时，会自动执行__init__方法
        2.会自动将对象作为第一个参数传入，对象参数名称为self，self这个名字可以改，但不建议（一眼就知道是对象本身了）

    功能
        用户给对象赋初始值 
</span><span style="color: #800000;">'''</span>
<span style="color: #008000;">#</span><span style="color: #008000;"> 初始化，不仅仅只是赋初值，还可以做一些其他操作，来保证对象的正常生成</span></pre>
</div>
<div class="cnblogs_code" onclick="cnblogs_code_show('0e57012c-f437-4745-97dd-dff70d30a415')"><img id="code_img_closed_0e57012c-f437-4745-97dd-dff70d30a415" class="code_img_closed" src="./images/python面向对象基础-010.png" alt="" /><img id="code_img_opened_0e57012c-f437-4745-97dd-dff70d30a415" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('0e57012c-f437-4745-97dd-dff70d30a415',event)" src="./images/python面向对象基础-011.png" alt="" />
<div id="cnblogs_code_open_0e57012c-f437-4745-97dd-dff70d30a415" class="cnblogs_code_hide">
<pre><code><span style="color: #800000;">'''</span><span style="color: #800000;">
    之前十个老师，每个老师都要输姓名年龄等，而属性的值又不一样，就不能直接定义成类的属性
    每定义一个对象都要写一次，很麻烦

    那么我们可以使用函数来简化这个赋值操作
    class Cls:  # 定义一个类
        pass

    def init(obj, kind, color, age):  # 定义一个方法来简化给对象添加（定制）属性
        obj.kind = kind  # 即 对象.属性 = 值（变量的） --&gt; 像什么？ 给对象添加属性嘛
        obj.color = color
        obj.age = age

    obj1 = Cls()  # 实例化出一个对象
    init(obj1, "泰日天", '棕色', 2)  # 通过调用 init 函数来给该对象添加属性
    obj2 = Cls()
    init(obj2, "拆家犬", '黑白', 1)
    # 这样子就有了两个对象，且都已经有了各自的属性了

</span><span style="color: #800000;">'''</span>


<span style="color: #0000ff;">class</span><span style="color: #000000;"> Dog:
    </span><span style="color: #0000ff;">def</span> <span style="color: #800080;">__init__</span><span style="color: #000000;">(self, kind, color, age):
        </span><span style="color: #008000;">#</span><span style="color: #008000;"> print(locals())  # {'age': 2, 'color': '棕色', 'kind': '泰日天', 'self': &lt;__main__.Dog object at 0x000002985BE586D8&gt;}</span>
        self.kind =<span style="color: #000000;"> kind
        self.color </span>=<span style="color: #000000;"> color
        self.age </span>=<span style="color: #000000;"> age
        </span><span style="color: #008000;">#</span><span style="color: #008000;"> __init__ 函数不允许写返回值（不能写，只能返回None，写return None 没有意思） 规定如此</span>
        
    <span style="color: #800000;">'''</span><span style="color: #800000;">
        不过在类里面直接写这个 init 函数会更方便（python内部做了一些处理）
        如上，当实例化对象时，会自动执行这个 __init__ 方法
            会自动将调用这个类实例化的对象作为第一个参数传入，对象参数名称为self
    </span><span style="color: #800000;">'''</span>


<span style="color: #008000;">#</span><span style="color: #008000;"> 那么在实例化的时候就可以简写成这样了，四行变两行</span>
teidi = Dog(<span style="color: #800000;">"</span><span style="color: #800000;">泰日天</span><span style="color: #800000;">"</span>, <span style="color: #800000;">'</span><span style="color: #800000;">棕色</span><span style="color: #800000;">'</span>, 2<span style="color: #000000;">)
</span><span style="color: #008000;">#</span><span style="color: #008000;"> print(teidi.__dict__)  # {'kind': '泰日天', 'color': '棕色', 'age': 2}</span>
erha = Dog(<span style="color: #800000;">"</span><span style="color: #800000;">拆家犬</span><span style="color: #800000;">"</span>, <span style="color: #800000;">'</span><span style="color: #800000;">黑白</span><span style="color: #800000;">'</span>, 1<span style="color: #000000;">)


</span><span style="color: #800000;">'''</span><span style="color: #800000;">
其实上面的写法还可以有优化，那个__init__ 函数还可以写得更简洁一点（参数越多越明显）
    def __init__(self, kind, color, age):
        lcs = locals()
        lcs.pop('self')
        self.__dict__.update(lcs)
    
    上面写法中的locals()内置函数在 __init__ 函数中，可以获取 __init__ 函数名称空间里的那些名字，它是一个字典
        # print(locals())  # {'age': 2, 'color': '棕色', 'kind': '泰日天', 'self': &lt;__main__.Dog object at 0x000002985BE586D8&gt;}
        我们将其赋给一个中间字典接收，将多余的 self 键值对去掉，就是我们对象想要的属性
        而对象.__dict__正好也是一个字典
        # print(teidi.__dict__)  # {'kind': '泰日天', 'color': '棕色', 'age': 2}
        都是字典？字典的update()方法还记得吗？
        将这个中间字典update()到对象的.__dict__ 中，即完成了对象的属性添加
        self.__dict__.update(lcs)
</span><span style="color: #800000;">'''</span></pre>
</div>
<span class="cnblogs_code_collapse">__init__</span></div>
<p><span style="color: #888888;"><img style="display: block; margin-left: auto; margin-right: auto;" src="./images/python面向对象基础-018.png" alt="" /></span></p>
<p><span style="color: #888888;">备注：关于python内一些 __名字__ 这种属性是什么情况，可以参考这篇博客哦（都说</span><span style="color: #ff0000;">不重要</span><span style="color: #888888;">，但总有我这样的好奇宝宝嘛）~</span>&nbsp; <a title="Python常用内建方法：__init__,__new__,__class__的使用详解" href="https://blog.csdn.net/qq_26442553/article/details/82464682" target="_blank">Python常用内建方法：__init__,__new__,__class__的使用详解</a></p>
<h2>绑定方法与非绑定方法</h2>
<p>对象的精髓所在就是将数据和处理数据的函数整合到一起了,这样一来，拿到一个对象就同时拿到了需要处理的数据以及处理数据的函数</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('c9c2618e-6b76-4377-b9a2-31195d70ed63')"><img id="code_img_closed_c9c2618e-6b76-4377-b9a2-31195d70ed63" class="code_img_closed" src="./images/python面向对象基础-010.png" alt="" /><img id="code_img_opened_c9c2618e-6b76-4377-b9a2-31195d70ed63" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('c9c2618e-6b76-4377-b9a2-31195d70ed63',event)" src="./images/python面向对象基础-011.png" alt="" />
<div id="cnblogs_code_open_c9c2618e-6b76-4377-b9a2-31195d70ed63" class="cnblogs_code_hide">
<pre><code><span style="color: #800000;">'''</span><span style="color: #800000;">
******* 这一块基础概念是重点 *******
对象绑定方法：self --&gt; 默认传入对象
    默认情况下，类中的方法都是对象绑定方法
    
    当使用对象调用时
        其特殊之处在于调用该函数时会自动传入对象本身作为第一个参数
    当使用类名来调用时就是一个普通函数，有几个参数就传几个参数


类绑定方法：@classmethod
            cls(加上@classmethod装饰后自己将self改为cls(class是关键字)) --&gt; 默认传入类
    给类的抽象方法，默认传入类作为参数 
    特殊之处：不管用类还是对象调用，都会自动传入类本身，作为第一个参数
    
    何时绑定给对象：当函数逻辑需要访问对象中的数据时
    何时绑定给类：当函数逻辑需要访问类中的数据时   
            

非绑定方法：@staticmethod
    装饰成普通函数，不管谁调都一样
        既不需要访问类的数据也不需要访问对象的数据
    定义时有几个参数调用时就需要传入几个参数


</span><span style="color: #800000;">'''</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Dog:
    species </span>= <span style="color: #800000;">'</span><span style="color: #800000;">dog</span><span style="color: #800000;">'</span>
    <span style="color: #008000;">#</span><span style="color: #008000;"> 初始化方法 __init__ 也属于对象绑定方法</span>
    <span style="color: #0000ff;">def</span> <span style="color: #800080;">__init__</span><span style="color: #000000;">(self, kind, nickname, skill):
        self.kind </span>=<span style="color: #000000;"> kind
        self.nickname </span>=<span style="color: #000000;"> nickname
        self.skill </span>=<span style="color: #000000;"> skill

    </span><span style="color: #008000;">#</span><span style="color: #008000;"> 这就属于一个对象绑定方法，默认将对象作为第一个参数传入（调用的时候不需要手动传入）</span>
    <span style="color: #0000ff;">def</span><span style="color: #000000;"> introduce(self):
        </span><span style="color: #0000ff;">print</span>(f<span style="color: #800000;">"</span><span style="color: #800000;">我是{self.kind}，我能{self.skill}，人送外号{self.nickname}</span><span style="color: #800000;">"</span><span style="color: #000000;">)

    </span><span style="color: #008000;">#</span><span style="color: #008000;"> 类绑定方法</span>
<span style="color: #000000;">    @classmethod
    </span><span style="color: #0000ff;">def</span> tell_species(cls):  <span style="color: #008000;">#</span><span style="color: #008000;"> 先写装饰器再写函数，默认参数就是cls了，写完函数再装饰的话，记得把self换成cls，表示参数是一个类</span>
        <span style="color: #0000ff;">print</span>(f<span style="color: #800000;">"</span><span style="color: #800000;">我的物种是{cls.species}</span><span style="color: #800000;">"</span><span style="color: #000000;">)

    </span><span style="color: #008000;">#</span><span style="color: #008000;"> 非绑定方法（既不需要传入类，也不需要传入对象）</span>
<span style="color: #000000;">    @staticmethod
    </span><span style="color: #0000ff;">def</span><span style="color: #000000;"> normal_func(arg1, arg2):
        </span><span style="color: #0000ff;">print</span>(f<span style="color: #800000;">"</span><span style="color: #800000;">参数一：{arg1} 参数二：{arg2}，这只是一个普通方法啦~</span><span style="color: #800000;">"</span><span style="color: #000000;">)

taidi </span>= Dog(<span style="color: #800000;">'</span><span style="color: #800000;">泰迪</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">泰日天</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">日天</span><span style="color: #800000;">'</span><span style="color: #000000;">)
erha </span>= Dog(<span style="color: #800000;">'</span><span style="color: #800000;">二哈</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">拆家犬</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">拆家</span><span style="color: #800000;">'</span><span style="color: #000000;">)


</span><span style="color: #008000;">#</span><span style="color: #008000;"> --------绑定对象方法的调用</span>
<span style="color: #000000;">taidi.introduce()
erha.introduce()
</span><span style="color: #008000;">#</span><span style="color: #008000;"> 我是泰迪，我能日天，人送外号泰日天</span><span style="color: #008000;">
#</span><span style="color: #008000;"> 我是二哈，我能拆家，人送外号拆家犬</span>
Dog.introduce(erha)  <span style="color: #008000;">#</span><span style="color: #008000;"> 类调用对象的方法要手动把对象传入进去</span><span style="color: #008000;">
#</span><span style="color: #008000;"> 我是二哈，我能拆家，人送外号拆家犬</span>

<span style="color: #008000;">#</span><span style="color: #008000;"> --------类绑定方法调用</span>
<span style="color: #000000;">Dog.tell_species()
taidi.tell_species()  </span><span style="color: #008000;">#</span><span style="color: #008000;"> 可以直接调用，无需手动传入 class</span><span style="color: #008000;">
#</span><span style="color: #008000;"> 我的物种是dog</span><span style="color: #008000;">
#</span><span style="color: #008000;"> 我的物种是dog</span>

<span style="color: #008000;">#</span><span style="color: #008000;"> --------非绑定方法调用</span>
Dog.normal_func(1, 2)  <span style="color: #008000;">#</span><span style="color: #008000;"> 非绑定方法，定义时有几个参数，调用时就要传几个参数</span>
taidi.normal_func(1, 2)  <span style="color: #008000;">#</span><span style="color: #008000;"> 非绑定方法，定义时有几个参数，调用时就要传几个参数</span><span style="color: #008000;">
#</span><span style="color: #008000;"> 参数一：1 参数二：2，这只是一个普通方法啦~</span><span style="color: #008000;">
#</span><span style="color: #008000;"> 参数一：1 参数二：2，这只是一个普通方法啦~</span></pre>
</div>
<span class="cnblogs_code_collapse">对象绑定方法、类绑定方法、非绑定方法</span></div>
<h2>利用pickle模块将对象序列化到本地</h2>
<p>如单机游戏的存档（把对象的数据等信息存储到文件中，下次启动再读取回来） --&gt; 游戏扩展</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('02cb40fe-797e-4765-ad39-e563ee5c392e')"><img id="code_img_closed_02cb40fe-797e-4765-ad39-e563ee5c392e" class="code_img_closed" src="./images/python面向对象基础-010.png" alt="" /><img id="code_img_opened_02cb40fe-797e-4765-ad39-e563ee5c392e" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('02cb40fe-797e-4765-ad39-e563ee5c392e',event)" src="./images/python面向对象基础-011.png" alt="" />
<div id="cnblogs_code_open_02cb40fe-797e-4765-ad39-e563ee5c392e" class="cnblogs_code_hide">
<pre><code><span style="color: #0000ff;">import</span><span style="color: #000000;"> pickle


</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> Student:
    </span><span style="color: #0000ff;">def</span> <span style="color: #800080;">__init__</span><span style="color: #000000;">(self, name):
        self.name </span>=<span style="color: #000000;"> name

    </span><span style="color: #0000ff;">def</span><span style="color: #000000;"> say_hi(self):
        </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">"</span><span style="color: #800000;">name:</span><span style="color: #800000;">"</span><span style="color: #000000;">, self.name)

    </span><span style="color: #0000ff;">def</span><span style="color: #000000;"> save(self):
        with open(self.name, </span><span style="color: #800000;">"</span><span style="color: #800000;">wb</span><span style="color: #800000;">"</span>) as f:  <span style="color: #008000;">#</span><span style="color: #008000;"> pickle 模块操作文件必须是b 模式</span>
            pickle.dump(self, f)  <span style="color: #008000;">#</span><span style="color: #008000;"> 利用pickle 模块，将传入的对象序列化到了文件中（json模块不支持对象这种类型）</span>
<span style="color: #000000;">
    @staticmethod
    </span><span style="color: #0000ff;">def</span><span style="color: #000000;"> get(name):
        with open(name, </span><span style="color: #800000;">"</span><span style="color: #800000;">rb</span><span style="color: #800000;">"</span><span style="color: #000000;">) as f:
            obj </span>= pickle.load(f)  <span style="color: #008000;">#</span><span style="color: #008000;"> 利用pickle 模块，将文件中的对象反序列化成python中的对象</span>
            <span style="color: #0000ff;">return</span><span style="color: #000000;"> obj


</span><span style="color: #008000;">#</span><span style="color: #008000;"> 将rose 和 jack两个从内存中对象序列化到文件中</span>
stu = Student(<span style="color: #800000;">"</span><span style="color: #800000;">rose</span><span style="color: #800000;">"</span><span style="color: #000000;">)
stu.save()
stu2 </span>= Student(<span style="color: #800000;">"</span><span style="color: #800000;">jack</span><span style="color: #800000;">"</span><span style="color: #000000;">)
stu2.save()

</span><span style="color: #008000;">#</span><span style="color: #008000;"> 将他两反序列化出来到内存中</span>
obj = Student.get(<span style="color: #800000;">"</span><span style="color: #800000;">rose</span><span style="color: #800000;">"</span>)  <span style="color: #008000;">#</span><span style="color: #008000;"> 调用类中的方法（类绑定方法）从文件中将对象加载到内存中</span>
<span style="color: #0000ff;">print</span>(obj.name)  <span style="color: #008000;">#</span><span style="color: #008000;"> 使用该对象获取属性值</span><span style="color: #008000;">
#</span><span style="color: #008000;"> rose</span>
obj2 = Student.get(<span style="color: #800000;">"</span><span style="color: #800000;">jack</span><span style="color: #800000;">"</span><span style="color: #000000;">)
</span><span style="color: #0000ff;">print</span><span style="color: #000000;">(obj2.name)
</span><span style="color: #008000;">#</span><span style="color: #008000;"> jack</span>

<span style="color: #0000ff;">print</span>(Student.<span style="color: #800080;">__name__</span>)  <span style="color: #008000;">#</span><span style="color: #008000;"> 获取类名</span><span style="color: #008000;">
#</span><span style="color: #008000;"> Student</span>

<span style="color: #008000;">#</span><span style="color: #008000;"> 反序列化出来的对象和序列化的那个对象已经不是同一个对象了</span>
<span style="color: #0000ff;">print</span><span style="color: #000000;">(id(stu), id(obj))
</span><span style="color: #008000;">#</span><span style="color: #008000;"> 2161209937816 2161209971880</span>
<span style="color: #0000ff;">print</span><span style="color: #000000;">(stu.name, obj.name)
</span><span style="color: #008000;">#</span><span style="color: #008000;"> rose rose</span>
<span style="color: #0000ff;">print</span><span style="color: #000000;">(id(stu2), id(obj2))
</span><span style="color: #008000;">#</span><span style="color: #008000;"> 2161209937872 2161209971824</span>
<span style="color: #0000ff;">print</span><span style="color: #000000;">(stu2.name, obj2.name)
</span><span style="color: #008000;">#</span><span style="color: #008000;"> jack jack</span>
obj2.name = <span style="color: #800000;">'</span><span style="color: #800000;">jack2</span><span style="color: #800000;">'</span>
<span style="color: #0000ff;">print</span><span style="color: #000000;">(stu2.name, obj2.name)
</span><span style="color: #008000;">#</span><span style="color: #008000;"> jack jack2</span></pre>
</div>
<span class="cnblogs_code_collapse">将对象从内存中序列化反序列化到文件中</span></div>
<h2>英雄大乱斗（随机）案例</h2>
<div class="cnblogs_code" onclick="cnblogs_code_show('0878e48f-8aa4-4a48-96f0-7bc403984452')"><img id="code_img_closed_0878e48f-8aa4-4a48-96f0-7bc403984452" class="code_img_closed" src="./images/python面向对象基础-010.png" alt="" /><img id="code_img_opened_0878e48f-8aa4-4a48-96f0-7bc403984452" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('0878e48f-8aa4-4a48-96f0-7bc403984452',event)" src="./images/python面向对象基础-011.png" alt="" />
<div id="cnblogs_code_open_0878e48f-8aa4-4a48-96f0-7bc403984452" class="cnblogs_code_hide">
<pre><code><span style="color: #0000ff;">import</span><span style="color: #000000;"> random
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> time


</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> Hero:
    </span><span style="color: #0000ff;">def</span> <span style="color: #800080;">__init__</span><span style="color: #000000;">(self, name, health, attack, q_hurt, w_hurt, e_hurt):
        lcs </span>=<span style="color: #000000;"> locals()
        lcs.pop(</span><span style="color: #800000;">'</span><span style="color: #800000;">self</span><span style="color: #800000;">'</span><span style="color: #000000;">)
        self.</span><span style="color: #800080;">__dict__</span><span style="color: #000000;">.update(lcs)

    </span><span style="color: #0000ff;">def</span><span style="color: #000000;"> attack(self, enemy):
        </span><span style="color: #0000ff;">print</span>(f<span style="color: #800000;">"</span><span style="color: #800000;">-- {self.name} --使用普通攻击攻击了-- {enemy.name} --,造成了 {self.attack} 点伤害，{enemy.name} 剩余 {enemy.health} 点生命值。\033[0m</span><span style="color: #800000;">"</span><span style="color: #000000;">)
        enemy.health </span>-=<span style="color: #000000;"> self.attack

    </span><span style="color: #0000ff;">def</span><span style="color: #000000;"> Q(self, enemy):
        </span><span style="color: #0000ff;">print</span>(f<span style="color: #800000;">"</span><span style="color: #800000;">\033[0m-- {self.name} --使用Q技能攻击了-- {enemy.name} --,造成了 {self.q_hurt} 点伤害，{enemy.name} 剩余 {enemy.health} 点生命值。\033[0m</span><span style="color: #800000;">"</span><span style="color: #000000;">)
        enemy.health </span>-=<span style="color: #000000;"> self.q_hurt

    </span><span style="color: #0000ff;">def</span><span style="color: #000000;"> W(self, enemy):
        </span><span style="color: #0000ff;">print</span>(f<span style="color: #800000;">"</span><span style="color: #800000;">\033[32m-- {self.name} --使用W技能攻击了-- {enemy.name} --,造成了 {self.w_hurt} 点伤害，{enemy.name} 剩余 {enemy.health} 点生命值。\033[0m</span><span style="color: #800000;">"</span><span style="color: #000000;">)
        enemy.health </span>-=<span style="color: #000000;"> self.w_hurt

    </span><span style="color: #0000ff;">def</span><span style="color: #000000;"> E(self, enemy):
        </span><span style="color: #0000ff;">print</span>(f<span style="color: #800000;">"</span><span style="color: #800000;">\033[35m-- {self.name} --使用E技能攻击了-- {enemy.name} --,造成了 {self.e_hurt} 点伤害，{enemy.name} 剩余 {enemy.health} 点生命值。\033[0m</span><span style="color: #800000;">"</span><span style="color: #000000;">)
        enemy.health </span>-=<span style="color: #000000;"> self.e_hurt


</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> check_hero(enemy, team):
    </span><span style="color: #0000ff;">if</span> enemy.health &lt;=<span style="color: #000000;"> 0:
        </span><span style="color: #0000ff;">print</span>(f<span style="color: #800000;">"</span><span style="color: #800000;">\033[31m** {enemy.name} ** 阵亡。\033[0m</span><span style="color: #800000;">"</span><span style="color: #000000;">)
        </span><span style="color: #0000ff;">if</span> team == <span style="color: #800000;">'</span><span style="color: #800000;">blue</span><span style="color: #800000;">'</span><span style="color: #000000;">:
            blue_team.remove(enemy)
        </span><span style="color: #0000ff;">elif</span> team == <span style="color: #800000;">'</span><span style="color: #800000;">red</span><span style="color: #800000;">'</span><span style="color: #000000;">:
            red_team.remove(enemy)


</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> get_random_skill():
    </span><span style="color: #0000ff;">return</span> skill_list.get(random.randint(1, 4<span style="color: #000000;">))


</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> get_random_blue_hero():
    </span><span style="color: #0000ff;">return</span> blue_team[random.randint(0, len(blue_team) - 1<span style="color: #000000;">)]


</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> get_random_red_hero():
    </span><span style="color: #0000ff;">return</span> red_team[random.randint(0, len(red_team) - 1<span style="color: #000000;">)]


blue_team </span>=<span style="color: #000000;"> [
    Hero(</span><span style="color: #800000;">'</span><span style="color: #800000;">瑞文</span><span style="color: #800000;">'</span>, 465, 65, 30, 25, 70<span style="color: #000000;">),
    Hero(</span><span style="color: #800000;">'</span><span style="color: #800000;">提莫</span><span style="color: #800000;">'</span>, 300, 35, 50, 40, 60<span style="color: #000000;">),
]

red_team </span>=<span style="color: #000000;"> [
    Hero(</span><span style="color: #800000;">'</span><span style="color: #800000;">李白</span><span style="color: #800000;">'</span>, 320, 60, 35, 29, 77<span style="color: #000000;">),
    Hero(</span><span style="color: #800000;">'</span><span style="color: #800000;">鲁班</span><span style="color: #800000;">'</span>, 280, 79, 35, 40, 80<span style="color: #000000;">),
]

skill_list </span>=<span style="color: #000000;"> {
    </span>1<span style="color: #000000;">: Hero.attack,
    </span>2<span style="color: #000000;">: Hero.Q,
    </span>3<span style="color: #000000;">: Hero.W,
    </span>4<span style="color: #000000;">: Hero.E,
}


</span><span style="color: #0000ff;">while</span> len(red_team) &gt; 0 <span style="color: #0000ff;">and</span> len(blue_team) &gt;<span style="color: #000000;"> 0:
    skill </span>=<span style="color: #000000;"> get_random_skill()
    blue </span>=<span style="color: #000000;"> get_random_blue_hero()
    red </span>=<span style="color: #000000;"> get_random_red_hero()
    flag </span>= random.randint(0, 1<span style="color: #000000;">)
    </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> flag:
        skill(blue, red)
        check_hero(red, </span><span style="color: #800000;">'</span><span style="color: #800000;">red</span><span style="color: #800000;">'</span><span style="color: #000000;">)
    </span><span style="color: #0000ff;">else</span><span style="color: #000000;">:
        skill(red, blue)
        check_hero(blue, </span><span style="color: #800000;">'</span><span style="color: #800000;">blue</span><span style="color: #800000;">'</span><span style="color: #000000;">)
    time.sleep(</span>0.3<span style="color: #000000;">)

    </span><span style="color: #0000ff;">if</span> len(red_team) ==<span style="color: #000000;"> 0:
        </span><span style="color: #0000ff;">print</span>(f<span style="color: #800000;">"</span><span style="color: #800000;">蓝色方获胜！</span><span style="color: #800000;">"</span><span style="color: #000000;">)
        </span><span style="color: #0000ff;">print</span>(f<span style="color: #800000;">"</span><span style="color: #800000;">蓝色方所剩英雄状态为：</span><span style="color: #800000;">"</span><span style="color: #000000;">)
        </span><span style="color: #0000ff;">for</span> hero <span style="color: #0000ff;">in</span><span style="color: #000000;"> blue_team:
            </span><span style="color: #0000ff;">print</span>(f<span style="color: #800000;">"</span><span style="color: #800000;">{hero.name} 剩余生命值 {hero.health}</span><span style="color: #800000;">"</span><span style="color: #000000;">)
    </span><span style="color: #0000ff;">elif</span> len(blue_team) ==<span style="color: #000000;"> 0:
        </span><span style="color: #0000ff;">print</span>(f<span style="color: #800000;">"</span><span style="color: #800000;">红色方获胜！</span><span style="color: #800000;">"</span><span style="color: #000000;">)
        </span><span style="color: #0000ff;">print</span>(f<span style="color: #800000;">"</span><span style="color: #800000;">红色方所剩英雄状态为：</span><span style="color: #800000;">"</span><span style="color: #000000;">)
        </span><span style="color: #0000ff;">for</span> hero <span style="color: #0000ff;">in</span><span style="color: #000000;"> red_team:
            </span><span style="color: #0000ff;">print</span>(f<span style="color: #800000;">"</span><span style="color: #800000;">{hero.name} 剩余生命值 {hero.health}</span><span style="color: #800000;">"</span>)</pre>
</div>
<span class="cnblogs_code_collapse">无注释版</span></div>
<p>注释版</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('bcb3980f-b99d-47ad-96ce-f74673ae4fd0')"><img id="code_img_closed_bcb3980f-b99d-47ad-96ce-f74673ae4fd0" class="code_img_closed" src="./images/python面向对象基础-010.png" alt="" /><img id="code_img_opened_bcb3980f-b99d-47ad-96ce-f74673ae4fd0" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('bcb3980f-b99d-47ad-96ce-f74673ae4fd0',event)" src="./images/python面向对象基础-011.png" alt="" />
<div id="cnblogs_code_open_bcb3980f-b99d-47ad-96ce-f74673ae4fd0" class="cnblogs_code_hide">
<pre><code><span style="color: #0000ff;">import</span><span style="color: #000000;"> random
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> time


</span><span style="color: #008000;">#</span><span style="color: #008000;"> 定义一个英雄类，表示英雄这一类的共同特征</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Hero:
    </span><span style="color: #0000ff;">def</span> <span style="color: #800080;">__init__</span><span style="color: #000000;">(self, name, health, attack, q_hurt, w_hurt, e_hurt):
        lcs </span>=<span style="color: #000000;"> locals()
        lcs.pop(</span><span style="color: #800000;">'</span><span style="color: #800000;">self</span><span style="color: #800000;">'</span><span style="color: #000000;">)
        self.</span><span style="color: #800080;">__dict__</span><span style="color: #000000;">.update(lcs)
        </span><span style="color: #800000;">'''</span><span style="color: #800000;">
            ********************************** 上述代码讲解 *************************************
            # 每次调用类生成对象的时候都会执行这里面的代码，并将对象作为第一个参数self 传进来
            print(locals())
            # {'e_hurt': 70, 'w_hurt': 25, 'q_hurt': 30, 'attack': 65, 'health': 465, 'name': '瑞文', 'self': &lt;__main__.Hero object at 0x000002371823B278&gt;}
            lcs = locals()  # 这个locals()在 __init__ 函数里 可以获取 __init__ 函数名称空间里的那些名字，他是一个字典
            lcs.pop('self')  # 发现上面的 locals() 多了一个 self 是不需要的，那就把它删掉
            print(lcs)
            # {'e_hurt': 70, 'w_hurt': 25, 'q_hurt': 30, 'attack': 65, 'health': 465, 'name': '瑞文'}
            # 这些内容正是初始化对象时想做的事（只不过是 对象.e_hurt = 70 这样的形式而已）
            self.__dict__.update(lcs)  # 将这些东西放到对象里，就重复了n变 self.参数 = 参数 （self.name = name）这样的动作
            print(self.__dict__)
            # {'e_hurt': 70, 'w_hurt': 25, 'q_hurt': 30, 'attack': 65, 'health': 465, 'name': '瑞文'}
            
            最初始的写法：
                self.name = name
                self.health = health
                self.attack = attack
                self.q_hurt = q_hurt
                self.w_hurt = w_hurt
                self.e_hurt = e_hurt
        </span><span style="color: #800000;">'''</span>

    <span style="color: #0000ff;">def</span><span style="color: #000000;"> attack(self, enemy):
        enemy.health </span>-=<span style="color: #000000;"> self.attack
        </span><span style="color: #0000ff;">print</span>(f<span style="color: #800000;">"</span><span style="color: #800000;">-- {self.name} --使用普通攻击攻击了-- {enemy.name} --,造成了 {self.attack} 点伤害，{enemy.name} 剩余 {enemy.health} 点生命值。\033[0m</span><span style="color: #800000;">"</span><span style="color: #000000;">)

    </span><span style="color: #0000ff;">def</span><span style="color: #000000;"> Q(self, enemy):
        enemy.health </span>-=<span style="color: #000000;"> self.q_hurt
        </span><span style="color: #0000ff;">print</span>(f<span style="color: #800000;">"</span><span style="color: #800000;">\033[0m-- {self.name} --使用Q技能攻击了-- {enemy.name} --,造成了 {self.q_hurt} 点伤害，{enemy.name} 剩余 {enemy.health} 点生命值。\033[0m</span><span style="color: #800000;">"</span><span style="color: #000000;">)

    </span><span style="color: #0000ff;">def</span><span style="color: #000000;"> W(self, enemy):
        enemy.health </span>-=<span style="color: #000000;"> self.w_hurt
        </span><span style="color: #0000ff;">print</span>(f<span style="color: #800000;">"</span><span style="color: #800000;">\033[32m-- {self.name} --使用W技能攻击了-- {enemy.name} --,造成了 {self.w_hurt} 点伤害，{enemy.name} 剩余 {enemy.health} 点生命值。\033[0m</span><span style="color: #800000;">"</span><span style="color: #000000;">)

    </span><span style="color: #0000ff;">def</span><span style="color: #000000;"> E(self, enemy):
        enemy.health </span>-=<span style="color: #000000;"> self.e_hurt
        </span><span style="color: #0000ff;">print</span>(f<span style="color: #800000;">"</span><span style="color: #800000;">\033[35m-- {self.name} --使用E技能攻击了-- {enemy.name} --,造成了 {self.e_hurt} 点伤害，{enemy.name} 剩余 {enemy.health} 点生命值。\033[0m</span><span style="color: #800000;">"</span><span style="color: #000000;">)


</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> check_hero(enemy, team):
    </span><span style="color: #0000ff;">if</span> enemy.health &lt;=<span style="color: #000000;"> 0:
        </span><span style="color: #008000;">#</span><span style="color: #008000;"> \033[31m 这种格式的是打印时的颜色控制（颜色可参考 https://www.cnblogs.com/easypython/p/9084426.html）</span>
        <span style="color: #0000ff;">print</span>(f<span style="color: #800000;">"</span><span style="color: #800000;">\033[31m** {enemy.name} ** 阵亡。\033[0m</span><span style="color: #800000;">"</span><span style="color: #000000;">)
        </span><span style="color: #0000ff;">if</span> team == <span style="color: #800000;">'</span><span style="color: #800000;">blue</span><span style="color: #800000;">'</span><span style="color: #000000;">:
            blue_team.remove(enemy)
        </span><span style="color: #0000ff;">elif</span> team == <span style="color: #800000;">'</span><span style="color: #800000;">red</span><span style="color: #800000;">'</span><span style="color: #000000;">:
            red_team.remove(enemy)


</span><span style="color: #008000;">#</span><span style="color: #008000;"> 随机选择一种攻击方式</span>
<span style="color: #0000ff;">def</span><span style="color: #000000;"> get_random_skill():
    </span><span style="color: #008000;">#</span><span style="color: #008000;"> random_index = random.randint(1, 4)</span>
    <span style="color: #008000;">#</span><span style="color: #008000;"> random_skill = skill_list.get(random_index)</span>
    <span style="color: #008000;">#</span><span style="color: #008000;"> return random_skill  # 函数名当做返回值返回，拿到可以直接加括号调用执行函数</span>
    <span style="color: #0000ff;">return</span> skill_list.get(random.randint(1, 4))  <span style="color: #008000;">#</span><span style="color: #008000;"> 上面代码的简便写法</span>


<span style="color: #008000;">#</span><span style="color: #008000;"> 随机选择一个蓝色方英雄</span>
<span style="color: #0000ff;">def</span><span style="color: #000000;"> get_random_blue_hero():
    </span><span style="color: #008000;">#</span><span style="color: #008000;"> 返回 blue_team 这个列表的索引为 random.randint(0, len(blue_team) - 1) 返回值的元素（英雄对象）</span>
    <span style="color: #008000;">#</span><span style="color: #008000;"> return blue_team[random.randint(0, len(blue_team) - 1)]  # 下面几行的简便写法</span>
    random_idndex = random.randint(0, len(blue_team) - 1<span style="color: #000000;">)
    hero </span>=<span style="color: #000000;"> blue_team[random_idndex]
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> hero


</span><span style="color: #008000;">#</span><span style="color: #008000;"> 随机选择一个红色方英雄</span>
<span style="color: #0000ff;">def</span><span style="color: #000000;"> get_random_red_hero():
    </span><span style="color: #0000ff;">return</span> red_team[random.randint(0, len(red_team) - 1<span style="color: #000000;">)]


</span><span style="color: #008000;">#</span><span style="color: #008000;"> 蓝色方英雄阵容 --- 可自定义 ---</span><span style="color: #008000;">
#</span><span style="color: #008000;"> 方便随机数取英雄对象</span>
blue_team =<span style="color: #000000;"> [
    </span><span style="color: #008000;">#</span><span style="color: #008000;"> 英雄名 生命值 普通攻击力 Q技能伤害 W技能伤害 E技能伤害</span>
    <span style="color: #008000;">#</span><span style="color: #008000;">  瑞文   465      65       30        25        70</span>
    Hero(<span style="color: #800000;">'</span><span style="color: #800000;">瑞文</span><span style="color: #800000;">'</span>, 465, 65, 30, 25, 70<span style="color: #000000;">),
    Hero(</span><span style="color: #800000;">'</span><span style="color: #800000;">提莫</span><span style="color: #800000;">'</span>, 300, 35, 50, 40, 60<span style="color: #000000;">),
    Hero(</span><span style="color: #800000;">'</span><span style="color: #800000;">锤石</span><span style="color: #800000;">'</span>, 600, 15, 20, 0, 32<span style="color: #000000;">),
]

</span><span style="color: #008000;">#</span><span style="color: #008000;"> 红色方英雄阵容 --- 可自定义 ---</span><span style="color: #008000;">
#</span><span style="color: #008000;"> 方便随机数取英雄对象</span>
red_team =<span style="color: #000000;"> [
    Hero(</span><span style="color: #800000;">'</span><span style="color: #800000;">李白</span><span style="color: #800000;">'</span>, 320, 60, 35, 29, 77<span style="color: #000000;">),
    Hero(</span><span style="color: #800000;">'</span><span style="color: #800000;">鲁班</span><span style="color: #800000;">'</span>, 280, 79, 35, 40, 80<span style="color: #000000;">),
    Hero(</span><span style="color: #800000;">'</span><span style="color: #800000;">盾山</span><span style="color: #800000;">'</span>, 800, 3, 3, 3, 3<span style="color: #000000;">),
]

</span><span style="color: #008000;">#</span><span style="color: #008000;"> 技能数字对应表（方便根据随机数取技能）</span>
skill_list =<span style="color: #000000;"> {
    </span>1<span style="color: #000000;">: Hero.attack,
    </span>2<span style="color: #000000;">: Hero.Q,
    </span>3<span style="color: #000000;">: Hero.W,
    </span>4<span style="color: #000000;">: Hero.E,
}


</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> run():
    </span><span style="color: #0000ff;">while</span> len(red_team) &gt; 0 <span style="color: #0000ff;">and</span> len(blue_team) &gt;<span style="color: #000000;"> 0:
        </span><span style="color: #008000;">#</span><span style="color: #008000;"> 调用方法随机获得一个技能</span>
        skill =<span style="color: #000000;"> get_random_skill()
        </span><span style="color: #008000;">#</span><span style="color: #008000;"> 调用方法随机获得一个蓝色方英雄</span>
        blue =<span style="color: #000000;"> get_random_blue_hero()
        </span><span style="color: #008000;">#</span><span style="color: #008000;"> 调用方法随机获得一个红色方英雄</span>
        red =<span style="color: #000000;"> get_random_red_hero()
        </span><span style="color: #008000;">#</span><span style="color: #008000;"> 随机选择一方为攻击方（那么另一方就是被攻击方）</span>
        flag = random.randint(0, 1<span style="color: #000000;">)
        </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> flag:
            skill(blue, red)
            check_hero(red, </span><span style="color: #800000;">'</span><span style="color: #800000;">red</span><span style="color: #800000;">'</span><span style="color: #000000;">)
        </span><span style="color: #0000ff;">else</span><span style="color: #000000;">:
            skill(red, blue)
            check_hero(blue, </span><span style="color: #800000;">'</span><span style="color: #800000;">blue</span><span style="color: #800000;">'</span><span style="color: #000000;">)
        </span><span style="color: #008000;">#</span><span style="color: #008000;"> 暂停0.3秒，可以慢慢看战斗过程</span>
        time.sleep(0.3<span style="color: #000000;">)

        </span><span style="color: #008000;">#</span><span style="color: #008000;"> 如果有任意一方没有英雄了，即游戏结束</span>
        <span style="color: #0000ff;">if</span> len(red_team) ==<span style="color: #000000;"> 0:
            </span><span style="color: #0000ff;">print</span>(f<span style="color: #800000;">"</span><span style="color: #800000;">蓝色方获胜！</span><span style="color: #800000;">"</span><span style="color: #000000;">)
            </span><span style="color: #0000ff;">print</span>(f<span style="color: #800000;">"</span><span style="color: #800000;">蓝色方所剩英雄状态为：</span><span style="color: #800000;">"</span><span style="color: #000000;">)
            </span><span style="color: #0000ff;">for</span> hero <span style="color: #0000ff;">in</span><span style="color: #000000;"> blue_team:
                </span><span style="color: #0000ff;">print</span>(f<span style="color: #800000;">"</span><span style="color: #800000;">{hero.name} 剩余生命值 {hero.health}</span><span style="color: #800000;">"</span><span style="color: #000000;">)
        </span><span style="color: #0000ff;">elif</span> len(blue_team) ==<span style="color: #000000;"> 0:
            </span><span style="color: #0000ff;">print</span>(f<span style="color: #800000;">"</span><span style="color: #800000;">红色方获胜！</span><span style="color: #800000;">"</span><span style="color: #000000;">)
            </span><span style="color: #0000ff;">print</span>(f<span style="color: #800000;">"</span><span style="color: #800000;">红色方所剩英雄状态为：</span><span style="color: #800000;">"</span><span style="color: #000000;">)
            </span><span style="color: #0000ff;">for</span> hero <span style="color: #0000ff;">in</span><span style="color: #000000;"> red_team:
                </span><span style="color: #0000ff;">print</span>(f<span style="color: #800000;">"</span><span style="color: #800000;">{hero.name} 剩余生命值 {hero.health}</span><span style="color: #800000;">"</span><span style="color: #000000;">)


</span><span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">'</span><span style="color: #800000;">__main__</span><span style="color: #800000;">'</span><span style="color: #000000;">:
    run()
    </span><span style="color: #800000;">'''</span><span style="color: #800000;">
        战斗记录
        ************************** 省略n多中间战斗步骤  *********************************
        -- 锤石 --使用W技能攻击了-- 盾山 --,造成了 0 点伤害，盾山 剩余 42 点生命值。
        -- 盾山 --使用E技能攻击了-- 瑞文 --,造成了 3 点伤害，瑞文 剩余 289 点生命值。
        -- 瑞文 --使用E技能攻击了-- 盾山 --,造成了 70 点伤害，盾山 剩余 -28 点生命值。
        ** 盾山 ** 阵亡。
        蓝色方获胜！
        蓝色方所剩英雄状态为：
        瑞文 剩余生命值 289
        锤石 剩余生命值 235
        
        战斗记录2
        ************************** 省略n多中间战斗步骤  *********************************
        -- 盾山 --使用普通攻击攻击了-- 锤石 --,造成了 3 点伤害，锤石 剩余 11 点生命值。
        -- 锤石 --使用普通攻击攻击了-- 盾山 --,造成了 15 点伤害，盾山 剩余 288 点生命值。
        -- 盾山 --使用E技能攻击了-- 瑞文 --,造成了 3 点伤害，瑞文 剩余 -1 点生命值。
        ** 瑞文 ** 阵亡。
        -- 盾山 --使用普通攻击攻击了-- 锤石 --,造成了 3 点伤害，锤石 剩余 8 点生命值。
        -- 盾山 --使用普通攻击攻击了-- 锤石 --,造成了 3 点伤害，锤石 剩余 5 点生命值。
        -- 盾山 --使用W技能攻击了-- 锤石 --,造成了 3 点伤害，锤石 剩余 2 点生命值。
        -- 盾山 --使用Q技能攻击了-- 锤石 --,造成了 3 点伤害，锤石 剩余 -1 点生命值。
        ** 锤石 ** 阵亡。
        红色方获胜！
        红色方所剩英雄状态为：
        盾山 剩余生命值 288
    </span><span style="color: #800000;">'''</span>

<span style="color: #800000;">'''</span><span style="color: #800000;">
有红蓝两方英雄（可自定义个数）
    随机一方英雄使用随机攻击方式攻击另一方英雄，任意一方英雄全部阵亡则游戏结束
        每个英雄有 名字、生命值、普通攻击、Q技能攻击、W技能攻击、E技能攻击以及对应的伤害值
            当生命值为 0 时阵亡，不再参与战斗
</span><span style="color: #800000;">'''</span></pre>
</div>
<span class="cnblogs_code_collapse">注释版案例</span></div>
<h1>后续完善博客思路</h1>
<div class="cnblogs_code" onclick="cnblogs_code_show('dcbcb10b-e36b-4aaa-95f4-cb5a92bcb971')"><img id="code_img_closed_dcbcb10b-e36b-4aaa-95f4-cb5a92bcb971" class="code_img_closed" src="./images/python面向对象基础-010.png" alt="" /><img id="code_img_opened_dcbcb10b-e36b-4aaa-95f4-cb5a92bcb971" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('dcbcb10b-e36b-4aaa-95f4-cb5a92bcb971',event)" src="./images/python面向对象基础-011.png" alt="" />
<div id="cnblogs_code_open_dcbcb10b-e36b-4aaa-95f4-cb5a92bcb971" class="cnblogs_code_hide">
<pre><code><span style="color: #000000;">调用类生成对象发生的一些事情（对比变量、模块名称空间生成等）

属性的查找顺序（画图表示吧）
　　先找自己的，再找父类的，一级一级往上找，直到基类object，再没有报错

英雄大乱斗案例
序列化、反序列化对象（保存、读取对象）(游戏退出，读档)</span></pre>
</div>
<span class="cnblogs_code_collapse">待完善内容(不算是面向对象的重点啦)</span></div>
<p>&nbsp;</p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>