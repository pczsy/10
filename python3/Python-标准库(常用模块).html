<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修Python-标准库(常用模块)' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>Python-标准库(常用模块)</center></div><div class='banquan'>原文出处:本文由博客园博主CoderJerry提供。<br/>
原文连接:https://www.cnblogs.com/yangyuanhu/p/11220172.html</div><br>
    <p>前言: 之所以为不同模块划分重要程度,是因为大家不不可能精力一直集中,也不可能一下掌握所有,</p>
<p>但这个并不表示重要度低的可以不用掌握 !</p>
<p>你必须掌握的点是每个模块分别干什么事,今后在需要实现某些功能时能够想起来这个模块的名字,然后再去查自己的资料找对应的使用方法</p>
<h1 id="一.logging模块">一.logging模块</h1>
<p>logging翻译为日志记录</p>
<h4 id="那问题是什么是日志">那问题是什么是日志?</h4>
<p>日志实际上是日记的一种,用于记录某个时间点发生了什么事情,比如大学老师的教学日志,工作日志等</p>
<h4 id="为什么要记录日志">为什么要记录日志?</h4>
<p>在实际生活中记录日志主要为了日后复查,</p>
<p>比如某个大学老师每天记录自己讲的什么内容,后面有学生某科成绩优异获奖了,校长想要奖励对应的老师,但由于每个老师教的班级都很多,并不一定记得是谁教的,这时候就可以查看教学日志来获取需要的信息了</p>
<p>再比如,工厂的生产日志,如果某个产品除了因为某个零件出现了故障,通过生成日志,可以找到与这个产品同批次的其他产品,进行返工,或是通过日志找到该零件的供应商,进行沟通解决!</p>
<h4 id="程序中的日志">程序中的日志</h4>
<p>我们的程序开发完成后会被不同系统环境的用户下载使用,期间可能就会出现问题,直接把错误信息展示给用户看是没有任何意义的,用户看不懂也不会解决,那这时候就可以将用户执行的所有操作,以及代码运行的过程,记录到日志中,程序员通过分析日志内容,可以快速的定位问题</p>
<p><strong>综上: 日志就是用来记录发生的事件的</strong></p>
<p><strong>日志并不会立即产生作用,而是当程序出现了问题时在去分析日志文件提取有用信息</strong></p>
<h2 id="什么是logging模块">什么是logging模块</h2>
<p>logging模块是python提供的用于记录日志的模块</p>
<h2 id="为什么需要logging">为什么需要logging</h2>
<p>我们完全可以自己打开文件然后,日志写进去,但是这些操作重复且没有任何技术含量,所以python帮我们进行了封装,有了logging后我们在记录日志时 只需要简单的调用接口即可,非常方便!</p>
<h2 id="日志级别">日志级别</h2>
<p>在开始记录日志前还需要明确,日志的级别</p>
<p>随着时间的推移,日志记录会非常多,成千上万行,如何快速找到需要的日志记录这就成了问题</p>
<p>解决的方案就是 给日志划分级别</p>
<p>logging模块将日志分为了五个级别,从高到低分别是:</p>
<p>1.info 常规信息</p>
<p>2.debug 调试信息</p>
<p>3.warning 警告信息</p>
<p>4.error 错误信息</p>
<p>5.cretical 严重错误</p>
<p>本质上他们使用数字来表示级别的,从高到低分别是10,20,30,40,50</p>
<h2 id="logging模块的使用">logging模块的使用</h2>
<pre><code><code>#1.导入模块
import logging

#2.输出日志
logging.info(&quot;info&quot;)
logging.debug(&quot;debug&quot;)
logging.warning(&quot;warning&quot;)
logging.error(&quot;error&quot;)
logging.critical(&quot;critical&quot;)

#输出 WARNING:root:warning
#输出 ERROR:root:error
#输出 CRITICAL:root:critical</code></pre>
<p>我们发现info 和 debug都没有输出,这是因为它们的级别不够,</p>
<p>默认情况下:</p>
<p>​ logging的最低显示级别为warning,对应的数值为30</p>
<p>​ 日志被打印到了控制台</p>
<p>​ 日志输出格式为:级别 日志生成器名称 日志消息</p>
<p>如何修改这写默认的行为呢?,这就需要我们自己来进行配置</p>
<h2 id="自定义配置">自定义配置</h2>
<pre><code><code>import logging
logging.basicConfig()

&quot;&quot;&quot;可用参数
filename：用指定的文件名创建FiledHandler（后边会具体讲解handler的概念），这样日志会被存储在指定的文件中。
filemode：文件打开方式，在指定了filename时使用这个参数，默认值为“a”还可指定为“w”。
format：指定handler使用的日志显示格式。 
datefmt：指定日期时间格式。 
level：设置rootlogger（后边会讲解具体概念）的日志级别 
&quot;&quot;&quot;

#案例:
logging.basicConfig(
    filename=&quot;aaa.log&quot;,
    filemode=&quot;at&quot;,
    datefmt=&quot;%Y-%m-%d %H:%M:%S %p&quot;,
    format=&quot;%(asctime)s - %(name)s - %(levelname)s - %(module)s: %(message)s&quot;,
    level=10
)</code></pre>
<p><strong>格式化全部可用名称</strong></p>
<pre><code><code>%(name)s：Logger的名字，并非用户名，详细查看
%(levelno)s：数字形式的日志级别
%(levelname)s：文本形式的日志级别
%(pathname)s：调用日志输出函数的模块的完整路径名，可能没有
%(filename)s：调用日志输出函数的模块的文件名
%(module)s：调用日志输出函数的模块名
%(funcName)s：调用日志输出函数的函数名
%(lineno)d：调用日志输出函数的语句所在的代码行
%(created)f：当前时间，用UNIX标准的表示时间的浮 点数表示
%(relativeCreated)d：输出日志信息时的，自Logger创建以 来的毫秒数
%(asctime)s：字符串形式的当前时间。默认格式是 “2003-07-08 16:49:45,896”。逗号后面的是毫秒
%(thread)d：线程ID。可能没有
%(threadName)s：线程名。可能没有
%(process)d：进程ID。可能没有
%(message)s：用户输出的消息</code></pre>
<p>至此我们已经可以自己来配置一 写基础信息了,但是当我们想要将同一个日志输出到不同位置时,这些基础配置就无法实现了,</p>
<p>例如 有一个登录注册的功能 需要记录日志,同时生成两份 一份给程序员看,一份给老板看,作为程序员应该查看较为详细的日志,二老板则应该简单一些,因为他不需要关心程序的细节</p>
<p>要实现这样的需要我们需要系统的了解loggin模块</p>
<h2 id="logging模块的四个核心角色">logging模块的四个核心角色</h2>
<p>1.Logger 日志生成器 产生日志</p>
<p>2.Filter 日志过滤器 过滤日志</p>
<p>3.Handler 日志处理器 对日志进行格式化,并输出到指定位置(控制台或文件)</p>
<p>4.Formater 处理日志的格式</p>
<h2 id="一条日志完整的生命周期">一条日志完整的生命周期</h2>
<p>1.由logger 产生日志 -&gt; 2.交给过滤器判断是否被过滤 -&gt; 3.将日志消息分发给绑定的所有处理器 -&gt; 4处理器按照绑定的格式化对象输出日志</p>
<p>其中 第一步 会先检查日志级别 如果低于设置的级别则不执行</p>
<p>第二步 使用场景不多 需要使用面向对象的技术点 后续用到再讲</p>
<p>第三步 也会检查日志级别,如果得到的日志低于自身的日志级别则不输出</p>
<p>​ 生成器的级别应低于句柄否则给句柄设置级别是没有意义的,</p>
<p>​ 例如 handler设置为20 生成器设置为30</p>
<p>​ 30以下的日志压根不会产生</p>
<p>第四步 如果不指定格式则按照默认格式</p>
<h1 id="logging各角色的使用了解">logging各角色的使用(了解)</h1>
<pre><code><code># 生成器
logger1 = logging.getLogger(&quot;日志对象1&quot;)

# 文件句柄
handler1 = logging.FileHandler(&quot;log1.log&quot;,encoding=&quot;utf-8&quot;)
handler2 = logging.FileHandler(&quot;log2.log&quot;,encoding=&quot;utf-8&quot;)

# 控制台句柄
handler3 = logging.StreamHandler()


# 格式化对象
fmt1 = logging.Formatter(
    fmt=&quot;%(asctime)s - %(name)s - %(levelname)s:  %(message)s&quot;,
    datefmt=&quot;%m-%d %H:%M:%S %p&quot;)
fmt2 = logging.Formatter(
    fmt=&quot;%(asctime)s - %(levelname)s :  %(message)s&quot;,
    datefmt=&quot;%Y/%m/%d %H:%M:%S&quot;)

# 绑定格式化对象与文件句柄
handler1.setFormatter(fmt1)
handler2.setFormatter(fmt2)
handler3.setFormatter(fmt1)

# 绑定生成器与文件句柄
logger1.addHandler(handler1)
logger1.addHandler(handler2)
logger1.addHandler(handler3)

# 设置日志级别
logger1.setLevel(10)    #生成器日志级别
handler1.setLevel(20)   #句柄日志级别

# 测试
logger1.debug(&quot;debug msessage&quot;)
logger1.info(&quot;info msessage&quot;)
logger1.warning(&quot;warning msessage&quot;)
logger1.critical(&quot;critical msessage&quot;)</code></pre>
<p>到此我们已经可以实现上述的需求了,但是这并不是我们最终的实现方式,因为每次都要编写这样的代码是非常痛苦的</p>
<h2 id="logging的继承了解">logging的继承(了解)</h2>
<p>可以将一个日志指定为另一个日志的子日志 或子孙日志</p>
<p>当存在继承关系时 子孙级日志收到日志时会将该日志向上传递</p>
<p>指定继承关系:</p>
<pre><code><code>import  logging

log1 = logging.getLogger(&quot;mother&quot;)
log2 = logging.getLogger(&quot;mother.son&quot;)
log3 = logging.getLogger(&quot;mother.son.grandson&quot;)

# handler
fh = logging.FileHandler(filename=&quot;cc.log&quot;,encoding=&quot;utf-8&quot;)
# formatter
fm = logging.Formatter(&quot;%(asctime)s - %(name)s -%(filename)s - %(message)s&quot;)

# 绑定
log1.addHandler(fh)
log2.addHandler(fh)
log3.addHandler(fh)
# 绑定格式
fh.setFormatter(fm)
# 测试
# log1.error(&quot;测试&quot;)
# log2.error(&quot;测试&quot;)
log3.error(&quot;测试&quot;)
# 取消传递
log3.propagate = False
# 再次测试
log3.error(&quot;测试&quot;)</code></pre>
<h2 id="通过字典配置日志模块重点">通过字典配置日志模块(重点)</h2>
<p>每次都要编写代码来配置非常麻烦 ,我们可以写一个完整的配置保存起来,以便后续直接使用</p>
<pre><code><code>import logging.config
logging.config.dictConfig(LOGGING_DIC)
logging.getLogger(&quot;aa&quot;).debug(&quot;测试&quot;)</code></pre>
<p><strong>LOGGING_DIC模板</strong></p>
<pre><code><code>standard_format = &#39;[%(asctime)s][%(threadName)s:%(thread)d][task_id:%(name)s][%(filename)s:%(lineno)d]&#39; \
                  &#39;[%(levelname)s][%(message)s]&#39; #其中name为getlogger指定的名字

simple_format = &#39;[%(levelname)s][%(asctime)s][%(filename)s:%(lineno)d]%(message)s&#39;

id_simple_format = &#39;[%(levelname)s][%(asctime)s] %(message)s&#39;
logfile_path = &quot;配置文件路径&quot;

LOGGING_DIC = {
    &#39;version&#39;: 1,
    &#39;disable_existing_loggers&#39;: False,
    &#39;formatters&#39;: {
        &#39;standard&#39;: {
            &#39;format&#39;: standard_format
        },
        &#39;simple&#39;: {
            &#39;format&#39;: simple_format
        },
    },
    &#39;filters&#39;: {},
    &#39;handlers&#39;: {
        #打印到终端的日志
        &#39;console&#39;: {
            &#39;level&#39;: &#39;DEBUG&#39;,
            &#39;class&#39;: &#39;logging.StreamHandler&#39;,  # 打印到屏幕
            &#39;formatter&#39;: &#39;simple&#39;
        },
        #打印到文件的日志,收集info及以上的日志
        &#39;default&#39;: {
            &#39;level&#39;: &#39;DEBUG&#39;,
            &#39;class&#39;: &#39;logging.handlers.RotatingFileHandler&#39;,  # 保存到文件
            &#39;formatter&#39;: &#39;standard&#39;,
            &#39;filename&#39;: logfile_path,  # 日志文件
            &#39;maxBytes&#39;: 1024*1024*5,  # 日志大小 5M
            &#39;backupCount&#39;: 5, #日志文件最大个数
            &#39;encoding&#39;: &#39;utf-8&#39;,  # 日志文件的编码
        },
    },
    &#39;loggers&#39;: {
        #logging.getLogger(__name__)拿到的logger配置
        &#39;aa&#39;: {
            &#39;handlers&#39;: [&#39;default&#39;, &#39;console&#39;],  # 这里把上面定义的两个handler都加上，即log数据既写入文件又打印到屏幕
            &#39;level&#39;: &#39;DEBUG&#39;,
            &#39;propagate&#39;: True,  # 向上（更高level的logger）传递
        },
    },
}</code></pre>
<p>补充:</p>
<p>getLogger参数就是对应字典中loggers的key , 如果没有匹配的key 则返回系统默认的生成器,我们可以在字典中通过空的key来将一个生成器设置为默认的</p>
<pre><code><code>&#39;loggers&#39;: {
        # 把key设置为空
        &#39;&#39;: {
            &#39;handlers&#39;: [&#39;default&#39;, &#39;console&#39;],  # 这里把上面定义的两个handler都加上，即log数据既写入文件又打印到屏幕
            &#39;level&#39;: &#39;DEBUG&#39;,
            &#39;propagate&#39;: True,  # 向上（更高level的logger）传递
        },
    },</code></pre>
<p>,往后在使用时可以这调用模块提供的函数,来输出日志</p>
<p>logging.info(&quot;测试信息!&quot;)</p>
<p>另外我们在第一次使用日志时并没有指定生成器,但也可以使用,这是因为系统有默认的生成器名称就叫root</p>
<p>最后来完成之前的需求:</p>
<p>有一个登录注册的功能 需要记录日志,同时生成两份 一份给程序员看,一份给老板看,作为程序员应该查看较为详细的日志,二老板则应该简单一些,因为他不需要关心程序的细节</p>
<pre><code><code># 程序员看的格式
standard_format = &#39;[%(asctime)s][%(threadName)s:%(thread)d][task_id:%(name)s][%(filename)s:%(lineno)d]&#39; \
                  &#39;[%(levelname)s][%(message)s]&#39; #其中name为getlogger指定的名字
logfile_path1 = &quot;coder.log&quot;

# 老板看的格式
simple_format = &#39;[%(levelname)s][%(asctime)s]%(message)s&#39;
logfile_path2 = &quot;boss.log&quot;


LOGGING_DIC = {
    &#39;version&#39;: 1,
    &#39;disable_existing_loggers&#39;: False,
    &#39;formatters&#39;: {
        &#39;standard&#39;: {
            &#39;format&#39;: standard_format
        },
        &#39;simple&#39;: {
            &#39;format&#39;: simple_format
        },
    },
    &#39;filters&#39;: {},
    &#39;handlers&#39;: {
        #打印到终端的日志
        &#39;console&#39;: {
            &#39;level&#39;: &#39;DEBUG&#39;,
            &#39;class&#39;: &#39;logging.StreamHandler&#39;,  # 打印到屏幕
            &#39;formatter&#39;: &#39;simple&#39;
        },
        #打印到文件的日志,收集info及以上的日志
        &#39;std&#39;: {
            &#39;level&#39;: &#39;DEBUG&#39;,
            &#39;class&#39;: &#39;logging.handlers.RotatingFileHandler&#39;,  # 保存到文件
            &#39;formatter&#39;: &#39;standard&#39;,
            &#39;filename&#39;: logfile_path1,  # 日志文件
            &#39;maxBytes&#39;: 1024*1024*5,  # 日志大小 5M
            &#39;backupCount&#39;: 5, #日志文件最大个数
            &#39;encoding&#39;: &#39;utf-8&#39;,  # 日志文件的编码
        },
        &#39;boss&#39;: {
            &#39;level&#39;: &#39;DEBUG&#39;,
            &#39;class&#39;: &#39;logging.handlers.RotatingFileHandler&#39;,  # 保存到文件
            &#39;formatter&#39;: &#39;simple&#39;,
            &#39;filename&#39;: logfile_path2,  # 日志文件
            &#39;maxBytes&#39;: 1024 * 1024 * 5,  # 日志大小 5M
            &#39;backupCount&#39;: 5,  # 日志文件最大个数
            &#39;encoding&#39;: &#39;utf-8&#39;,  # 日志文件的编码
        }
    },
    &#39;loggers&#39;: {
        #logging.getLogger(__name__)拿到的logger配置
        &#39;aa&#39;: {
            &#39;handlers&#39;: [&#39;std&#39;, &#39;console&#39;,&quot;boss&quot;],  # 这里把上面定义的handler都加上，即log数据会同时输出到三个位置
            &#39;level&#39;: &#39;INFO&#39;,
            &#39;propagate&#39;: True,  # 向上（更高level的logger）传递
        },
    },
}</code></pre>
<h1 id="二.os模块">二.os模块</h1>
<p>os翻译过来就是操作系统,os模块提供了与操作系统打交道需要用到的函数,</p>
<p>那我们什么时候需要与操作系统打交道呢?</p>
<p><strong>在操作系统中,我们最最常用的操作就是,对文件及文件夹的操作, 所以 当你需要与操作文件时,就应该想到os模块了</strong></p>
<p>os提供一下函数</p>
<pre><code><code>os.getcwd() 获取当前工作目录，即当前python脚本工作的目录路径
os.chdir(&quot;dirname&quot;)  改变当前脚本工作目录；相当于shell下cd
os.curdir  返回当前目录: (&#39;.&#39;)
os.pardir  获取当前目录的父目录字符串名：(&#39;..&#39;)
os.makedirs(&#39;dirname1/dirname2&#39;)    可生成多层递归目录
os.removedirs(&#39;dirname1&#39;)    若目录为空，则删除，并递归到上一级目录，如若也为空，则删除，依此类推
os.mkdir(&#39;dirname&#39;)    生成单级目录；相当于shell中mkdir dirname
os.rmdir(&#39;dirname&#39;)    删除单级空目录，若目录不为空则无法删除，报错；相当于shell中rmdir dirname
os.listdir(&#39;dirname&#39;)    列出指定目录下的所有文件和子目录，包括隐藏文件，并以列表方式打印
os.remove()  删除一个文件
os.rename(&quot;oldname&quot;,&quot;newname&quot;)  重命名文件/目录
os.stat(&#39;path/filename&#39;)  获取文件/目录信息
os.sep    输出操作系统特定的路径分隔符，win下为&quot;\\&quot;,Linux下为&quot;/&quot;
os.linesep    输出当前平台使用的行终止符，win下为&quot;\t\n&quot;,Linux下为&quot;\n&quot;
os.pathsep    输出用于分割文件路径的字符串 win下为;,Linux下为:
os.name    输出字符串指示当前使用平台。win-&gt;&#39;nt&#39;; Linux-&gt;&#39;posix&#39;
os.system(&quot;bash command&quot;)  运行shell命令，直接显示
os.environ  获取系统环境变量</code></pre>
<h1 id="三.os.path模块">三.os.path模块</h1>
<p>该模块用于处理路径,我们知道python是一门跨平台的语言,二每种操作系统,文件路径是截然不同的,为了使程序可以在不同平台生正确运行,python提供了该模块,使用该模块可以实现路径在不同品台下的自动转换,从而实现跨平台,</p>
<p><strong>今后只要涉及到文件或文件夹路径,就应该使用该模块</strong></p>
<p>提供的函数:</p>
<pre><code><code>os.path.abspath(path)  返回path规范化的绝对路径
os.path.split(path)  将path分割成目录和文件名二元组返回
os.path.dirname(path)  返回path的目录。其实就是os.path.split(path)的第一个元素
os.path.basename(path)  返回path最后的文件名。如何path以／或\结尾，那么就会返回空值。即os.path.split(path)的第二个元素
os.path.exists(path)  如果path存在，返回True；如果path不存在，返回False
os.path.isabs(path)  如果path是绝对路径，返回True
os.path.isfile(path)  如果path是一个存在的文件，返回True。否则返回False
os.path.isdir(path)  如果path是一个存在的目录，则返回True。否则返回False
os.path.join(path1[, path2[, ...]])  将多个路径组合后返回，第一个绝对路径之前的参数将被忽略
os.path.getatime(path)  返回path所指向的文件或者目录的最后存取时间
os.path.getmtime(path)  返回path所指向的文件或者目录的最后修改时间
os.path.getsize(path) 返回path的大小</code></pre>
<pre><code><code>normcase函数
在Linux和Mac平台上，该函数会原样返回path，在windows平台上会将路径中所有字符转换为小写，并将所有斜杠转换为饭斜杠。
&gt;&gt;&gt; os.path.normcase(&#39;c:/windows\\system32\\&#39;)   
&#39;c:\\windows\\system32\\&#39;   
   
normpath函数
规范化路径，如..和/
&gt;&gt;&gt; os.path.normpath(&#39;c://windows\\System32\\../Temp/&#39;)   
&#39;c:\\windows\\Temp&#39;   

&gt;&gt;&gt; a=&#39;/Users/jieli/test1/\\\a1/\\\\aa.py/../..&#39;
&gt;&gt;&gt; print(os.path.normpath(a))
/Users/jieli/test1</code></pre>
<h1 id="四.subprocess">四.subprocess</h1>
<p>subprocess 称之为子进程,进程是一个正在运行的程序</p>
<p>为什么要使用子进程,因为之前的os.system()函数无法获取命令的执行结果,另一个问题是当我们启动了某一其他进程时无法与这个子进程进行通讯,</p>
<p><strong>当要在python程序中执行系统指令时 就应该使用subprocess</strong> 自动化运维经常会使用</p>
<pre><code><code>#测试
res = os.system(&quot;python&quot;)
print(res)
# res结果为执行状态</code></pre>
<h2 id="subprocess的使用">subprocess的使用</h2>
<pre><code><code>import subprocess

p = subprocess.Popen(&quot;ls&quot;,shell=True)
#shell=True 告诉系统这是一个指令 而不是某个文件名
#此时效果与sys.system()没有任何区别,都是将结果输出到控制台

# 那如何与这个进程交互数据呢,这需要用到三个参数
1.stdin  表示输入交给子进程的数据
2.stdout 表示子进程返回的数据
3.stderr 表示子进程发送的错误信息

#这三个参数,的类型都是管道,(管道本质就是一个文件,可以进行读写操作),使用subprocess.PIPE来获取一个管道
</code></pre>
<h5 id="案例">案例:</h5>
<p>理解了三个参数的意义后让我们来实现一个小功能</p>
<p>一个子进程执行tasklist命令获取所有的任务信息,然后将结果交给另一个进程进行查找</p>
<p>另一个子进程执行findstr 查找某个任务信息</p>
<pre><code><code>p1 = subprocess.Popen(&quot;tasklist&quot;,shell=True,stdout=subprocess.PIPE)
p2 = subprocess.Popen(&quot;findstr smss&quot;,shell=True,stdin=p1.stdout,stdout=subprocess.PIPE)
print(p2.stdout.read())</code></pre>
<p>总结: subprocess 主要用于执行系统命令,对比sys.system 区别在于可以在进程间交换数据</p>
<h1 id="五.sys-模块">五.sys 模块</h1>
<p>sys是system的缩写,表示系统,但是要注意</p>
<p>sys指的是解释器自身,而非操作系统</p>
<p>所以该模块主要是处理与解释器相关的操作的</p>
<p>提供的函数和属性:</p>
<pre><code><code>sys.argv           命令行参数List，第一个元素是程序本身路径
sys.exit(n)        退出程序，正常退出时exit(0)
sys.version        获取Python解释程序的版本信息
sys.maxint         最大的Int值
sys.path           返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值
sys.platform       返回操作系统平台名称</code></pre>
<p>其中提供了有一个arg属性用于接收从控制台传入的参数,当你要开发一款命令行程序时,该属性非常重要</p>
<p>案例:开发一款命令行界面的文件复制工具</p>
<p>思路:第一个参数是当前执行文件本身,第二个参数用于接收源文件,第三个参数用于接收目标文件</p>
<pre><code><code>import sys

source_path = sys.argv[1]
target_path = sys.argv[2]
print(source_path)
print(target_path)
with open(source_path, &quot;rb&quot;) as f1:
    with open(target_path, &quot;wb&quot;) as f2:
        while True:
            data = f1.read(1024)
            if not data:
                break
            f2.write(data)</code></pre>
<h1 id="六.confiparser">六.confiparser</h1>
<p>confiparser,翻译为配置解析,很显然,他是用来解析配置文件的,</p>
<p>何为配置文件?</p>
<p>用于编写程序的配置信息的文件</p>
<p>何为配置信息?</p>
<p>为了提高程序的扩展性,我们会把一些程序中需要用到的值交给用户来确定,比如迅雷的下载目录,同时下载数,qq的提示音等等,</p>
<p>作为配置信息的数据 应满足两个条件</p>
<p>1.数据的值不是固定的</p>
<p>2.可以由用户来指定的</p>
<p>例如我们做一个登录功能,为了方便使用我们可以将用户的用户名密码写到配置文件中,可以不需要每次都输入</p>
<h2 id="配置文件编写格式">配置文件编写格式</h2>
<p>在使用该模块前必须要先知道其配置文件的格式,由于读写文件的代码是模块封装好的,所以必须按照固定的方式来边编写,才能被正常解析, 当然并不是只有python有配置文件,其他任何语言都有,但是格式是相同的!</p>
<p>格式:</p>
<p>配置文件中只允许出现两种类型的数据</p>
<p>第一种 section 分区 方括号中是分区的名称 例如:[ATM ]</p>
<p>第二种 option 选项 名称 = 值</p>
<p>注意:</p>
<p>不能出现重复的分区名</p>
<p>同一个分区下不能有相同的选项名</p>
<p>值可以是任何类型 且字符串不需要加引号</p>
<h2 id="confiparser的使用">confiparser的使用</h2>
<h4 id="读取数据">读取数据</h4>
<pre><code><code>import configparser
#获取解析器对象
config=configparser.ConfigParser()
# 读取某个配置文件
config.read(&#39;a.cfg&#39;)

#查看所有的分区
res=config.sections() #[&#39;section1&#39;, &#39;section2&#39;]
print(res)

#查看标题section1下所有key=value的key
options=config.options(&#39;section1&#39;)
print(options) #[&#39;k1&#39;, &#39;k2&#39;, &#39;user&#39;, &#39;age&#39;, &#39;is_admin&#39;, &#39;salary&#39;]

#查看标题section1下所有key=value的(key,value)格式
item_list=config.items(&#39;section1&#39;)
print(item_list) #[(&#39;k1&#39;, &#39;v1&#39;), (&#39;k2&#39;, &#39;v2&#39;), (&#39;user&#39;, &#39;egon&#39;), (&#39;age&#39;, &#39;18&#39;), (&#39;is_admin&#39;, &#39;true&#39;), (&#39;salary&#39;, &#39;31&#39;)]

#查看标题section1下user的值=&gt;字符串格式
val=config.get(&#39;section1&#39;,&#39;user&#39;)
print(val) #egon

#由于使用前需要进行转换,所以模块封装了转换类型的功能,只需要调用对应的函数即可,如下:
val1=config.getint(&#39;section1&#39;,&#39;age&#39;)
val2=config.getboolean(&#39;section1&#39;,&#39;is_admin&#39;)
val3=config.getfloat(&#39;section1&#39;,&#39;salary&#39;)

#是否存在某选项
print(cfg.has_option(&quot;mysql&quot;,&quot;name&quot;))
#是否存在某分区
print(cfg.has_section(&quot;db&quot;))</code></pre>
<h4 id="添加删除修改">添加,删除,修改</h4>
<pre><code><code>import configparser

config=configparser.ConfigParser()
config.read(&#39;a.cfg&#39;,encoding=&#39;utf-8&#39;)

#删除整个标题section2
config.remove_section(&#39;section2&#39;)

#删除标题section1下的某个k1和k2
config.remove_option(&#39;section1&#39;,&#39;k1&#39;)
config.remove_option(&#39;section1&#39;,&#39;k2&#39;)

#判断是否存在某个标题
print(config.has_section(&#39;section1&#39;))

#判断标题section1下是否有user
print(config.has_option(&#39;section1&#39;,&#39;user&#39;))


#添加一个标题
config.add_section(&#39;jack&#39;)

#在标题egon下添加name=egon,age=18的配置
config.set(&#39;jack&#39;,&#39;name&#39;,&#39;egon&#39;) # 如果已存则覆盖原来的值
#config.set(&#39;jack&#39;,&#39;age&#39;,18) #报错,必须是字符串

#最后将修改的内容写入文件,完成最终的修改
config.write(open(&#39;a.cfg&#39;,&#39;w&#39;))</code></pre>
<h4 id="代码创建生成文件">代码创建生成文件</h4>
<pre><code><code>import configparser

config = configparser.ConfigParser()
config.add_section(&quot;setion1&quot;)
config.set(&quot;setion1&quot;,&quot;name&quot;,&quot;zhangsn&quot;)

with open(&quot;test.config&quot;,&quot;w&quot;) as f:
    config.write(f)</code></pre>
<p>总结configparser 用于解析配置文件,虽然可以修改和,创建,配置文件,但是并不常用,解析才是其核心功能!</p>
<h1 id="七.shevle模块">七.shevle模块</h1>
<p>该模块用于序列化python中的数据,但是序列化已经有pickle了为什么出现了shevle?</p>
<p>因为shevle更加简单,封装了文件的读写操作.load和dump操作,</p>
<p>只有一个open函数，返回类似字典的对象，可读可写;key必须为字符串，而值可以是python所支持的数据类型</p>
<p>完全可以将其看做是一个带有持久存储功能的字典来看待,操作方式与字典没有任何区别</p>
<pre><code><code>#保存数据
s = shelve.open(&quot;shv.shv&quot;)
s[&quot;name&quot;] = &quot;jack&quot;

#取出数据
s = shelve.open(&quot;shv.shv&quot;)
print(s[&quot;name&quot;])
#输出 jack

#关闭资源
s.close</code></pre>
<h1 id="八.shutil">八.shutil</h1>
<p>该模块提供了更加丰富的文件操作功能,压缩,解压缩,获取文件信息等</p>
<p>提供的功能:</p>
<pre><code><code>    shutil.copyfileobj   拷贝文件 提供两个文件对象 长度表示缓冲区大小
    shutil.copyfile(src, dst) 拷贝文件 提供两个文件路径 
    shutil.copymode()  拷贝文件权限 提供两个文件路径
    shutil.copystat(src, dst) 拷贝文件状态信息 最后访问 最后修改 权限 提供两个文件路径
    shutil.copy(src, dst) 拷贝文件和权限   提供两个文件路径
    shutil.copy2(src, dst) 拷贝文件和状态信息 提供两个文件路径

    shutil.ignore_patterns(&quot;mp3&quot;,&quot;*.py&quot;)
    shutil.copytree(src, dst, symlinks=False, ignore=None) 拷贝目录  
    symlinks默认False将软连接拷贝为硬链接  否则拷贝为软连接
    
    shutil.rmtree 删除目录 可以设置忽略文件
    shutil.move(src, dst)   移动目录和文件</code></pre>
<p>压缩与解压缩测试</p>
<pre><code><code>import shutil
#压缩,  文件名 格式  需要压缩的文件所在文件夹
shutil.make_archive(&quot;压缩测试&quot;,&quot;zip&quot;,r&quot;/Users/jerry/PycharmProjects/备课/常用模块五期&quot;)
#解压缩 #压缩,  文件名  解压后的文件存放目录
shutil.unpack_archive(&quot;压缩测试.zip&quot;,r&quot;/Users/jerry/PycharmProjects/备课/常用模块五期/
                      
# #压缩当前执行文件所在文件夹内容到当前目录
# shutil.make_archive(&quot;test&quot;,&quot;zip&quot;)
#
# #压缩root_dir指定路径的文件到当前目录
# shutil.make_archive(&quot;test&quot;,&quot;zip&quot;,root_dir=r&quot;/Users/jerry/PycharmProjects/work/re模块&quot;)
#

# #压缩root_dir指定路径的文件到base_name指定路径
# shutil.make_archive(&quot;/Users/jerry/PycharmProjects/work/压缩文件/test&quot;,&quot;zip&quot;,root_dir=r&quot;/Users/jerry/PycharmProjects/work/re模块&quot;)

                      
# #压缩root_dir指定路径的文件到base_name指定的压缩文件  压缩文件仅包含re模块下的的内容
# shutil.make_archive(&quot;test&quot;,
#                     &quot;zip&quot;,
#                     root_dir=r&quot;/Users/jerry/PycharmProjects/work&quot;,)


# 当指定base_dir时  则优先使用base_dir 与root_dir不同的是 压缩文件不仅包含re模块下的内容 还包括re模块的完整文件夹层级
# # 解压后得到Users -&gt;jerry -&gt; PycharmProject-&gt;work-&gt;re模块
# shutil.make_archive(&quot;test&quot;,
#                     &quot;zip&quot;,
#                     root_dir=r&quot;/Users/jerry/PycharmProjects/work/re模块&quot;,
#                     base_dir=r&quot;/Users/jerry/PycharmProjects/work/re模块&quot;)
 
                      </code></pre>

</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>