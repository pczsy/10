<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修Python之路【第二十六篇】HTTP协议' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>Python之路【第二十六篇】HTTP协议</center></div><div class='banquan'>原文出处:本文由博客园博主Simon92提供。<br/>
原文连接:https://www.cnblogs.com/hackerer/p/11604229.html</div><br>
    <h1>HTTP协议</h1>
<h2>一、HTTP概述</h2>
<p>HTTP(hypertext transport protocol),即超文本传输协议。这个协议详细规定了浏览器和万维网服务器之间互相通信的规则。</p>
<p>HTTP就是通信规则，通信规则规定了客户端发送给服务器的内容格式，也规定了服务器发送给客户端的内容格式。其实我们要学习的就是两种格式！客户端发送给服务器的格式叫&ldquo;请求协议&rdquo;；服务器发送给客户端的格式叫&ldquo;响应协议&rdquo;。</p>
<p><strong>特点：</strong></p>
<p>1、HTTP叫超文本传输协议，基于请求/响应模式；</p>
<p>2、HTTP是无状态协议；</p>
<p>URL:统一资源定位符，就是一个网址：协议名：//域名：端口/路径，例如：http://www.baidu.com:80/index.html</p>
<h2 class="p1"><span class="s1">二、请求协议</span></h2>
<p class="p2"><span class="s2">请求协议的格式如下：</span></p>
<div class="cnblogs_code">
<pre><code>请求首行；  // 请求方式 请求路径 协议和版本，例如：GET /index.html HTTP/1.1
请求头信息；// 请求头名称:请求头内容，即为key:value格式，例如：Host:localhost
空行；     // 用来与请求体分隔开
请求体。   // GET没有请求体，只有POST有请求体。</pre>
</div>
<p class="p1"><span class="s1">浏览器发送给服务器的内容就这个格式的，如果不是这个格式服务器将无法解读！在<span class="s2">HTTP<span class="s1">协议中，请求有很多请求方法，其中最为常用的就是<span class="s2">GET<span class="s1">和<span class="s2">POST<span class="s1">。不同的请求方法之间的区别，后面会一点一点的介绍。</span></span></span></span></span></span></span></p>
<h3 class="p1"><span class="s1">2.1&nbsp;<span class="s2"><span class="s1">GET<span class="s2">请求</span></span></span></span></h3>
<p>HTTP默认的请求方法就是GET<br />&nbsp; &nbsp; &nbsp;* 没有请求体<br />&nbsp; &nbsp; &nbsp;* 数据必须在1K之内！<br />&nbsp; &nbsp; &nbsp;* GET请求数据会暴露在浏览器的地址栏中</p>
<p>GET请求常用的操作：<br />&nbsp; &nbsp; &nbsp; &nbsp;1. 在浏览器的地址栏中直接给出URL，那么就一定是GET请求<br />&nbsp; &nbsp; &nbsp; &nbsp;2. 点击页面上的超链接也一定是GET请求<br />&nbsp; &nbsp; &nbsp; &nbsp;3. 提交表单时，表单默认使用GET请求，但可以设置为POST</p>
<div class="cnblogs_code">
<pre><code>Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8<span>
Accept-<span>Encoding:gzip, deflate, sdch
Accept-Language:zh-CN,zh;q=0.8<span>
Cache-Control:no-<span>cache
Connection:keep-<span>alive
Cookie:csrftoken=<span>z5H43ZwARx7AIJ82OEizBOWbsAQA2LPk
Host:127.0.0.1:8090<span>
Pragma:no-<span>cache
Upgrade-Insecure-Requests:1<span>
User-Agent:Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.89 Safari/537.36<span>
Name
login/
1 requests&ensp;❘&ensp;737&thinsp;B transferred&ensp;❘&ensp;Finish: 5&thinsp;ms&ensp;❘&ensp;DOMContentLoaded: 14&thinsp;ms&ensp;❘&ensp;Load: 14&thinsp;ms</span></span></span></span></span></span></span></span></span></span></pre>
</div>
<ul>
<li class="li1"><span class="s1"><span class="s1"><span class="s1"><span class="s1"><span class="s2">GET&nbsp;127.0.0.1:8090/login &nbsp;HTTP/1.1<span class="s3">：<span class="s4">GET<span class="s5">请求，请求服务器路径为 &nbsp;127.0.0.1:8090/login&nbsp;，协议为<span class="s4">1.1<span class="s5">；</span></span></span></span></span></span></span></span></span></span></li>
<li class="li1"><span class="s1"><span class="s2">Host:localhost<span class="s3">：<span class="s4">请求的主机名为<span class="s5">localhost<span class="s4">；</span></span></span></span></span></span></li>
<li class="li1"><span class="s1"><span class="s2">*User-Agent: Mozilla/5.0 (<strong>Windows NT 5.1</strong>; rv:5.0) Gecko/20100101<strong>&nbsp;Firefox/5.0</strong><span class="s3">：<span class="s4">与浏览器和<span class="s5">OS<span class="s4">相关的信息。有些网站会显示用户的系统版本和浏览器版本信息，这都是通过获取<span class="s5">User-Agent<span class="s4">头信息而来的；</span></span></span></span></span></span></span></span></li>
<li class="li1"><span class="s1">&nbsp;<span class="s1"><span class="s2">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8<span class="s3">：<span class="s4">告诉服务器，当前客户端可以接收的文档类型，其实这里包含了<span class="s5">*/*<span class="s4">，就表示什么都可以接收；</span></span></span></span></span></span></span></li>
<li class="li1"><span class="s1"><span class="s2">Accept-Language: zh-cn,zh;q=0.5<span class="s3">：<span class="s4">当前客户端支持的语言，可以在浏览器的工具<span class="s5"><span class="s4">选项中找到语言相关信息；</span></span></span></span></span></span></li>
<li class="li1"><span class="s1"><span class="s2">Accept-Encoding: gzip, deflate<span class="s3">：<span class="s4">支持的压缩格式。数据在网络上传递时，可能服务器会把数据压缩后再发送；</span></span></span></span></li>
<li class="li1"><span class="s1"><span class="s2">Accept-Charset: GB2312,utf-8;q=0.7,*;q=0.7<span class="s3">：<span class="s4">客户端支持的编码；</span></span></span></span></li>
<li class="li2"><span class="s5"><span class="s6">Connection: keep-alive<span class="s7">：<span class="s3">客户端支持的链接方式，保持一段时间链接，默认为<span class="s2">3000ms<span class="s3">；</span></span></span></span></span></span></li>
<li class="li2"><span class="s5"><span class="s6">Cookie: JSESSIONID=369766FDF6220F7803433C0B2DE36D98<span class="s7">：<span class="s3">因为不是第一次访问这个地址，所以会在请求中把上一次服务器响应中发送过来的<span class="s2">Cookie<span class="s3">在请求中一并发送去过；这个<span class="s2">Cookie<span class="s3">的名字为<span class="s2">JSESSIONID。</span></span></span></span></span></span></span></span></span></li>
</ul>
<h4 class="p1"><span class="s1">注意</span></h4>
<div class="cnblogs_code">
<pre><code><span>HTTP无状态：无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。从另一方面讲，打开一个服务器上的网页
和你之前打开这个服务器上的网页之间没有任何联系
如果你要实现一个购物车，需要借助于Cookie或Session或服务器端API（如NSAPI and<span> ISAPI）记录这些信息，请求服务器结算页面时同时将这些信息提交到服务器
当你登录到一个网站时，你的登录状态也是由Cookie或Session来&ldquo;记忆&rdquo;的，因为服务器并不知道你是否登录
优点：服务器不用为每个客户端连接分配内存来记忆大量状态，也不用在客户端失去连接时去清理内存，以更高效地去处理WEB业务
缺点：客户端的每次请求都需要携带相应参数，服务器需要处理这些参数

容易犯的误区：
1<span>、HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）
2、从HTTP/1.1起，默认都开启了Keep-<span>Alive，保持连接特性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输
HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接
3、Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间</span></span></span></span></pre>
</div>
<h3 class="p1"><span class="s1">2.2&nbsp;<span class="s2"><span class="s1">POST<span class="s2">请求</span></span></span></span></h3>
<p>(1). 数据不会出现在地址栏中<br />(2). 数据的大小没有上限<br />(3). 有请求体<br />(4). 请求体中如果存在中文，会使用URL编码！</p>
<div class="cnblogs_code">
<pre><code>username=%E5%BC%A0%E4%B8%89&amp;password=123</pre>
</div>
<p>为什么要进行URL编码：</p>
<div class="cnblogs_code">
<pre><code>我们都知道Http协议中参数的传输是"key=value"这种简直对形式的，如果要传多个参数就需要用&ldquo;&amp;&rdquo;符号对键值对进行分割。如"?name1=value1&amp;name2=value2"，这样在服务端在收到这种字符串的时候，会用&ldquo;&amp;&rdquo;分割出每一个参数，然后再用&ldquo;=<span>&rdquo;来分割出参数值。

 

针对&ldquo;name1=value1&amp;name2=<span>value2&rdquo;我们来说一下客户端到服务端的概念上解析过程: 
  上述字符串在计算机中用ASCII吗表示为： 
  6E616D6531 3D 76616C756531 26<span> 6E616D6532 3D 76616C756532。 
   6E616D6531：name1 
   3D：=<span> 
   76616C756531：value1 
   26：&amp;<span>
   6E616D6532：name2 
   3D：=<span> 
   76616C756532：value2 
   服务端在接收到该数据后就可以遍历该字节流，首先一个字节一个字节的吃，当吃到3D这字节后，服务端就知道前面吃得字节表示一个key，再想后吃，如果遇到26，说明从刚才吃的3D到26子节之间的是上一个key的value，以此类推就可以解析出客户端传过来的参数。

   现在有这样一个问题，如果我的参数值中就包含=或&amp;<span>这种特殊字符的时候该怎么办。 
比如说&ldquo;name1=value1&rdquo;,其中value1的值是&ldquo;va&amp;lu=e1&rdquo;字符串，那么实际在传输过程中就会变成这样&ldquo;name1=va&amp;lu=<span>e1&rdquo;。我们的本意是就只有一个键值对，但是服务端会解析成两个键值对，这样就产生了奇异。

如何解决上述问题带来的歧义呢？解决的办法就是对参数进行URL编码 
   URL编码只是简单的在特殊字符的各个字节前加上%，例如，我们对上述会产生奇异的字符进行URL编码后结果：&ldquo;name1=va%26lu%3D&rdquo;，这样服务端会把紧跟在&ldquo;%<span>&rdquo;后的字节当成普通的字节，就是不会把它当成各个参数或键值对的分隔符。</span></span></span></span></span></span></span></span></span></pre>
</div>
<p>&nbsp;</p>
<p>使用表单可以发POST请求，但表单默认是GET</p>
<div class="cnblogs_code">
<pre><code>&lt;form action="" method="post"&gt;<span>
  关键字：&lt;input type="text" name="keyword"/&gt;
  &lt;input type="submit" value="提交"/&gt;
&lt;/form&gt;</span></pre>
</div>
<p class="p1"><span class="s1">输入yuan<span class="s2"><span class="s1">后点击提交，查看请求内容如下：</span></span></span></p>
<div class="cnblogs_code">
<pre><code><span>Request Headers
Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Accept-Encoding:gzip, deflate
Accept-Language:zh-CN,zh;q=0.8
Cache-Control:no-cache
Connection:keep-alive
Content-Length:13
Content-Type:application/x-www-form-urlencoded
Cookie:csrftoken=z5H43ZwARx7AIJ82OEizBOWbsAQA2LPk
Host:127.0.0.1:8090
Origin:http://127.0.0.1:8090
Pragma:no-cache
Referer:http://127.0.0.1:8090/login/
Upgrade-Insecure-Requests:1
User-Agent:Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_1) 
           AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.89 Safari/537.36

Form Data
username:zhurui</span></pre>
</div>
<p class="p1"><span class="s1">POST<span class="s2">请求是可以有体的，而<span class="s1">GET<span class="s2">请求不能有请求体。</span></span></span></span></p>
<ul>
<li class="li1"><span class="s1"><span class="s2"><strong>Referer</strong><span class="s3">:&nbsp;http://localhost:8080/hello/index.jsp<span class="s4">：<span class="s5">请求来自哪个页面，例如你在百度上点击链接到了这里，那么<span class="s6">Referer:http://www.baidu.com<span class="s5">；如果你是在浏览器的地址栏中直接输入的地址，那么就没有<span class="s6">Referer<span class="s5">这个请求头了；</span></span></span></span></span></span></span></span></span></li>
<li class="li2"><span class="s1"><span class="s3">Content-Type: application/x-www-form-urlencoded<span class="s4">：<span class="s5">表单的数据类型，说明会使用<span class="s6">url<span class="s5">格式编码数据；<span class="s6">url<span class="s5">编码的数据都是以<span class="s6">&ldquo;%&rdquo;<span class="s5">为前缀，后面跟随两位的<span class="s6">16<span class="s5">进制。</span></span></span></span></span></span></span></span></span></span></span></span></li>
<li class="li3"><span class="s7"><span class="s6">Content-Length:13<span class="s5">：<span class="s8">请求体的长度，这里表示<span class="s9">13<span class="s8">个字节。</span></span></span></span></span></span></li>
<li class="li4"><span class="s1"><span class="s10">keyword=hello<span class="s3">：<span class="s6">请求体内容！<span class="s11">hello<span class="s6">是在表单中输入的数据，<span class="s11">keyword<span class="s6">是表单字段的名字。</span></span></span></span></span></span></span></span></li>
</ul>
<p><strong>referer应用：</strong></p>
<div class="cnblogs_code">
<pre><code><span>Referer请求头是比较有用的一个请求头，它可以用来做统计工作，也可以用来做防盗链。
统计工作：我公司网站在百度上做了广告，但不知道在百度上做广告对我们网站的访问量是否有影响，那么可以对每个请求中的Referer进行分析，如果Referer为百度的很多，那么说明用户都是通过百度找到我们公司网站的。
防盗链：我公司网站上有一个下载链接，而其他网站盗链了这个地址，例如在我网站上的index.html页面中有一个链接，点击即可下载JDK7.0，但有某个人的微博中盗链了这个资源，它也有一个链接指向我们网站的JDK7.0，也就是说登录它的微博，点击链接就可以从我网站上下载JDK7.0，这导致我们网站的广告没有看，但下载的却是我网站的资源。这时可以使用Referer进行防盗链，在资源被下载之前，我们对Referer进行判断，如果请求来自本网站，那么允许下载，如果非本网站，先跳转到本网站看广告，然后再允许下载。</span></pre>
</div>
<p>&nbsp;</p>
<h2 class="p1"><span class="s1"><strong>三、</strong><span class="s2"><strong>响应协议</strong></span></span></h2>
<h3 class="p2"><span class="s3">3.1&nbsp;<span class="s2">响应内容</span></span></h3>
<p class="p3"><span class="s2">响应协议的格式如下：</span></p>
<div class="cnblogs_code">
<pre><code>响应首行；
响应头信息；
空行；
响应体。</pre>
</div>
<p class="p1"><span class="s1">响应内容是由服务器发送给浏览器的内容，浏览器会根据响应内容来显示。遇到&lt;img src=''&gt;会开一个新的线程加载，所以有时图片多的话，内容会先显示出来，然后图片才一张张加载出来。</span></p>
<div class="cnblogs_code">
<pre><code>Request URL:http://127.0.0.1:8090/login/
Request Method:GET
Status Code:200 OK
Remote Address:127.0.0.1:8090
Response Headers
view source
Content-Type:text/html; charset=utf-8
Date:Wed, 26 Oct 2016 06:48:50 GMT
Server:WSGIServer/0.2 CPython/3.5.2
X-Frame-Options:SAMEORIGIN

&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;form action="/login/" method="post"&gt;
  用户名：&lt;input type="text" name="username"/&gt;
  &lt;input type="submit" value="提交"/&gt;
&lt;/form&gt;    
&lt;/body&gt;
&lt;/html&gt;</pre>
</div>
<ul>
<li class="li1"><span class="s1"><span class="s2">HTTP/1.1 200 OK<span class="s3">：<span class="s4">响应协议为<span class="s5">HTTP1.1<span class="s4">，状态码为<span class="s5">200<span class="s4">，表示请求成功，<span class="s5">OK<span class="s4">是对状态码的解释；</span></span></span></span></span></span></span></span></span></span></li>
<li class="li2">Server:WSGIServer/0.2 CPython/3.5.2：<span class="s8">服务器的版本信息；</span></li>
<li class="li2"><span class="s6"><span class="s4">Content-Type: text/html;charset=UTF-8<span class="s7">：<span class="s8">响应体使用的编码为<span class="s9">UTF-8<span class="s8">；</span></span></span></span></span></span></li>
<li class="li3"><span class="s6"><span class="s4">Content-Length: 724<span class="s7">：<span class="s8">响应体为<span class="s9">724<span class="s8">字节；</span></span></span></span></span></span></li>
<li class="li3"><span class="s6"><span class="s4">Set-Cookie: JSESSIONID=C97E2B4C55553EAB46079A4F263435A4; Path=/hello<span class="s7">：<span class="s8">响应给客户端的<span class="s9">Cookie<span class="s8">；</span></span></span></span></span></span></li>
<li class="li3"><span class="s6"><span class="s4">Date: Wed, 25 Sep 2012 04:15:03 GMT<span class="s7">：<span class="s8">响应的时间，这可能会有<span class="s9">8<span class="s8">小时的时区差；</span></span></span></span></span></span></li>
</ul>
<h3 class="p1"><span class="s1">3.2、<span class="s2"><span class="s3">状态<span class="s2">码</span></span></span></span></h3>
<p class="p2"><span class="s2">响应头对浏览器来说很重要，它说明了响应的真正含义。例如<span class="s4">200<span class="s2">表示响应成功了，<span class="s4">302<span class="s2">表示重定向，这说明浏览器需要再发一个新的请求。</span></span></span></span></span></p>
<ul>
<li class="li3"><span class="s5"><span class="s4">200<span class="s2">：请求成功，浏览器会把响应体内容（通常是<span class="s4">html<span class="s2">）显示在浏览器中；</span></span></span></span></span></li>
<li class="li3"><span class="s5"><span class="s4">404<span class="s2">：请求的资源没有找到，说明客户端错误的请求了不存在的资源；</span></span></span></li>
<li class="li3"><span class="s5"><span class="s4">500<span class="s2">：请求资源找到了，但服务器内部出现了错误；</span></span></span></li>
<li class="li3"><span class="s5"><span class="s4">302<span class="s2">：重定向，当响应码为<span class="s4">302<span class="s2">时，表示服务器要求浏览器重新再发一个请求，服务器会发送一个响应头<span class="s4">Location<span class="s2">，它指定了新请求的<span class="s4">URL<span class="s2">地址；</span></span></span></span></span></span></span></span></span></li>
<li class="li1"><span class="s1"><span class="s1"><span class="s1"><span class="s2">304<span class="s3">：</span></span></span></span></span></li>
</ul>
<div class="cnblogs_code">
<pre><code> 当用户第一次请求index.html时，服务器会添加一个名为Last-<span>Modified响应头，这个头说明了
  index.html的最后修改时间，浏览器会把index.html内容，以及最后响应时间缓存下来。当用户第
  二次请求index.html时，在请求中包含一个名为If-Modified-<span>Since请求头，它的值就是第一次请
  求时服务器通过Last-<span>Modified响应头发送给浏览器的值，即index.html最后的修改时间，
  If-Modified-<span>Since请求头就是在告诉服务器，我这里浏览器缓存的index.html最后修改时间是这个,
  您看看现在的index.html最后修改时间是不是这个，如果还是，那么您就不用再响应这个index.html
  内容了，我会把缓存的内容直接显示出来。而服务器端会获取If-Modified-<span>Since值，与index.html
  的当前最后修改时间比对，如果相同，服务器会发响应码304，表示index.html与浏览器上次缓存的相
  同，无需再次发送，浏览器可以显示自己的缓存页面，如果比对不同，那么说明index.html已经做了修
  改，服务器会响应200。</span></span></span></span></span></pre>
</div>
<h3 class="p1"><span class="s1">3.3&nbsp;<span class="s2">其他响应头</span></span></h3>
<p class="p2"><span class="s2">告诉浏览器不要缓存的响应头：</span></p>
<ul>
<li class="li3"><span class="s3"><span class="s2">Expires: -1<span class="s4">；</span></span></span></li>
<li class="li3"><span class="s3"><span class="s2">Cache-Control: no-cache<span class="s4">；</span></span></span></li>
<li class="li3"><span class="s3"><span class="s2">Pragma: no-cache<span class="s4">；</span></span></span></li>
</ul>
<p class="p5"><span class="s4">自动刷新响应头，浏览器会在<span class="s2">3<span class="s4">秒之后请求<span class="s2">http://www.baidu.com<span class="s4">：</span></span></span></span></span></p>
<ul>
<li class="li3"><span class="s3">Refresh: 3;url=http://www.baidu.com<span class="s2">&nbsp;</span></span></li>
</ul>
<h3 class="p7"><span class="s2">3.4&nbsp;<span class="s4"><span class="s2">HTML<span class="s4">中指定响应头</span></span></span></span></h3>
<p class="p8"><span class="s4">在<span class="s2">HTMl<span class="s4">页面中可以使用<span class="s2">&lt;meta http-equiv="" content=""&gt;<span class="s4">来指定响应头，例如在<span class="s2">index.html<span class="s4">页面中给出<span class="s2">&lt;meta http-equiv="Refresh" content="3;url=http://www.baidu.com"&gt;<span class="s4">，表示浏览器只会显示<span class="s2">index.html<span class="s4">页面<span class="s2">3<span class="s4">秒，然后自动跳转到<span class="s2">http://www.baidu.com.</span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<div class="clear">&nbsp;</div>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>