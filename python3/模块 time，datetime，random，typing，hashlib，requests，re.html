<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修模块 time，datetime，random，typing，hashlib，requests，re' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>模块 time，datetime，random，typing，hashlib，requests，re</center></div><div class='banquan'>原文出处:本文由博客园博主SetCreed提供。<br/>
原文连接:https://www.cnblogs.com/setcreed/p/11628032.html</div><br>
    <div class="toc">
    <p class="toc-title">目录</p>
    <div class="toc-list">
        <ul>
        <li><a href="#包">包</a><ul>
        <li><a href="#什么是包">什么是包</a></li>
        <li><a href="#为什么要包">为什么要包</a></li>
        <li><a href="#包的介绍">1. 包的介绍</a></li>
        <li><a href="#绝对导入和相对导入">2. 绝对导入和相对导入</a><ul>
        <li><a href="#绝对导入">- 绝对导入</a></li>
        <li><a href="#相对导入">- 相对导入</a></li>
        </ul></li>
        </ul></li>
        <li><a href="#time模块">time模块</a><ul>
        <li><a href="#时间戳">时间戳</a></li>
        <li><a href="#格式化时间">格式化时间</a></li>
        <li><a href="#结构化时间">结构化时间</a></li>
        <li><a href="#sleep">sleep</a></li>
        </ul></li>
        <li><a href="#datetime模块">datetime模块</a></li>
        <li><a href="#random模块">random模块</a></li>
        <li><a href="#typing模块">typing模块</a><ul>
        <li><a href="#typing常用类型">typing常用类型</a></li>
        </ul></li>
        <li><a href="#hashlib模块">hashlib模块</a><ul>
        <li><a href="#hash是什么">hash是什么</a></li>
        <li><a href="#撞库破解hash算法">撞库破解hash算法</a></li>
        <li><a href="#hmac模块">hmac模块</a></li>
        </ul></li>
        <li><a href="#requests模块">requests模块</a></li>
        <li><a href="#re模块">re模块</a></li>
        </ul>
    </div>
</div>
<h1 id="包">包</h1>
<h2 id="什么是包">什么是包</h2>
<p>包是模块的一种形式，就是含有<code>.py</code>文件的文件夹</p>
<h2 id="为什么要包">为什么要包</h2>
<p>刚开始模块只有几个功能，未来模块扩展功能，模块名和用法应该最好不要去修改，但这是对于用户来说是方便了，对于开发者来说，模块管理起来很麻烦，所以就用包来扩展模块的功能。</p>
<h2 id="包的介绍">1. 包的介绍</h2>
<ol>
<li>本质就是模块，实际上就是一个含有<code>__init__.py</code>文件的文件夹</li>
<li>导包就是导入<code>__init__.py</code>文件</li>
<li>包一定是被当作模块文件导入，模块文件的搜索路径以执行文件的路径为准</li>
</ol>
<h2 id="绝对导入和相对导入">2. 绝对导入和相对导入</h2>
<p>只能在包中使用</p>
<h3 id="绝对导入">- 绝对导入</h3>
<p>from 包名.模块名 import 方法名</p>
<h3 id="相对导入">- 相对导入</h3>
<ul>
<li>.代表当前被导入文件所在的文件夹</li>
<li>..代表当前被导入文件所在的文件夹的上一级</li>
<li>...代表当前被导入文件所在的文件夹的上一级的上一级</li>
</ul>
<h1 id="time模块">time模块</h1>
<h2 id="时间戳">时间戳</h2>
<pre><code><code>import time

print(time.time())   # 从1970年1月1日00:00:00开始计算到现在的秒数</code></pre>
<h2 id="格式化时间">格式化时间</h2>
<pre><code><code>import time 
print(time.strftime(&#39;%Y-%m-%d %H:%M:%S&#39;))  # 2019-09-28 17:15:47

print(time.strftime(&#39;%Y-%m-%d %X&#39;))   # 2019-09-28 17:16:50</code></pre>
<h2 id="结构化时间">结构化时间</h2>
<pre><code><code>import time
print(time.localtime())   # time.struct_time(tm_year=2019, tm_mon=9, tm_mday=28, tm_hour=17, tm_min=18, tm_sec=11, tm_wday=5, tm_yday=271, tm_isdst=0)</code></pre>
<pre><code><code># 结构化基础时间
import time
print(time.localtime(0))   # time.struct_time(tm_year=1970, tm_mon=1, tm_mday=1, tm_hour=8, tm_min=0, tm_sec=0, tm_wday=3, tm_yday=1, tm_isdst=0)</code></pre>
<h2 id="sleep">sleep</h2>
<pre><code><code>import time 

start = time.time()
time.sleep(2)
end = time.time()
print(f&#39;暂停了{end - start}秒&#39;)  # 暂停了2.000108003616333秒</code></pre>
<h1 id="datetime模块">datetime模块</h1>
<pre><code><code>import datetime

# 输出当前时间
print(datetime.datetime.now())
# 2019-09-28 17:25:24.551237


# 加时间
now = datetime.datetime.now()
print(now + datetime.timedelta(days=3))
# 2019-10-01 17:28:24.710093


print(now.replace(year=1940))
# 1940-09-28 17:29:45.066855</code></pre>
<h1 id="random模块">random模块</h1>
<pre><code><code>import random

# 0-1随机数
print(random.random())


# 1-100随机整数
print(random.randint(1,100))

# 1-3之间随机整数
print(random.randrange(1, 3))

# 打乱lt的顺序
lt = [1,2,4,60]
random.shuffle(lt)   # [4, 1, 60, 2]
print(lt)

# 随机选择lt中一个元素
print(random.choice(lt))

# random.seed
import random

random.seed(4)   # 给一个随机数种子
print(random.random())   # 只第一次随机生成，之后生成的数字就一样了
print(random.random())

# 如果不自定义种子，则种子按照当前的时间来</code></pre>
<h1 id="typing模块">typing模块</h1>
<p>与函数联用，控制函数参数的数据类型，提供了基础数据类型之外的数据类型</p>
<pre><code><code>from typing import Iterable

def func(x:int, lt:list) -&gt; list:
    return [1,2,3]

func(10,[12,3])</code></pre>
<h2 id="typing常用类型">typing常用类型</h2>
<ul>
<li>int、long、float: 整型、长整形、浮点型</li>
<li>bool、str: 布尔型、字符串类型</li>
<li>List、 Tuple、 Dict、 Set:列表、元组、字典、集合</li>
<li>Iterable、Iterator:可迭代类型、迭代器类型</li>
<li>Generator：生成器类型</li>
</ul>
<h1 id="hashlib模块">hashlib模块</h1>
<h2 id="hash是什么">hash是什么</h2>
<p>hash是一种算法（Python3.版本里使用hashlib模块代替了md5模块和sha模块，主要提供 SHA1、SHA224、SHA256、SHA384、SHA512、MD5 算法），该算法接受传入的内容，经过运算得到一串hash值。</p>
<pre><code><code>import hashlib

m = hashlib.md5()
m.update(b&#39;sayhello&#39;)   # 981fe96ed23ad8b9554cfeea38cd334a
print(m.hexdigest())   # 对于不同的字符而言，永不重复</code></pre>
<h2 id="撞库破解hash算法">撞库破解hash算法</h2>
<pre><code><code>pwd_list = [
    &#39;hash3714&#39;,
    &#39;hash1313&#39;,
    &#39;hash94139413&#39;,
    &#39;hash123456&#39;,
    &#39;123456hash&#39;,
    &#39;h123ash&#39;,
]

hash_pwd = &#39;0562b36c3c5a3925dbe3c4d32a4f2ba2&#39;

for pwd in pwd_list:
    m = hashlib.md5()
    m.update(pwd.encode(&#39;utf-8&#39;))
    res = m.hexdigest()
    if res in hash_pwd:
        print(f&#39;获取密码成功：{pwd}&#39;)  # 获取密码成功：hash123456</code></pre>
<h2 id="hmac模块">hmac模块</h2>
<p>密钥 加盐</p>
<pre><code><code>import hmac

m = hmac.new(b&#39;haha&#39;)
m.update(b&#39;hash123456&#39;)
print(m.hexdigest())    # 24bb8daab11e526fc9b8178e51bc2ae7


m = m = hmac.new(b&#39;sadness&#39;)
m.update(b&#39;hash123456&#39;)
print(m.hexdigest())   # df405ffd019d6d3cd9a190fcab33aca5</code></pre>
<h1 id="requests模块">requests模块</h1>
<p>可以用来爬取数据，模拟浏览器对url发送请求，拿到数据</p>
<pre><code><code>import requests

response = requests.get(&#39;https://www.baidu.com&#39;)
print(response.text)</code></pre>
<h1 id="re模块">re模块</h1>
<p>去字符串找符合某种特点的字符串</p>
<p>re模块的基本使用：</p>
<pre><code><code>import re  # 第一步，要引入re模块
a = re.findall(&quot;匹配规则&quot;, &quot;这个字符串是否有匹配规则的字符&quot;)  # 第二步，调用模块函数
print(a)  # 以列表形式返回匹配到的字符串</code></pre>
<p>^字符</p>
<p>以……开头</p>
<pre><code><code>s = &#39;abcdabc&#39;

res = re.findall(&#39;^abc&#39;,s)  
print(res)                  # [&#39;abc&#39;]
res = re.findall(&#39;^bc&#39;,s)
print(res)                  # []</code></pre>
<p>$ 字符</p>
<p>以……结尾</p>
<pre><code><code>s = &#39;abcdabc&#39;

res = re.findall(&#39;bc$&#39;,s)
print(res)             # [&#39;bc&#39;]</code></pre>
<p>. : 任意字符</p>
<pre><code><code>s = &#39;abc是dabc&#39;

res = re.findall(&#39;abc.&#39;,s)
print(res)   # [&#39;abc是&#39;]</code></pre>
<p>\d：数字</p>
<pre><code><code>s = &#39;asdhg213214h4c&#39;

res = re.findall(&#39;\d&#39;,s)
print(res)   # [&#39;2&#39;, &#39;1&#39;, &#39;3&#39;, &#39;2&#39;, &#39;1&#39;, &#39;4&#39;, &#39;4&#39;]</code></pre>
<p>\D: 非数字</p>
<pre><code><code>s = &#39;asdhg2132 -14h4c&#39;

res = re.findall(&#39;\D&#39;,s)
print(res)   # [&#39;a&#39;, &#39;s&#39;, &#39;d&#39;, &#39;h&#39;, &#39;g&#39;, &#39; &#39;, &#39;-&#39;, &#39;h&#39;, &#39;c&#39;]</code></pre>
<p>\w: 非空, 数字、字母、下划线</p>
<pre><code><code>s = &#39;asdhg213214h4c&#39;

res = re.findall(&#39;\w&#39;,s)
print(res)   # [&#39;a&#39;, &#39;s&#39;, &#39;d&#39;, &#39;h&#39;, &#39;g&#39;, &#39;2&#39;, &#39;1&#39;, &#39;3&#39;, &#39;2&#39;, &#39;1&#39;, &#39;4&#39;, &#39;h&#39;, &#39;4&#39;, &#39;c&#39;]</code></pre>
<p>\W: 空，除了数字、字母、下划线外</p>
<pre><code><code>s = &#39;as;g:21?32    -14h4c\n&#39;

res = re.findall(&#39;\W&#39;,s)
print(res)  # [&#39;;&#39;, &#39;:&#39;, &#39;?&#39;, &#39; &#39;, &#39; &#39;, &#39; &#39;, &#39; &#39;, &#39;-&#39;, &#39;\n&#39;]</code></pre>
<p>\s: 空</p>
<pre><code><code>s = &#39;asdhg2132 14h4c&#39;

res = re.findall(&#39;\s&#39;,s)
print(res)    # [&#39; &#39;]</code></pre>
<p>\S : 不空</p>
<pre><code><code>s = &#39;asdhg2132    -14h4c\n&#39;

res = re.findall(&#39;\S&#39;,s)
print(res)  # [&#39;a&#39;, &#39;s&#39;, &#39;d&#39;, &#39;h&#39;, &#39;g&#39;, &#39;2&#39;, &#39;1&#39;, &#39;3&#39;, &#39;2&#39;, &#39;-&#39;, &#39;1&#39;, &#39;4&#39;, &#39;h&#39;, &#39;4&#39;, &#39;c&#39;]</code></pre>
<p><code>+</code>: 前面的1个字符至少1个</p>
<pre><code><code>s = &#39;abcdddd abcd abc ab&#39;
print(re.findall(&#39;abc+&#39;, s))</code></pre>
<p>?: 前面的1个字符0-1个</p>
<pre><code><code>s = &#39;abcdddd abcd abc ab a&#39;
print(re.findall(&#39;abc?&#39;, s))  # [&#39;abc&#39;, &#39;abc&#39;, &#39;abc&#39;, &#39;ab&#39;]</code></pre>
<p><code>*</code>: 前面的1个字符至少0个</p>
<pre><code><code>s = &#39;abcdddd abcd abc ab a&#39;
print(re.findall(&#39;abcd*&#39;, s))   # [&#39;abcdddd&#39;, &#39;abcd&#39;, &#39;abc&#39;]</code></pre>
<pre><code><code>s = &#39;abc bbc cbc dbc&#39;
print(re.findall(&#39;[abc]bc&#39;, s))  # [&#39;abc&#39;, &#39;bbc&#39;, &#39;cbc&#39;]</code></pre>
<p>[^] : 中括号的都不可以</p>
<pre><code><code>s = &#39;abc bbc cbc dbc&#39;
print(re.findall(&#39;[^abc]bc&#39;, s))  # [&#39;dbc&#39;]</code></pre>
<p>| : 或</p>
<pre><code><code>s = &#39;abc bbc dbc&#39;
print(re.findall(&#39;abc|bbc&#39;, s))  # [&#39;abc&#39;, &#39;bbc&#39;]</code></pre>
<p>{2} : 前面的字符2个</p>
<pre><code><code>s = &#39;abcccab abcc&#39;
print(re.findall(&#39;abc{2}&#39;, s))   # [&#39;abcc&#39;, &#39;abcc&#39;] 
print(re.findall(&#39;abc{0,2}&#39;, s))  # [&#39;abcc&#39;, &#39;ab&#39;, &#39;abcc&#39;]</code></pre>
<p>贪婪模式</p>
<p>(任意字符) * (0-无穷个)</p>
<pre><code><code>s = &#39;abcdefgaaaaaaaaaaag&#39;
print(re.findall(&#39;a.*g&#39;,s))
# [&#39;abcdefgaaaaaaaaaaag&#39;]</code></pre>
<p>非贪婪模式</p>
<p>(任意字符) * (0-无穷个) ？</p>
<pre><code><code>s = &#39;abcdefgbbbbbbbg&#39;
print(re.findall(&#39;a.*?g&#39;,s))   # [&#39;abcdefg&#39;]</code></pre>
<p>了解：特殊构造</p>
<pre><code><code># a(?=\d) ：a后面是数字，但是不要数字，不消耗字符串内容
s = &#39;a123 aaaa a234 abc&#39;
print(re.findall(&#39;a(?=\d)&#39;, s))  #[&#39;a&#39;, &#39;a&#39;]

print(re.findall(&#39;a(?=\w)&#39;, s))  #[&#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;a&#39;]</code></pre>
<p>compile</p>
<pre><code><code># 早期，re.findall不能传模式，只能用compile
s = &#39;#@#@#@nickchen121@163.com$$$$////nick@qq.com$$#$#$[]]2287273393@162.com@$2423423lksdlfj#&#39;
email_pattern = re.compile(&#39;\w+@\w+.com&#39;)
phone_patter = re.compile(&#39;\d{13}&#39;)
print(re.findall(email_pattern, s))</code></pre>
<p>match : 从开头找一个，找的到就不找了，找不到就报错</p>
<pre><code><code>s = &#39;abcd abcddd abc&#39;
res = re.match(&#39;abcd*&#39;, s)
print(res.group())  # abcd</code></pre>
<p>search： 从字符串找一个，就不找了</p>
<pre><code><code>s = &#39;abcd abcddd abc&#39;
res = re.search(&#39;abcd*&#39;, s)
print(res.group())  # abcd</code></pre>
<p>split 切分</p>
<pre><code><code>s = &#39;adad213114242wjdnadjia1241423daj&#39;
print(re.split(&#39;\d+&#39;, s))  # [&#39;adad&#39;, &#39;wjdnadjia&#39;, &#39;daj&#39;]</code></pre>
<p>sub 替换</p>
<pre><code><code>s = &#39;adad213114242wjdnadjia1241423daj&#39;
print(re.sub(&#39;\d+&#39;, &#39;  &#39;, s))  # adad  wjdnadjia  daj</code></pre>
<p>subn 替换，比sub多了 替换了多少次</p>
<pre><code><code>s = &#39;adad213114242wjdnadjia1241423daj&#39;
print(re.subn(&#39;\d+&#39;, &#39;  &#39;, s))   # (&#39;adad  wjdnadjia  daj&#39;, 2)</code></pre>
<p>补充: re.S</p>
<pre><code><code>s = &#39;&#39;&#39;abc
abcabc*abc
&#39;&#39;&#39;

print(re.findall(&#39;abc.abc&#39;,s ))  # [&#39;abc*abc&#39;]   原本.不匹配换行

print(re.findall(&#39;abc.abc&#39;,s ,re.S))  # [&#39;abc\nabc&#39;, &#39;abc*abc&#39;]</code></pre>
<p>分组： 只要括号里的</p>
<pre><code><code>s = &#39;abc abcd abcddd&#39;
print(re.findall(&#39;a(.)c(d)&#39;, s))  # [(&#39;b&#39;, &#39;d&#39;), (&#39;b&#39;, &#39;d&#39;)]</code></pre>
<p>有名分组</p>
<pre><code><code>s = &#39;abc abcd abcddd&#39;
print(re.search(&#39;a(?P&lt;name1&gt;.)c(?P&lt;name2&gt;d)&#39;, s).groupdict()) # {&#39;name1&#39;: &#39;b&#39;, &#39;name2&#39;: &#39;d&#39;}</code></pre>
<p>超高级用法</p>
<pre><code><code>s = &#39;abc123abc123&#39;  # c123a
print(re.sub(&#39;c(\d+)a&#39;, &#39; &#39;, s))
print(re.sub(&#39;c(?P&lt;name1&gt;\d+)a&#39;, &#39; \g&lt;name1&gt; &#39;, s))  # \g&lt;name1&gt;这个东西不能替换掉

# ab bc123
# ab 123 bc123</code></pre>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>