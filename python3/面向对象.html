<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修面向对象' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>面向对象</center></div><div class='banquan'>原文出处:本文由博客园博主corei5tj提供。<br/>
原文连接:https://www.cnblogs.com/tangjian219/p/11341951.html</div><br>
    <h1 id="面向对象">面向对象</h1>
<h3 id="面向对象编程是一类相似功能函数的集合使你的代码更清晰化更合理化">面向对象编程：是一类相似功能函数的集合,使你的代码更清晰化，更合理化</h3>
<h2 id="面向对象的结构第一部分静态属性-属性-静态变量-静态字段第二部分方法-函数-动态属性">1.面向对象的结构（第一部分：静态属性 属性 静态变量 静态字段）/（第二部分：方法 函数 动态属性)</h2>
<pre><code><code>class Stu:
    study = &quot;学习&quot;#静态属性
    exam = &quot;考试&quot;#静态属性

    def work(self):#动态属性
        print(&quot;每天上课&quot;)
    def homework(self):
        print(&quot;写作业&quot;)
class是类的关键字，即为定义一个类
Stu为类名  使用大驼峰命名风格 首字母大写</code></pre>
<h2 id="类名操作静态属性">2.类名操作静态属性</h2>
<pre><code><code>1查看类中的内容：.__dict__ 类名.__dict__
class Stu:
    study = &quot;学习&quot;#静态属性
    exam = &quot;考试&quot;#静态属性

    def work(self):#动态属性
        print(&quot;每天上课&quot;)
    def homework(self):
        print(&quot;写作业&quot;)
print(Stu.__dict__)
#{&#39;__module__&#39;: &#39;__main__&#39;, &#39;study&#39;: &#39;学习&#39;, &#39;exam&#39;: &#39;考试&#39;, &#39;work&#39;: &lt;function Stu.work at 0x000001280185CBF8&gt;, &#39;homework&#39;: &lt;function Stu.homework at 0x000001280185CC80&gt;, &#39;__dict__&#39;: &lt;attribute &#39;__dict__&#39; of &#39;Stu&#39; objects&gt;, &#39;__weakref__&#39;: &lt;attribute &#39;__weakref__&#39; of &#39;Stu&#39; objects&gt;, &#39;__doc__&#39;: None}

2.万能的点.
class Stu:
    study = &quot;学习&quot;#静态属性
    exam = &quot;考试&quot;#静态属性

    def work(self):#动态属性
        print(&quot;每天上课&quot;)
    def homework(self):
        print(&quot;写作业&quot;)
print(Stu.__dict__)
查
print(Stu.study)
print(Stu.exam)

增
Stu.close = &quot;校服&quot;
print(Stu.close)

删
del Stu.close
print(Stu.__dict__)

改
Stu.exam = &quot;不想考试&quot;
print(Stu.exam)</code></pre>
<h2 id="类名操作动态方法">3.类名操作动态方法</h2>
<pre><code><code>class Hun:
    mind = &quot;有点思想&quot;
    dic = {}
    l1 = []
    def work(self):
        print(&quot;人类会工作&quot;)
    def too(self):
        print(&quot;人类会使用工具&quot;)
hun.work(11)#11为参数，work中的self需要接受一个参数</code></pre>
<h2 id="从对象的角度研究类">4.从对象的角度研究类</h2>
<pre><code><code>类名+()就是一个实例化过程 就会实例化成一个对象
class Human:
    mind=&quot;有思想&quot;
    language = &quot;使用语言&quot;
    def __init__(self,name,sex,age,hobby):
   #self就是类中方法的第一个位置参数，self 和obj指向的同一内存地址 name,sex,age,hobby就是self封装的四个属性
        self.姓名=name
        self.性别 = sex
        self.年龄 = age
        self.爱好 = hobby
        print(self)#&lt;__main__.human object at 0x00000258965EDC18&gt;
        #self 和obj指向的同一内存地址

obj = Human(&quot;barry&quot;,&quot;男&quot;,18,&quot;运动&quot;)
obj.职业 = &quot;it&quot;#增
obj.性别 = &quot;女&quot;#改
del obj.性别   #删
print(obj.年龄)#查
print(obj.__dict__)
print(obj)#&lt;__main__.Human object at 0x00000258965EDC18&gt;
1.在内存中开辟了一个对象空间
2.自动执行类中的__init__方法，并将这个对象空间（内存地址）传给了__init__方法的第一个位置参数self。
3.在__init__ 方法中通过self给对象空间添加属性

一个类实例化多个对象
class Human:
    mind=&quot;有思想&quot;
    language = &quot;使用语言&quot;
    def __init__(self,name,sex,age,hobby):
        self.姓名=name
        self.性别 = sex
        self.年龄 = age
        self.爱好 = hobby
obj1 = Human(&#39;小胖&#39;,&#39;男&#39;,20,&#39;美女&#39;)
obj2 = Human(&#39;相爷&#39;,&#39;男&#39;,22,&#39;肥女&#39;)
print(obj1.__dict__)
print(obj2.__dict__)
#{&#39;姓名&#39;: &#39;小胖&#39;, &#39;性别&#39;: &#39;男&#39;, &#39;年龄&#39;: 20, &#39;爱好&#39;: &#39;美女&#39;}
 {&#39;姓名&#39;: &#39;相爷&#39;, &#39;性别&#39;: &#39;男&#39;, &#39;年龄&#39;: 22, &#39;爱好&#39;: &#39;肥女&#39;}</code></pre>
<h2 id="继承">继承</h2>
<pre><code><code>继承的有点也是显而易见的：
1，增加了类的耦合性（耦合性不宜多，宜精）。
2，减少了重复代码。
3，使得代码更加规范化，合理化

# 单继承
class People:
    mind = &quot;有思想的&quot;
    def __init__(self,name,age):
        self.name = name
        self.age = age
class Animal(People):
    mind = &quot;无脑的&quot;

People为父类,基类,超类，Animal为子类,派生类
obj = People(&quot;八戒&quot;,36)
obj1 = Animal(&quot;八戒&quot;,36)
实例化对象时必须执行__init__方法,类中没有，从父类找，父类没有，从object类中找。
先要执行自己类中的方法，自己类没有才能执行父类中的方法
print(obj.mind)
print(obj1.mind)


# 同时执行类和父类的方法
# 方法一
class Ainmal:
    def __init__(self,name,age,sex):
        self.name = name
        self.age = age
        self.sex = sex

class People:
    def __init__(self,name,age,sex,hobby): #父类方法重构 增加hobby是为了区别人类和动物的区别，但还要用之前人和动物的共同属性，在原来的基础上增加hobby
        Ainmal.__init__(self,name,age,sex) #调用Ainmal中的__init__
        self.hobby = hobby                 #添加hobby
obj = Ainmal(&quot;八戒&quot;,36,&quot;男&quot;)
obj1 = People(&quot;八戒&quot;,36,&quot;男&quot;,&quot;女&quot;)
print(obj.__dict__)
{&#39;name&#39;: &#39;八戒&#39;, &#39;age&#39;: 36, &#39;sex&#39;: &#39;男&#39;}
print(obj1.__dict__)
{&#39;name&#39;: &#39;八戒&#39;, &#39;age&#39;: 36, &#39;sex&#39;: &#39;男&#39;, &#39;hobby&#39;: &#39;女&#39;}


# 方法二
class Ainmal:
    def __init__(self,name,age,sex):
        self.name = name
        self.age = age
        self.sex = sex

class People(Ainmal):
    def __init__(self,name,age,sex,hobby):
        super(People,self).__init__(name,age,sex) # 完整版
        super().__init__(name,age,sex)            # 简写版
        self.hobby = hobby

obj = People(&quot;八戒&quot;,36,&quot;男&quot;,&quot;女&quot;)
print(obj.__dict__)
{&#39;name&#39;: &#39;八戒&#39;, &#39;age&#39;: 36, &#39;sex&#39;: &#39;男&#39;, &#39;hobby&#39;: &#39;女&#39;}


class Ainmal:
    def __init__(self, name, age, sex):
        self.name = name
        self.age = age
        self.sex = sex

    def eat(self):
        print(&quot;吃饭&quot;)
class People(Ainmal):
    def __init__(self, name, age, sex, hobby):
        super(People, self).__init__(name, age, sex)  # 完整版
        super().__init__(name, age, sex)  # 简写版
        self.hobby = hobby

    def eat(self):
        super().eat()   #调用父类中的方法
        print(f&quot;{self.name}吃饭&quot;)
obj = People(&quot;八戒&quot;, 36, &quot;男&quot;, &quot;女&quot;)
print(obj.__dict__)
obj.eat()
# 吃饭
# 八戒吃饭


# 单继承练习
# 第一题
class Base:
    def __init__(self, num):
        self.num = num
    def func1(self):
        print(self.num)

class Foo(Base):
    pass
obj = Foo(123)
obj.func1()
&quot;&quot;&quot;
先在本类中找 Foo为本类
1.obj = Foo(123)实例化对象，自动执行__init__方法，此时self = obj,num = 123
2.执行obj.func1()，首先在Foo的类中找func1，Foo中没有，到父类中找func1，执行func1 ，打印123
&quot;&quot;&quot;

# 第二题
class Base:
    def __init__(self, num):
        self.num = num
    def func1(self):
        print(self.num)
class Foo(Base):
    def func1(self):
        print(&quot;Foo. func1&quot;, self.num)
obj = Foo(123)
obj.func1()
&quot;&quot;&quot;
先在本类中找 Foo为本类
1.obj = Foo(123)实例化对象，自动执行__init__方法，此时self = obj,num = 123
2.执行obj.func1()，首先在Foo的类中找func1，Foo有，则执行func1 ，打印   Foo. func1 123
&quot;&quot;&quot;

# 第三题
class Base:
    def __init__(self, num):
        self.num = num
    def func1(self):
        print(self.num)
        self.func2()
    def func2(self):
        print(&quot;Base.func2&quot;)
class Foo(Base):
    def func2(self):
        print(&quot;Foo.func2&quot;)
obj = Foo(123)
obj.func1()
&quot;&quot;&quot;
先在本类中找 Foo为本类
1.obj = Foo(123)实例化对象，自动执行__init__方法，此时self = obj,num = 123
2.执行obj.func1()，首先在Foo的类中找func1，Foo中没有，去父类中找func1，父类中有，则执行func1 ，打印123
3.继续执行func2 也是先去Foo中找func2 找到则执行，找不到则在父类中继续找 结果 123  Foo.func2
&quot;&quot;&quot;

# 第四题
class Base:
    def __init__(self, num):
        self.num = num
    def func1(self):
        print(self.num)
        self.func2()
    def func2(self):
        print(111, self.num)
class Foo(Base):
    def func2(self):
        print(222, self.num)
lst = [Base(1), Base(2), Foo(3)]
for obj in lst:
    obj.func2()
&quot;&quot;&quot;
1.Base(1), Base(2), Foo(3)实例化，num分别为1，2，3
2.循环列表 1.Base(1)在执行Base(1)中的func2中内容 打印111 1  2.Base(2)中的func2中内容 打印111 2  3.执行Foo(3)在Foo中内容 222 3
&quot;&quot;&quot;

多继承

在python2x版本中存在两种类.：
　　⼀个叫经典类. 在python2.2之前. ⼀直使⽤的是经典类. 经典类在基类的根如果什么都不写.
　　⼀个叫新式类. 在python2.2之后出现了新式类. 新式类的特点是基类的根是object类。
python3x版本中只有一种类：
python3中使⽤的都是新式类. 如果基类谁都不继承. 那这个类会默认继承 object

class A:
    pass
class B(A):
    pass
class C(A):
    pass
class D(B, C):
    pass
class E:
    pass
class F(D, E):
    pass
class G(F, D):
    pass
class H:
    pass
class Foo(H, G):
    pass
MRO: Foo-&gt; H -&gt; G -&gt; F -&gt; E -&gt; D -&gt; B -&gt; A -&gt; C(看图)
    
print(Foo.mro())******（直接计算）

原则：从头开始. 从左往右. ⼀条路跑到头, 然后回头. 继续⼀条路跑到头. 就是经典类的MRO算法. </code></pre>
<p><img src="C:\python学习笔记\assets\1565095855639.png" alt="1565095855639" /></p>
<h2 id="封装-和-多态">封装 和 多态</h2>
<p>封装，顾名思义就是将内容封装到某个地方，以后再去调用被封装在某处的内容。</p>
<p>所以，在使用面向对象的封装特性时，需要：</p>
<ul>
<li>将内容封装到某处</li>
<li>从某处调用被封装的内容封装，顾名思义就是将内容封装到某个地方，以后再去调用被封装在某处的内容。</li>
</ul>
<pre><code><code>封装
class foo:
    def __init__(self,name,age):
        self.name = name
        self.age = age
obj1 = foo(&quot;wupeiqi&quot;,18)
obj2 = foo(&quot;alex&quot;,73)
通过对象直接调用被封装里的内容
print(obj1.name)
print(obj1.age)
print(obj2.name)
print(obj2.age)

class foo:
    def __init__(self,name,age):
        self.name = name
        self.age = age
    def info(self):
        print(self.name)
        print(self.age)
间接通过self调用
obj1 = foo(&quot;wupeiqi&quot;,18)
obj2 = foo(&quot;alex&quot;,73)
obj1.info()
obj2.info()


多态

多态，同一个对象，多种形态。python默认支持多态。
ython中有一句谚语说的好，你看起来像鸭子，那么你就是鸭子。
对于代码上的解释其实很简答：
class A:
    def f1(self):
        print(&#39;in A f1&#39;)
    
    def f2(self):
        print(&#39;in A f2&#39;)

class B:
    def f1(self):
        print(&#39;in A f1&#39;)
    
    def f2(self):
        print(&#39;in A f2&#39;)
       
obj = A()
obj.f1()
obj.f2()

obj2 = B()
obj2.f1()
obj2.f2()
# A 和 B两个类完全没有耦合性，但是在某种意义上他们却统一了一个标准。
# 对相同的功能设定了相同的名字，这样方便开发，这两个方法就可以互成为鸭子类型。

# 这样的例子比比皆是：str  tuple list 都有 index方法，这就是统一了规范。
# str bytes 等等 这就是互称为鸭子类型。</code></pre>
<h2 id="类的约束">类的约束</h2>
<pre><code><code>提取⽗类. 然后在⽗类中定义好⽅法. 在这个⽅法中什么都不⽤⼲. 就抛⼀个异常就可以了.
这样所有的⼦类都必须重写这个⽅法. 否则. 访问的时候就会报错.
方法1*****
class payment:
    def pay(self,money):
        raise Exception(&quot;子类没有引用pay方法&quot;)
        #手动添加报错信息
class qqpay(payment):
    def pay(self,money):
        print(f&quot;使用QQ支付{money}&quot;)

class wechatpay(payment):
    def pay(self,money):
        print(f&quot;使用QQ支付{money}&quot;)

class Alipaypay(payment):
    def zhifu(self,money):
        print(f&quot;使用支付支付{money}&quot;)

def pay(obj,money):统一接口（支付接口，方便其他文件的互相调用）
    obj.pay(money)

obj1 = qqpay()
obj2 =wechatpay()
obj3 =Alipaypay()

pay(obj1,100)
pay(obj2,100)
pay(obj3,100)


方法2：抽象类，接口类 ：强制指定规则
from abc import ABCMeta,abstractmethod
class Payment(metaclass=ABCMeta):
    @abstractmethod
    def pay(self,money):
        pass
class qqpay(Payment):
    def pay(self,money):
        print(f&quot;使用QQ支付{money}&quot;)

class wechatpay(Payment):
    def pay(self,money):
        print(f&quot;使用QQ支付{money}&quot;)

class (Payment):
    def pay(self,money):
        print(f&quot;使用支付宝支付{money}&quot;)
def pay(obj,money):
    obj.pay(money)

obj1 = qqpay()
obj2 =wechatpay()
obj3 =Alipaypay()

pay(obj1,100)
pay(obj2,100)
pay(obj3,100)</code></pre>
<h2 id="super深度深入了解">super深度深入了解</h2>
<pre><code><code>class A:
    def f1(self):
        print(&#39;in A&#39;)

class Foo(A):
    def f1(self):
        super().f1()
        print(&#39;in Foo&#39;)

class Bar(A):
    def f1(self):
        print(&#39;in Bar&#39;)

class Info(Foo,Bar):
    def f1(self):
        super().f1()
        print(&#39;in Info f1&#39;)
 print(Info.mro())#  Info--》Foo--》Bar--》A--》object

obj = Info()
obj.f1()
1.实例化一个对象
2.先在info的类中找f1 info中有f1 执行super().f1 去Foo中找f1，打印&#39;in Foo&#39; 在打印 &#39;in Info f1&#39; 按照mro算法的执行顺序向父类中查找

class A:
    def f1(self):
        print(&#39;in A&#39;)

class Foo(A):
    def f1(self):
        super().f1()
        print(&#39;in Foo&#39;)

class Bar(A):
    def f1(self):
        print(&#39;in Bar&#39;)

class Info(Foo,Bar):
    def f1(self):
        super(Foo,self).f1()
        print(&#39;in Info f1&#39;)

obj = Info()
obj.f1()
1.实例化一个对象
2.先在Info 中找f1 ，执行 super(Foo,self).f1() 到Foo中找f1 在执行Foo中的super().f1() 在到Bar中找f1 打印in Foo 在打印in Info f1 按照mro算法的执行顺序向父类中查找
Info--》Foo--》Bar--》A--》object
3.严格按照对象从属于类的mro的顺序,查询下一个类.</code></pre>
<h2 id="类的成员">类的成员</h2>
<ol>
<li>细分类的成员</li>
</ol>
<pre><code><code>class C:
    name = &#39;公有静态字段/变量&#39;
    _phone = 15032551128    #私有静态变量
    def __init__(self,name):#特殊方法
        self.name = name

    def func(self):          #普通方法
        print(C.name)

    def _func(self,name):    #私有方法
        self.name = name
        print(&#39;私有方法&#39;)
class d(C):
    def show(self):
        print(C.name)

    @classmethod
    def class_func(cls):
        print(&quot;类方法&quot;)

    @staticmethod
    def static_func():
        print(&quot;静态方法&quot;)

    @property
    def prop(self):
        print(&quot;属性&quot;)
obj = C(&quot;八戒&quot;)
print(obj.name)
print(C.nunc()
obj1 = d(1)
obj1.show()

</code></pre>
<ol>
<li>类的私有成员</li>
</ol>
<pre><code><code>公有成员，在任何地方都能访问
私有成员，只有在类的内部才能方法
静态字段(静态属性)  
   公有静态字段：类可以访问；类内部可以访问；派生类中可以访问
class C:

    name = &quot;公有静态字段&quot;

    def func(self):
        print (C.__name)

class D(C):

    def show(self):
        print (C.__name)


C.name         # 类访问
obj = C()
obj.func()     # 类内部可以访问
obj_son = D()
obj_son.show() # 派生类中可以访问    


   私有静态字段：仅类内部可以访问；
class C:

    __name = &quot;私有静态字段&quot;

    def func(self):
        print (C.__name)

class D(C):

    def show(self):
        print (C.__name)


C.__name       # 不可在外部访问
obj = C()
obj.__name     # 不可在外部访问
obj.func()     # 类内部可以访问  
obj_son = D()
obj_son.show() #不可在派生类中可以访问 

***************************************************
普通字段(对象属性)

1.公有普通字段：对象可以访问；类内部可以访问；派生类中可以访问
class C:
    
    def __init__(self):
        self.foo = &quot;公有字段&quot;

    def func(self):
        print(self.foo) 　#　类内部访问

class D(C):
    
    def show(self):
        print(self.foo)　＃　派生类中访问

obj = C()
obj.foo     # 通过对象访问
obj.func()  # 类内部访问
obj_son = D();
obj_son.show()  # 派生类中访问


2.私有普通字段：仅类内部可以访问
class C:  
    def __init__(self):
        self.__foo = &quot;私有字段&quot;

    def func(self):
        print(self.foo) 　#　类内部访问

class D(C):
    def show(self):
        print(self.foo)　#　派生类中访问

obj = C()
obj.__foo     # 通过对象访问    ==&gt; 错误
obj.func()  # 类内部访问        ==&gt; 正确
obj_son = D()
obj_son.show()  # 派生类中访问  ==&gt; 错误



*****************************************************************************************************
 类的私有成员
1.在类的内部访问
class A:
    name = &quot;liye&quot;
    __name = &quot;gangge&quot;
    def func(self):
        print(self.name)    #类的内部
        print(self.__name)  #类的内部
obj = A()
obj.func()

类的外部不能访问私有方法
class A:
    name = &quot;liye&quot;
    __name = &quot;gangge&quot;
    def func(self):
        pass
obj = A()
print(obj.name)    #liye
print(A.__name)    #错误
print(obj.__name)  #错误

类的派生类不能访问
class A:
    name = &#39;李业&#39;
    __name = &#39;钢哥&#39;

class B(A):
    def func(self):
        print(self.__name)

obj = B()
# print(obj.__name)
obj.func()


总结：私有对象属性只能在类的内部使用,不能再类外部以及派生类使用.

class A:
    def __init__(self,name,pwd):
        self.name = name
        self.pwd = pwd
    def md5(self):
        self.__pwd = self.__pwd + &quot;123&quot;
obj = A(&quot;八戒&quot;,123456)
print(obj.__pwd) #&#39;A&#39; object has no attribute &#39;__pwd&#39; 错误
私有成员来说: 当你遇到重要的数据,功能,(只允许本类使用的一些方法,数据)设置成私有成员.
python所有的私有成员都是纸老虎,形同虚设.

class A:

    name = &#39;李业&#39;
    __name = &#39;钢哥&#39;  # 私有类的属性

    def __func(self):
        print(&#39;in __func&#39;)

print(A.__dict__)
print(A._A__name)#别用

类从加载时,只要遇到类中的私有成员,都会在私有成员前面加上_类名 .


类的其他方法

类方法有什么用???
    1. 得到类名可以实例化对象.
    2. 可以操作类的属性.
class A:
    def func(self):
        print(&#39;实例方法&#39;)
    @classmethod    #类方法
    def cls_func(cls):
        print(f&#39;cls----&gt;{cls}&#39;)#&lt;class &#39;__main__.A&#39;&gt;
        obj = cls()
        print(obj)
        print(&#39;类方法&#39;)
print(A) #&lt;class &#39;__main__.A&#39;&gt;
A.cls_func()
obj = A()
obj.cls_func()
类方法: 一般就是通过类名去调用的方法,并且自动将类名地址传给cls,
但是如果通过对象调用也可以,但是传的地址还是类名地址


创建学生类,只要实例化一个对象,写一个类方法,统计一下具体实例化多少个学生?
原则上，类方法是将类本身作为对象进行操作的方法，默认有个 cls 参数，可以被类和对象调用
通过实例化一个对象就执行一次 __init__方法 然后调用add 函数 执行自动加1
class Student:

    count = 0
    def __init__(self,name,id):
        self.name = name
        self.id = id
        Student.add()

    @classmethod
    def add(cls):
        print(cls)
        cls.count+=1

    @classmethod
    def get(cls):
        return cls.count

obj1 =Student(&quot;liye&quot;,2542621222)
obj1 =Student(&quot;liye&quot;,2542621222)
obj1 =Student(&quot;liye&quot;,2542621222)
print(obj1)
print(Student.get())

class student:
    count = 0
    def __init__(self,name,id):
        self.name = name
        self.id = id
        student.add()

    @classmethod
    def add(cls):
        cls.count += 1

        return cls.count
obj = student(&quot;d&quot;,252531)
obj1 = student(&quot;d&quot;,252531)
obj2 = student(&quot;d&quot;,252531)
print(student.count)
student.add()


静态方法
class A:

    def func(self):
        print(&#39;实例方法&#39;)


    @classmethod
    def cls_func(cls):
        pass

    @staticmethod
    def static_func():
        print(&#39;静态方法&#39;)

静态方法是不依赖于对象与类的,其实静态方法就是函数.
保证代码的规范性,合理的划分.后续维护性高.

@property的组合
class Foo:

    @property
    def bmi(self):
        print(&quot;1&quot;)
    @bmi.setter
    def bmi(self,v):
        print(2)
    @bmi.deleter
    def bmi(self):
        print(3)

obj = Foo()
obj.bmi       #不加括号也可以直接调用bmi 函数
obj.bmi = 666 #操作命令，这个命令并不是改变bmi的值，而知执行被bmi.setter装饰器装饰的函数 得不到返回值（return）
del obj.bmi   #操作命令，这个命令并不是删除bmi的值，而知执行被bmi.setter装饰器装饰的函数 得不到返回值（return）


 利用实例化对象的方式设置属性.

class Foo:
    def get_AAA(self):
        print(&#39;get的时候运行我啊&#39;)

    def set_AAA(self,value):
        print(&#39;set的时候运行我啊&#39;)

    def delete_AAA(self):
        print(&#39;delete的时候运行我啊&#39;)

    AAA = property(get_AAA,set_AAA,delete_AAA) #内置property三个参数与get,set,delete一一对应

f1=Foo()
f1.AAA
f1.AAA=&#39;aaa&#39;
del f1.AAA
*****************************************************************************************************


isinstance(a,b)：判断a是否是b类（或者b类的派生类）实例化的对象
issubclass(a,b)： 判断a类是否是b类（或者b的派生类）的派生类</code></pre>

</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>