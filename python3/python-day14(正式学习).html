<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修python-day14(正式学习)' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>python-day14(正式学习)</center></div><div class='banquan'>原文出处:本文由博客园博主wind叶提供。<br/>
原文连接:https://www.cnblogs.com/leaf-wind/p/11348848.html</div><br>
    <div class="toc">
    <p class="toc-title">目录</p>
    <div class="toc-list">
        <ul>
        <li><a href="#三元表达式">三元表达式</a></li>
        <li><a href="#列表推导式">列表推导式</a></li>
        <li><a href="#字典生成式">字典生成式</a><ul>
        <li><a href="#zip方法">zip()方法</a></li>
        </ul></li>
        <li><a href="#生成器">生成器</a><ul>
        <li><a href="#yield关键字">yield关键字</a></li>
        <li><a href="#迭代套迭代">迭代套迭代</a></li>
        <li><a href="#sendvalue">send(value)</a></li>
        <li><a href="#close">close()</a></li>
        <li><a href="#throw">throw()</a></li>
        <li><a href="#自定义range方法">自定义range方法</a></li>
        <li><a href="#生成器表达式">生成器表达式</a></li>
        </ul></li>
        <li><a href="#匿名函数">匿名函数</a><ul>
        <li><a href="#与内联函数联用">与内联函数联用</a></li>
        </ul></li>
        </ul>
    </div>
</div>
<h1 id="三元表达式">三元表达式</h1>
<p>条件成立时的返回值 if 条件 else 条件不成立时的返回值</p>
<pre><code><code>x = 10
y = 20

print(f&quot;x if x &gt; y else y: {x if x &gt; y else y}&quot;)</code></pre>
<pre><code><code>x if x &gt; y else y: 20</code></pre>
<h1 id="列表推导式">列表推导式</h1>
<pre><code><code>[expression for item1 in iterable1 if condition1
for item2 in iterable2 if condition2
...
for itemN in iterableN if conditionN
]
类似于
res=[]
for item1 in iterable1:
    if condition1:
        for item2 in iterable2:
            if condition2
                ...
                for itemN in iterableN:
                    if conditionN:
                        res.append(expression)
                        
print(F&quot;[i for i in range(10)]: {[i for i in range(10)]}&quot;)

##[i for i in range(10)]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
print(F&quot;[i**2 for i in range(10)]: {[i**2 for i in range(10)]}&quot;)

##[i**2 for i in range(10)]: [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</code></pre>
<p>说实话没啥用，仅限于装逼。。。</p>
<h1 id="字典生成式">字典生成式</h1>
<pre><code><code>print({i: i**2 for i in range(10)})</code></pre>
<pre><code><code>{0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81}</code></pre>
<h2 id="zip方法">zip()方法</h2>
<pre><code><code>keys = [&#39;name&#39;, &#39;age&#39;, &#39;gender&#39;]
values = [&#39;nick&#39;, 19, &#39;male&#39;]

res = zip(keys, values)
print(F&quot;zip(keys,values): {zip(keys,values)}&quot;)

info_dict = {k: v for k, v in res}
print(f&quot;info_dict: {info_dict}&quot;)


##zip(keys,values): &lt;zip object at 0x11074c088&gt;
##info_dict: {&#39;name&#39;: &#39;nick&#39;, &#39;age&#39;: 19, &#39;sex&#39;: &#39;male&#39;}</code></pre>
<p>通过解压缩函数生成一个字典</p>
<pre><code><code>info_dict = {&#39;name&#39;: &#39;nick&#39;, &#39;age&#39;: 19, &#39;gender&#39;: &#39;male&#39;}
print(f&quot;info_dict.keys(): {info_dict.keys()}&quot;)
print(f&quot;info_dict.values(): {info_dict.values()}&quot;)

res = zip(info_dict.keys(), info_dict.values())
print(F&quot;zip(keys,values): {zip(info_dict.keys(),info_dict.values())}&quot;)

info_dict = {k: v for k, v in res}
print(f&quot;info_dict: {info_dict}&quot;)


##info_dict.keys(): dict_keys([&#39;name&#39;, &#39;age&#39;, &#39;gender&#39;])
##info_dict.values(): dict_values([&#39;nick&#39;, 19, &#39;male&#39;])
##zip(keys,values): &lt;zip object at 0x1105cefc8&gt;
##info_dict: {&#39;name&#39;: &#39;nick&#39;, &#39;age&#39;: 19, &#39;gender&#39;: &#39;male&#39;}</code></pre>
<p>这个还有点用。。。</p>
<h1 id="生成器">生成器</h1>
<h2 id="yield关键字">yield关键字</h2>
<p>yield的英文单词意思是生产，在函数中但凡出现yield关键字，再调用函数，就不会继续执行函数体代码，而是会返回一个值。</p>
<pre><code><code>def func():
    print(1)
    yield
    print(2)
    yield


g = func()
print(g)
&lt;generator object func at 0x10ddb6b48&gt;</code></pre>
<p>生成器的本质就是迭代器，同时也并不仅仅是迭代器，不过迭代器之外的用途实在是不多，所以我们可以大声地说：生成器提供了非常方便的自定义迭代器的途径。并且从Python 2.5+开始，[PEP 342：通过增强生成器实现协同程序]的实现为生成器加入了更多的特性，这意味着生成器还可以完成更多的工作。这部分我们会在稍后的部分介绍。</p>
<pre><code><code>def func():
    print(&#39;from func 1&#39;)
    yield &#39;a&#39;
    print(&#39;from func 2&#39;)
    yield &#39;b&#39;


g = func()
print(F&quot;g.__iter__ == g: {g.__iter__() == g}&quot;)

res1 = g.__next__()
print(f&quot;res1: {res1}&quot;)

res2 = next(g)
print(f&quot;res2: {res2}&quot;)

# next(g)  # StopIteration
g.__iter__ == g: True
from func 1
res1: a
from func 2
res2: b
def func():
    print(&#39;from func 1&#39;)
    yield &#39;a&#39;
    print(&#39;from func 2&#39;)
    yield &#39;b&#39;


g = func()
for i in g:
    print(i)

print(f&quot;list(func()): {list(func())}&quot;)
from func 1
a
from func 2
b
from func 1
from func 2
list(func()): [&#39;a&#39;, &#39;b&#39;]</code></pre>
<p><strong>生成器就没必要加return了</strong></p>
<h2 id="迭代套迭代">迭代套迭代</h2>
<p>如果我需要在生成器的迭代过程中接入另一个生成器的迭代怎么办？写成下面这样好傻好天真。并且你这样做的意图是什么？？？</p>
<pre><code><code>def sub_generator():
    yield 1
    yield 2
    for i in range(3):
        yield i


for i in sub_generator():
    print(i)
##  
1
2
0
1
2
##
def sub_generator():
    yield 1
    yield 2
    yield from range(3)


for i in sub_generator():
    print(i)
##
1
2
0
1
2
##</code></pre>
<h2 id="sendvalue">send(value)</h2>
<p>send是除next外另一个恢复生成器的方法。Python2.5+中，yield语句变成了yield表达式，这意味着yield现在可以有一个值，而这个值就是在生成器的send方法被调用从而恢复执行时，调用send方法的参数。</p>
<pre><code><code>def h():
    print(&#39;--start--&#39;)
    first = yield 5  # 等待接收 Fighting! 值
    print(&#39;1&#39;, first)
    second = yield 12  # 等待接收 hahaha! 值
    print(&#39;2&#39;, second)
    yield 13
    print(&#39;--end--&#39;)


g = h()
first = next(g)  # m 获取了yield 5 的参数值 5
# (yield 5)表达式被赋予了&#39;Fighting!&#39;,  d 获取了yield 12 的参数值12
second = g.send(&#39;Fighting!&#39;)
third = g.send(&#39;hahaha!&#39;)  # (yield 12)表达式被赋予了&#39;hahaha!&#39;
print(f&#39;--over--&#39;)
print(f&quot;first:{first}, second:{second}, third:{third}&quot;)
--start--
1 Fighting!
2 hahaha!
--over--
first:5, second:12, third:13</code></pre>
<ul>
<li>调用send传入非None值前，生成器必须处于挂起状态，否则将抛出异常。不过，未启动的生成器仍可以使用None作为参数调用send。</li>
<li>如果使用next恢复生成器，yield表达式的值将是None。</li>
</ul>
<h2 id="close">close()</h2>
<p>这个方法用于关闭生成器。对关闭的生成器后再次调用next或send将抛出StopIteration异常。</p>
<pre><code><code>def repeater():
    n = 0
    while True:
        n = (yield n)


r = repeater()
r.close()
print(next(r))  # StopIteration</code></pre>
<h2 id="throw">throw()</h2>
<p>中断Generator是一个非常灵活的技巧，可以通过throw抛出一个GeneratorExit异常来终止Generator。Close()方法作用是一样的，其实内部它是调用了throw(GeneratorExit)的。我们看close的源代码：</p>
<pre><code><code>def close(self):
    try:
        self.throw(GeneratorExit)
    except (GeneratorExit, StopIteration):
        pass 
    else:
        raise RuntimeError(&quot;generator ignored GeneratorExit&quot;) # Other exceptions are not caught</code></pre>
<h2 id="自定义range方法">自定义range方法</h2>
<pre><code><code>def my_range(start, stop, step=1):
    while start &lt; stop:
        yield start
        start += 1


g = my_range(0, 3)
print(f&quot;list(g): {list(g)}&quot;)</code></pre>
<p>list(g):[0,1,2]</p>
<p>yield:</p>
<ol>
<li>提供一种自定义迭代器的方式</li>
<li>yield可以暂停住函数，并提供当前的返回值</li>
</ol>
<p>yield和return:</p>
<ol>
<li>相同点：两者都是在函数内部使用，都可以返回值，并且返回值没有类型和个数的限制</li>
<li>不同点：return只能返回一次之；yield可以返回多次值</li>
</ol>
<h2 id="生成器表达式">生成器表达式</h2>
<ul>
<li>把列表推导式的[]换成()就是生成器表达式</li>
<li>优点：省内存，一次只产生一个值在内存中</li>
</ul>
<pre><code><code>t = (i for i in range(10))
print(t)
print(f&quot;next(t): {next(t)}&quot;)
&lt;generator object &lt;genexpr&gt; at 0x1101c4888&gt;
next(t): 0</code></pre>
<h1 id="匿名函数">匿名函数</h1>
<p>匿名函数，他没有绑定名字，使用一次即被收回，加括号既可以运行。</p>
<pre><code><code>lambda x, y: x+y
##&lt;function __main__.&lt;lambda&gt;(x, y)&gt;
res = (lambda x, y: x+y)(1, 2)
print(res)
##3</code></pre>
<h2 id="与内联函数联用">与内联函数联用</h2>
<p>1.如果我们想从上述字典中取出薪资最高的人，我们可以使用max()方法，但是max()默认比较的是字典的key。</p>
<ol>
<li>首先将可迭代对象变成迭代器对象</li>
<li>res=next(迭代器对象)，将res当做参数传给key指定的函数，然后将该函数的返回值当做判断依据</li>
</ol>
<pre><code><code>salary_dict = {
    &#39;nick&#39;: 3000,
    &#39;jason&#39;: 100000,
    &#39;tank&#39;: 5000,
    &#39;sean&#39;: 2000
}

print(f&quot;max(salary_dict): {max(salary_dict)}&quot;)


def func(k):
    return salary_dict[k]


print(f&quot;max(salary_dict, key=func()): {max(salary_dict, key=func)}&quot;)
# &#39;nick&#39;, v1 = func(&#39;nick&#39;)
# &#39;jason&#39;, v2 = func(&#39;jason&#39;)
# &#39;tank&#39;, v3 = func(&#39;tank&#39;)
# &#39;sean&#39;, v4 = func(&#39;sean&#39;)


print(
    f&quot;max(salary_dict, key=lambda name: salary_dict[name]): {max(salary_dict, key=lambda name: salary_dict[name])}&quot;)</code></pre>
<pre><code><code>max(salary_dict): tank
max(salary_dict, key=func()): jason
max(salary_dict, key=lambda name: salary_dict[name]): jason</code></pre>
<p>2.如果我们想对上述字典中的人，按照薪资从大到小排序，可以使用sorted()方法。</p>
<p>sorted()工作原理：</p>
<ol>
<li>首先将可迭代对象变成迭代器对象</li>
<li>res=next(迭代器对象)，将res当做参数传给第一个参数指定的函数，然后将该函数的返回值当做判断依据。</li>
</ol>
<pre><code><code>lis = [1, 3, 2, 5, 8, 6]
sorted(lis)
print(f&quot;lis: {lis}&quot;)
print(f&quot;sorted(lis,reverse=True): {sorted(lis,reverse=True)}&quot;)

##lis: [1, 3, 2, 5, 8, 6]
##sorted(lis,reverse=True): [8, 6, 5, 3, 2, 1]

salary_dict = {
    &#39;nick&#39;: 3000,
    &#39;jason&#39;: 100000,
    &#39;tank&#39;: 5000,
    &#39;sean&#39;: 2000
}

print(
    f&quot;sorted(salary_dict, key=lambda name: salary_dict[name]): {sorted(salary_dict, key=lambda name: salary_dict[name])}&quot;)

##sorted(salary_dict, key=lambda name: salary_dict[name]): [&#39;sean&#39;, &#39;nick&#39;, &#39;tank&#39;, &#39;jason&#39;]</code></pre>
<p>3.如果我们想对一个列表中的某个人名做处理，可以使用map()方法。</p>
<p>map()工作原理：</p>
<ol>
<li>首先将可迭代对象变成迭代器对象</li>
<li>res=next(迭代器对象)，将res当做参数传给第一个参数指定的函数，然后将该函数的返回值作为map()方法的结果之一。</li>
</ol>
<pre><code><code>name_list = [&#39;jason&#39;, &#39;tank&#39;, &#39;sean&#39;]

res = map(lambda name: f&quot;{name} sb&quot;, name_list)
print(f&quot;list(res): {list(res)}&quot;)

##list(res): [&#39;jason sb&#39;, &#39;tank sb&#39;, &#39;sean sb&#39;]</code></pre>
<p>4.如果我们想筛选除名字中含有'sb'的名字，我们可以使用filter()方法。</p>
<p>filter()工作原理：</p>
<ol>
<li>首先将可迭代对象变成迭代器对象</li>
<li>res=next(迭代器对象)，将res当做参数传给第一个参数指定的函数，然后filter会判断函数的返回值的真假，如果为真则留下。</li>
</ol>
<pre><code><code>name_list = [&#39;nick&#39;, &#39;jason sb&#39;, &#39;tank sb&#39;, &#39;sean sb&#39;]

filter_res = filter(lambda name: name.endswith(&#39;sb&#39;), name_list)
print(f&quot;list(filter_res): {list(filter_res)}&quot;)

##list(filter_res): [&#39;jason sb&#39;, &#39;tank sb&#39;, &#39;sean sb&#39;]</code></pre>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>