<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修TypeScript躬行记（5）——类型兼容性' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>TypeScript躬行记（5）——类型兼容性</center></div><div class='banquan'>原文出处:本文由博客园博主咖啡机（K.F.J）提供。<br/>
原文连接:https://www.cnblogs.com/strick/p/11726848.html</div><br>
    <p>　　TypeScript是一种基于结构类型的语言，可根据其成员来描述类型。以结构相同的Person接口和Programmer类为例，如下所示。</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">interface</span><span style="color: #000000;"> Person {
  name: </span><span style="color: #0000ff;">string</span><span style="color: #000000;">;
}
</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> Programmer {
  name: </span><span style="color: #0000ff;">string</span><span style="color: #000000;">;
}
let person: Person </span>= <span style="color: #0000ff;">new</span> Programmer();</pre>
</div>
<p>　　由于结构类型的关系，因此当变量声明为Person类型时，可通过Programmer类实例化。由此可知，结构类型只关注类型的组成结构，而名称并不重要。</p>
<h1>一、函数</h1>
<p>　　在判断两个函数的兼容性时，需要考虑参数数量、返回值类型等多个方面。</p>
<p><span style="font-size: 18px;"><strong>1）参数数量</strong></span></p>
<p>　　假设有两个函数add()和sum()，它们的参数数量不同，后者比前者多一个参数，而函数的返回值类型相同，如下所示。</p>
<div class="cnblogs_code">
<pre><code>let add = (x: number) =&gt; 0<span style="color: #000000;">;
let sum </span>= (y: number, z: number) =&gt; 0;</pre>
</div>
<p>　　当把add赋给sum时，编译能成功执行；而反之，则会报错，如下所示。</p>
<div class="cnblogs_code">
<pre><code>sum = add;        <span style="color: #008000;">//</span><span style="color: #008000;">正确</span>
add = sum;        <span style="color: #008000;">//</span><span style="color: #008000;">错误</span></pre>
</div>
<p>　　由此可知，参数少的函数不能赋给参数多的；而反过来时，需要确保每个位置所对应的参数类型保持一致，不过参数名称可以不同。</p>
<p><span style="font-size: 18px;"><strong>2）返回值类型</strong></span></p>
<p>　　假设有两个函数add()和sum()，它们没有参数，后者的返回值比前者多一个属性，如下所示。</p>
<div class="cnblogs_code">
<pre><code>let add = () =&gt; ({ x: 1<span style="color: #000000;"> });
let sum </span>= () =&gt; ({ x: 1, y: 2});</pre>
</div>
<p>　　当把sum赋给add时，编译能成功执行；而反之，则会报错，如下所示。</p>
<div class="cnblogs_code">
<pre><code>add = sum;        <span style="color: #008000;">//</span><span style="color: #008000;">正确</span>
sum = add;        <span style="color: #008000;">//</span><span style="color: #008000;">错误</span></pre>
</div>
<p>　　由此可知，源函数的返回值类型得是目标函数返回值的子类型。</p>
<p><span style="font-size: 18px;"><strong>3）参数类型</strong></span></p>
<p>　　TypeScript中的参数类型需要同时满足协变和逆变，即双向协变。协变比较好理解，是指子类型兼容父类型，而逆变正好与协变相反。在下面的示例中，定义了父类Person和子类Programmer，Programmer类覆盖了Person类中的work()方法，并且其参数类型声明的更加宽泛。</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span><span style="color: #000000;"> Person {
  work(msg: </span><span style="color: #0000ff;">string</span> |<span style="color: #000000;"> undefined) { }
}
</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> Programmer extends Person {
  work(msg: </span><span style="color: #0000ff;">string</span><span style="color: #000000;">) { }
}</span></pre>
</div>
<p>　　接下来声明两个函数，它们的参数类型分别是Person和Programmer两个类，如下所示，其中person()函数是programmer()函数的子类型。</p>
<div class="cnblogs_code">
<pre><code>let person = (x: Person) =&gt; 0<span style="color: #000000;">;
let programmer </span>= (x: Programmer) =&gt; 0;</pre>
</div>
<p>　　由于参数类型是双向协变的，因此两个变量之间可相互赋值，如下所示。</p>
<div class="cnblogs_code">
<pre><code>person =<span style="color: #000000;"> programmer;
programmer </span>= person;</pre>
</div>
<p><span style="font-size: 18px;"><strong>4）可选参数和剩余参数</strong></span></p>
<p>　　在比较函数的兼容性时，不需要匹配可选参数。以下面的pls()和add()两个函数为例，pls()中的两个参数必传，而add()中的第二个参数是可选的。</p>
<div class="cnblogs_code">
<pre><code>let pls = (x: number, y: number) =&gt; 0<span style="color: #000000;">;
let add </span>= (x: number, y?: number) =&gt; 0<span style="color: #000000;">;
pls </span>=<span style="color: #000000;"> add;
add </span>= pls;</pre>
</div>
<p>　　虽然参数不同，但是两个函数仍然是兼容的，并且可以相互赋值。剩余参数相当于无限个可选参数，也不会被匹配。下面示例中的sum()函数只声明了剩余参数，它与pls()和add()两个函数都是兼容的。</p>
<div class="cnblogs_code">
<pre><code>let sum = (...args: number[]) =&gt; 0<span style="color: #000000;">;
pls </span>=<span style="color: #000000;"> sum;
sum </span>=<span style="color: #000000;"> pls;

add </span>=<span style="color: #000000;"> sum;
sum </span>= add;</pre>
</div>
<p><span style="font-size: 18px;"><strong>5）函数重载</strong></span></p>
<p>　　当比较存在多个重载的函数时，其每个重载都要在目标函数上找到对应的函数签名，以此确保目标函数能在源函数所有可调用的地方调用，如下所示。</p>
<div class="cnblogs_code">
<pre><code><span style="color: #000000;">interface add {
  (x: number, y: string): any;
  (x: number, y: number): number;
}
</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> sum(x: number, y: string): any;
</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> sum(x: number, y: number): number;
let func: add </span>= sum;</pre>
</div>
<h1>二、枚举</h1>
<p>　　来自于不同枚举类型的枚举值，被认为是不兼容的，如下所示，当把Direction.Up赋给color变量时，在编译阶段会报错。</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">enum</span><span style="color: #000000;"> Color { Red, Green, Blue }
</span><span style="color: #0000ff;">enum</span><span style="color: #000000;"> Direction { Up, Down, Left, Right }
let color </span>= Color.Red;        <span style="color: #008000;">//</span><span style="color: #008000;">正确</span>
color = Direction.Up;         <span style="color: #008000;">//</span><span style="color: #008000;">错误</span></pre>
</div>
<p>　　数字枚举和数字类型相互兼容，如下所示，color变量被赋予了枚举成员，digit变量是一个数字，它们之间可以相互赋值。</p>
<div class="cnblogs_code">
<pre><code>let color =<span style="color: #000000;"> Color.Red;
let digit </span>= 1<span style="color: #000000;">;
color </span>=<span style="color: #000000;"> digit;
digit </span>= color;</pre>
</div>
<p>　　字符串枚举无法兼容字符串类型，如下所示，当把field变量赋给Color的枚举成员时，在编译阶段会报错，但反过来可以正确执行。</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">enum</span> Color { Red = <span style="color: #800000;">"</span><span style="color: #800000;">RED</span><span style="color: #800000;">"</span>, Green = <span style="color: #800000;">"</span><span style="color: #800000;">GREEN</span><span style="color: #800000;">"</span>, Blue = <span style="color: #800000;">"</span><span style="color: #800000;">BLUE</span><span style="color: #800000;">"</span><span style="color: #000000;"> }
let color </span>=<span style="color: #000000;"> Color.Red;
let field </span>= <span style="color: #800000;">"</span><span style="color: #800000;">PURPLE</span><span style="color: #800000;">"</span><span style="color: #000000;">;
color </span>= field;            <span style="color: #008000;">//</span><span style="color: #008000;">错误</span>
field = color;            <span style="color: #008000;">//</span><span style="color: #008000;">正确</span></pre>
</div>
<h1>三、类</h1>
<p>　　类与对象字面量和接口类似，但类包含静态和实例两部分。在比较两个类实例时，仅匹配它们的实例成员，而静态成员和构造函数不影响兼容性，因为它们在比较时会被忽略。</p>
<p>　　在下面的示例中，创建了Person和Programmer两个类，虽然Programmer类包含了一个静态属性，并且其构造函数与Person类不同，但是它们之间可以相互兼容。</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span><span style="color: #000000;"> Person {
  name: </span><span style="color: #0000ff;">string</span><span style="color: #000000;">;
  constructor(name: </span><span style="color: #0000ff;">string</span><span style="color: #000000;">) { }
}
</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> Programmer {
  name: </span><span style="color: #0000ff;">string</span><span style="color: #000000;">;
  </span><span style="color: #0000ff;">static</span><span style="color: #000000;"> age: number;
  constructor(name: </span><span style="color: #0000ff;">string</span><span style="color: #000000;">, age: number) { }
}

let person: Person;
let programmer: Programmer;
person </span>=<span style="color: #000000;"> programmer;
programmer </span>= person;</pre>
</div>
<p>　　类的私有成员和受保护成员会影响兼容性，TypeScript要求它们必须来源于同一个类，从而既能保证父类兼容子类，也能避免与其它相同结构的类兼容。</p>
<p>　　在下面的示例中，Person和Teacher两个类都包含一个同名的私有属性，Programmer是Person的子类，三个变量的类型对应这三个类。</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span><span style="color: #000000;"> Person {
  </span><span style="color: #0000ff;">private</span> name: <span style="color: #0000ff;">string</span><span style="color: #000000;">;
}
</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> Teacher {
  </span><span style="color: #0000ff;">private</span> name: <span style="color: #0000ff;">string</span><span style="color: #000000;">;
}
</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> Programmer extends Person { }

let person: Person;
let programmer: Programmer;
let teacher: Teacher;</span></pre>
</div>
<p>　　person和programmer两个变量可相互赋值，因为它们的私有成员来源于同一个类，如下所示。</p>
<div class="cnblogs_code">
<pre><code>person =<span style="color: #000000;"> programmer;
programmer </span>= person;</pre>
</div>
<p>　　虽然person和teacher两个变量的结构相同，但是它们的私有成员来源于两个不同的类，因此无法相互赋值，如下所示。</p>
<div class="cnblogs_code">
<pre><code>person = teacher;        <span style="color: #008000;">//</span><span style="color: #008000;">错误</span>
teacher = person;        <span style="color: #008000;">//</span><span style="color: #008000;">错误</span></pre>
</div>
<h1>四、泛型</h1>
<p>　　当泛型接口中的类型参数未使用时，不会影响其兼容性，如下所示，x和y两个变量可相互赋值。</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">interface</span> Person&lt;T&gt;<span style="color: #000000;"> { }
let x: Person</span>&lt;number&gt;<span style="color: #000000;">;
let y: Person</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;">;

x </span>=<span style="color: #000000;"> y;
y </span>= x;</pre>
</div>
<p>　　当泛型接口中的类型参数被一个成员使用时，就会影响其兼容性，如下所示，x和y两个变量不可相互赋值。</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">interface</span> Person&lt;T&gt;<span style="color: #000000;"> {
  data: T;
}
let x: Person</span>&lt;number&gt;<span style="color: #000000;">;
let y: Person</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;">;

x </span>= y;        <span style="color: #008000;">//</span><span style="color: #008000;">错误</span>
y = x;        <span style="color: #008000;">//</span><span style="color: #008000;">错误</span></pre>
</div>
<p>　　当比较未指定参数类型的泛型函数时，在检查兼容性之前会将其替换成any类型，例如下面的两个函数，相当于对&ldquo;(x: any)=&gt;any&rdquo;和&ldquo;(y: any)=&gt;any&rdquo;进行匹配，因此可相互赋值。</p>
<div class="cnblogs_code">
<pre><code>let send = <span style="color: #0000ff;">function</span>&lt;T&gt;<span style="color: #000000;">(x: T): T {
  </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> x;
}
let func </span>= <span style="color: #0000ff;">function</span>&lt;U&gt;<span style="color: #000000;">(y: U): U {
  </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> y;
}

send </span>=<span style="color: #000000;"> func;
func </span>= send;</pre>
</div>
<p>&nbsp;　　泛型类的兼容性规则与之前所述一致。</p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>