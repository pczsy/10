<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修什么是泛型？' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>什么是泛型？</center></div><div class='banquan'>原文出处:本文由博客园博主hncboy提供。<br/>
原文连接:https://www.cnblogs.com/hncboy/p/12055261.html</div><br>
    <h1 class="md-end-block md-heading"><span class="md-plain md-expand">一、泛型的概念</span></h1>
<p class="md-end-block md-p"><span class="md-plain">泛型是 Java SE5 出现的新特性，泛型的本质是<span><strong>类型参数化或参数化类型</strong><span class="md-plain">，在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型。</span></span></span></p>
<h1 class="md-end-block md-heading"><span class="md-plain">二、泛型的意义</span></h1>
<p class="md-end-block md-p"><span class="md-plain">一般的类和方法，只能使用具体的类型：要么是基本类型，要么是自定义的类。如果要编写可以应用于多种类型的代码，这种刻板的限制对代码的束缚就会很大。</span></p>
<p class="md-end-block md-p"><span class="md-plain">Java 在引入泛型之前，表示可变对象，通常使用 Object 来实现，但是在进行类型强制转换时存在安全风险。有了泛型后：</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">编译期间确定类型，保证类型安全，放的是什么，取的也是什么，不用担心抛出 ClassCastException 异常。</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">提升可读性，从编码阶段就显式地知道泛型集合、泛型方法等处理的对象类型是什么。</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">泛型合并了同类型的处理代码提高代码的重用率，增加程序的通用灵活性。</span></p>
</li>
</ul>
<p class="md-end-block md-p"><span class="md-plain">举个例子：</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> method1() {
    List list </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> ArrayList();
    List.add(</span>22<span style="color: #000000;">);
    List.add(</span>"hncboy"<span style="color: #000000;">);
    List.add(</span><span style="color: #0000ff;">new</span><span style="color: #000000;"> Object());
​
    </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (Object o : list) {
        System.out.println(o.getClass());
    }
}</span></pre>
</div>
<p class="md-end-block md-p"><span class="md-plain">未使用泛型前，我们对集合可以进行任意类型的 add 操作，遍历结果都被转换成 Object 类型，因为不确定集合里存放的具体类型，输出结果如下所示。</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span><span style="color: #000000;"> java.lang.Integer
</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> java.lang.String
</span><span style="color: #0000ff;">class</span> java.lang.Object</pre>
</div>
<p class="md-end-block md-p"><span class="md-plain">采用泛型之后，创建集合对象可以明确的指定类型，在编译期间就确定了该集合存储的类型，存储其他类型的对象编译器会报错。这时遍历集合就可以直接采用明确的 String 类型输出。</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> method2() {
    List</span>&lt;String&gt; list = <span style="color: #0000ff;">new</span><span style="color: #000000;"> ArrayList();
    list.add(</span>"22"<span style="color: #000000;">);
    list.add(</span>"hncboy"<span style="color: #000000;">);
    </span><span style="color: #008000;">//</span><span style="color: #008000;">list.add(new Object()); 报错</span>
<span style="color: #000000;">​
    </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (String s : arrayList) {
        System.out.println(s);
    }
}</span></pre>
</div>
<h1 class="md-end-block md-heading"><span class="md-plain">三、泛型的表示</span></h1>
<p class="md-end-block md-p">&nbsp;</p>
<p class="md-end-block md-p"><span class="md-plain">泛型可以定义在类、接口、方法中，分别表示为泛型类、泛型接口、泛型方法。泛型的使用需要先声明，声明通过<span><strong>&lt;符号&gt;</strong><span class="md-plain">的方式，符号可以任意，编译器通过识别尖括号和尖括号内的字母来解析泛型。泛型的类型只能为类，不能为基本数据类型。尖括号的位置也是固定的，只能在<span><strong>类名之后</strong><span class="md-plain">或<span><strong>方法返回值之前</strong><span class="md-plain">。</span></span></span></span></span></span></span></p>
<p class="md-end-block md-p"><span class="md-plain">一般泛型有约定的符号：E 代表 Element，<span class="md-tag md-raw-inline">&lt;E&gt;<span class="md-plain"> 通常在集合中使用；T 代表 Type，<span class="md-tag md-raw-inline">&lt;T &gt;<span class="md-plain">通常用于表示类；K 代表 Key，V 代表 Value，&lt;K, V&gt; 通常用于键值对的表示；? 代表泛型通配符。</span></span></span></span></span></p>
<p class="md-end-block md-p"><span class="md-plain">泛型的表达式有如下几种：</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">普通符号 <span class="md-tag md-raw-inline">&lt;T&gt;</span></span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">无边界通配符 &lt;?&gt; </span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">上界通配符 &lt;? extends E&gt; 父类是 E</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">下界通配符 &lt;? super E&gt; 是 E 的父类</span></p>
</li>
</ul>
<h1 class="md-end-block md-heading"><span class="md-plain">四、泛型的使用</span></h1>
<h2 class="md-end-block md-heading"><span class="md-plain">4.1 泛型类</span></h2>
<p class="md-end-block md-p"><span class="md-plain">将泛型定义在类名后，使得用户在使用该类时，根据不同情况传入不同类型。在类上定义的泛型，在实例方法中可以直接使用，不需要定义，但是静态方法上的泛型需要在静态方法上声明，不能直接使用。举个例子：</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> Test&lt;T&gt;<span style="color: #000000;"> {
    
    </span><span style="color: #0000ff;">private</span><span style="color: #000000;"> T data;
​
    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> T getData() {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> data;
    }
​
    </span><span style="color: #008000;">/**</span><span style="color: #008000;"> 这种写法是错误的，提示 T 未定义 </span><span style="color: #008000;">*/</span>
    <span style="color: #008000;">/*</span><span style="color: #008000;">public static T get() {
        return null;
    }</span><span style="color: #008000;">*/</span>
    <span style="color: #008000;">/**</span><span style="color: #008000;"> 正确写法，该方法上的 T 和类上的 T 虽然一样，但是是两个指代，可以完全相同，互不影响 </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> &lt;T&gt;<span style="color: #000000;"> T get() {
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span><span style="color: #000000;">;
    }
    
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> setData(T data) {
        </span><span style="color: #0000ff;">this</span>.data =<span style="color: #000000;"> data;
    }
}</span></pre>
</div>
<h2 class="md-end-block md-heading"><span class="md-plain">4.2 泛型方法</span></h2>
<p class="md-end-block md-p"><span class="md-plain">泛型方法，是在调用方法时指明的具体的泛型类型。虽然类上定义的泛型，实例方法中可以直接使用，但是该方法不属于泛型方法。举个例子：get 方法为泛型方法，而且该程序能编译通过运行，因为尖括号里的每个元素都指代一种未知类型，可以为任何符号，尖括号里的 String 并非 java.lang.String 类型，而是作为泛型标识 <span class="md-tag md-raw-inline">&lt;String&gt;<span class="md-plain">，传入的 first 为 Integer 类型，所以该 String 标识符也指代 Integer 类型，返回值自然也是 Integer 类型。不过，应该也不会用这种泛型符号定义在实际情况中。</span></span></span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Test {
​
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> &lt;String, T, Hncboy&gt;<span style="color: #000000;"> String get(String string, Hncboy hncboy) {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> string;
    }
​
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        Integer first </span>= 666<span style="color: #000000;">;
        Double second </span>= 888.0<span style="color: #000000;">;
        Integer result </span>=<span style="color: #000000;"> get(first, second);
        System.out.println(result);
    }
}</span></pre>
</div>
<h2 class="md-end-block md-heading"><span class="md-plain">4.3 泛型通配符</span></h2>
<p class="md-end-block md-p"><span class="md-plain">? 为泛型非限定通配符，表示类型未知，不用声明，可以匹配任意的类。该通配符只能读，不能写，且不对返回值进行操作。也可以将非限定通配符出现的地方用普通泛型标识，不过使用通配符更简洁。举个例子：</span></p>
<p class="md-end-block md-p"><span class="md-plain">test1() 是通过通配符来输出集合的每一个元素的，test2() 和 test1() 的作用一样，只不过将通配符用 <span class="md-tag md-raw-inline">&lt;T&gt;<span class="md-plain"> 来代替了；test3() 用来演示集合在通配符的情况下写操作，发现编译器报错，int 和 String 都不属于 ? 类型，当然放不进集合，因为所有类都有 null 元素，所以可以放进集合。比如主函数传的是 List<span class="md-tag md-raw-inline">&lt;Double&gt;<span class="md-plain">，而想要在集合里添加一个 String，这是不可能的；test4() 的写法也是错的，? 是不确定，返回值返回不了；test5() 的用法使用来比较 List<span class="md-tag md-raw-inline">&lt;Object&gt;<span class="md-plain"> 和 List&lt;?&gt; 的，在主函数里调用 test5(list) 报错的，显示 java: 不兼容的类型: java.util.List&lt;java.lang.Integer&gt;无法转换为java.util.List&lt;java.lang.Object&gt;，因为 List<span class="md-tag md-raw-inline">&lt;Integer&gt;<span class="md-plain"> 不是 List<span class="md-tag md-raw-inline">&lt;Object&gt;<span class="md-plain"> 的子类。</span></span></span></span></span></span></span></span></span></span></span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Test {
​
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> test1(List&lt;?&gt;<span style="color: #000000;"> list) {
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 0; i &lt; list.size(); i++<span style="color: #000000;">) {
            System.out.println(list.get(i));
        }
    }
​
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> &lt;T&gt; <span style="color: #0000ff;">void</span> test2(List&lt;T&gt;<span style="color: #000000;"> list) {
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 0; i &lt; list.size(); i++<span style="color: #000000;">) {
            System.out.println(list.get(i));
        }
    }
​
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> test3(List&lt;?&gt;<span style="color: #000000;"> list) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">list.add(1); capture of ?
        </span><span style="color: #008000;">//</span><span style="color: #008000;">list.add("1"); capture of ?</span>
        list.add(<span style="color: #0000ff;">null</span><span style="color: #000000;">);
    }
​
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">public static ? test4(List&lt;?&gt; list) {
        return null;
    }</span><span style="color: #008000;">*/</span>
    
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> test5(List&lt;Object&gt;<span style="color: #000000;"> list) {
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 0; i &lt; list.size(); i++<span style="color: #000000;">) {
            System.out.println(list.get(i));
        }
    }
    
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        List</span>&lt;Integer&gt; list = <span style="color: #0000ff;">new</span> ArrayList&lt;&gt;<span style="color: #000000;">();
        list.add(</span>1<span style="color: #000000;">);
        list.add(</span>2<span style="color: #000000;">);
        list.add(</span>3<span style="color: #000000;">);
        test1(list);
        test2(list);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">test5(list);</span>
<span style="color: #000000;">    }
}</span></pre>
</div>
<p class="md-end-block md-p"><span class="md-plain">通过使用泛型通配符可以实现泛型的上下边界 &lt;? extend T&gt; 和 &lt;? super T&gt;，下面将使用 Number 类以及该类的子类来演示这两种上下型边界，Number 类的关系图如下。</span></p>
<div class="md-htmlblock md-rawblock md-end-block">​
<div class="md-htmlblock-container md-rawblock-container">
<div align="center"><img src="./images/什么是泛型？0.png" alt="" data-src="./images/什么是泛型？0.png" /></div>
</div>
​</div>
<p class="md-end-block md-p"><span>&lt;<span class="md-plain">? extends Number&gt; 表示类型为 Number 或 Number 的子类，&lt;? super Integer&gt; 表示类型为 Integer 或 Integer 的父类，举个例子，method1 方法测试是上边界 Number，由于 arrayList1 和 arrayList2 的泛型都为 Number 或其子类，所以可以插入成功，而 arrayList3 的类型 String 和 Number 无关，因此编译报错。method2 方法测试的是下边界 Integer，由于 arrayList4，arrayList5 和 arrayList7 种的类型 Integer、Object 和 Number 都为 Integer 的父类，所以插入成功，而 arrayList7 的类型 Double，因此插入失败。</span></span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Generic {
    
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        ArrayList</span>&lt;Integer&gt; arrayList1 = <span style="color: #0000ff;">new</span> ArrayList&lt;&gt;<span style="color: #000000;">();
        ArrayList</span>&lt;Number&gt; arrayList2 = <span style="color: #0000ff;">new</span> ArrayList&lt;&gt;<span style="color: #000000;">();
        ArrayList</span>&lt;String&gt; arrayList3 = <span style="color: #0000ff;">new</span> ArrayList&lt;&gt;<span style="color: #000000;">();
        method1(arrayList1);
        method1(arrayList2);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">method1(arrayList3);</span>
<span style="color: #000000;">        
        ArrayList</span>&lt;Integer&gt; arrayList4 = <span style="color: #0000ff;">new</span> ArrayList&lt;&gt;<span style="color: #000000;">();
        ArrayList</span>&lt;Object&gt; arrayList5 = <span style="color: #0000ff;">new</span> ArrayList&lt;&gt;<span style="color: #000000;">();
        ArrayList</span>&lt;Number&gt; arrayList6 = <span style="color: #0000ff;">new</span> ArrayList&lt;&gt;<span style="color: #000000;">();
        ArrayList</span>&lt;Double&gt; arrayList7 = <span style="color: #0000ff;">new</span> ArrayList&lt;&gt;<span style="color: #000000;">();
        method2(arrayList4);
        method2(arrayList5);
        method2(arrayList6);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">method2(arrayList7)</span>
<span style="color: #000000;">    }
    
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> method1(ArrayList&lt;? <span style="color: #0000ff;">extends</span> Number&gt;<span style="color: #000000;"> arrayList) {
    }
    
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> method2(ArrayList&lt;? <span style="color: #0000ff;">super</span> Integer&gt;<span style="color: #000000;"> arrayList) {
    }
}</span></pre>
</div>
<p class="md-end-block md-p">&nbsp;</p>
<h2 class="md-end-block md-heading"><span class="md-plain">4.4 泛型接口</span></h2>
<p class="md-end-block md-p"><span class="md-plain">泛型接口就是在接口上定义的泛型，当一个类型未确定的类实现接口时，需要声明该类型。举个例子：</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">interface</span> CalcGeneric&lt;T&gt;<span style="color: #000000;"> {
    T add(T num1, T num2);
}
​
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> CalculatorGeneric&lt;T&gt; <span style="color: #0000ff;">implements</span> CalcGeneric&lt;T&gt;<span style="color: #000000;"> {
​
    @Override
    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> T add(T num1, T num2) {
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span><span style="color: #000000;">;
    }
}</span></pre>
</div>
<h2 class="md-end-block md-heading"><span class="md-plain">4.5 泛型数组</span></h2>
<p class="md-end-block md-p"><span class="md-plain">数组是支持协变的，什么是数组的协变呢？举个例子：这段代码中，数组支持以 1 的方式定义数组，因为 Integer 是 Number 的子类，一个 Integer 对象也是一个 Number 对象，所以一个 Integer 的数组也是一个 Number 的数组，这就是数组的协变。虽然这种写法编译时能通过，但是数组实际上存储的是 Integer 对象，如果加入 Double 对象，那么在运行时就会抛出 ArrayStoreException 异常，该种设计存在缺陷。3 方式所示的定义数组方式编译错误，4 所指示的代码才是正确的。泛型是不变的，没有内建的协变类型，使用泛型的时候，类型信息在编译期会被类型擦除，所以泛型将这种错误检测移到了编译器。泛型的设计目的之一就是保证了类型安全，让这种运行时期的错误在编译期就能发现，所以泛型是不支持协变的，如 5 所示的该行代码会有编译错误，</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Test {
​
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        Number[] numbers </span>= <span style="color: #0000ff;">new</span> Integer[10]; <span style="color: #008000;">//</span><span style="color: #008000;"> 1
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> java.lang.ArrayStoreException: java.lang.Double</span>
        numbers[0] = <span style="color: #0000ff;">new</span> Double(1); <span style="color: #008000;">//</span><span style="color: #008000;"> 2
        </span><span style="color: #008000;">//</span><span style="color: #008000;">List&lt;String&gt;[] list = new ArrayList&lt;String&gt;[10]; </span><span style="color: #008000;">//</span><span style="color: #008000;"> 3</span>
        List&lt;String&gt;[] list2 = <span style="color: #0000ff;">new</span> ArrayList[10]; <span style="color: #008000;">//</span><span style="color: #008000;"> 4
        </span><span style="color: #008000;">//</span><span style="color: #008000;">List&lt;Number&gt; list3 = new ArrayList&lt;Integer&gt;(); </span><span style="color: #008000;">//</span><span style="color: #008000;"> 5</span>
<span style="color: #000000;">    }
}</span></pre>
</div>
<h2 class="md-end-block md-heading"><span class="md-plain">4.6 泛型擦除</span></h2>
<p class="md-end-block md-p"><span class="md-plain">在泛型内部，无法获得任何有关泛型参数类型的信息，泛型只在编译阶段有效，泛型类型在逻辑上可看成是多个不同的类型，但是其实质都是同一个类型。因为泛型是在JDK5之后才出现的，需要处理 JDK5之前的非泛型类库。擦除的核心动机是它使得泛化的客户端可以用非泛化的类库实现，反之亦然，这经常被称为"迁移兼容性"。</span></p>
<p class="md-end-block md-p"><span class="md-plain">代价：泛型不能用于显式地引用运行时类型地操作之中，例如转型、instanceof 操作和 new 表达式，因为所有关于参数地类型信息都丢失了。无论何时，当你在编写这个类的代码的时候，提醒自己，他只是个Object。catch 语句不能捕获泛型类型的异常。</span></p>
<p class="md-end-block md-p"><span class="md-plain">举个例子：这串代码的运行输出是，因此可见泛型在运行期间对类型进行了擦除。</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span><span style="color: #000000;"> java.util.ArrayList
</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> java.util.ArrayList
</span><span style="color: #0000ff;">true</span></pre>
</div>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> method1() {
    List</span>&lt;Integer&gt; integerArrayList = <span style="color: #0000ff;">new</span><span style="color: #000000;"> ArrayList();
    List</span>&lt;String&gt; stringArrayList = <span style="color: #0000ff;">new</span><span style="color: #000000;"> ArrayList();
​
    System.out.println(integerArrayList.getClass());
    System.out.println(stringArrayList.getClass());
    System.out.println(integerArrayList.getClass() </span>==<span style="color: #000000;"> stringArrayList.getClass());
}</span></pre>
</div>
<p class="md-end-block md-p"><span class="md-plain">将上面的 Java 代码编译成字节码后查看也可看见两个集合都是 java/util/ArrayList</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span><span style="color: #000000;"> method1()V
    L0
    LINENUMBER </span>14<span style="color: #000000;"> L0
    NEW java</span>/util/<span style="color: #000000;">ArrayList
    DUP
    INVOKESPECIAL java</span>/util/ArrayList.&lt;init&gt;<span style="color: #000000;"> ()V
    ASTORE </span>0<span style="color: #000000;">
    L1
    LINENUMBER </span>15<span style="color: #000000;"> L1
    NEW java</span>/util/<span style="color: #000000;">ArrayList
    DUP
    INVOKESPECIAL java</span>/util/ArrayList.&lt;init&gt;<span style="color: #000000;"> ()V
    ASTORE </span>1</pre>
</div>
<p class="md-end-block md-p md-focus"><span class="md-plain md-expand">因为在运行期间类型擦除的关系，可以通过反射在运行期间修改集合能添加的类，不过添加后查询该集合会抛出 ClassCastException 异常，代码如下。</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> method4() <span style="color: #0000ff;">throws</span><span style="color: #000000;"> Exception {
    ArrayList</span>&lt;String&gt; stringArrayList = <span style="color: #0000ff;">new</span> ArrayList&lt;&gt;<span style="color: #000000;">();
    stringArrayList.add(</span>"hnc"<span style="color: #000000;">);
    stringArrayList.add(</span>"boy"<span style="color: #000000;">);
    System.out.println(</span>"之前长度：" +<span style="color: #000000;"> stringArrayList.size());
​
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 通过反射增加元素</span>
    Class&lt;?&gt; clazz =<span style="color: #000000;"> stringArrayList.getClass();
    Method method </span>= clazz.getDeclaredMethod("add", Object.<span style="color: #0000ff;">class</span><span style="color: #000000;">);
    method.invoke(stringArrayList, </span>60<span style="color: #000000;">);
​
    System.out.println(</span>"之后长度：" +<span style="color: #000000;"> stringArrayList.size());
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 存的还是 Integer 类型
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String</span>
    <span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 0; i &lt; stringArrayList.size(); i++<span style="color: #000000;">) {
        System.out.println(stringArrayList.get(i).getClass());
    }
}</span></pre>
</div>
<h1 class="md-end-block md-heading"><span class="md-plain">五、总结</span></h1>
<p class="md-end-block md-p"><span class="md-plain">泛型在平时的学习中用到的还是挺多的。</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">数组不支持泛型</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">泛型的类型不能为基础数据类型</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">泛型只在编译阶段有效</span></p>
</li>
</ul>
<p class="md-end-block md-p">&nbsp;</p>
<blockquote>
<p class="md-end-block md-p"><span class="md-plain">Java 编程思想</span></p>
<p class="md-end-block md-p"><span class="md-plain">码出高效 Java 开发手册</span></p>
<p class="md-end-block md-p"><span class=" md-link"><span class="md-plain"><a href="https://blog.csdn.net/s10461/article/details/53941091">java 泛型详解</a></span></span></p>
</blockquote>
<div class="md-htmlblock md-rawblock md-end-block">​</div>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>