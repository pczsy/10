<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修源码详解系列(四) ------ DBCP2的使用和分析（包括JNDI和JTA支持）' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>源码详解系列(四) ------ DBCP2的使用和分析（包括JNDI和JTA支持）</center></div><div class='banquan'>原文出处:本文由博客园博主子月生提供。<br/>
原文连接:https://www.cnblogs.com/ZhangZiSheng001/p/12003922.html</div><br>
    <h1 id="简介">简介</h1>
<p><code>DBCP</code>用于创建和管理连接，利用“池”的方式复用连接减少资源开销，和其他连接池一样，也具有连接数控制、连接有效性检测、连接泄露控制、缓存语句等功能。目前，<code>tomcat</code>自带的连接池就是<code>DBCP</code>，Spring开发组也推荐使用<code>DBCP</code>，阿里的<code>druid</code>也是参照<code>DBCP</code>开发出来的。</p>
<p><code>DBCP</code>除了我们熟知的使用方式外，还支持通过<code>JNDI</code>获取数据源，并支持获取<code>JTA</code>或<code>XA</code>事务中用于<code>2PC</code>（两阶段提交）的连接对象，本文也将以例子说明。</p>
<p>本文将包含以下内容(因为篇幅较长，可根据需要选择阅读)：</p>
<ol>
<li><code>DBCP</code>的使用方法（入门案例说明）；</li>
<li><code>DBCP</code>的配置参数详解；</li>
<li><code>DBCP</code>主要源码分析；</li>
<li><code>DBCP</code>其他特性的使用方法，如<code>JNDI</code>和<code>JTA</code>支持。</li>
</ol>
<h1 id="使用例子">使用例子</h1>
<h2 id="需求">需求</h2>
<p>使用<code>DBCP</code>连接池获取连接对象，对用户数据进行简单的增删改查。</p>
<h2 id="工程环境">工程环境</h2>
<p><code>JDK</code>：1.8.0_201</p>
<p><code>maven</code>：3.6.1</p>
<p><code>IDE</code>：eclipse 4.12</p>
<p><code>mysql-connector-java</code>：8.0.15</p>
<p><code>mysql</code>：5.7.28</p>
<p><code>DBCP</code>：2.6.0</p>
<h2 id="主要步骤">主要步骤</h2>
<ol>
<li><p>编写<code>dbcp.properties</code>，设置数据库连接参数和连接池基本参数等。</p></li>
<li><p>通过<code>BasicDataSourceFactory</code>加载<code>dbcp.properties</code>，并获得<code>BasicDataDource</code>对象。</p></li>
<li><p>通过<code>BasicDataDource</code>对象获取<code>Connection</code>对象。</p></li>
<li><p>使用<code>Connection</code>对象对用户表进行增删改查。</p></li>
</ol>
<h2 id="创建项目">创建项目</h2>
<p>项目类型Maven Project，打包方式war（其实jar也可以，之所以使用war是为了测试<code>JNDI</code>）。</p>
<h2 id="引入依赖">引入依赖</h2>
<pre><code><code>&lt;!-- junit --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;junit&lt;/groupId&gt;
    &lt;artifactId&gt;junit&lt;/artifactId&gt;
    &lt;version&gt;4.12&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;!-- dbcp --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
    &lt;artifactId&gt;commons-dbcp2&lt;/artifactId&gt;
    &lt;version&gt;2.6.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- log4j --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;log4j&lt;/groupId&gt;
    &lt;artifactId&gt;log4j&lt;/artifactId&gt;
    &lt;version&gt;1.2.17&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- mysql驱动的jar包 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;version&gt;8.0.15&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
<h2 id="编写dbcp.prperties">编写dbcp.prperties</h2>
<p>路径<code>resources</code>目录下，因为是入门例子，这里仅给出数据库连接参数和连接池基本参数，后面源码会对配置参数进行详细说明。另外，数据库<code>sql</code>脚本也在该目录下。</p>
<pre class="properties"><code>#连接基本属性
driverClassName=com.mysql.cj.jdbc.Driver
url=jdbc:mysql://localhost:3306/github_demo?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=GMT%2B8&amp;useSSL=true
username=root
password=root

#-------------连接池大小和连接超时参数--------------------------------
#初始化连接数量:连接池启动时创建的初始化连接数量
#默认为0
initialSize=0

#最大活动连接数量:连接池在同一时间能够分配的最大活动连接的数量, 如果设置为负数则表示不限制
#默认为8
maxTotal=8

#最大空闲连接:连接池中容许保持空闲状态的最大连接数量,超过的空闲连接将被释放,如果设置为负数表示不限制
#默认为8
maxIdle=8

#最小空闲连接:连接池中容许保持空闲状态的最小连接数量,低于这个数量将创建新的连接,如果设置为0则不创建
#注意：timeBetweenEvictionRunsMillis为正数时，这个参数才能生效。
#默认为0
minIdle=0

#最大等待时间
#当没有可用连接时,连接池等待连接被归还的最大时间(以毫秒计数),超过时间则抛出异常,如果设置为&lt;=0表示无限等待
#默认-1
maxWaitMillis=-1</code></pre>
<h2 id="获取连接池和获取连接">获取连接池和获取连接</h2>
<p>项目中编写了<code>JDBCUtils</code>来初始化连接池、获取连接、管理事务和释放资源等，具体参见项目源码。</p>
<p>路径：<code>cn.zzs.dbcp</code></p>
<pre class="java"><code>    // 导入配置文件
    Properties properties = new Properties();
    InputStream in = JDBCUtil.class.getClassLoader().getResourceAsStream(&quot;dbcp.properties&quot;);
    properties.load(in);
    // 根据配置文件内容获得数据源对象
    DataSource dataSource = BasicDataSourceFactory.createDataSource(properties);
    // 获得连接
    Connection conn = dataSource.getConnection();</code></pre>
<h2 id="编写测试类">编写测试类</h2>
<p>这里以保存用户为例，路径test目录下的<code>cn.zzs.dbcp</code>。</p>
<pre class="java"><code>    @Test
    public void save() {
        // 创建sql
        String sql = &quot;insert into demo_user values(null,?,?,?,?,?)&quot;;
        Connection connection = null;
        PreparedStatement statement = null;
        try {
            // 获得连接
            connection = JDBCUtils.getConnection();
            // 开启事务设置非自动提交
            JDBCUtils.startTrasaction();
            // 获得Statement对象
            statement = connection.prepareStatement(sql);
            // 设置参数
            statement.setString(1, &quot;zzf003&quot;);
            statement.setInt(2, 18);
            statement.setDate(3, new Date(System.currentTimeMillis()));
            statement.setDate(4, new Date(System.currentTimeMillis()));
            statement.setBoolean(5, false);
            // 执行
            statement.executeUpdate();
            // 提交事务
            JDBCUtils.commit();
        } catch(Exception e) {
            JDBCUtils.rollback();
            log.error(&quot;保存用户失败&quot;, e);
        } finally {
            // 释放资源
            JDBCUtils.release(connection, statement, null);
        }
    }</code></pre>
<h1 id="配置文件详解">配置文件详解</h1>
<p>这部分内容从网上参照过来，同样的内容发的到处都是，暂时没找到出处。因为内容太过杂乱，而且最新版本更新了不少内容，所以我花了好大功夫才改好，后面找到出处再补上参考资料吧。</p>
<h2 id="基本连接属性">基本连接属性</h2>
<p>注意，这里在<code>url</code>后面拼接了多个参数用于避免乱码、时区报错问题。 补充下，如果不想加入时区的参数，可以在<code>mysql</code>命令窗口执行如下命令：<code>set global time_zone='+8:00'</code>。</p>
<pre class="properties"><code>driverClassName=com.mysql.cj.jdbc.Driver
url=jdbc:mysql://localhost:3306/github_demo?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=GMT%2B8&amp;useSSL=true
username=root
password=root</code></pre>
<h2 id="连接池大小参数">连接池大小参数</h2>
<p>这几个参数都比较常用，具体设置多少需根据项目调整。</p>
<pre class="properties"><code>#-------------连接池大小和连接超时参数--------------------------------
#初始化连接数量:连接池启动时创建的初始化连接数量
#默认为0
initialSize=0

#最大活动连接数量:连接池在同一时间能够分配的最大活动连接的数量, 如果设置为负数则表示不限制
#默认为8
maxTotal=8

#最大空闲连接:连接池中容许保持空闲状态的最大连接数量,超过的空闲连接将被释放,如果设置为负数表示不限制
#默认为8
maxIdle=8

#最小空闲连接:连接池中容许保持空闲状态的最小连接数量,低于这个数量将创建新的连接,如果设置为0则不创建
#注意：timeBetweenEvictionRunsMillis为正数时，这个参数才能生效。
#默认为0
minIdle=0

#最大等待时间
#当没有可用连接时,连接池等待连接被归还的最大时间(以毫秒计数),超过时间则抛出异常,如果设置为&lt;=0表示无限等待
#默认-1
maxWaitMillis=-1

#连接池创建的连接的默认的数据库名，如果是使用DBCP的XA连接必须设置，不然注册不了多个资源管理器
#defaultCatalog=github_demo

#连接池创建的连接的默认的schema。如果是mysql，这个设置没什么用。
#defaultSchema=github_demo</code></pre>
<h2 id="缓存语句">缓存语句</h2>
<p>缓存语句在<code>mysql</code>下建议关闭。</p>
<pre class="properties"><code>#-------------缓存语句--------------------------------
#是否缓存preparedStatement，也就是PSCache。
#PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭
#默认为false
poolPreparedStatements=false

#缓存PreparedStatements的最大个数
#默认为-1
#注意：poolPreparedStatements为true时，这个参数才有效
maxOpenPreparedStatements=-1

#缓存read-only和auto-commit状态。设置为true的话，所有连接的状态都会是一样的。
#默认是true
cacheState=true
</code></pre>
<h2 id="连接检查参数">连接检查参数</h2>
<p>针对连接失效和连接泄露的问题，建议开启<code>testWhileIdle</code>，而不是开启<code>testOnReturn</code>或<code>testOnBorrow</code>（从性能考虑）。</p>
<pre class="properties"><code>#-------------连接检查情况--------------------------------
#通过SQL查询检测连接,注意必须返回至少一行记录
#默认为空。即会调用Connection的isValid和isClosed进行检测
#注意：如果是oracle数据库的话，应该改为select 1 from dual
validationQuery=select 1 from dual

#SQL检验超时时间
validationQueryTimeout=-1

#是否从池中取出连接前进行检验。
#默认为true
testOnBorrow=true

#是否在归还到池中前进行检验 
#默认为false
testOnReturn=false

#是否开启空闲资源回收器。
#默认为false
testWhileIdle=false

#空闲资源的检测周期(单位为毫秒)。
#默认-1。即空闲资源回收器不工作。
timeBetweenEvictionRunsMillis=-1

#做空闲资源回收器时，每次的采样数。
#默认3，单位毫秒。如果设置为-1，就是对所有连接做空闲监测。
numTestsPerEvictionRun=3

#资源池中资源最小空闲时间(单位为毫秒)，达到此值后将被移除。
#默认值1000*60*30 = 30分钟
minEvictableIdleTimeMillis=1800000

#资源池中资源最小空闲时间(单位为毫秒)，达到此值后将被移除。但是会保证minIdle
#默认值-1
#softMinEvictableIdleTimeMillis=-1

#空闲资源回收策略
#默认org.apache.commons.pool2.impl.DefaultEvictionPolicy
#如果要自定义的话，需要实现EvictionPolicy重写evict方法
evictionPolicyClassName=org.apache.commons.pool2.impl.DefaultEvictionPolicy

#连接最大存活时间。非正数表示不限制
#默认-1
maxConnLifetimeMillis=-1

#当达到maxConnLifetimeMillis被关闭时，是否打印相关消息
#默认true
#注意：maxConnLifetimeMillis设置为正数时，这个参数才有效
logExpiredConnections=true</code></pre>
<h2 id="事务相关参数">事务相关参数</h2>
<p>这里的参数主要和事务相关，一般默认就行。</p>
<pre class="properties"><code>#-------------事务相关的属性--------------------------------
#连接池创建的连接的默认的auto-commit状态
#默认为空，由驱动决定
defaultAutoCommit=true

#连接池创建的连接的默认的read-only状态。
#默认值为空，由驱动决定
defaultReadOnly=false

#连接池创建的连接的默认的TransactionIsolation状态
#可用值为下列之一：NONE,READ_UNCOMMITTED, READ_COMMITTED, REPEATABLE_READ, SERIALIZABLE
#默认值为空，由驱动决定
defaultTransactionIsolation=REPEATABLE_READ

#归还连接时是否设置自动提交为true
#默认true
autoCommitOnReturn=true

#归还连接时是否设置回滚事务
#默认true
rollbackOnReturn=true
</code></pre>
<h2 id="连接泄漏回收参数">连接泄漏回收参数</h2>
<p>当我们从连接池获得了连接对象，但因为疏忽或其他原因没有<code>close</code>，这个时候这个连接对象就是一个泄露资源。通过配置以下参数可以回收这部分对象。</p>
<pre class="properties"><code>#-------------连接泄漏回收参数--------------------------------
#当未使用的时间超过removeAbandonedTimeout时，是否视该连接为泄露连接并删除（当getConnection()被调用时检测）
#默认为false
#注意：这个机制在(getNumIdle() &lt; 2) and (getNumActive() &gt; (getMaxActive() - 3))时被触发
removeAbandonedOnBorrow=false

#当未使用的时间超过removeAbandonedTimeout时，是否视该连接为泄露连接并删除（空闲evictor检测）
#默认为false
#注意：当空闲资源回收器开启才生效
removeAbandonedOnMaintenance=false

#泄露的连接可以被删除的超时值, 单位秒
#默认为300
removeAbandonedTimeout=300

#标记当Statement或连接被泄露时是否打印程序的stack traces日志。
#默认为false
logAbandoned=true

#这个不是很懂
#默认为false
abandonedUsageTracking=false
</code></pre>
<h2 id="其他">其他</h2>
<p>这部分参数比较少用。</p>
<pre class="properties"><code>#-------------其他--------------------------------
#是否使用快速失败机制
#默认为空，由驱动决定
fastFailValidation=false

#当使用快速失败机制时，设置触发的异常码
#多个code用&quot;,&quot;隔开
#disconnectionSqlCodes

#borrow连接的顺序
#默认true
lifo=true

#每个连接创建时执行的语句
#connectionInitSqls=

#连接参数：例如username、password、characterEncoding等都可以在这里设置
#多个参数用&quot;;&quot;隔开
#connectionProperties=

#指定数据源的jmx名
#jmxName=

#查询超时时间
#默认为空，即根据驱动设置
#defaultQueryTimeout=

#控制PoolGuard是否容许获取底层连接
#默认为false
accessToUnderlyingConnectionAllowed=false

#如果容许则可以使用下面的方式来获取底层物理连接:
#    Connection conn = ds.getConnection();
#    Connection dconn = ((DelegatingConnection) conn).getInnermostDelegate();
#    ...
#    conn.close();</code></pre>
<h1 id="源码分析">源码分析</h1>
<p>注意：考虑篇幅和可读性，以下代码经过删减，仅保留所需部分。</p>
<h2 id="创建数据源和连接池">创建数据源和连接池</h2>
<p>研究之前，先来看下<code>BasicDataSource</code>的<code>UML</code>图：</p>
<p><img src="./images/源码详解系列(四) ------ DBCP2的使用和分析（包括JNDI和JTA支持）0.png" alt="BasicDataSource的UML图" /></p>
<p>这里介绍下这几个类的作用：</p>
<table>
<thead>
<tr class="header">
<th>类名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>BasicDataSource</code></td>
<td>用于满足基本数据库操作需求的数据源</td>
</tr>
<tr class="even">
<td><code>BasicManagedDataSource</code></td>
<td><code>BasicDataSource</code>的子类，用于创建支持<code>XA</code>事务或<code>JTA</code>事务的连接</td>
</tr>
<tr class="odd">
<td><code>PoolingDataSource</code></td>
<td><code>BasicDataSource</code>中实际调用的数据源，可以说<code>BasicDataSource</code>只是封装了<code>PoolingDataSource</code></td>
</tr>
<tr class="even">
<td><code>ManagedDataSource</code></td>
<td><code>PoolingDataSource</code>的子类，用于支持<code>XA</code>事务或<code>JTA</code>事务的连接。是<code>BasicManagedDataSource</code>中实际调用的数据源，可以说<code>BasicManagedDataSource</code>只是封装了<code>ManagedDataSource</code></td>
</tr>
</tbody>
</table>
<p>另外，为了支持<code>JNDI</code>，<code>DBCP</code>也提供了相应的类。</p>
<table>
<thead>
<tr class="header">
<th>类名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>InstanceKeyDataSource</code></td>
<td>用于支持<code>JDNI</code>环境的数据源</td>
</tr>
<tr class="even">
<td><code>PerUserPoolDataSource</code></td>
<td><code>InstanceKeyDataSource</code>的子类，针对每个用户会单独分配一个连接池，每个连接池可以设置不同属性。例如以下需求，相比user，<code>admin</code>可以创建更多地连接以保证</td>
</tr>
<tr class="odd">
<td><code>SharedPoolDataSource</code></td>
<td><code>InstanceKeyDataSource</code>的子类，不同用户共享一个连接池</td>
</tr>
</tbody>
</table>
<p>本文的源码分析仅会涉及到<code>BasicDataSource</code>（包含它封装的<code>PoolingDataSource</code>），其他的数据源暂时不扩展。</p>
<h3 id="basicdatasource.getconnection">BasicDataSource.getConnection()</h3>
<p><code>BasicDataSourceFactory</code>只是简单地<code>new</code>了一个<code>BasicDataSource</code>对象并初始化配置参数，此时真正的数据源（<code>PoolingDataSource</code>）以及连接池（<code>GenericObjectPool&lt;PoolableConnection&gt;</code>）并没有创建，而创建的时机为我们第一次调用<code>getConnection()</code>的时候。因此，本文直接从<code>BasicDataSource</code>的<code>getConnection()</code>方法开始分析。</p>
<pre class="java"><code>    public Connection getConnection() throws SQLException {
        return createDataSource().getConnection();
    }</code></pre>
<h3 id="basicdatasource.createdatasource">BasicDataSource.createDataSource()</h3>
<p>这个方法会创建数据源和连接池，整个过程可以概括为以下几步：</p>
<ol>
<li>注册<code>MBean</code>，用于支持<code>JMX</code>；</li>
<li>创建连接池对象<code>GenericObjectPool&lt;PoolableConnection&gt;</code>；</li>
<li>创建数据源对象<code>PoolingDataSource&lt;PoolableConnection&gt;</code>；</li>
<li>初始化连接数；</li>
<li>开启空闲资源回收线程（如果设置<code>timeBetweenEvictionRunsMillis</code>为正数）。</li>
</ol>
<pre class="java"><code>    protected DataSource createDataSource() throws SQLException {
        if(closed) {
            throw new SQLException(&quot;Data source is closed&quot;);
        }
        if(dataSource != null) {
            return dataSource;
        }

        synchronized(this) {
            if(dataSource != null) {
                return dataSource;
            }
            // 注册MBean，用于支持JMX，这方面的内容不在这里扩展
            jmxRegister();

            // 创建原生Connection工厂：本质就是持有数据库驱动对象和几个连接参数
            final ConnectionFactory driverConnectionFactory = createConnectionFactory();

            // 将driverConnectionFactory包装成池化Connection工厂
            PoolableConnectionFactory poolableConnectionFactory = createPoolableConnectionFactory(driverConnectionFactory);
            // 设置PreparedStatements缓存（其实在这里可以发现，上面创建池化工厂时就设置了缓存，这里没必要再设置一遍）
            poolableConnectionFactory.setPoolStatements(poolPreparedStatements);
            poolableConnectionFactory.setMaxOpenPreparedStatements(maxOpenPreparedStatements);

            // 创建数据库连接池对象GenericObjectPool，用于管理连接
            // BasicDataSource将持有GenericObjectPool对象
            createConnectionPool(poolableConnectionFactory);

            // 创建PoolingDataSource对象
            // 该对象持有GenericObjectPool对象的引用
            DataSource newDataSource = createDataSourceInstance();
            newDataSource.setLogWriter(logWriter);

            // 根据我们设置的initialSize创建初始连接
            for(int i = 0; i &lt; initialSize; i++) {
                connectionPool.addObject();
            }

            // 开启连接池的evictor线程
            startPoolMaintenance();
            // 最后BasicDataSource将持有上面创建的PoolingDataSource对象
            dataSource = newDataSource;
            return dataSource;
        }
    }</code></pre>
<p>以上方法涉及到几个类，这里再补充下<code>UML</code>图。</p>
<p><img src="./images/源码详解系列(四) ------ DBCP2的使用和分析（包括JNDI和JTA支持）1.png" alt="GenericObjectPool的UML图" /></p>
<table>
<thead>
<tr class="header">
<th>类名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>DriverConnectionFactory</code></td>
<td>用于生成原生的Connection对象</td>
</tr>
<tr class="even">
<td><code>PoolableConnectionFactory</code></td>
<td>用于生成池化的Connection对象，持有<code>ConnectionFactory</code>对象的引用</td>
</tr>
<tr class="odd">
<td><code>GenericObjectPool</code></td>
<td>数据库连接池，用于管理连接。持有<code>PoolableConnectionFactory</code>对象的引用</td>
</tr>
</tbody>
</table>
<h2 id="获取连接对象">获取连接对象</h2>
<p>上面已经大致分析了数据源和连接池对象的获取过程，接下来研究下连接对象的获取。在此之前先了解下<code>DBCP</code>中几个<code>Connection</code>实现类。</p>
<p><img src="./images/源码详解系列(四) ------ DBCP2的使用和分析（包括JNDI和JTA支持）2.png" alt="DelegatingConnection的UML图" /></p>
<table>
<thead>
<tr class="header">
<th>类名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>DelegatingConnection</code></td>
<td><code>Connection</code>实现类，是以下几个类的父类</td>
</tr>
<tr class="even">
<td><code>PoolingConnection</code></td>
<td>用于包装原生的<code>Connection</code>，支持缓存<code>prepareStatement</code>和<code>prepareCall</code></td>
</tr>
<tr class="odd">
<td><code>PoolableConnection</code></td>
<td>用于包装原生的<code>PoolingConnection</code>(如果没有开启<code>poolPreparedStatements</code>，则包装的只是原生<code>Connection</code>)，调用<code>close()</code>时只是将连接还给连接池</td>
</tr>
<tr class="even">
<td><code>PoolableManagedConnection</code></td>
<td><code>PoolableConnection</code>的子类，用于包装<code>ManagedConnection</code>，支持<code>JTA</code>和<code>XA</code>事务</td>
</tr>
<tr class="odd">
<td><code>ManagedConnection</code></td>
<td>用于包装原生的<code>Connection</code>，支持<code>JTA</code>和<code>XA</code>事务</td>
</tr>
<tr class="even">
<td><code>PoolGuardConnectionWrapper</code></td>
<td>用于包装<code>PoolableConnection</code>，当<code>accessToUnderlyingConnectionAllowed</code>才能获取底层连接对象。我们获取到的就是这个对象</td>
</tr>
</tbody>
</table>
<p>另外，这里先概括下获得连接的整个过程：</p>
<ol>
<li>如果设置了<code>removeAbandonedOnBorrow</code>，达到条件会进行检测；</li>
<li>从连接池中获取连接，如果没有就通过工厂创建(通过<code>DriverConnectionFactory</code>创建原生对象，再通过<code>PoolableConnectionFactory</code>包装为池化对象)；</li>
<li>通过工厂重新初始化连接对象；</li>
<li>如果设置了<code>testOnBorrow</code>或者<code>testOnCreate</code>，会通过工厂校验连接有效性；</li>
<li>使用<code>PoolGuardConnectionWrapper</code>包装连接对象，并返回给客户端</li>
</ol>
<h3 id="poolingdatasource.getconnection">PoolingDataSource.getConnection()</h3>
<p>前面已经说过，<code>BasicDataSource</code>本质上是调用<code>PoolingDataSource</code>的方法来获取连接，所以这里从<code>PoolingDataSource.getConnection()</code>开始研究。</p>
<p>以下代码可知，该方法会从连接池中“借出”连接。</p>
<pre class="java"><code>    public Connection getConnection() throws SQLException {
        // 这个泛型C指的是PoolableConnection对象
        // 调用的是GenericObjectPool的方法返回PoolableConnection对象，这个方法后面会展开
        final C conn = pool.borrowObject();
        if (conn == null) {
            return null;
        }
        // 包装PoolableConnection对象，当accessToUnderlyingConnectionAllowed为true时，可以使用底层连接
        return new PoolGuardConnectionWrapper&lt;&gt;(conn);
    }</code></pre>
<h3 id="genericobjectpool.borrowobject">GenericObjectPool.borrowObject()</h3>
<p><code>GenericObjectPool</code>是一个很简练的类，里面涉及到的属性设置和锁机制都涉及得非常巧妙。</p>
<pre class="java"><code>    // 存放着连接池所有的连接对象（但不包含已经释放的）
    private final Map&lt;IdentityWrapper&lt;T&gt;, PooledObject&lt;T&gt;&gt; allObjects =
        new ConcurrentHashMap&lt;&gt;();
    // 存放着空闲连接对象的阻塞队列
    private final LinkedBlockingDeque&lt;PooledObject&lt;T&gt;&gt; idleObjects;
    // 为n&gt;1表示当前有n个线程正在创建新连接对象
    private long makeObjectCount = 0;
    // 创建连接对象时所用的锁
    private final Object makeObjectCountLock = new Object();
    // 连接对象创建总数量
    private final AtomicLong createCount = new AtomicLong(0);

    public T borrowObject() throws Exception {
        // 如果我们设置了连接获取等待时间，“借出”过程就必须在指定时间内完成
        return borrowObject(getMaxWaitMillis());
    }

    public T borrowObject(final long borrowMaxWaitMillis) throws Exception {
        // 校验连接池是否打开状态
        assertOpen();
        
        // 如果设置了removeAbandonedOnBorrow，达到触发条件是会遍历所有连接，未使用时长超过removeAbandonedTimeout的将被释放掉（一般可以检测出泄露连接）
        final AbandonedConfig ac = this.abandonedConfig;
        if (ac != null &amp;&amp; ac.getRemoveAbandonedOnBorrow() &amp;&amp;
                (getNumIdle() &lt; 2) &amp;&amp;
                (getNumActive() &gt; getMaxTotal() - 3) ) {
            removeAbandoned(ac);
        }
        
        
        PooledObject&lt;T&gt; p = null;
        // 连接数达到maxTotal是否阻塞等待
        final boolean blockWhenExhausted = getBlockWhenExhausted();

        boolean create;
        final long waitTime = System.currentTimeMillis();
        
        // 如果获取的连接对象为空，会再次进入获取
        while (p == null) {
            create = false;
            // 获取空闲队列的第一个元素，如果为空就试图创建新连接
            p = idleObjects.pollFirst();
            if (p == null) {
                // 后面分析这个方法
                p = create();
                if (p != null) {
                    create = true;
                }
            }
            // 连接数达到maxTotal且暂时没有空闲连接，这时需要阻塞等待，直到获得空闲队列中的连接或等待超时
            if (blockWhenExhausted) {
                if (p == null) {
                    if (borrowMaxWaitMillis &lt; 0) {
                        // 无限等待
                        p = idleObjects.takeFirst();
                    } else {
                        // 等待maxWaitMillis
                        p = idleObjects.pollFirst(borrowMaxWaitMillis,
                                TimeUnit.MILLISECONDS);
                    }
                }
                // 这个时候还是没有就只能抛出异常
                if (p == null) {
                    throw new NoSuchElementException(
                            &quot;Timeout waiting for idle object&quot;);
                }
            } else {
                if (p == null) {
                    throw new NoSuchElementException(&quot;Pool exhausted&quot;);
                }
            }
            // 如果连接处于空闲状态，会修改连接的state、lastBorrowTime、lastUseTime、borrowedCount等，并返回true
            if (!p.allocate()) {
                p = null;
            }

            if (p != null) {
                // 利用工厂重新初始化连接对象，这里会去校验连接存活时间、设置lastUsedTime、及其他初始参数
                try {
                    factory.activateObject(p);
                } catch (final Exception e) {
                    try {
                        destroy(p);
                    } catch (final Exception e1) {
                        // Ignore - activation failure is more important
                    }
                    p = null;
                    if (create) {
                        final NoSuchElementException nsee = new NoSuchElementException(
                                &quot;Unable to activate object&quot;);
                        nsee.initCause(e);
                        throw nsee;
                    }
                }
                // 根据设置的参数，判断是否检测连接有效性
                if (p != null &amp;&amp; (getTestOnBorrow() || create &amp;&amp; getTestOnCreate())) {
                    boolean validate = false;
                    Throwable validationThrowable = null;
                    try {
                        // 这里会去校验连接的存活时间是否超过maxConnLifetimeMillis，以及通过SQL去校验执行时间
                        validate = factory.validateObject(p);
                    } catch (final Throwable t) {
                        PoolUtils.checkRethrow(t);
                        validationThrowable = t;
                    }
                    // 如果校验不通过，会释放该对象
                    if (!validate) {
                        try {
                            destroy(p);
                            destroyedByBorrowValidationCount.incrementAndGet();
                        } catch (final Exception e) {
                            // Ignore - validation failure is more important
                        }
                        p = null;
                        if (create) {
                            final NoSuchElementException nsee = new NoSuchElementException(
                                    &quot;Unable to validate object&quot;);
                            nsee.initCause(validationThrowable);
                            throw nsee;
                        }
                    }
                }
            }
        }
        // 更新borrowedCount、idleTimes和waitTimes
        updateStatsBorrow(p, System.currentTimeMillis() - waitTime);

        return p.getObject();
    }</code></pre>
<h3 id="genericobjectpool.create">GenericObjectPool.create()</h3>
<p>这里在创建连接对象时采用的锁机制非常值得学习，简练且高效。</p>
<pre class="java"><code>    private PooledObject&lt;T&gt; create() throws Exception {
        int localMaxTotal = getMaxTotal();
        if (localMaxTotal &lt; 0) {
            localMaxTotal = Integer.MAX_VALUE;
        }

        final long localStartTimeMillis = System.currentTimeMillis();
        final long localMaxWaitTimeMillis = Math.max(getMaxWaitMillis(), 0);

        // 创建标识：
        // - TRUE:  调用工厂创建返回对象
        // - FALSE: 直接返回null
        // - null:  继续循环
        Boolean create = null;
        while (create == null) {
            synchronized (makeObjectCountLock) {
                final long newCreateCount = createCount.incrementAndGet();
                if (newCreateCount &gt; localMaxTotal) {
                    // 当前池已经达到maxTotal，或者有另外一个线程正在试图创建一个新的连接使之达到容量极限
                    createCount.decrementAndGet();
                    if (makeObjectCount == 0) {
                        // 连接池确实已达到容量极限
                        create = Boolean.FALSE;
                    } else {
                        // 当前另外一个线程正在试图创建一个新的连接使之达到容量极限，此时需要等待
                        makeObjectCountLock.wait(localMaxWaitTimeMillis);
                    }
                } else {
                    // 当前连接池容量未到达极限，可以继续创建连接对象
                    makeObjectCount++;
                    create = Boolean.TRUE;
                }
            }

            // 当达到maxWaitTimeMillis时不创建连接对象，直接退出循环
            if (create == null &amp;&amp;
                (localMaxWaitTimeMillis &gt; 0 &amp;&amp;
                 System.currentTimeMillis() - localStartTimeMillis &gt;= localMaxWaitTimeMillis)) {
                create = Boolean.FALSE;
            }
        }

        if (!create.booleanValue()) {
            return null;
        }

        final PooledObject&lt;T&gt; p;
        try {
            // 调用工厂创建对象，后面对这个方法展开分析
            p = factory.makeObject();
        } catch (final Throwable e) {
            createCount.decrementAndGet();
            throw e;
        } finally {
            synchronized (makeObjectCountLock) {
                // 创建标识-1
                makeObjectCount--;
                // 唤醒makeObjectCountLock锁住的对象
                makeObjectCountLock.notifyAll();
            }
        }

        final AbandonedConfig ac = this.abandonedConfig;
        if (ac != null &amp;&amp; ac.getLogAbandoned()) {
            p.setLogAbandoned(true);
            // TODO: in 3.0, this can use the method defined on PooledObject
            if (p instanceof DefaultPooledObject&lt;?&gt;) {
                ((DefaultPooledObject&lt;T&gt;) p).setRequireFullStackTrace(ac.getRequireFullStackTrace());
            }
        }
        // 连接数量+1
        createdCount.incrementAndGet();
        // 将创建的对象放入allObjects
        allObjects.put(new IdentityWrapper&lt;&gt;(p.getObject()), p);
        return p;
    }
</code></pre>
<h3 id="poolableconnectionfactory.makeobject">PoolableConnectionFactory.makeObject()</h3>
<pre class="java"><code>    public PooledObject&lt;PoolableConnection&gt; makeObject() throws Exception {
        // 创建原生的Connection对象
        Connection conn = connectionFactory.createConnection();
        if (conn == null) {
            throw new IllegalStateException(&quot;Connection factory returned null from createConnection&quot;);
        }
        try {
            // 执行我们设置的connectionInitSqls
            initializeConnection(conn);
        } catch (final SQLException sqle) {
            // Make sure the connection is closed
            try {
                conn.close();
            } catch (final SQLException ignore) {
                // ignore
            }
            // Rethrow original exception so it is visible to caller
            throw sqle;
        }
        // 连接索引+1
        final long connIndex = connectionIndex.getAndIncrement();
        
        // 如果设置了poolPreparedStatements，则创建包装连接为PoolingConnection对象
        if (poolStatements) {
            conn = new PoolingConnection(conn);
            final GenericKeyedObjectPoolConfig&lt;DelegatingPreparedStatement&gt; config = new GenericKeyedObjectPoolConfig&lt;&gt;();
            config.setMaxTotalPerKey(-1);
            config.setBlockWhenExhausted(false);
            config.setMaxWaitMillis(0);
            config.setMaxIdlePerKey(1);
            config.setMaxTotal(maxOpenPreparedStatements);
            if (dataSourceJmxObjectName != null) {
                final StringBuilder base = new StringBuilder(dataSourceJmxObjectName.toString());
                base.append(Constants.JMX_CONNECTION_BASE_EXT);
                base.append(Long.toString(connIndex));
                config.setJmxNameBase(base.toString());
                config.setJmxNamePrefix(Constants.JMX_STATEMENT_POOL_PREFIX);
            } else {
                config.setJmxEnabled(false);
            }
            final PoolingConnection poolingConn = (PoolingConnection) conn;
            final KeyedObjectPool&lt;PStmtKey, DelegatingPreparedStatement&gt; stmtPool = new GenericKeyedObjectPool&lt;&gt;(
                    poolingConn, config);
            poolingConn.setStatementPool(stmtPool);
            poolingConn.setCacheState(cacheState);
        }

        // 用于注册连接到JMX
        ObjectName connJmxName;
        if (dataSourceJmxObjectName == null) {
            connJmxName = null;
        } else {
            connJmxName = new ObjectName(
                    dataSourceJmxObjectName.toString() + Constants.JMX_CONNECTION_BASE_EXT + connIndex);
        }
        
        // 创建PoolableConnection对象
        final PoolableConnection pc = new PoolableConnection(conn, pool, connJmxName, disconnectionSqlCodes,
                fastFailValidation);
        pc.setCacheState(cacheState);
        
        // 包装成连接池所需的对象
        return new DefaultPooledObject&lt;&gt;(pc);
    }</code></pre>
<h2 id="空闲对象回收器evictor">空闲对象回收器Evictor</h2>
<p>以上基本已分析完连接对象的获取过程，下面再研究下空闲对象回收器。前面已经讲到当创建完数据源对象时会开启连接池的<code>evictor</code>线程，所以我们从<code>BasicDataSource.startPoolMaintenance()</code>开始分析。</p>
<h3 id="basicdatasource.startpoolmaintenance">BasicDataSource.startPoolMaintenance()</h3>
<p>前面说过<code>timeBetweenEvictionRunsMillis</code>为非正数时不会开启开启空闲对象回收器，从以下代码可以理解具体逻辑。</p>
<pre class="java"><code>    protected void startPoolMaintenance() {
        // 只有timeBetweenEvictionRunsMillis为正数，才会开启空闲对象回收器
        if (connectionPool != null &amp;&amp; timeBetweenEvictionRunsMillis &gt; 0) {
            connectionPool.setTimeBetweenEvictionRunsMillis(timeBetweenEvictionRunsMillis);
        }
    }</code></pre>
<h3 id="basegenericobjectpool.settimebetweenevictionrunsmillislong">BaseGenericObjectPool.setTimeBetweenEvictionRunsMillis(long)</h3>
<p>这个<code>BaseGenericObjectPool</code>是上面说到的<code>GenericObjectPool</code>的父类。</p>
<pre class="java"><code>    public final void setTimeBetweenEvictionRunsMillis(
            final long timeBetweenEvictionRunsMillis) {
        // 设置回收线程运行间隔时间
        this.timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
        // 继续调用本类的方法，下面继续进入方法分析
        startEvictor(timeBetweenEvictionRunsMillis);
    }</code></pre>
<h3 id="basegenericobjectpool.startevictorlong">BaseGenericObjectPool.startEvictor(long)</h3>
<p>这里会去定义一个<code>Evictor</code>对象，这个其实是一个<code>Runnable</code>对象，后面会讲到。</p>
<pre class="java"><code>    final void startEvictor(final long delay) {
        synchronized (evictionLock) {
            if (null != evictor) {
                EvictionTimer.cancel(evictor, evictorShutdownTimeoutMillis, TimeUnit.MILLISECONDS);
                evictor = null;
                evictionIterator = null;
            }
            // 创建回收器任务，并执行定时调度
            if (delay &gt; 0) {
                evictor = new Evictor();
                EvictionTimer.schedule(evictor, delay, delay);
            }
        }
    }</code></pre>
<h3 id="evictiontimer.scheduleevictor-long-long">EvictionTimer.schedule(Evictor, long, long)</h3>
<p><code>DBCP</code>是使用<code>ScheduledThreadPoolExecutor</code>来实现回收器的定时检测。 涉及到<code>ThreadPoolExecutor</code>为<code>JDK</code>自带的<code>api</code>，这里不再深入分析线程池如何实现定时调度。感兴趣的朋友可以复习下常用的几款线程池。</p>
<pre class="java"><code>    static synchronized void schedule(
            final BaseGenericObjectPool&lt;?&gt;.Evictor task, final long delay, final long period) 
        if (null == executor) {
            // 创建线程池，队列为DelayedWorkQueue，corePoolSize为1，maximumPoolSize为无限大
            executor = new ScheduledThreadPoolExecutor(1, new EvictorThreadFactory());
            // 当任务被取消的同时从等待队列中移除
            executor.setRemoveOnCancelPolicy(true);
        }
        // 设置任务定时调度
        final ScheduledFuture&lt;?&gt; scheduledFuture =
                executor.scheduleWithFixedDelay(task, delay, period, TimeUnit.MILLISECONDS);
        task.setScheduledFuture(scheduledFuture);
    }</code></pre>
<h3 id="basegenericobjectpool.evictor">BaseGenericObjectPool.Evictor</h3>
<p><code>Evictor</code>是<code>BaseGenericObjectPool</code>的内部类，实现了<code>Runnable</code>接口，这里看下它的run方法。</p>
<pre class="java"><code>    class Evictor implements Runnable {

        private ScheduledFuture&lt;?&gt; scheduledFuture;

        @Override
        public void run() {
            final ClassLoader savedClassLoader =
                    Thread.currentThread().getContextClassLoader();
            try {
                // 确保回收器使用的类加载器和工厂对象的一样
                if (factoryClassLoader != null) {
                    final ClassLoader cl = factoryClassLoader.get();
                    if (cl == null) {
                        cancel();
                        return;
                    }
                    Thread.currentThread().setContextClassLoader(cl);
                }

               
                try {
                // 回收符合条件的对象，后面继续扩展
                    evict();
                } catch(final Exception e) {
                    swallowException(e);
                } catch(final OutOfMemoryError oome) {
                    // Log problem but give evictor thread a chance to continue
                    // in case error is recoverable
                    oome.printStackTrace(System.err);
                }
                try {
                    // 确保最小空闲对象
                    ensureMinIdle();
                } catch (final Exception e) {
                    swallowException(e);
                }
            } finally {
                Thread.currentThread().setContextClassLoader(savedClassLoader);
            }
        }


        void setScheduledFuture(final ScheduledFuture&lt;?&gt; scheduledFuture) {
            this.scheduledFuture = scheduledFuture;
        }


        void cancel() {
            scheduledFuture.cancel(false);
        }
    }</code></pre>
<h3 id="genericobjectpool.evict">GenericObjectPool.evict()</h3>
<p>这里的回收过程包括以下四道校验：</p>
<ol>
<li><p>按照<code>evictionPolicy</code>校验<code>idleSoftEvictTime</code>、<code>idleEvictTime</code>；</p></li>
<li><p>利用工厂重新初始化样本，这里会校验<code>maxConnLifetimeMillis</code>（<code>testWhileIdle</code>为true）；</p></li>
<li><p>校验<code>maxConnLifetimeMillis</code>和<code>validationQueryTimeout</code>（<code>testWhileIdle</code>为true）；</p></li>
<li><p>校验所有连接的未使用时间是否超过r<code>emoveAbandonedTimeout</code>（<code>removeAbandonedOnMaintenance</code>为true）。</p></li>
</ol>
<pre class="java"><code>    public void evict() throws Exception {
        // 校验当前连接池是否关闭
        assertOpen();

        if (idleObjects.size() &gt; 0) {

            PooledObject&lt;T&gt; underTest = null;
            // 介绍参数时已经讲到，这个evictionPolicy我们可以自定义
            final EvictionPolicy&lt;T&gt; evictionPolicy = getEvictionPolicy();

            synchronized (evictionLock) {
                final EvictionConfig evictionConfig = new EvictionConfig(
                        getMinEvictableIdleTimeMillis(),
                        getSoftMinEvictableIdleTimeMillis(),
                        getMinIdle());

                final boolean testWhileIdle = getTestWhileIdle();
                // 获取我们指定的样本数，并开始遍历
                for (int i = 0, m = getNumTests(); i &lt; m; i++) {
                    if (evictionIterator == null || !evictionIterator.hasNext()) {
                        evictionIterator = new EvictionIterator(idleObjects);
                    }
                    if (!evictionIterator.hasNext()) {
                        // Pool exhausted, nothing to do here
                        return;
                    }

                    try {
                        underTest = evictionIterator.next();
                    } catch (final NoSuchElementException nsee) {
                        // 当前样本正被另一个线程借出
                        i--;
                        evictionIterator = null;
                        continue;
                    }
                    // 判断如果样本是空闲状态，设置为EVICTION状态
                    // 如果不是，说明另一个线程已经借出了这个样本
                    if (!underTest.startEvictionTest()) {
                        i--;
                        continue;
                    }

                    boolean evict;
                    try {
                        // 调用回收策略来判断是否回收该样本，按照默认策略，以下情况都会返回true：
                        // 1. 样本空闲时间大于我们设置的idleSoftEvictTime，且当前池中空闲连接数量&gt;minIdle
                        // 2.  样本空闲时间大于我们设置的idleEvictTime
                        evict = evictionPolicy.evict(evictionConfig, underTest,
                                idleObjects.size());
                    } catch (final Throwable t) {
                        PoolUtils.checkRethrow(t);
                        swallowException(new Exception(t));
                        evict = false;
                    }
                    // 如果需要回收，则释放这个样本
                    if (evict) {
                        destroy(underTest);
                        destroyedByEvictorCount.incrementAndGet();
                    } else {
                        // 如果设置了testWhileIdle，会
                        if (testWhileIdle) {
                            boolean active = false;
                            try {
                                // 利用工厂重新初始化样本，这里会校验maxConnLifetimeMillis
                                factory.activateObject(underTest);
                                active = true;
                            } catch (final Exception e) {
                                // 抛出异常标识校验不通过，释放样本
                                destroy(underTest);
                                destroyedByEvictorCount.incrementAndGet();
                            }
                            if (active) {
                                // 接下来会校验maxConnLifetimeMillis和validationQueryTimeout
                                if (!factory.validateObject(underTest)) {
                                    destroy(underTest);
                                    destroyedByEvictorCount.incrementAndGet();
                                } else {
                                    try {
                                        // 这里会将样本rollbackOnReturn、autoCommitOnReturn等
                                        factory.passivateObject(underTest);
                                    } catch (final Exception e) {
                                        destroy(underTest);
                                        destroyedByEvictorCount.incrementAndGet();
                                    }
                                }
                            }
                        }
                        // 如果状态为EVICTION或EVICTION_RETURN_TO_HEAD，修改为IDLE
                        if (!underTest.endEvictionTest(idleObjects)) {
                            //空
                        }
                    }
                }
            }
        }
        // 校验所有连接的未使用时间是否超过removeAbandonedTimeout
        final AbandonedConfig ac = this.abandonedConfig;
        if (ac != null &amp;&amp; ac.getRemoveAbandonedOnMaintenance()) {
            removeAbandoned(ac);
        }
    }</code></pre>
<p>以上已基本研究完数据源创建、连接对象获取和空闲资源回收器，后续有空再做补充。</p>
<h1 id="通过jndi获取数据源对象">通过JNDI获取数据源对象</h1>
<h2 id="需求-1">需求</h2>
<p>本文测试使用<code>JNDI</code>获取<code>PerUserPoolDataSource</code>和<code>SharedPoolDataSource</code>对象，选择使用<code>tomcat 9.0.21</code>作容器。</p>
<p>如果之前没有接触过<code>JNDI</code>，并不会影响下面例子的理解，其实可以理解为像<code>spring</code>的<code>bean</code>配置和获取。</p>
<p>源码分析时已经讲到，除了我们熟知的<code>BasicDataSource</code>，<code>DBCP</code>还提供了通过<code>JDNI</code>获取数据源，如下表。</p>
<table>
<thead>
<tr class="header">
<th>类名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>InstanceKeyDataSource</code></td>
<td>用于支持<code>JDNI</code>环境的数据源，是以下两个类的父类</td>
</tr>
<tr class="even">
<td><code>PerUserPoolDataSource</code></td>
<td><code>InstanceKeyDataSource</code>的子类，针对每个用户会单独分配一个连接池，每个连接池可以设置不同属性。例如以下需求，相比user，<code>admin</code>可以创建更多地连接以保证</td>
</tr>
<tr class="odd">
<td><code>SharedPoolDataSource</code></td>
<td><code>InstanceKeyDataSource</code>的子类，不同用户共享一个连接池</td>
</tr>
</tbody>
</table>
<h2 id="引入依赖-1">引入依赖</h2>
<p>本文在前面例子的基础上增加以下依赖，因为是web项目，所以打包方式为<code>war</code>：</p>
<pre><code><code>        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
            &lt;artifactId&gt;jstl&lt;/artifactId&gt;
            &lt;version&gt;1.2&lt;/version&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
            &lt;version&gt;3.1.0&lt;/version&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;
            &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt;
            &lt;version&gt;2.2.1&lt;/version&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;</code></pre>
<h2 id="编写context.xml">编写context.xml</h2>
<p>在<code>webapp</code>文件下创建目录<code>META-INF</code>，并创建<code>context.xml</code>文件。这里面的每个<code>resource</code>节点都是我们配置的对象，类似于<code>spring</code>的<code>bean</code>节点。其中<code>bean/DriverAdapterCPDS</code>这个对象需要被另外两个使用到。</p>
<pre><code><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;Context&gt;
    &lt;Resource 
        name=&quot;bean/SharedPoolDataSourceFactory&quot; 
        auth=&quot;Container&quot;
        type=&quot;org.apache.commons.dbcp2.datasources.SharedPoolDataSource&quot;
        factory=&quot;org.apache.commons.dbcp2.datasources.SharedPoolDataSourceFactory&quot; 
        singleton=&quot;false&quot; 
        driverClassName=&quot;com.mysql.cj.jdbc.Driver&quot;
        url=&quot;jdbc:mysql://localhost:3306/github_demo?useUnicode=true&amp;amp;characterEncoding=utf8&amp;amp;serverTimezone=GMT%2B8&amp;amp;useSSL=true&quot; 
        username=&quot;root&quot;
        password=&quot;root&quot; 
        maxTotal=&quot;8&quot; 
        maxIdle=&quot;10&quot; 
        dataSourceName=&quot;java:comp/env/bean/DriverAdapterCPDS&quot;
         /&gt;
    &lt;Resource 
        name=&quot;bean/PerUserPoolDataSourceFactory&quot; 
        auth=&quot;Container&quot;
        type=&quot;org.apache.commons.dbcp2.datasources.PerUserPoolDataSource&quot;
        factory=&quot;org.apache.commons.dbcp2.datasources.PerUserPoolDataSourceFactory&quot; 
        singleton=&quot;false&quot; 
        driverClassName=&quot;com.mysql.cj.jdbc.Driver&quot;
        url=&quot;jdbc:mysql://localhost:3306/github_demo?useUnicode=true&amp;amp;characterEncoding=utf8&amp;amp;serverTimezone=GMT%2B8&amp;amp;useSSL=true&quot; 
        username=&quot;root&quot;
        password=&quot;root&quot; 
        maxTotal=&quot;8&quot; 
        maxIdle=&quot;10&quot; 
        dataSourceName=&quot;java:comp/env/bean/DriverAdapterCPDS&quot;
         /&gt;      
    &lt;Resource 
        name=&quot;bean/DriverAdapterCPDS&quot; 
        auth=&quot;Container&quot;
        type=&quot;org.apache.commons.dbcp2.cpdsadapter.DriverAdapterCPDS&quot;
        factory=&quot;org.apache.commons.dbcp2.cpdsadapter.DriverAdapterCPDS&quot; 
        singleton=&quot;false&quot; 
        driverClassName=&quot;com.mysql.cj.jdbc.Driver&quot;
        url=&quot;jdbc:mysql://localhost:3306/github_demo?useUnicode=true&amp;amp;characterEncoding=utf8&amp;amp;serverTimezone=GMT%2B8&amp;amp;useSSL=true&quot; 
        userName=&quot;root&quot;
        userPassword=&quot;root&quot; 
        maxIdle=&quot;10&quot; 
         /&gt;      
&lt;/Context&gt;</code></pre>
<h2 id="编写web.xml">编写web.xml</h2>
<p>在<code>web-app</code>节点下配置资源引用，每个<code>resource-env-ref</code>指向了我们配置好的对象。</p>
<pre><code><code>    &lt;resource-env-ref&gt;
        &lt;description&gt;Test DriverAdapterCPDS&lt;/description&gt;
        &lt;resource-env-ref-name&gt;bean/DriverAdapterCPDS&lt;/resource-env-ref-name&gt;
        &lt;resource-env-ref-type&gt;org.apache.commons.dbcp2.cpdsadapter.DriverAdapterCPDS&lt;/resource-env-ref-type&gt;        
    &lt;/resource-env-ref&gt; 
    &lt;resource-env-ref&gt;
        &lt;description&gt;Test SharedPoolDataSource&lt;/description&gt;
        &lt;resource-env-ref-name&gt;bean/SharedPoolDataSourceFactory&lt;/resource-env-ref-name&gt;
        &lt;resource-env-ref-type&gt;org.apache.commons.dbcp2.datasources.SharedPoolDataSource&lt;/resource-env-ref-type&gt;        
    &lt;/resource-env-ref&gt;
    &lt;resource-env-ref&gt;
        &lt;description&gt;Test erUserPoolDataSource&lt;/description&gt;
        &lt;resource-env-ref-name&gt;bean/erUserPoolDataSourceFactory&lt;/resource-env-ref-name&gt;
        &lt;resource-env-ref-type&gt;org.apache.commons.dbcp2.datasources.erUserPoolDataSource&lt;/resource-env-ref-type&gt;        
    &lt;/resource-env-ref&gt; </code></pre>
<h2 id="编写jsp">编写jsp</h2>
<p>因为需要在<code>web</code>环境中使用，如果直接建类写个<code>main</code>方法测试，会一直报错的，目前没找到好的办法。这里就简单地使用<code>jsp</code>来测试吧(这是从tomcat官网参照的例子)。</p>
<pre class="jsp"><code>&lt;body&gt;
    &lt;%  
        // 获得名称服务的上下文对象
        Context initCtx = new InitialContext();
        Context envCtx = (Context)initCtx.lookup(&quot;java:comp/env/&quot;);
        
        // 查找指定名字的对象
        DataSource ds = (DataSource)envCtx.lookup(&quot;bean/SharedPoolDataSourceFactory&quot;);
        
        DataSource ds2 = (DataSource)envCtx.lookup(&quot;bean/PerUserPoolDataSourceFactory&quot;);        
        // 获取连接
        Connection conn = ds.getConnection(&quot;root&quot;,&quot;root&quot;);
        System.out.println(&quot;conn&quot; + conn); 
        Connection conn2 = ds2.getConnection(&quot;zzf&quot;,&quot;zzf&quot;);
        System.out.println(&quot;conn2&quot; + conn2); 
        
        // ... 使用连接操作数据库，以及释放资源 ...
        conn.close();
        conn2.close();
    %&gt;
&lt;/body&gt;</code></pre>
<h2 id="测试结果">测试结果</h2>
<p>打包项目在<code>tomcat9</code>上运行，访问 http://localhost:8080/DBCP-demo/testInstanceKeyDataSource.jsp ，控制台打印如下内容：</p>
<pre><code><code>conn=1971654708, URL=jdbc:mysql://localhost:3306/github_demo?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=GMT%2B8&amp;useSSL=true, UserName=root@localhost, MySQL Connector/J
conn2=128868782, URL=jdbc:mysql://localhost:3306/github_demo?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=GMT%2B8&amp;useSSL=true, UserName=zzf@localhost, MySQL Connector/J</code></pre>
<h1 id="使用dbcp测试两阶段提交">使用DBCP测试两阶段提交</h1>
<p>前面源码分析已经讲到，以下类用于支持<code>JTA</code>事务。本文将介绍如何使用<code>DBCP</code>来实现<code>JTA</code>事务两阶段提交（当然，实际项目并不支持使用<code>2PC</code>，因为性能开销太大）。</p>
<table>
<thead>
<tr class="header">
<th>类名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>BasicManagedDataSource</code></td>
<td><code>BasicDataSource</code>的子类，用于创建支持<code>XA</code>事务或<code>JTA</code>事务的连接</td>
</tr>
<tr class="even">
<td><code>ManagedDataSource</code></td>
<td><code>PoolingDataSource</code>的子类，用于支持<code>XA</code>事务或<code>JTA</code>事务的连接。是<code>BasicManagedDataSource</code>中实际调用的数据源，可以说<code>BasicManagedDataSource</code>只是封装了<code>ManagedDataSource</code></td>
</tr>
</tbody>
</table>
<h2 id="准备工作">准备工作</h2>
<p>因为测试例子使用的是<code>mysql</code>，使用<code>XA</code>事务需要开启支持。注意，<code>mysql</code>只有<code>innoDB</code>引擎才支持（另外，<code>XA</code>事务和常规事务是互斥的，如果开启了<code>XA</code>事务，其他线程进来即使只读也是不行的）。</p>
<pre class="sql"><code>SHOW VARIABLES LIKE &#39;%xa%&#39; -- 查看XA事务是否开启
SET innodb_support_xa = ON -- 开启XA事务</code></pre>
<p>除了原来的<code>github_demo</code>数据库，我另外建了一个<code>test</code>数据库，简单地模拟两个数据库。</p>
<h2 id="mysql的xa事务使用">mysql的XA事务使用</h2>
<p>测试之前，这里简单回顾下直接使用<code>sql</code>操作<code>XA</code>事务的过程，将有助于对以下内容的理解：</p>
<pre class="sql"><code>XA START &#39;my_test_xa&#39;; -- 启动一个xid为my_test_xa的事务，并使之为active状态
UPDATE github_demo.demo_user SET deleted = 1 WHERE id = &#39;1&#39;; -- 事务中的语句
XA END &#39;my_test_xa&#39;; -- 把事务置为idle状态
XA PREPARE &#39;my_test_xa&#39;; -- 把事务置为prepare状态
XA COMMIT &#39;my_test_xa&#39;; -- 提交事务
XA ROLLBACK &#39;my_test_xa&#39;; -- 回滚事务
XA RECOVER; -- 查看处于prepare状态的事务列表</code></pre>
<h2 id="引入依赖-2">引入依赖</h2>
<p>在入门例子的基础上，增加以下依赖，本文采用第三方<code>atomikos</code>的实现。</p>
<pre><code><code>        &lt;!-- jta:用于测试DBCP对JTA事务的支持 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.transaction&lt;/groupId&gt;
            &lt;artifactId&gt;jta&lt;/artifactId&gt;
            &lt;version&gt;1.1&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.atomikos&lt;/groupId&gt;
            &lt;artifactId&gt;transactions-jdbc&lt;/artifactId&gt;
            &lt;version&gt;3.9.3&lt;/version&gt;
        &lt;/dependency&gt;</code></pre>
<h2 id="获取basicmanageddatasource">获取BasicManagedDataSource</h2>
<p>这里千万记得要设置<code>DefaultCatalog</code>，否则当前事务中注册不同资源管理器时，可能都会被当成同一个资源管理器而拒绝注册并报错，因为这个问题，花了我好长时间才解决。</p>
<pre class="java"><code>    public BasicManagedDataSource getBasicManagedDataSource(
            TransactionManager transactionManager, 
            String url, 
            String username, 
            String password) {
        BasicManagedDataSource basicManagedDataSource = new BasicManagedDataSource();
        basicManagedDataSource.setTransactionManager(transactionManager);
        basicManagedDataSource.setUrl(url);
        basicManagedDataSource.setUsername(username);
        basicManagedDataSource.setPassword(password);
        basicManagedDataSource.setDefaultAutoCommit(false);
        basicManagedDataSource.setXADataSource(&quot;com.mysql.cj.jdbc.MysqlXADataSource&quot;);
        return basicManagedDataSource;
    }
    @Test
    public void test01() throws Exception {
        // 获得事务管理器
        TransactionManager transactionManager = new UserTransactionManager();
        
        // 获取第一个数据库的数据源
        BasicManagedDataSource basicManagedDataSource1 = getBasicManagedDataSource(
                transactionManager, 
                &quot;jdbc:mysql://localhost:3306/github_demo?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=GMT%2B8&amp;useSSL=true&quot;, 
                &quot;root&quot;, 
                &quot;root&quot;);
        // 注意，这一步非常重要
        basicManagedDataSource1.setDefaultCatalog(&quot;github_demo&quot;);
        
        // 获取第二个数据库的数据源
        BasicManagedDataSource basicManagedDataSource2 = getBasicManagedDataSource(
                transactionManager, 
                &quot;jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=GMT%2B8&amp;useSSL=true&quot;, 
                &quot;zzf&quot;, 
                &quot;zzf&quot;);
        // 注意，这一步非常重要
        basicManagedDataSource1.setDefaultCatalog(&quot;test&quot;);
    }</code></pre>
<h2 id="编写两阶段提交的代码">编写两阶段提交的代码</h2>
<p>通过运行代码可以发现，当数据库1和2的操作都成功，才会提交，只要其中一个数据库执行失败，两个操作都会回滚。</p>
<pre class="java"><code>    @Test
    public void test01() throws Exception { 
        Connection connection1 = null;
        Statement statement1 = null;
        Connection connection2 = null;
        Statement statement2 = null;
        transactionManager.begin();
        try {
            // 获取连接并进行数据库操作，这里会将会将XAResource注册到当前线程的XA事务对象
            /**
             * XA START xid1;-- 启动一个事务，并使之为active状态
             */
            connection1 = basicManagedDataSource1.getConnection();
            statement1 = connection1.createStatement();
            /**
             * update github_demo.demo_user set deleted = 1 where id = &#39;1&#39;; -- 事务中的语句
             */
            boolean result1 = statement1.execute(&quot;update github_demo.demo_user set deleted = 1 where id = &#39;1&#39;&quot;);
            System.out.println(result1);
            
            /**
             * XA START xid2;-- 启动一个事务，并使之为active状态
             */
            connection2 = basicManagedDataSource2.getConnection();
            statement2 = connection2.createStatement();
            /**
             * update test.demo_user set deleted = 1 where id = &#39;1&#39;; -- 事务中的语句
             */
            boolean result2 = statement2.execute(&quot;update test.demo_user set deleted = 1 where id = &#39;1&#39;&quot;);
            System.out.println(result2);
            
            /**
             * 当这执行以下语句：
             * XA END xid1; -- 把事务置为idle状态
             * XA PREPARE xid1; -- 把事务置为prepare状态
             * XA END xid2; -- 把事务置为idle状态
             * XA PREPARE xid2; -- 把事务置为prepare状态   
             * XA COMMIT xid1; -- 提交事务
             * XA COMMIT xid2; -- 提交事务
             */
            transactionManager.commit();
        } catch(Exception e) {
            e.printStackTrace();
        } finally {
            statement1.close();
            statement2.close();
            connection1.close();
            connection2.close();
        }
    }</code></pre>
<blockquote>
<p>本文为原创文章，转载请附上原文出处链接：https://github.com/ZhangZiSheng001/dbcp-demo。</p>
</blockquote>

</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>