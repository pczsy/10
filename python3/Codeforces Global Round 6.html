<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修Codeforces Global Round 6' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>Codeforces Global Round 6</center></div><div class='banquan'>原文出处:本文由博客园博主GsjzTle提供。<br/>
原文连接:https://www.cnblogs.com/StarRoadTang/p/12074716.html</div><br>
    <p><strong><span style="font-size: 18pt;">久违的写篇博客吧&nbsp;</span></strong></p>
<h1>A. Competitive Programmer</h1>
<h2>题目链接：<span style="text-decoration: underline;"><span style="color: #ff0000;"><a href="https://codeforces.com/contest/1266/problem/A" target="_blank"><span style="color: #ff0000; text-decoration: underline;">https://codeforces.com/contest/1266/problem/A</span></a></span></span></h2>
<p><span style="font-size: 16px;">题意：</span></p>
<p><span style="font-size: 16px;">给你一个只包含数字的字符串，你可以将字符串随机排列，问最后组成的数字能否被60整除</span></p>
<p><span style="font-size: 16px;">分析：</span></p>
<p><span style="font-size: 16px;">我们先考虑能被6整除的数的特点：</span></p>
<p><span style="font-size: 16px;">①各个位数和 % 3 == 0</span></p>
<p><span style="font-size: 16px;">②末尾数必须为 0 2 4 6 8中的一个</span></p>
<p><span style="font-size: 16px;">再考虑能被10整除的数的特点：</span></p>
<p><span style="font-size: 16px;">末尾数必须为0</span></p>
<p><span style="font-size: 16px;">因为60中6在十位部分 ，10在个位部分，所以最后组成的数除了各个位数和 % 3 == 0 外十位部分必须为0 、2 、4、6、8 中的一个， 个位数必须为0。</span></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('8e16fb4a-72bd-497d-998b-56344cabe10c')"><img id="code_img_closed_8e16fb4a-72bd-497d-998b-56344cabe10c" class="code_img_closed" src="./images/Codeforces Global Round 60.png" alt="" /><img id="code_img_opened_8e16fb4a-72bd-497d-998b-56344cabe10c" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('8e16fb4a-72bd-497d-998b-56344cabe10c',event)" src="./images/Codeforces Global Round 61.png" alt="" />
<div id="cnblogs_code_open_8e16fb4a-72bd-497d-998b-56344cabe10c" class="cnblogs_code_hide">
<pre><code>#include&lt;bits/stdc++.h&gt;
<span style="color: #0000ff;">#define</span> ios std::ios::sync_with_stdio(false)
<span style="color: #0000ff;">#define</span> sd(n) scanf("%d",&amp;n)
<span style="color: #0000ff;">#define</span> sdd(n,m) scanf("%d%d",&amp;n,&amp;m)
<span style="color: #0000ff;">#define</span> sddd(n,m,k) scanf("%d%d%d",&amp;n,&amp;m,&amp;k)
<span style="color: #0000ff;">#define</span> pd(n) printf("%d\n", (n))
<span style="color: #0000ff;">#define</span> pdd(n,m) printf("%d %d\n", n, m)
<span style="color: #0000ff;">#define</span> pld(n) printf("%lld\n", n)
<span style="color: #0000ff;">#define</span> pldd(n,m) printf("%lld %lld\n", n, m)
<span style="color: #0000ff;">#define</span> sld(n) scanf("%lld",&amp;n)
<span style="color: #0000ff;">#define</span> sldd(n,m) scanf("%lld%lld",&amp;n,&amp;m)
<span style="color: #0000ff;">#define</span> slddd(n,m,k) scanf("%lld%lld%lld",&amp;n,&amp;m,&amp;k)
<span style="color: #0000ff;">#define</span> sf(n) scanf("%lf",&amp;n)
<span style="color: #0000ff;">#define</span> sff(n,m) scanf("%lf%lf",&amp;n,&amp;m)
<span style="color: #0000ff;">#define</span> sfff(n,m,k) scanf("%lf%lf%lf",&amp;n,&amp;m,&amp;k)
<span style="color: #0000ff;">#define</span> rep(i,a,n) for (int i=a;i&lt;=n;i++)
<span style="color: #0000ff;">#define</span> per(i,n,a) for (int i=n;i&gt;=a;i--)
<span style="color: #0000ff;">#define</span> mm(a,n) memset(a, n, sizeof(a))
<span style="color: #0000ff;">#define</span> pb push_back
<span style="color: #0000ff;">#define</span> all(x) (x).begin(),(x).end()
<span style="color: #0000ff;">#define</span> fi first
<span style="color: #0000ff;">#define</span> se second
<span style="color: #0000ff;">#define</span> il inline
<span style="color: #0000ff;">#define</span> ll long long
<span style="color: #0000ff;">#define</span> lson rt &lt;&lt; 1
<span style="color: #0000ff;">#define</span> rson rt &lt;&lt; 1 | 1
<span style="color: #0000ff;">#define</span> MOD 1000000007
<span style="color: #0000ff;">#define</span> pi 3.14159265358979323
<span style="color: #0000ff;">#define</span> debug(x)               cout &lt;&lt;#x&lt;&lt;": "&lt;&lt;x&lt;&lt;endl
<span style="color: #0000ff;">#define</span> debug2(x, y)          cout &lt;&lt;#x&lt;&lt;": "&lt;&lt;x&lt;&lt;" | "&lt;&lt;#y&lt;&lt;": "&lt;&lt;y&lt;&lt;endl;
<span style="color: #0000ff;">#define</span> debug3(x, y, z)       cout &lt;&lt;#x&lt;&lt;": "&lt;&lt;x&lt;&lt;" | "&lt;&lt;#y&lt;&lt;": "&lt;&lt;y&lt;&lt;" | "&lt;&lt;#z&lt;&lt;": "&lt;&lt;z&lt;&lt;endl;
<span style="color: #0000ff;">#define</span> debug4(a, b, c, d)    cout &lt;&lt;#a&lt;&lt;": "&lt;&lt;a&lt;&lt;" | "&lt;&lt;#b&lt;&lt;": "&lt;&lt;b&lt;&lt;" | "&lt;&lt;#c&lt;&lt;": "&lt;&lt;c&lt;&lt;" | "&lt;&lt;#d&lt;&lt;": "&lt;&lt;d&lt;&lt;endl;
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #0000ff;">const</span><span style="color: #000000;"> ll INF (0x3f3f3f3f3f3f3f3fll);
</span><span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> inf (<span style="color: #800080;">0x3f3f3f3f</span><span style="color: #000000;">);
template</span>&lt;typename T&gt;<span style="color: #0000ff;">void</span> read(T &amp;res){<span style="color: #0000ff;">bool</span> flag=<span style="color: #0000ff;">false</span>;<span style="color: #0000ff;">char</span> ch;<span style="color: #0000ff;">while</span>(!isdigit(ch=getchar()))(ch==<span style="color: #800000;">'</span><span style="color: #800000;">-</span><span style="color: #800000;">'</span>)&amp;&amp;(flag=<span style="color: #0000ff;">true</span><span style="color: #000000;">);
</span><span style="color: #0000ff;">for</span>(res=ch-<span style="color: #800080;">48</span>;isdigit(ch=getchar());res=(res&lt;&lt;<span style="color: #800080;">1</span>)+(res&lt;&lt;<span style="color: #800080;">3</span>)+ch - <span style="color: #800080;">48</span>);flag&amp;&amp;(res=-<span style="color: #000000;">res);}
template</span>&lt;typename T&gt;<span style="color: #0000ff;">void</span> Out(T x){<span style="color: #0000ff;">if</span>(x&lt;<span style="color: #800080;">0</span>)putchar(<span style="color: #800000;">'</span><span style="color: #800000;">-</span><span style="color: #800000;">'</span>),x=-x;<span style="color: #0000ff;">if</span>(x&gt;<span style="color: #800080;">9</span>)Out(x/<span style="color: #800080;">10</span>);putchar(x%<span style="color: #800080;">10</span>+<span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">);}
ll gcd(ll a,ll b){</span><span style="color: #0000ff;">return</span> b?gcd(b,a%<span style="color: #000000;">b):a;}
ll lcm(ll a,ll b){</span><span style="color: #0000ff;">return</span> a*b/<span style="color: #000000;">gcd(a,b);}
ll pow_mod(ll x,ll n,ll mod){ll res</span>=<span style="color: #800080;">1</span>;<span style="color: #0000ff;">while</span>(n){<span style="color: #0000ff;">if</span>(n&amp;<span style="color: #800080;">1</span>)res=res*x%mod;x=x*x%mod;n&gt;&gt;=<span style="color: #800080;">1</span>;}<span style="color: #0000ff;">return</span><span style="color: #000000;"> res;}
ll fact_pow(ll n,ll p){ll res</span>=<span style="color: #800080;">0</span>;<span style="color: #0000ff;">while</span>(n){n/=p;res+=n;}<span style="color: #0000ff;">return</span><span style="color: #000000;"> res;}
ll mult(ll a,ll b,ll p){a</span>%=p;b%=p;ll r=<span style="color: #800080;">0</span>,v=a;<span style="color: #0000ff;">while</span>(b){<span style="color: #0000ff;">if</span>(b&amp;<span style="color: #800080;">1</span>){r+=v;<span style="color: #0000ff;">if</span>(r&gt;p)r-=p;}v&lt;&lt;=<span style="color: #800080;">1</span>;<span style="color: #0000ff;">if</span>(v&gt;p)v-=p;b&gt;&gt;=<span style="color: #800080;">1</span>;}<span style="color: #0000ff;">return</span><span style="color: #000000;"> r;}
ll quick_pow(ll a,ll b,ll p){ll r</span>=<span style="color: #800080;">1</span>,v=a%p;<span style="color: #0000ff;">while</span>(b){<span style="color: #0000ff;">if</span>(b&amp;<span style="color: #800080;">1</span>)r=mult(r,v,p);v=mult(v,v,p);b&gt;&gt;=<span style="color: #800080;">1</span>;}<span style="color: #0000ff;">return</span><span style="color: #000000;"> r;}
</span><span style="color: #0000ff;">bool</span><span style="color: #000000;"> CH(ll a,ll n,ll x,ll t)
{ll r</span>=quick_pow(a,x,n);ll z=r;<span style="color: #0000ff;">for</span>(ll i=<span style="color: #800080;">1</span>;i&lt;=t;i++){r=mult(r,r,n);<span style="color: #0000ff;">if</span>(r==<span style="color: #800080;">1</span>&amp;&amp;z!=<span style="color: #800080;">1</span>&amp;&amp;z!=n-<span style="color: #800080;">1</span>)<span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span>;z=r;}<span style="color: #0000ff;">return</span> r!=<span style="color: #800080;">1</span><span style="color: #000000;">;}
</span><span style="color: #0000ff;">bool</span><span style="color: #000000;"> Miller_Rabin(ll n)
{</span><span style="color: #0000ff;">if</span>(n&lt;<span style="color: #800080;">2</span>)<span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span>;<span style="color: #0000ff;">if</span>(n==<span style="color: #800080;">2</span>)<span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span>;<span style="color: #0000ff;">if</span>(!(n&amp;<span style="color: #800080;">1</span>))<span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span>;ll x=n-<span style="color: #800080;">1</span>,t=<span style="color: #800080;">0</span>;<span style="color: #0000ff;">while</span>(!(x&amp;<span style="color: #800080;">1</span>)){x&gt;&gt;=<span style="color: #800080;">1</span>;t++<span style="color: #000000;">;}srand(time(NULL));
ll o</span>=<span style="color: #800080;">8</span>;<span style="color: #0000ff;">for</span>(ll i=<span style="color: #800080;">0</span>;i&lt;o;i++){ll a=rand()%(n-<span style="color: #800080;">1</span>)+<span style="color: #800080;">1</span>;<span style="color: #0000ff;">if</span>(CH(a,n,x,t))<span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span>;}<span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;}
</span><span style="color: #008000;">/*</span><span style="color: #008000;">
int prime[30000010],minprime[30000010];
void euler(int n)
{int c=0,i,j;for(i=2;i&lt;=n;i++){if(!minprime[i])prime[++c]=i,minprime[i]=i;for(j=1;j&lt;=c&amp;&amp;i*prime[j]&lt;=n;j++)
{minprime[i*prime[j]]=prime[j];if(i%prime[j]==0)break;}}}
struct Tree{ll l,r,sum,lazy,maxn,minn;}tree[1000000];
il void push_up(ll rt)
{tree[rt].sum=tree[rt&lt;&lt;1].sum+tree[rt&lt;&lt;1|1].sum;
tree[rt].maxn=max(tree[rt&lt;&lt;1].maxn,tree[rt&lt;&lt;1|1].maxn);
tree[rt].minn=min(tree[rt&lt;&lt;1].minn,tree[rt&lt;&lt;1|1].minn);}
il void push_down(ll rt , ll now)
{if(tree[rt].lazy){tree[rt&lt;&lt;1].lazy+=tree[rt].lazy;tree[rt&lt;&lt;1|1].lazy+=tree[rt].lazy;
tree[rt&lt;&lt;1].sum+=(now-(now&gt;&gt;1))*tree[rt].lazy;tree[rt&lt;&lt;1|1].sum+=(now&gt;&gt;1)*tree[rt].lazy;
tree[rt&lt;&lt;1].minn+=tree[rt].lazy;tree[rt&lt;&lt;1|1].minn+=tree[rt].lazy;
tree[rt&lt;&lt;1].maxn+=tree[rt].lazy;tree[rt&lt;&lt;1|1].maxn+=tree[rt].lazy;tree[rt].lazy=0;}}
il void build(ll l , ll r , ll rt , ll *aa)
{tree[rt].lazy=0;tree[rt].l=l;tree[rt].r=r;if(l==r)
{tree[rt].sum=aa[l];tree[rt].minn=tree[rt].sum;tree[rt].maxn=tree[rt].sum;return;}
ll mid=(l+r)&gt;&gt;1;build(l,mid,rt&lt;&lt;1,aa);build(mid+1,r,rt&lt;&lt;1|1,aa);push_up(rt);}
il void update_range(ll L , ll R , ll key , ll rt)
{if(L&lt;=tree[rt].l&amp;&amp;R&gt;=tree[rt].r){tree[rt].sum+=(tree[rt].r-tree[rt].l+1)*key;
tree[rt].minn+=key;tree[rt].maxn+=key;tree[rt].lazy+=key;return;}push_down(rt,tree[rt].r-tree[rt].l+1);
ll mid=(tree[rt].r+tree[rt].l)&gt;&gt;1;if(L&lt;=mid)update_range(L,R,key,lson);
if(R&gt;mid)update_range(L,R,key,rson);push_up(rt);}
il ll query_range(ll L, ll R, ll rt)
{if(L&lt;=tree[rt].l&amp;&amp;R&gt;=tree[rt].r){return tree[rt].sum;}push_down(rt,tree[rt].r-tree[rt].l+1);
ll mid=(tree[rt].r+tree[rt].l)&gt;&gt;1;ll ans=0;if(L&lt;=mid)ans+=query_range(L,R,lson);
if(R&gt;mid)ans+=query_range(L,R,rson);return ans;}
il ll query_min(ll L,ll R,ll rt)
{if(L&lt;=tree[rt].l&amp;&amp;R&gt;=tree[rt].r){return tree[rt].minn;}push_down(rt,tree[rt].r-tree[rt].l+1);
ll mid=(tree[rt].r+tree[rt].l)&gt;&gt;1;ll ans=(0x3f3f3f3f3f3f3f3fll);if(L&lt;=mid)ans=min(ans,query_min(L,R,lson));
if(R&gt;mid)ans=min(ans,query_min(L,R,rson));return ans;}
il ll query_max(ll L, ll R, ll rt)
{if(L&lt;=tree[rt].l&amp;&amp;R&gt;=tree[rt].r){return tree[rt].maxn;}push_down(rt,tree[rt].r-tree[rt].l+1);
ll mid=(tree[rt].r+tree[rt].l)&gt;&gt;1;ll ans=-(0x3f3f3f3f3f3f3f3fll);if(L&lt;=mid)ans=max(ans,query_max(L,R,lson));
if(R&gt;mid)ans=max(ans,query_max(L,R,rson));return ans;}
</span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> N = 1e3 + <span style="color: #800080;">10</span><span style="color: #000000;">;
ll a[N][N];
map</span>&lt;<span style="color: #0000ff;">int</span> , <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;">ha;
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main()
{
    ios;
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> n ;
    cin </span>&gt;&gt;<span style="color: #000000;"> n;
    </span><span style="color: #0000ff;">while</span>(n --<span style="color: #000000;">) 
    {
        ha.clear();
        </span><span style="color: #0000ff;">string</span><span style="color: #000000;"> s;
        cin </span>&gt;&gt;<span style="color: #000000;"> s;
        </span><span style="color: #0000ff;">int</span> len = s.size() - <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> tot = <span style="color: #800080;">0</span><span style="color: #000000;">;
        rep(j , </span><span style="color: #800080;">0</span><span style="color: #000000;"> , len)
        {
            ha[s[j] </span>- <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span>] ++<span style="color: #000000;">;
            tot </span>+= s[j] - <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">if</span>(ha[<span style="color: #800080;">0</span>] &amp;&amp; (ha[<span style="color: #800080;">2</span>] || ha[<span style="color: #800080;">4</span>] || ha[<span style="color: #800080;">6</span>] || ha[<span style="color: #800080;">8</span>] || (ha[<span style="color: #800080;">0</span>] - <span style="color: #800080;">1</span>)) &amp;&amp; tot % <span style="color: #800080;">3</span> == <span style="color: #800080;">0</span><span style="color: #000000;">)
        cout </span>&lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">red</span><span style="color: #800000;">"</span> &lt;&lt; <span style="color: #800000;">'</span><span style="color: #800000;">\n</span><span style="color: #800000;">'</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">else</span> cout &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">cyan</span><span style="color: #800000;">"</span> &lt;&lt; <span style="color: #800000;">'</span><span style="color: #800000;">\n</span><span style="color: #800000;">'</span><span style="color: #000000;">;
 
    }
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1>B. Dice Tower</h1>
<h2>题目链接：<a href="https://codeforces.com/contest/1266/problem/B" target="_blank"><span style="text-decoration: underline;"><span style="color: #ff0000; text-decoration: underline;">https://codeforces.com/contest/1266/problem/B</span></span></a></h2>
<p><span style="font-size: 16px;">题意：</span></p>
<p><span style="font-size: 16px;">你有无限个骰子，你可以从中选出任意个来拼搭，问&ldquo;没有被挡住的点数的和&rdquo;能否组成某个数X</span></p>
<p><span style="font-size: 16px;">分析：</span></p>
<p><span style="font-size: 16px;">首先一个骰子所有点数和为21 ， 并且1的对立面为6，2的对立面为5，3对立面为4。</span></p>
<p><span style="font-size: 16px;">当骰子只有一个的时候，它被挡住的只会它的底部，那么它可以组成的数就为21 - （1~6） = 15 ~ 20</span></p>
<p><span style="font-size: 16px;">当骰子有两个的时候，因为它们要拼搭在一起，所以第一个骰子会被第二个骰子挡住一个面，第二个骰子会被第一个骰子挡住一个面，并且这两个面是对立的</span></p>
<p><span style="font-size: 16px;">所以当第二个骰子加入的时候，总的点数为原先点数 + 21（第二个骰子的总点数） - 7（第二个骰子加入时减去的部分） = &nbsp;（15 ~ 20） + 14 </span></p>
<p><span style="font-size: 16px;">加入第三个第四个第五个。。。第n个同理 ， 最后的总点数就为 （15 ~ 20） + 14 * (n - 1) ， 所以如果可以拼凑出X则 X % 14 的答案为 （15 ~ 20 ）% 14 = 1 ~ 6</span></p>
<p><span style="font-size: 16px;">所以最后只要判断X是否大于等于15并且&nbsp;X % 14 在不在 1 ~ 6 这个范围就可以了</span></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('6896426d-f317-49b5-9510-3ce45870844f')"><img id="code_img_closed_6896426d-f317-49b5-9510-3ce45870844f" class="code_img_closed" src="./images/Codeforces Global Round 60.png" alt="" /><img id="code_img_opened_6896426d-f317-49b5-9510-3ce45870844f" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('6896426d-f317-49b5-9510-3ce45870844f',event)" src="./images/Codeforces Global Round 61.png" alt="" />
<div id="cnblogs_code_open_6896426d-f317-49b5-9510-3ce45870844f" class="cnblogs_code_hide">
<pre><code>#include&lt;bits/stdc++.h&gt;
<span style="color: #0000ff;">#define</span> ios std::ios::sync_with_stdio(false)
<span style="color: #0000ff;">#define</span> sd(n) scanf("%d",&amp;n)
<span style="color: #0000ff;">#define</span> sdd(n,m) scanf("%d%d",&amp;n,&amp;m)
<span style="color: #0000ff;">#define</span> sddd(n,m,k) scanf("%d%d%d",&amp;n,&amp;m,&amp;k)
<span style="color: #0000ff;">#define</span> pd(n) printf("%d\n", (n))
<span style="color: #0000ff;">#define</span> pdd(n,m) printf("%d %d\n", n, m)
<span style="color: #0000ff;">#define</span> pld(n) printf("%lld\n", n)
<span style="color: #0000ff;">#define</span> pldd(n,m) printf("%lld %lld\n", n, m)
<span style="color: #0000ff;">#define</span> sld(n) scanf("%lld",&amp;n)
<span style="color: #0000ff;">#define</span> sldd(n,m) scanf("%lld%lld",&amp;n,&amp;m)
<span style="color: #0000ff;">#define</span> slddd(n,m,k) scanf("%lld%lld%lld",&amp;n,&amp;m,&amp;k)
<span style="color: #0000ff;">#define</span> sf(n) scanf("%lf",&amp;n)
<span style="color: #0000ff;">#define</span> sff(n,m) scanf("%lf%lf",&amp;n,&amp;m)
<span style="color: #0000ff;">#define</span> sfff(n,m,k) scanf("%lf%lf%lf",&amp;n,&amp;m,&amp;k)
<span style="color: #0000ff;">#define</span> rep(i,a,n) for (int i=a;i&lt;=n;i++)
<span style="color: #0000ff;">#define</span> per(i,n,a) for (int i=n;i&gt;=a;i--)
<span style="color: #0000ff;">#define</span> mm(a,n) memset(a, n, sizeof(a))
<span style="color: #0000ff;">#define</span> pb push_back
<span style="color: #0000ff;">#define</span> all(x) (x).begin(),(x).end()
<span style="color: #0000ff;">#define</span> fi first
<span style="color: #0000ff;">#define</span> se second
<span style="color: #0000ff;">#define</span> il inline
<span style="color: #0000ff;">#define</span> ll long long
<span style="color: #0000ff;">#define</span> lson rt &lt;&lt; 1
<span style="color: #0000ff;">#define</span> rson rt &lt;&lt; 1 | 1
<span style="color: #0000ff;">#define</span> MOD 1000000007
<span style="color: #0000ff;">#define</span> pi 3.14159265358979323
<span style="color: #0000ff;">#define</span> debug(x)               cout &lt;&lt;#x&lt;&lt;": "&lt;&lt;x&lt;&lt;endl
<span style="color: #0000ff;">#define</span> debug2(x, y)          cout &lt;&lt;#x&lt;&lt;": "&lt;&lt;x&lt;&lt;" | "&lt;&lt;#y&lt;&lt;": "&lt;&lt;y&lt;&lt;endl;
<span style="color: #0000ff;">#define</span> debug3(x, y, z)       cout &lt;&lt;#x&lt;&lt;": "&lt;&lt;x&lt;&lt;" | "&lt;&lt;#y&lt;&lt;": "&lt;&lt;y&lt;&lt;" | "&lt;&lt;#z&lt;&lt;": "&lt;&lt;z&lt;&lt;endl;
<span style="color: #0000ff;">#define</span> debug4(a, b, c, d)    cout &lt;&lt;#a&lt;&lt;": "&lt;&lt;a&lt;&lt;" | "&lt;&lt;#b&lt;&lt;": "&lt;&lt;b&lt;&lt;" | "&lt;&lt;#c&lt;&lt;": "&lt;&lt;c&lt;&lt;" | "&lt;&lt;#d&lt;&lt;": "&lt;&lt;d&lt;&lt;endl;
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #0000ff;">const</span><span style="color: #000000;"> ll INF (0x3f3f3f3f3f3f3f3fll);
</span><span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> inf (<span style="color: #800080;">0x3f3f3f3f</span><span style="color: #000000;">);
template</span>&lt;typename T&gt;<span style="color: #0000ff;">void</span> read(T &amp;res){<span style="color: #0000ff;">bool</span> flag=<span style="color: #0000ff;">false</span>;<span style="color: #0000ff;">char</span> ch;<span style="color: #0000ff;">while</span>(!isdigit(ch=getchar()))(ch==<span style="color: #800000;">'</span><span style="color: #800000;">-</span><span style="color: #800000;">'</span>)&amp;&amp;(flag=<span style="color: #0000ff;">true</span><span style="color: #000000;">);
</span><span style="color: #0000ff;">for</span>(res=ch-<span style="color: #800080;">48</span>;isdigit(ch=getchar());res=(res&lt;&lt;<span style="color: #800080;">1</span>)+(res&lt;&lt;<span style="color: #800080;">3</span>)+ch - <span style="color: #800080;">48</span>);flag&amp;&amp;(res=-<span style="color: #000000;">res);}
template</span>&lt;typename T&gt;<span style="color: #0000ff;">void</span> Out(T x){<span style="color: #0000ff;">if</span>(x&lt;<span style="color: #800080;">0</span>)putchar(<span style="color: #800000;">'</span><span style="color: #800000;">-</span><span style="color: #800000;">'</span>),x=-x;<span style="color: #0000ff;">if</span>(x&gt;<span style="color: #800080;">9</span>)Out(x/<span style="color: #800080;">10</span>);putchar(x%<span style="color: #800080;">10</span>+<span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">);}
ll gcd(ll a,ll b){</span><span style="color: #0000ff;">return</span> b?gcd(b,a%<span style="color: #000000;">b):a;}
ll lcm(ll a,ll b){</span><span style="color: #0000ff;">return</span> a*b/<span style="color: #000000;">gcd(a,b);}
ll pow_mod(ll x,ll n,ll mod){ll res</span>=<span style="color: #800080;">1</span>;<span style="color: #0000ff;">while</span>(n){<span style="color: #0000ff;">if</span>(n&amp;<span style="color: #800080;">1</span>)res=res*x%mod;x=x*x%mod;n&gt;&gt;=<span style="color: #800080;">1</span>;}<span style="color: #0000ff;">return</span><span style="color: #000000;"> res;}
ll fact_pow(ll n,ll p){ll res</span>=<span style="color: #800080;">0</span>;<span style="color: #0000ff;">while</span>(n){n/=p;res+=n;}<span style="color: #0000ff;">return</span><span style="color: #000000;"> res;}
ll mult(ll a,ll b,ll p){a</span>%=p;b%=p;ll r=<span style="color: #800080;">0</span>,v=a;<span style="color: #0000ff;">while</span>(b){<span style="color: #0000ff;">if</span>(b&amp;<span style="color: #800080;">1</span>){r+=v;<span style="color: #0000ff;">if</span>(r&gt;p)r-=p;}v&lt;&lt;=<span style="color: #800080;">1</span>;<span style="color: #0000ff;">if</span>(v&gt;p)v-=p;b&gt;&gt;=<span style="color: #800080;">1</span>;}<span style="color: #0000ff;">return</span><span style="color: #000000;"> r;}
ll quick_pow(ll a,ll b,ll p){ll r</span>=<span style="color: #800080;">1</span>,v=a%p;<span style="color: #0000ff;">while</span>(b){<span style="color: #0000ff;">if</span>(b&amp;<span style="color: #800080;">1</span>)r=mult(r,v,p);v=mult(v,v,p);b&gt;&gt;=<span style="color: #800080;">1</span>;}<span style="color: #0000ff;">return</span><span style="color: #000000;"> r;}
</span><span style="color: #0000ff;">bool</span><span style="color: #000000;"> CH(ll a,ll n,ll x,ll t)
{ll r</span>=quick_pow(a,x,n);ll z=r;<span style="color: #0000ff;">for</span>(ll i=<span style="color: #800080;">1</span>;i&lt;=t;i++){r=mult(r,r,n);<span style="color: #0000ff;">if</span>(r==<span style="color: #800080;">1</span>&amp;&amp;z!=<span style="color: #800080;">1</span>&amp;&amp;z!=n-<span style="color: #800080;">1</span>)<span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span>;z=r;}<span style="color: #0000ff;">return</span> r!=<span style="color: #800080;">1</span><span style="color: #000000;">;}
</span><span style="color: #0000ff;">bool</span><span style="color: #000000;"> Miller_Rabin(ll n)
{</span><span style="color: #0000ff;">if</span>(n&lt;<span style="color: #800080;">2</span>)<span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span>;<span style="color: #0000ff;">if</span>(n==<span style="color: #800080;">2</span>)<span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span>;<span style="color: #0000ff;">if</span>(!(n&amp;<span style="color: #800080;">1</span>))<span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span>;ll x=n-<span style="color: #800080;">1</span>,t=<span style="color: #800080;">0</span>;<span style="color: #0000ff;">while</span>(!(x&amp;<span style="color: #800080;">1</span>)){x&gt;&gt;=<span style="color: #800080;">1</span>;t++<span style="color: #000000;">;}srand(time(NULL));
ll o</span>=<span style="color: #800080;">8</span>;<span style="color: #0000ff;">for</span>(ll i=<span style="color: #800080;">0</span>;i&lt;o;i++){ll a=rand()%(n-<span style="color: #800080;">1</span>)+<span style="color: #800080;">1</span>;<span style="color: #0000ff;">if</span>(CH(a,n,x,t))<span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span>;}<span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;}
</span><span style="color: #008000;">/*</span><span style="color: #008000;">
int prime[30000010],minprime[30000010];
void euler(int n)
{int c=0,i,j;for(i=2;i&lt;=n;i++){if(!minprime[i])prime[++c]=i,minprime[i]=i;for(j=1;j&lt;=c&amp;&amp;i*prime[j]&lt;=n;j++)
{minprime[i*prime[j]]=prime[j];if(i%prime[j]==0)break;}}}
struct Tree{ll l,r,sum,lazy,maxn,minn;}tree[1000000];
il void push_up(ll rt)
{tree[rt].sum=tree[rt&lt;&lt;1].sum+tree[rt&lt;&lt;1|1].sum;
tree[rt].maxn=max(tree[rt&lt;&lt;1].maxn,tree[rt&lt;&lt;1|1].maxn);
tree[rt].minn=min(tree[rt&lt;&lt;1].minn,tree[rt&lt;&lt;1|1].minn);}
il void push_down(ll rt , ll now)
{if(tree[rt].lazy){tree[rt&lt;&lt;1].lazy+=tree[rt].lazy;tree[rt&lt;&lt;1|1].lazy+=tree[rt].lazy;
tree[rt&lt;&lt;1].sum+=(now-(now&gt;&gt;1))*tree[rt].lazy;tree[rt&lt;&lt;1|1].sum+=(now&gt;&gt;1)*tree[rt].lazy;
tree[rt&lt;&lt;1].minn+=tree[rt].lazy;tree[rt&lt;&lt;1|1].minn+=tree[rt].lazy;
tree[rt&lt;&lt;1].maxn+=tree[rt].lazy;tree[rt&lt;&lt;1|1].maxn+=tree[rt].lazy;tree[rt].lazy=0;}}
il void build(ll l , ll r , ll rt , ll *aa)
{tree[rt].lazy=0;tree[rt].l=l;tree[rt].r=r;if(l==r)
{tree[rt].sum=aa[l];tree[rt].minn=tree[rt].sum;tree[rt].maxn=tree[rt].sum;return;}
ll mid=(l+r)&gt;&gt;1;build(l,mid,rt&lt;&lt;1,aa);build(mid+1,r,rt&lt;&lt;1|1,aa);push_up(rt);}
il void update_range(ll L , ll R , ll key , ll rt)
{if(L&lt;=tree[rt].l&amp;&amp;R&gt;=tree[rt].r){tree[rt].sum+=(tree[rt].r-tree[rt].l+1)*key;
tree[rt].minn+=key;tree[rt].maxn+=key;tree[rt].lazy+=key;return;}push_down(rt,tree[rt].r-tree[rt].l+1);
ll mid=(tree[rt].r+tree[rt].l)&gt;&gt;1;if(L&lt;=mid)update_range(L,R,key,lson);
if(R&gt;mid)update_range(L,R,key,rson);push_up(rt);}
il ll query_range(ll L, ll R, ll rt)
{if(L&lt;=tree[rt].l&amp;&amp;R&gt;=tree[rt].r){return tree[rt].sum;}push_down(rt,tree[rt].r-tree[rt].l+1);
ll mid=(tree[rt].r+tree[rt].l)&gt;&gt;1;ll ans=0;if(L&lt;=mid)ans+=query_range(L,R,lson);
if(R&gt;mid)ans+=query_range(L,R,rson);return ans;}
il ll query_min(ll L,ll R,ll rt)
{if(L&lt;=tree[rt].l&amp;&amp;R&gt;=tree[rt].r){return tree[rt].minn;}push_down(rt,tree[rt].r-tree[rt].l+1);
ll mid=(tree[rt].r+tree[rt].l)&gt;&gt;1;ll ans=(0x3f3f3f3f3f3f3f3fll);if(L&lt;=mid)ans=min(ans,query_min(L,R,lson));
if(R&gt;mid)ans=min(ans,query_min(L,R,rson));return ans;}
il ll query_max(ll L, ll R, ll rt)
{if(L&lt;=tree[rt].l&amp;&amp;R&gt;=tree[rt].r){return tree[rt].maxn;}push_down(rt,tree[rt].r-tree[rt].l+1);
ll mid=(tree[rt].r+tree[rt].l)&gt;&gt;1;ll ans=-(0x3f3f3f3f3f3f3f3fll);if(L&lt;=mid)ans=max(ans,query_max(L,R,lson));
if(R&gt;mid)ans=max(ans,query_max(L,R,rson));return ans;}
</span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> N = 1e3 + <span style="color: #800080;">10</span><span style="color: #000000;">;
ll a[N][N];
map</span>&lt;<span style="color: #0000ff;">int</span> , <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;">ha;
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main()
{
    ios;
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> t;
    cin </span>&gt;&gt;<span style="color: #000000;"> t;
    </span><span style="color: #0000ff;">while</span>(t --<span style="color: #000000;">) 
    {
        ll x;
        cin </span>&gt;&gt;<span style="color: #000000;"> x;
        </span><span style="color: #0000ff;">if</span>(x &lt; <span style="color: #800080;">15</span><span style="color: #000000;">)
        {
            cout </span>&lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">NO</span><span style="color: #800000;">"</span> &lt;&lt; <span style="color: #800000;">'</span><span style="color: #800000;">\n</span><span style="color: #800000;">'</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">continue</span><span style="color: #000000;">;
        }
        x </span>%= <span style="color: #800080;">14</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span>(x &gt; <span style="color: #800080;">6</span> || x &lt; <span style="color: #800080;">1</span><span style="color: #000000;">)
        cout </span>&lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">NO</span><span style="color: #800000;">"</span> &lt;&lt; <span style="color: #800000;">'</span><span style="color: #800000;">\n</span><span style="color: #800000;">'</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> 
        cout </span>&lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">YES</span><span style="color: #800000;">"</span> &lt;&lt; <span style="color: #800000;">'</span><span style="color: #800000;">\n</span><span style="color: #800000;">'</span><span style="color: #000000;">;
    }
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1>C. Diverse Matrix</h1>
<h2>题目链接：<span style="text-decoration: underline;"><a href="https://codeforces.com/contest/1266/problem/C" target="_blank"><span style="color: #ff0000; text-decoration: underline;">https://codeforces.com/contest/1266/problem/C</span></a></span></h2>
<p><span style="font-size: 16px;">题意：</span></p>
<p><span style="font-size: 16px;">要求构造一个 r 行 c 列的矩阵， 并且矩阵的每一行的gcd和每一列的gcd的都只出现过一次，且每行的gcd都要求最小</span></p>
<p><span style="font-size: 16px;">分析：</span></p>
<p><span style="font-size: 16px;">首先当 r = 1 &amp;&amp; c = 1 的时候， 它的行gcd和列gcd为同一元素， 所以是无法构造出来的</span></p>
<p><span style="font-size: 16px;">当 r = 1 或者 c = 1 时 ， 我们可以 1 2 3 4 5 6 ... 输出</span></p>
<p><span style="font-size: 16px;">对于其它的可能，我们考虑这么构造：</span></p>
<p><span style="font-size: 16px;">假设 r = 2 ， c = 2 ， A 、B 、C 、D 为矩阵元素</span></p>
<p><span style="font-size: 16px;">1 | &nbsp;A &nbsp; C</span></p>
<p><span style="font-size: 16px;">2 | &nbsp;B &nbsp; D &nbsp; &nbsp;我们可以让第一行的gcd结果为1 ， 第二行gcd结果为2，第一列gcd结果为3，第二列gcd结果为4</span></p>
<p><span style="font-size: 16px;">&nbsp; 　3 &nbsp; 4 &nbsp; &nbsp; &nbsp;</span></p>
<p><span style="font-size: 16px;">则 A = 1 * 3 , B = 2 * 3 , C = 1 * 4 , D = 2 * 4 这样构造即可</span></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('6ef5490f-3310-4719-914f-f21f5f9225bd')"><img id="code_img_closed_6ef5490f-3310-4719-914f-f21f5f9225bd" class="code_img_closed" src="./images/Codeforces Global Round 60.png" alt="" /><img id="code_img_opened_6ef5490f-3310-4719-914f-f21f5f9225bd" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('6ef5490f-3310-4719-914f-f21f5f9225bd',event)" src="./images/Codeforces Global Round 61.png" alt="" />
<div id="cnblogs_code_open_6ef5490f-3310-4719-914f-f21f5f9225bd" class="cnblogs_code_hide">
<pre><code>#include&lt;bits/stdc++.h&gt;
<span style="color: #0000ff;">#define</span> ios std::ios::sync_with_stdio(false)
<span style="color: #0000ff;">#define</span> sd(n) scanf("%d",&amp;n)
<span style="color: #0000ff;">#define</span> sdd(n,m) scanf("%d%d",&amp;n,&amp;m)
<span style="color: #0000ff;">#define</span> sddd(n,m,k) scanf("%d%d%d",&amp;n,&amp;m,&amp;k)
<span style="color: #0000ff;">#define</span> pd(n) printf("%d\n", (n))
<span style="color: #0000ff;">#define</span> pdd(n,m) printf("%d %d\n", n, m)
<span style="color: #0000ff;">#define</span> pld(n) printf("%lld\n", n)
<span style="color: #0000ff;">#define</span> pldd(n,m) printf("%lld %lld\n", n, m)
<span style="color: #0000ff;">#define</span> sld(n) scanf("%lld",&amp;n)
<span style="color: #0000ff;">#define</span> sldd(n,m) scanf("%lld%lld",&amp;n,&amp;m)
<span style="color: #0000ff;">#define</span> slddd(n,m,k) scanf("%lld%lld%lld",&amp;n,&amp;m,&amp;k)
<span style="color: #0000ff;">#define</span> sf(n) scanf("%lf",&amp;n)
<span style="color: #0000ff;">#define</span> sff(n,m) scanf("%lf%lf",&amp;n,&amp;m)
<span style="color: #0000ff;">#define</span> sfff(n,m,k) scanf("%lf%lf%lf",&amp;n,&amp;m,&amp;k)
<span style="color: #0000ff;">#define</span> rep(i,a,n) for (int i=a;i&lt;=n;i++)
<span style="color: #0000ff;">#define</span> per(i,n,a) for (int i=n;i&gt;=a;i--)
<span style="color: #0000ff;">#define</span> mm(a,n) memset(a, n, sizeof(a))
<span style="color: #0000ff;">#define</span> pb push_back
<span style="color: #0000ff;">#define</span> all(x) (x).begin(),(x).end()
<span style="color: #0000ff;">#define</span> fi first
<span style="color: #0000ff;">#define</span> se second
<span style="color: #0000ff;">#define</span> il inline
<span style="color: #0000ff;">#define</span> ll long long
<span style="color: #0000ff;">#define</span> lson rt &lt;&lt; 1
<span style="color: #0000ff;">#define</span> rson rt &lt;&lt; 1 | 1
<span style="color: #0000ff;">#define</span> MOD 1000000007
<span style="color: #0000ff;">#define</span> pi 3.14159265358979323
<span style="color: #0000ff;">#define</span> debug(x)               cout &lt;&lt;#x&lt;&lt;": "&lt;&lt;x&lt;&lt;endl
<span style="color: #0000ff;">#define</span> debug2(x, y)          cout &lt;&lt;#x&lt;&lt;": "&lt;&lt;x&lt;&lt;" | "&lt;&lt;#y&lt;&lt;": "&lt;&lt;y&lt;&lt;endl;
<span style="color: #0000ff;">#define</span> debug3(x, y, z)       cout &lt;&lt;#x&lt;&lt;": "&lt;&lt;x&lt;&lt;" | "&lt;&lt;#y&lt;&lt;": "&lt;&lt;y&lt;&lt;" | "&lt;&lt;#z&lt;&lt;": "&lt;&lt;z&lt;&lt;endl;
<span style="color: #0000ff;">#define</span> debug4(a, b, c, d)    cout &lt;&lt;#a&lt;&lt;": "&lt;&lt;a&lt;&lt;" | "&lt;&lt;#b&lt;&lt;": "&lt;&lt;b&lt;&lt;" | "&lt;&lt;#c&lt;&lt;": "&lt;&lt;c&lt;&lt;" | "&lt;&lt;#d&lt;&lt;": "&lt;&lt;d&lt;&lt;endl;
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #0000ff;">const</span><span style="color: #000000;"> ll INF (0x3f3f3f3f3f3f3f3fll);
</span><span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> inf (<span style="color: #800080;">0x3f3f3f3f</span><span style="color: #000000;">);
template</span>&lt;typename T&gt;<span style="color: #0000ff;">void</span> read(T &amp;res){<span style="color: #0000ff;">bool</span> flag=<span style="color: #0000ff;">false</span>;<span style="color: #0000ff;">char</span> ch;<span style="color: #0000ff;">while</span>(!isdigit(ch=getchar()))(ch==<span style="color: #800000;">'</span><span style="color: #800000;">-</span><span style="color: #800000;">'</span>)&amp;&amp;(flag=<span style="color: #0000ff;">true</span><span style="color: #000000;">);
</span><span style="color: #0000ff;">for</span>(res=ch-<span style="color: #800080;">48</span>;isdigit(ch=getchar());res=(res&lt;&lt;<span style="color: #800080;">1</span>)+(res&lt;&lt;<span style="color: #800080;">3</span>)+ch - <span style="color: #800080;">48</span>);flag&amp;&amp;(res=-<span style="color: #000000;">res);}
template</span>&lt;typename T&gt;<span style="color: #0000ff;">void</span> Out(T x){<span style="color: #0000ff;">if</span>(x&lt;<span style="color: #800080;">0</span>)putchar(<span style="color: #800000;">'</span><span style="color: #800000;">-</span><span style="color: #800000;">'</span>),x=-x;<span style="color: #0000ff;">if</span>(x&gt;<span style="color: #800080;">9</span>)Out(x/<span style="color: #800080;">10</span>);putchar(x%<span style="color: #800080;">10</span>+<span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">);}
ll gcd(ll a,ll b){</span><span style="color: #0000ff;">return</span> b?gcd(b,a%<span style="color: #000000;">b):a;}
ll lcm(ll a,ll b){</span><span style="color: #0000ff;">return</span> a*b/<span style="color: #000000;">gcd(a,b);}
ll pow_mod(ll x,ll n,ll mod){ll res</span>=<span style="color: #800080;">1</span>;<span style="color: #0000ff;">while</span>(n){<span style="color: #0000ff;">if</span>(n&amp;<span style="color: #800080;">1</span>)res=res*x%mod;x=x*x%mod;n&gt;&gt;=<span style="color: #800080;">1</span>;}<span style="color: #0000ff;">return</span><span style="color: #000000;"> res;}
ll fact_pow(ll n,ll p){ll res</span>=<span style="color: #800080;">0</span>;<span style="color: #0000ff;">while</span>(n){n/=p;res+=n;}<span style="color: #0000ff;">return</span><span style="color: #000000;"> res;}
ll mult(ll a,ll b,ll p){a</span>%=p;b%=p;ll r=<span style="color: #800080;">0</span>,v=a;<span style="color: #0000ff;">while</span>(b){<span style="color: #0000ff;">if</span>(b&amp;<span style="color: #800080;">1</span>){r+=v;<span style="color: #0000ff;">if</span>(r&gt;p)r-=p;}v&lt;&lt;=<span style="color: #800080;">1</span>;<span style="color: #0000ff;">if</span>(v&gt;p)v-=p;b&gt;&gt;=<span style="color: #800080;">1</span>;}<span style="color: #0000ff;">return</span><span style="color: #000000;"> r;}
ll quick_pow(ll a,ll b,ll p){ll r</span>=<span style="color: #800080;">1</span>,v=a%p;<span style="color: #0000ff;">while</span>(b){<span style="color: #0000ff;">if</span>(b&amp;<span style="color: #800080;">1</span>)r=mult(r,v,p);v=mult(v,v,p);b&gt;&gt;=<span style="color: #800080;">1</span>;}<span style="color: #0000ff;">return</span><span style="color: #000000;"> r;}
</span><span style="color: #0000ff;">bool</span><span style="color: #000000;"> CH(ll a,ll n,ll x,ll t)
{ll r</span>=quick_pow(a,x,n);ll z=r;<span style="color: #0000ff;">for</span>(ll i=<span style="color: #800080;">1</span>;i&lt;=t;i++){r=mult(r,r,n);<span style="color: #0000ff;">if</span>(r==<span style="color: #800080;">1</span>&amp;&amp;z!=<span style="color: #800080;">1</span>&amp;&amp;z!=n-<span style="color: #800080;">1</span>)<span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span>;z=r;}<span style="color: #0000ff;">return</span> r!=<span style="color: #800080;">1</span><span style="color: #000000;">;}
</span><span style="color: #0000ff;">bool</span><span style="color: #000000;"> Miller_Rabin(ll n)
{</span><span style="color: #0000ff;">if</span>(n&lt;<span style="color: #800080;">2</span>)<span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span>;<span style="color: #0000ff;">if</span>(n==<span style="color: #800080;">2</span>)<span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span>;<span style="color: #0000ff;">if</span>(!(n&amp;<span style="color: #800080;">1</span>))<span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span>;ll x=n-<span style="color: #800080;">1</span>,t=<span style="color: #800080;">0</span>;<span style="color: #0000ff;">while</span>(!(x&amp;<span style="color: #800080;">1</span>)){x&gt;&gt;=<span style="color: #800080;">1</span>;t++<span style="color: #000000;">;}srand(time(NULL));
ll o</span>=<span style="color: #800080;">8</span>;<span style="color: #0000ff;">for</span>(ll i=<span style="color: #800080;">0</span>;i&lt;o;i++){ll a=rand()%(n-<span style="color: #800080;">1</span>)+<span style="color: #800080;">1</span>;<span style="color: #0000ff;">if</span>(CH(a,n,x,t))<span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span>;}<span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;}
</span><span style="color: #008000;">/*</span><span style="color: #008000;">
int prime[30000010],minprime[30000010];
void euler(int n)
{int c=0,i,j;for(i=2;i&lt;=n;i++){if(!minprime[i])prime[++c]=i,minprime[i]=i;for(j=1;j&lt;=c&amp;&amp;i*prime[j]&lt;=n;j++)
{minprime[i*prime[j]]=prime[j];if(i%prime[j]==0)break;}}}
struct Tree{ll l,r,sum,lazy,maxn,minn;}tree[1000000];
il void push_up(ll rt)
{tree[rt].sum=tree[rt&lt;&lt;1].sum+tree[rt&lt;&lt;1|1].sum;
tree[rt].maxn=max(tree[rt&lt;&lt;1].maxn,tree[rt&lt;&lt;1|1].maxn);
tree[rt].minn=min(tree[rt&lt;&lt;1].minn,tree[rt&lt;&lt;1|1].minn);}
il void push_down(ll rt , ll now)
{if(tree[rt].lazy){tree[rt&lt;&lt;1].lazy+=tree[rt].lazy;tree[rt&lt;&lt;1|1].lazy+=tree[rt].lazy;
tree[rt&lt;&lt;1].sum+=(now-(now&gt;&gt;1))*tree[rt].lazy;tree[rt&lt;&lt;1|1].sum+=(now&gt;&gt;1)*tree[rt].lazy;
tree[rt&lt;&lt;1].minn+=tree[rt].lazy;tree[rt&lt;&lt;1|1].minn+=tree[rt].lazy;
tree[rt&lt;&lt;1].maxn+=tree[rt].lazy;tree[rt&lt;&lt;1|1].maxn+=tree[rt].lazy;tree[rt].lazy=0;}}
il void build(ll l , ll r , ll rt , ll *aa)
{tree[rt].lazy=0;tree[rt].l=l;tree[rt].r=r;if(l==r)
{tree[rt].sum=aa[l];tree[rt].minn=tree[rt].sum;tree[rt].maxn=tree[rt].sum;return;}
ll mid=(l+r)&gt;&gt;1;build(l,mid,rt&lt;&lt;1,aa);build(mid+1,r,rt&lt;&lt;1|1,aa);push_up(rt);}
il void update_range(ll L , ll R , ll key , ll rt)
{if(L&lt;=tree[rt].l&amp;&amp;R&gt;=tree[rt].r){tree[rt].sum+=(tree[rt].r-tree[rt].l+1)*key;
tree[rt].minn+=key;tree[rt].maxn+=key;tree[rt].lazy+=key;return;}push_down(rt,tree[rt].r-tree[rt].l+1);
ll mid=(tree[rt].r+tree[rt].l)&gt;&gt;1;if(L&lt;=mid)update_range(L,R,key,lson);
if(R&gt;mid)update_range(L,R,key,rson);push_up(rt);}
il ll query_range(ll L, ll R, ll rt)
{if(L&lt;=tree[rt].l&amp;&amp;R&gt;=tree[rt].r){return tree[rt].sum;}push_down(rt,tree[rt].r-tree[rt].l+1);
ll mid=(tree[rt].r+tree[rt].l)&gt;&gt;1;ll ans=0;if(L&lt;=mid)ans+=query_range(L,R,lson);
if(R&gt;mid)ans+=query_range(L,R,rson);return ans;}
il ll query_min(ll L,ll R,ll rt)
{if(L&lt;=tree[rt].l&amp;&amp;R&gt;=tree[rt].r){return tree[rt].minn;}push_down(rt,tree[rt].r-tree[rt].l+1);
ll mid=(tree[rt].r+tree[rt].l)&gt;&gt;1;ll ans=(0x3f3f3f3f3f3f3f3fll);if(L&lt;=mid)ans=min(ans,query_min(L,R,lson));
if(R&gt;mid)ans=min(ans,query_min(L,R,rson));return ans;}
il ll query_max(ll L, ll R, ll rt)
{if(L&lt;=tree[rt].l&amp;&amp;R&gt;=tree[rt].r){return tree[rt].maxn;}push_down(rt,tree[rt].r-tree[rt].l+1);
ll mid=(tree[rt].r+tree[rt].l)&gt;&gt;1;ll ans=-(0x3f3f3f3f3f3f3f3fll);if(L&lt;=mid)ans=max(ans,query_max(L,R,lson));
if(R&gt;mid)ans=max(ans,query_max(L,R,rson));return ans;}
</span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> N = 1e3 + <span style="color: #800080;">10</span><span style="color: #000000;">;
ll a[N][N];
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main()
{
    ios;
    ll r , c;
    cin </span>&gt;&gt; r &gt;&gt;<span style="color: #000000;"> c;
    </span><span style="color: #0000ff;">if</span>(r == <span style="color: #800080;">1</span>  &amp;&amp; c == <span style="color: #800080;">1</span><span style="color: #000000;">)
    </span><span style="color: #0000ff;">return</span> cout &lt;&lt; <span style="color: #800080;">0</span> &lt;&lt; <span style="color: #800000;">'</span><span style="color: #800000;">\n</span><span style="color: #800000;">'</span> , <span style="color: #800080;">0</span><span style="color: #000000;">; 
    </span><span style="color: #0000ff;">if</span>(r == <span style="color: #800080;">1</span><span style="color: #000000;">)
    {
        </span><span style="color: #0000ff;">int</span> tot = <span style="color: #800080;">2</span><span style="color: #000000;">;
        rep(i , </span><span style="color: #800080;">1</span><span style="color: #000000;"> , c)
        cout </span>&lt;&lt; tot ++ &lt;&lt; <span style="color: #800000;">'</span> <span style="color: #800000;">'</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
    }
    </span><span style="color: #0000ff;">if</span>(c == <span style="color: #800080;">1</span><span style="color: #000000;">)
    {
        </span><span style="color: #0000ff;">int</span> tot = <span style="color: #800080;">2</span><span style="color: #000000;">;
        rep(i , </span><span style="color: #800080;">1</span><span style="color: #000000;"> , r)
        cout </span>&lt;&lt; tot ++ &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">\n</span><span style="color: #800000;">"</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
    }
    
    rep(i , </span><span style="color: #800080;">1</span><span style="color: #000000;"> , r)
    {
        rep(j , </span><span style="color: #800080;">1</span><span style="color: #000000;"> , c)
        {
            a[i][j] </span>= i * (j +<span style="color: #000000;"> r);
        }
    }
    rep(i , </span><span style="color: #800080;">1</span><span style="color: #000000;"> , r)
    {
        rep(j , </span><span style="color: #800080;">1</span><span style="color: #000000;"> , c)
        cout </span>&lt;&lt; a[i][j] &lt;&lt; <span style="color: #800000;">"</span> <span style="color: #800000;">"</span><span style="color: #000000;">;
        cout </span>&lt;&lt; <span style="color: #800000;">'</span><span style="color: #800000;">\n</span><span style="color: #800000;">'</span><span style="color: #000000;">;
    }
    
        </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1>D. Decreasing Debts</h1>
<h2><span style="font-size: 18pt;">题目链接：<span style="text-decoration: underline; color: #ff0000;"><a href="https://codeforces.ml/contest/1266/problem/D" target="_blank"><span style="color: #ff0000; text-decoration: underline;">https://codeforces.ml/contest/1266/problem/D</span></a></span></span></h2>
<p><span style="font-size: 16px;">题意：</span></p>
<p><span style="font-size: 16px;">给你几个债务关系，如A欠B五元， B欠C五元，此时总的债务为 5 + 5 = 10 。</span></p>
<p><span style="font-size: 16px;">我们可以把关系转换为A欠C五元，那这样总的债务为 5&nbsp;</span></p>
<p><span style="font-size: 16px;">问不限转换次数 ， 怎么把总债务化为最小。</span></p>
<p><span style="font-size: 16px;">分析：</span></p>
<p><span style="font-size: 16px;">当把总债务化为最小时 ， 每个人的债务关系也将是最简的（以上述例子阐述，对B , 它欠C五元，这时候它的支出为5，但是A欠它五元，所以它的收入为5，所以它最后对总债务的关系为abs（5 - 5）= 0）</span></p>
<p><span style="font-size: 16px;">对于A、C也是一样的，所以最后A的最简形式为A支出5元,B的最简形式为0，C的最简形式为收入5元。按照这样，我们只要将A指向C即可</span></p>
<p><span style="font-size: 16px;">（因为总的收入和总的支出一定是相同的且题目也说债务关系数量最小，所以即使某个人 D 收入的金额大于另一个人 E 支出的金额，也可以先将E连向D，然后D的收入金额减去E的支出金额）</span></p>
<p><span style="font-size: 16px;">我们用 in 容器来存最简形式为收入的人的编号， ou容器来存最简形式为支出的人的编号，再用指针one指向in里的元素，two指向ou里的元素，他们的债务可以表示为min(a[one] , a[two]) , 将关系存于ans容器里。</span></p>
<p><span style="font-size: 16px;">当one == in.size() || two == ou.size() 即已经没有支出的人或已经没有收入的人了，则债务关系可以结束储存（题目要求最后输出债务关系） &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</span></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('4982036d-d3f6-45ee-94c7-df194ed9c2c0')"><img id="code_img_closed_4982036d-d3f6-45ee-94c7-df194ed9c2c0" class="code_img_closed" src="./images/Codeforces Global Round 60.png" alt="" /><img id="code_img_opened_4982036d-d3f6-45ee-94c7-df194ed9c2c0" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('4982036d-d3f6-45ee-94c7-df194ed9c2c0',event)" src="./images/Codeforces Global Round 61.png" alt="" />
<div id="cnblogs_code_open_4982036d-d3f6-45ee-94c7-df194ed9c2c0" class="cnblogs_code_hide">
<pre><code>#include&lt;bits/stdc++.h&gt;
<span style="color: #0000ff;">#define</span> ios std::ios::sync_with_stdio(false)
<span style="color: #0000ff;">#define</span> sd(n) scanf("%d",&amp;n)
<span style="color: #0000ff;">#define</span> sdd(n,m) scanf("%d%d",&amp;n,&amp;m)
<span style="color: #0000ff;">#define</span> sddd(n,m,k) scanf("%d%d%d",&amp;n,&amp;m,&amp;k)
<span style="color: #0000ff;">#define</span> pd(n) printf("%d\n", (n))
<span style="color: #0000ff;">#define</span> pdd(n,m) printf("%d %d\n", n, m)
<span style="color: #0000ff;">#define</span> pld(n) printf("%lld\n", n)
<span style="color: #0000ff;">#define</span> pldd(n,m) printf("%lld %lld\n", n, m)
<span style="color: #0000ff;">#define</span> sld(n) scanf("%lld",&amp;n)
<span style="color: #0000ff;">#define</span> sldd(n,m) scanf("%lld%lld",&amp;n,&amp;m)
<span style="color: #0000ff;">#define</span> slddd(n,m,k) scanf("%lld%lld%lld",&amp;n,&amp;m,&amp;k)
<span style="color: #0000ff;">#define</span> sf(n) scanf("%lf",&amp;n)
<span style="color: #0000ff;">#define</span> sff(n,m) scanf("%lf%lf",&amp;n,&amp;m)
<span style="color: #0000ff;">#define</span> sfff(n,m,k) scanf("%lf%lf%lf",&amp;n,&amp;m,&amp;k)
<span style="color: #0000ff;">#define</span> rep(i,a,n) for (int i=a;i&lt;=n;i++)
<span style="color: #0000ff;">#define</span> per(i,n,a) for (int i=n;i&gt;=a;i--)
<span style="color: #0000ff;">#define</span> mm(a,n) memset(a, n, sizeof(a))
<span style="color: #0000ff;">#define</span> pb push_back
<span style="color: #0000ff;">#define</span> all(x) (x).begin(),(x).end()
<span style="color: #0000ff;">#define</span> fi first
<span style="color: #0000ff;">#define</span> se second
<span style="color: #0000ff;">#define</span> il inline
<span style="color: #0000ff;">#define</span> ll long long
<span style="color: #0000ff;">#define</span> lson rt &lt;&lt; 1
<span style="color: #0000ff;">#define</span> rson rt &lt;&lt; 1 | 1
<span style="color: #0000ff;">#define</span> MOD 1000000007
<span style="color: #0000ff;">#define</span> pi 3.14159265358979323
<span style="color: #0000ff;">#define</span> debug(x)               cout &lt;&lt;#x&lt;&lt;": "&lt;&lt;x&lt;&lt;endl
<span style="color: #0000ff;">#define</span> debug2(x, y)          cout &lt;&lt;#x&lt;&lt;": "&lt;&lt;x&lt;&lt;" | "&lt;&lt;#y&lt;&lt;": "&lt;&lt;y&lt;&lt;endl;
<span style="color: #0000ff;">#define</span> debug3(x, y, z)       cout &lt;&lt;#x&lt;&lt;": "&lt;&lt;x&lt;&lt;" | "&lt;&lt;#y&lt;&lt;": "&lt;&lt;y&lt;&lt;" | "&lt;&lt;#z&lt;&lt;": "&lt;&lt;z&lt;&lt;endl;
<span style="color: #0000ff;">#define</span> debug4(a, b, c, d)    cout &lt;&lt;#a&lt;&lt;": "&lt;&lt;a&lt;&lt;" | "&lt;&lt;#b&lt;&lt;": "&lt;&lt;b&lt;&lt;" | "&lt;&lt;#c&lt;&lt;": "&lt;&lt;c&lt;&lt;" | "&lt;&lt;#d&lt;&lt;": "&lt;&lt;d&lt;&lt;endl;
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #0000ff;">const</span><span style="color: #000000;"> ll INF (0x3f3f3f3f3f3f3f3fll);
</span><span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> inf (<span style="color: #800080;">0x3f3f3f3f</span><span style="color: #000000;">);
template</span>&lt;typename T&gt;<span style="color: #0000ff;">void</span> read(T &amp;res){<span style="color: #0000ff;">bool</span> flag=<span style="color: #0000ff;">false</span>;<span style="color: #0000ff;">char</span> ch;<span style="color: #0000ff;">while</span>(!isdigit(ch=getchar()))(ch==<span style="color: #800000;">'</span><span style="color: #800000;">-</span><span style="color: #800000;">'</span>)&amp;&amp;(flag=<span style="color: #0000ff;">true</span><span style="color: #000000;">);
</span><span style="color: #0000ff;">for</span>(res=ch-<span style="color: #800080;">48</span>;isdigit(ch=getchar());res=(res&lt;&lt;<span style="color: #800080;">1</span>)+(res&lt;&lt;<span style="color: #800080;">3</span>)+ch - <span style="color: #800080;">48</span>);flag&amp;&amp;(res=-<span style="color: #000000;">res);}
template</span>&lt;typename T&gt;<span style="color: #0000ff;">void</span> Out(T x){<span style="color: #0000ff;">if</span>(x&lt;<span style="color: #800080;">0</span>)putchar(<span style="color: #800000;">'</span><span style="color: #800000;">-</span><span style="color: #800000;">'</span>),x=-x;<span style="color: #0000ff;">if</span>(x&gt;<span style="color: #800080;">9</span>)Out(x/<span style="color: #800080;">10</span>);putchar(x%<span style="color: #800080;">10</span>+<span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">);}
ll gcd(ll a,ll b){</span><span style="color: #0000ff;">return</span> b?gcd(b,a%<span style="color: #000000;">b):a;}
ll lcm(ll a,ll b){</span><span style="color: #0000ff;">return</span> a*b/<span style="color: #000000;">gcd(a,b);}
ll pow_mod(ll x,ll n,ll mod){ll res</span>=<span style="color: #800080;">1</span>;<span style="color: #0000ff;">while</span>(n){<span style="color: #0000ff;">if</span>(n&amp;<span style="color: #800080;">1</span>)res=res*x%mod;x=x*x%mod;n&gt;&gt;=<span style="color: #800080;">1</span>;}<span style="color: #0000ff;">return</span><span style="color: #000000;"> res;}
ll fact_pow(ll n,ll p){ll res</span>=<span style="color: #800080;">0</span>;<span style="color: #0000ff;">while</span>(n){n/=p;res+=n;}<span style="color: #0000ff;">return</span><span style="color: #000000;"> res;}
ll mult(ll a,ll b,ll p){a</span>%=p;b%=p;ll r=<span style="color: #800080;">0</span>,v=a;<span style="color: #0000ff;">while</span>(b){<span style="color: #0000ff;">if</span>(b&amp;<span style="color: #800080;">1</span>){r+=v;<span style="color: #0000ff;">if</span>(r&gt;p)r-=p;}v&lt;&lt;=<span style="color: #800080;">1</span>;<span style="color: #0000ff;">if</span>(v&gt;p)v-=p;b&gt;&gt;=<span style="color: #800080;">1</span>;}<span style="color: #0000ff;">return</span><span style="color: #000000;"> r;}
ll quick_pow(ll a,ll b,ll p){ll r</span>=<span style="color: #800080;">1</span>,v=a%p;<span style="color: #0000ff;">while</span>(b){<span style="color: #0000ff;">if</span>(b&amp;<span style="color: #800080;">1</span>)r=mult(r,v,p);v=mult(v,v,p);b&gt;&gt;=<span style="color: #800080;">1</span>;}<span style="color: #0000ff;">return</span><span style="color: #000000;"> r;}
</span><span style="color: #0000ff;">bool</span><span style="color: #000000;"> CH(ll a,ll n,ll x,ll t)
{ll r</span>=quick_pow(a,x,n);ll z=r;<span style="color: #0000ff;">for</span>(ll i=<span style="color: #800080;">1</span>;i&lt;=t;i++){r=mult(r,r,n);<span style="color: #0000ff;">if</span>(r==<span style="color: #800080;">1</span>&amp;&amp;z!=<span style="color: #800080;">1</span>&amp;&amp;z!=n-<span style="color: #800080;">1</span>)<span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span>;z=r;}<span style="color: #0000ff;">return</span> r!=<span style="color: #800080;">1</span><span style="color: #000000;">;}
</span><span style="color: #0000ff;">bool</span><span style="color: #000000;"> Miller_Rabin(ll n)
{</span><span style="color: #0000ff;">if</span>(n&lt;<span style="color: #800080;">2</span>)<span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span>;<span style="color: #0000ff;">if</span>(n==<span style="color: #800080;">2</span>)<span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span>;<span style="color: #0000ff;">if</span>(!(n&amp;<span style="color: #800080;">1</span>))<span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span>;ll x=n-<span style="color: #800080;">1</span>,t=<span style="color: #800080;">0</span>;<span style="color: #0000ff;">while</span>(!(x&amp;<span style="color: #800080;">1</span>)){x&gt;&gt;=<span style="color: #800080;">1</span>;t++<span style="color: #000000;">;}srand(time(NULL));
ll o</span>=<span style="color: #800080;">8</span>;<span style="color: #0000ff;">for</span>(ll i=<span style="color: #800080;">0</span>;i&lt;o;i++){ll a=rand()%(n-<span style="color: #800080;">1</span>)+<span style="color: #800080;">1</span>;<span style="color: #0000ff;">if</span>(CH(a,n,x,t))<span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span>;}<span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;}
</span><span style="color: #008000;">/*</span><span style="color: #008000;">
int prime[30000010],minprime[30000010];
void euler(int n)
{int c=0,i,j;for(i=2;i&lt;=n;i++){if(!minprime[i])prime[++c]=i,minprime[i]=i;for(j=1;j&lt;=c&amp;&amp;i*prime[j]&lt;=n;j++)
{minprime[i*prime[j]]=prime[j];if(i%prime[j]==0)break;}}}
struct Tree{ll l,r,sum,lazy,maxn,minn;}tree[1000000];
il void push_up(ll rt)
{tree[rt].sum=tree[rt&lt;&lt;1].sum+tree[rt&lt;&lt;1|1].sum;
tree[rt].maxn=max(tree[rt&lt;&lt;1].maxn,tree[rt&lt;&lt;1|1].maxn);
tree[rt].minn=min(tree[rt&lt;&lt;1].minn,tree[rt&lt;&lt;1|1].minn);}
il void push_down(ll rt , ll now)
{if(tree[rt].lazy){tree[rt&lt;&lt;1].lazy+=tree[rt].lazy;tree[rt&lt;&lt;1|1].lazy+=tree[rt].lazy;
tree[rt&lt;&lt;1].sum+=(now-(now&gt;&gt;1))*tree[rt].lazy;tree[rt&lt;&lt;1|1].sum+=(now&gt;&gt;1)*tree[rt].lazy;
tree[rt&lt;&lt;1].minn+=tree[rt].lazy;tree[rt&lt;&lt;1|1].minn+=tree[rt].lazy;
tree[rt&lt;&lt;1].maxn+=tree[rt].lazy;tree[rt&lt;&lt;1|1].maxn+=tree[rt].lazy;tree[rt].lazy=0;}}
il void build(ll l , ll r , ll rt , ll *aa)
{tree[rt].lazy=0;tree[rt].l=l;tree[rt].r=r;if(l==r)
{tree[rt].sum=aa[l];tree[rt].minn=tree[rt].sum;tree[rt].maxn=tree[rt].sum;return;}
ll mid=(l+r)&gt;&gt;1;build(l,mid,rt&lt;&lt;1,aa);build(mid+1,r,rt&lt;&lt;1|1,aa);push_up(rt);}
il void update_range(ll L , ll R , ll key , ll rt)
{if(L&lt;=tree[rt].l&amp;&amp;R&gt;=tree[rt].r){tree[rt].sum+=(tree[rt].r-tree[rt].l+1)*key;
tree[rt].minn+=key;tree[rt].maxn+=key;tree[rt].lazy+=key;return;}push_down(rt,tree[rt].r-tree[rt].l+1);
ll mid=(tree[rt].r+tree[rt].l)&gt;&gt;1;if(L&lt;=mid)update_range(L,R,key,lson);
if(R&gt;mid)update_range(L,R,key,rson);push_up(rt);}
il ll query_range(ll L, ll R, ll rt)
{if(L&lt;=tree[rt].l&amp;&amp;R&gt;=tree[rt].r){return tree[rt].sum;}push_down(rt,tree[rt].r-tree[rt].l+1);
ll mid=(tree[rt].r+tree[rt].l)&gt;&gt;1;ll ans=0;if(L&lt;=mid)ans+=query_range(L,R,lson);
if(R&gt;mid)ans+=query_range(L,R,rson);return ans;}
il ll query_min(ll L,ll R,ll rt)
{if(L&lt;=tree[rt].l&amp;&amp;R&gt;=tree[rt].r){return tree[rt].minn;}push_down(rt,tree[rt].r-tree[rt].l+1);
ll mid=(tree[rt].r+tree[rt].l)&gt;&gt;1;ll ans=(0x3f3f3f3f3f3f3f3fll);if(L&lt;=mid)ans=min(ans,query_min(L,R,lson));
if(R&gt;mid)ans=min(ans,query_min(L,R,rson));return ans;}
il ll query_max(ll L, ll R, ll rt)
{if(L&lt;=tree[rt].l&amp;&amp;R&gt;=tree[rt].r){return tree[rt].maxn;}push_down(rt,tree[rt].r-tree[rt].l+1);
ll mid=(tree[rt].r+tree[rt].l)&gt;&gt;1;ll ans=-(0x3f3f3f3f3f3f3f3fll);if(L&lt;=mid)ans=max(ans,query_max(L,R,lson));
if(R&gt;mid)ans=max(ans,query_max(L,R,rson));return ans;}
</span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> N = 3e5 + <span style="color: #800080;">10</span><span style="color: #000000;">;
ll a[N];
vector</span>&lt;ll&gt;<span style="color: #0000ff;">in</span><span style="color: #000000;"> , ou;
vector</span>&lt;pair&lt;pair&lt;ll , ll&gt;, ll&gt; &gt;<span style="color: #000000;"> ans;
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main()
{
    ios;
    ll n , m ;
    cin </span>&gt;&gt; n &gt;&gt;<span style="color: #000000;"> m;
    rep(i , </span><span style="color: #800080;">1</span><span style="color: #000000;"> , m)
    {
        ll x , y , z;
        cin </span>&gt;&gt; x &gt;&gt; y &gt;&gt;<span style="color: #000000;"> z;
        a[x] </span>+=<span style="color: #000000;"> z;
        a[y] </span>-=<span style="color: #000000;"> z;
    }
    rep(i , </span><span style="color: #800080;">1</span><span style="color: #000000;"> , n)
    {
        </span><span style="color: #0000ff;">if</span>(a[i] &gt; <span style="color: #800080;">0</span><span style="color: #000000;">)
        </span><span style="color: #0000ff;">in</span><span style="color: #000000;">.pb(i);
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(a[i] &lt; <span style="color: #800080;">0</span><span style="color: #000000;">)
        ou.pb(i);
    }
    ll one </span>= <span style="color: #800080;">0</span> , two = <span style="color: #800080;">0</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">while</span>(<span style="color: #0000ff;">true</span><span style="color: #000000;">)
    {
        </span><span style="color: #0000ff;">if</span>(one == <span style="color: #0000ff;">in</span>.size() || two ==<span style="color: #000000;"> ou.size())
            </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
        ll ha </span>= min(a[<span style="color: #0000ff;">in</span>[one]] , -<span style="color: #000000;">a[ou[two]]);
        ans.pb(make_pair(make_pair(</span><span style="color: #0000ff;">in</span><span style="color: #000000;">[one] , ou[two]) , ha));
        a[</span><span style="color: #0000ff;">in</span>[one]] -=<span style="color: #000000;"> ha;
        a[ou[two]] </span>+=<span style="color: #000000;"> ha;
        </span><span style="color: #0000ff;">if</span>(!a[<span style="color: #0000ff;">in</span>[one]]) one ++<span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span>(!a[ou[two]]) two ++<span style="color: #000000;">;
    }
    ll len </span>=<span style="color: #000000;"> ans.size();
    cout </span>&lt;&lt; len &lt;&lt; <span style="color: #800000;">'</span><span style="color: #800000;">\n</span><span style="color: #800000;">'</span><span style="color: #000000;">;
    rep(i , </span><span style="color: #800080;">0</span> , len - <span style="color: #800080;">1</span><span style="color: #000000;">)
    cout </span>&lt;&lt; ans[i].fi.fi &lt;&lt; <span style="color: #800000;">"</span> <span style="color: #800000;">"</span> &lt;&lt; ans[i].fi.se &lt;&lt; <span style="color: #800000;">"</span> <span style="color: #800000;">"</span> &lt;&lt; ans[i].se &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">\n</span><span style="color: #800000;">"</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>&nbsp;</p>
<p><span style="font-size: 15px;">&nbsp;</span></p>
<p>&nbsp;</p>
<h1>E. Spaceship Solitaire</h1>
<h2>题目链接：<span style="text-decoration: underline;"><a href="https://codeforces.ml/contest/1266/problem/E" target="_blank"><span style="color: #ff0000; text-decoration: underline;">https://codeforces.ml/contest/1266/problem/E</span></a></span></h2>
<p><span style="font-size: 16px;">题意：</span></p>
<p><span style="font-size: 16px;">你要建个飞船 ， 建飞船需要 n 种资源 ， 每种资源的需求量为 a[i] 。每一回合你只能选择一种资源并生产一个。然后你有里程牌？？？</span></p>
<p><span style="font-size: 16px;">里程碑包含三个元素 S 、 T 、 U ， 意思是如果你有 T 个 S 资源， 你就可以获得一个U资源。（0 &lt; T &lt; a[S]）</span></p>
<p><span style="font-size: 16px;">不同的里程碑 S 和 T 不相同 （如果S 相同且 T 相同则它们是同一个里程碑）&nbsp;</span></p>
<p><span style="font-size: 16px;">给你 q 次询问， 每次询问会加入一个里程碑（如果该里程碑先前存在过 ， 则用现在的里程碑代替之前的里程碑 ， 如果U == 0 , 则销毁该里程碑）</span></p>
<p><span style="font-size: 16px;">问建造飞船最少需要多少回合&nbsp;</span></p>
<p><span style="font-size: 16px;">分析：</span></p>
<p><span style="font-size: 16px;">i 种资源 每种需要 a[i] 个，那么当没有里程碑的情况下总的回合数为 a[1] + a[2] + ... + a[n] , 记为sum</span></p>
<p><span style="font-size: 16px;">首先我们要知道的是，不论如何，最后飞船是肯定可以建成的。又因为对任意里程碑 T &lt; a[S] , 所以里程碑起作用的条件是肯定可以满足的 ，那么对于当前询问加入的里程碑来说</span></p>
<p><span style="font-size: 16px;">如果它先前出现过，则我们判断它先前出现的时候是否会对sum起影响（因为可能在该里程碑起作用之前，资源U已经采集的够了，所以该里程碑不起到作用。如果在起作用前U采集还不够，则它起到作用了， sum 会减一）</span></p>
<p><span style="font-size: 16px;">如果不影响，sum保持不变，影响了，则sum++（把先前造成的影响去掉）</span></p>
<p><span style="font-size: 16px;">然后我们判断新的里程碑是否起作用（如果起作用sum -- ， 否则sum不变），对于每个询问输出sum即可。（只需判断当前类型里程碑，其他里程碑不受影响）</span></p>
<p><span style="font-size: 16px;">简单模拟题。</span></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('8fc9e3f5-948a-4704-aa39-3b0179e5c41c')"><img id="code_img_closed_8fc9e3f5-948a-4704-aa39-3b0179e5c41c" class="code_img_closed" src="./images/Codeforces Global Round 60.png" alt="" /><img id="code_img_opened_8fc9e3f5-948a-4704-aa39-3b0179e5c41c" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('8fc9e3f5-948a-4704-aa39-3b0179e5c41c',event)" src="./images/Codeforces Global Round 61.png" alt="" />
<div id="cnblogs_code_open_8fc9e3f5-948a-4704-aa39-3b0179e5c41c" class="cnblogs_code_hide">
<pre><code>#include&lt;bits/stdc++.h&gt;
<span style="color: #0000ff;">#define</span> ios std::ios::sync_with_stdio(false)
<span style="color: #0000ff;">#define</span> sd(n) scanf("%d",&amp;n)
<span style="color: #0000ff;">#define</span> sdd(n,m) scanf("%d%d",&amp;n,&amp;m)
<span style="color: #0000ff;">#define</span> sddd(n,m,k) scanf("%d%d%d",&amp;n,&amp;m,&amp;k)
<span style="color: #0000ff;">#define</span> pd(n) printf("%d\n", (n))
<span style="color: #0000ff;">#define</span> pdd(n,m) printf("%d %d\n", n, m)
<span style="color: #0000ff;">#define</span> pld(n) printf("%lld\n", n)
<span style="color: #0000ff;">#define</span> pldd(n,m) printf("%lld %lld\n", n, m)
<span style="color: #0000ff;">#define</span> sld(n) scanf("%lld",&amp;n)
<span style="color: #0000ff;">#define</span> sldd(n,m) scanf("%lld%lld",&amp;n,&amp;m)
<span style="color: #0000ff;">#define</span> slddd(n,m,k) scanf("%lld%lld%lld",&amp;n,&amp;m,&amp;k)
<span style="color: #0000ff;">#define</span> sf(n) scanf("%lf",&amp;n)
<span style="color: #0000ff;">#define</span> sff(n,m) scanf("%lf%lf",&amp;n,&amp;m)
<span style="color: #0000ff;">#define</span> sfff(n,m,k) scanf("%lf%lf%lf",&amp;n,&amp;m,&amp;k)
<span style="color: #0000ff;">#define</span> rep(i,a,n) for (int i=a;i&lt;=n;i++)
<span style="color: #0000ff;">#define</span> per(i,n,a) for (int i=n;i&gt;=a;i--)
<span style="color: #0000ff;">#define</span> mm(a,n) memset(a, n, sizeof(a))
<span style="color: #0000ff;">#define</span> pb push_back
<span style="color: #0000ff;">#define</span> all(x) (x).begin(),(x).end()
<span style="color: #0000ff;">#define</span> fi first
<span style="color: #0000ff;">#define</span> se second
<span style="color: #0000ff;">#define</span> il inline
<span style="color: #0000ff;">#define</span> ll long long
<span style="color: #0000ff;">#define</span> lson rt &lt;&lt; 1
<span style="color: #0000ff;">#define</span> rson rt &lt;&lt; 1 | 1
<span style="color: #0000ff;">#define</span> MOD 1000000007
<span style="color: #0000ff;">#define</span> pi 3.14159265358979323
<span style="color: #0000ff;">#define</span> debug(x)               cout &lt;&lt;#x&lt;&lt;": "&lt;&lt;x&lt;&lt;endl
<span style="color: #0000ff;">#define</span> debug2(x, y)          cout &lt;&lt;#x&lt;&lt;": "&lt;&lt;x&lt;&lt;" | "&lt;&lt;#y&lt;&lt;": "&lt;&lt;y&lt;&lt;endl;
<span style="color: #0000ff;">#define</span> debug3(x, y, z)       cout &lt;&lt;#x&lt;&lt;": "&lt;&lt;x&lt;&lt;" | "&lt;&lt;#y&lt;&lt;": "&lt;&lt;y&lt;&lt;" | "&lt;&lt;#z&lt;&lt;": "&lt;&lt;z&lt;&lt;endl;
<span style="color: #0000ff;">#define</span> debug4(a, b, c, d)    cout &lt;&lt;#a&lt;&lt;": "&lt;&lt;a&lt;&lt;" | "&lt;&lt;#b&lt;&lt;": "&lt;&lt;b&lt;&lt;" | "&lt;&lt;#c&lt;&lt;": "&lt;&lt;c&lt;&lt;" | "&lt;&lt;#d&lt;&lt;": "&lt;&lt;d&lt;&lt;endl;
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #0000ff;">const</span><span style="color: #000000;"> ll INF (0x3f3f3f3f3f3f3f3fll);
</span><span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> inf (<span style="color: #800080;">0x3f3f3f3f</span><span style="color: #000000;">);
template</span>&lt;typename T&gt;<span style="color: #0000ff;">void</span> read(T &amp;res){<span style="color: #0000ff;">bool</span> flag=<span style="color: #0000ff;">false</span>;<span style="color: #0000ff;">char</span> ch;<span style="color: #0000ff;">while</span>(!isdigit(ch=getchar()))(ch==<span style="color: #800000;">'</span><span style="color: #800000;">-</span><span style="color: #800000;">'</span>)&amp;&amp;(flag=<span style="color: #0000ff;">true</span><span style="color: #000000;">);
</span><span style="color: #0000ff;">for</span>(res=ch-<span style="color: #800080;">48</span>;isdigit(ch=getchar());res=(res&lt;&lt;<span style="color: #800080;">1</span>)+(res&lt;&lt;<span style="color: #800080;">3</span>)+ch - <span style="color: #800080;">48</span>);flag&amp;&amp;(res=-<span style="color: #000000;">res);}
template</span>&lt;typename T&gt;<span style="color: #0000ff;">void</span> Out(T x){<span style="color: #0000ff;">if</span>(x&lt;<span style="color: #800080;">0</span>)putchar(<span style="color: #800000;">'</span><span style="color: #800000;">-</span><span style="color: #800000;">'</span>),x=-x;<span style="color: #0000ff;">if</span>(x&gt;<span style="color: #800080;">9</span>)Out(x/<span style="color: #800080;">10</span>);putchar(x%<span style="color: #800080;">10</span>+<span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">);}
ll gcd(ll a,ll b){</span><span style="color: #0000ff;">return</span> b?gcd(b,a%<span style="color: #000000;">b):a;}
ll lcm(ll a,ll b){</span><span style="color: #0000ff;">return</span> a*b/<span style="color: #000000;">gcd(a,b);}
ll pow_mod(ll x,ll n,ll mod){ll res</span>=<span style="color: #800080;">1</span>;<span style="color: #0000ff;">while</span>(n){<span style="color: #0000ff;">if</span>(n&amp;<span style="color: #800080;">1</span>)res=res*x%mod;x=x*x%mod;n&gt;&gt;=<span style="color: #800080;">1</span>;}<span style="color: #0000ff;">return</span><span style="color: #000000;"> res;}
ll fact_pow(ll n,ll p){ll res</span>=<span style="color: #800080;">0</span>;<span style="color: #0000ff;">while</span>(n){n/=p;res+=n;}<span style="color: #0000ff;">return</span><span style="color: #000000;"> res;}
ll mult(ll a,ll b,ll p){a</span>%=p;b%=p;ll r=<span style="color: #800080;">0</span>,v=a;<span style="color: #0000ff;">while</span>(b){<span style="color: #0000ff;">if</span>(b&amp;<span style="color: #800080;">1</span>){r+=v;<span style="color: #0000ff;">if</span>(r&gt;p)r-=p;}v&lt;&lt;=<span style="color: #800080;">1</span>;<span style="color: #0000ff;">if</span>(v&gt;p)v-=p;b&gt;&gt;=<span style="color: #800080;">1</span>;}<span style="color: #0000ff;">return</span><span style="color: #000000;"> r;}
ll quick_pow(ll a,ll b,ll p){ll r</span>=<span style="color: #800080;">1</span>,v=a%p;<span style="color: #0000ff;">while</span>(b){<span style="color: #0000ff;">if</span>(b&amp;<span style="color: #800080;">1</span>)r=mult(r,v,p);v=mult(v,v,p);b&gt;&gt;=<span style="color: #800080;">1</span>;}<span style="color: #0000ff;">return</span><span style="color: #000000;"> r;}
</span><span style="color: #0000ff;">bool</span><span style="color: #000000;"> CH(ll a,ll n,ll x,ll t)
{ll r</span>=quick_pow(a,x,n);ll z=r;<span style="color: #0000ff;">for</span>(ll i=<span style="color: #800080;">1</span>;i&lt;=t;i++){r=mult(r,r,n);<span style="color: #0000ff;">if</span>(r==<span style="color: #800080;">1</span>&amp;&amp;z!=<span style="color: #800080;">1</span>&amp;&amp;z!=n-<span style="color: #800080;">1</span>)<span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span>;z=r;}<span style="color: #0000ff;">return</span> r!=<span style="color: #800080;">1</span><span style="color: #000000;">;}
</span><span style="color: #0000ff;">bool</span><span style="color: #000000;"> Miller_Rabin(ll n)
{</span><span style="color: #0000ff;">if</span>(n&lt;<span style="color: #800080;">2</span>)<span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span>;<span style="color: #0000ff;">if</span>(n==<span style="color: #800080;">2</span>)<span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span>;<span style="color: #0000ff;">if</span>(!(n&amp;<span style="color: #800080;">1</span>))<span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span>;ll x=n-<span style="color: #800080;">1</span>,t=<span style="color: #800080;">0</span>;<span style="color: #0000ff;">while</span>(!(x&amp;<span style="color: #800080;">1</span>)){x&gt;&gt;=<span style="color: #800080;">1</span>;t++<span style="color: #000000;">;}srand(time(NULL));
ll o</span>=<span style="color: #800080;">8</span>;<span style="color: #0000ff;">for</span>(ll i=<span style="color: #800080;">0</span>;i&lt;o;i++){ll a=rand()%(n-<span style="color: #800080;">1</span>)+<span style="color: #800080;">1</span>;<span style="color: #0000ff;">if</span>(CH(a,n,x,t))<span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span>;}<span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;}
</span><span style="color: #008000;">/*</span><span style="color: #008000;">
int prime[30000010],minprime[30000010];
void euler(int n)
{int c=0,i,j;for(i=2;i&lt;=n;i++){if(!minprime[i])prime[++c]=i,minprime[i]=i;for(j=1;j&lt;=c&amp;&amp;i*prime[j]&lt;=n;j++)
{minprime[i*prime[j]]=prime[j];if(i%prime[j]==0)break;}}}
struct Tree{ll l,r,sum,lazy,maxn,minn;}tree[1000000];
il void push_up(ll rt)
{tree[rt].sum=tree[rt&lt;&lt;1].sum+tree[rt&lt;&lt;1|1].sum;
tree[rt].maxn=max(tree[rt&lt;&lt;1].maxn,tree[rt&lt;&lt;1|1].maxn);
tree[rt].minn=min(tree[rt&lt;&lt;1].minn,tree[rt&lt;&lt;1|1].minn);}
il void push_down(ll rt , ll now)
{if(tree[rt].lazy){tree[rt&lt;&lt;1].lazy+=tree[rt].lazy;tree[rt&lt;&lt;1|1].lazy+=tree[rt].lazy;
tree[rt&lt;&lt;1].sum+=(now-(now&gt;&gt;1))*tree[rt].lazy;tree[rt&lt;&lt;1|1].sum+=(now&gt;&gt;1)*tree[rt].lazy;
tree[rt&lt;&lt;1].minn+=tree[rt].lazy;tree[rt&lt;&lt;1|1].minn+=tree[rt].lazy;
tree[rt&lt;&lt;1].maxn+=tree[rt].lazy;tree[rt&lt;&lt;1|1].maxn+=tree[rt].lazy;tree[rt].lazy=0;}}
il void build(ll l , ll r , ll rt , ll *aa)
{tree[rt].lazy=0;tree[rt].l=l;tree[rt].r=r;if(l==r)
{tree[rt].sum=aa[l];tree[rt].minn=tree[rt].sum;tree[rt].maxn=tree[rt].sum;return;}
ll mid=(l+r)&gt;&gt;1;build(l,mid,rt&lt;&lt;1,aa);build(mid+1,r,rt&lt;&lt;1|1,aa);push_up(rt);}
il void update_range(ll L , ll R , ll key , ll rt)
{if(L&lt;=tree[rt].l&amp;&amp;R&gt;=tree[rt].r){tree[rt].sum+=(tree[rt].r-tree[rt].l+1)*key;
tree[rt].minn+=key;tree[rt].maxn+=key;tree[rt].lazy+=key;return;}push_down(rt,tree[rt].r-tree[rt].l+1);
ll mid=(tree[rt].r+tree[rt].l)&gt;&gt;1;if(L&lt;=mid)update_range(L,R,key,lson);
if(R&gt;mid)update_range(L,R,key,rson);push_up(rt);}
il ll query_range(ll L, ll R, ll rt)
{if(L&lt;=tree[rt].l&amp;&amp;R&gt;=tree[rt].r){return tree[rt].sum;}push_down(rt,tree[rt].r-tree[rt].l+1);
ll mid=(tree[rt].r+tree[rt].l)&gt;&gt;1;ll ans=0;if(L&lt;=mid)ans+=query_range(L,R,lson);
if(R&gt;mid)ans+=query_range(L,R,rson);return ans;}
il ll query_min(ll L,ll R,ll rt)
{if(L&lt;=tree[rt].l&amp;&amp;R&gt;=tree[rt].r){return tree[rt].minn;}push_down(rt,tree[rt].r-tree[rt].l+1);
ll mid=(tree[rt].r+tree[rt].l)&gt;&gt;1;ll ans=(0x3f3f3f3f3f3f3f3fll);if(L&lt;=mid)ans=min(ans,query_min(L,R,lson));
if(R&gt;mid)ans=min(ans,query_min(L,R,rson));return ans;}
il ll query_max(ll L, ll R, ll rt)
{if(L&lt;=tree[rt].l&amp;&amp;R&gt;=tree[rt].r){return tree[rt].maxn;}push_down(rt,tree[rt].r-tree[rt].l+1);
ll mid=(tree[rt].r+tree[rt].l)&gt;&gt;1;ll ans=-(0x3f3f3f3f3f3f3f3fll);if(L&lt;=mid)ans=max(ans,query_max(L,R,lson));
if(R&gt;mid)ans=max(ans,query_max(L,R,rson));return ans;}
</span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> N = 2e5 + <span style="color: #800080;">10</span><span style="color: #000000;">;
ll a[N] , sum;
map</span>&lt;ll , ll&gt;<span style="color: #000000;"> vis[N];
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main()
{
    ios;cin.tie(</span><span style="color: #800080;">0</span><span style="color: #000000;">);
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> n , q;
    cin </span>&gt;&gt;<span style="color: #000000;"> n ;
    rep(i , </span><span style="color: #800080;">1</span><span style="color: #000000;"> , n)
    cin </span>&gt;&gt; a[i] , sum +=<span style="color: #000000;"> a[i];
    cin </span>&gt;&gt;<span style="color: #000000;"> q;
    rep(i , </span><span style="color: #800080;">1</span><span style="color: #000000;"> , q)
    {
        ll s , t , u;
        cin </span>&gt;&gt; s &gt;&gt; t &gt;&gt;<span style="color: #000000;"> u;
        </span><span style="color: #0000ff;">if</span><span style="color: #000000;">(vis[s][t])
        {
            a[vis[s][t]] </span>++<span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span>(a[vis[s][t]] &gt; <span style="color: #800080;">0</span><span style="color: #000000;">)
            sum </span>++<span style="color: #000000;">;
            vis[s][t] </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">if</span><span style="color: #000000;">(u)
        {
            vis[s][t] </span>=<span style="color: #000000;"> u;
            a[u] </span>--<span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span>(a[u] &gt;= <span style="color: #800080;">0</span><span style="color: #000000;">)
            sum </span>--<span style="color: #000000;">;
        }
        cout </span>&lt;&lt; sum &lt;&lt; <span style="color: #800000;">'</span><span style="color: #800000;">\n</span><span style="color: #800000;">'</span><span style="color: #000000;">;
    }                           
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>