<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修Python入门之 Python内置函数' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>Python入门之 Python内置函数</center></div><div class='banquan'>原文出处:本文由博客园博主永亮提供。<br/>
原文连接:https://www.cnblogs.com/caiyongliang/p/11439198.html</div><br>
    <h1 id="python入门之-python内置函数">Python入门之 Python内置函数</h1>
<p>函数就是以功能为导向，一个函数封装一个功能，那么Python将一些常用的功能（比如len）给我们封装成了一个一个的函数，供我们使用，他们不仅效率高（底层都是用C语言写的），而且是拿来即用，避免重复早轮子，那么这些函数就称为内置函数，到目前为止python给我们提供的内置函数一共是68个。</p>
<h2 id="内置函数一">1、内置函数一</h2>
<h3 id="eval-执行字符串类型的代码并返回最终结果-神器一">（1）eval() : 执行字符串类型的代码，并返回最终结果 神器一</h3>
<pre><code><code>a = &quot;88 + 99&quot;
print(eval(a))

eval(&quot;n + 4&quot;)  # 85
eval(&#39;print(666)&#39;)  # 666</code></pre>
<p>注意：千万记住禁止使用</p>
<h3 id="exec-执行字符串类型的代码-神器二">（2）exec() : 执行字符串类型的代码 神器二</h3>
<pre><code><code>def func():
    print(111)
func()

exec(func())</code></pre>
<p>注意：千万记住禁止使用</p>
<h3 id="hash-作用就是区分可变数据类型和不可变数据类型">（3）hash() :作用就是区分可变数据类型和不可变数据类型</h3>
<pre><code><code>print(hash(&quot;123&quot;))
print(hash(12))
print(hash(-1))
print(hash(-10))
print(hash((2,1)))

dic = {[1,2,3]:2}
print(hash([1,2,3]))</code></pre>
<h3 id="help-查看帮助信息用于查看函数或模块用途的详细说明">（4）help() :查看帮助信息，用于查看函数或模块用途的详细说明</h3>
<pre><code><code>help(list) </code></pre>
<h3 id="callable-查看对象是否可调用">（5）callable() :查看对象是否可调用</h3>
<pre><code><code>def func():
    print(1)
lst = [1,23,4,]
print(callable(lst))</code></pre>
<h3 id="int-将一个字符串或数字转换为整型">（6）int() :将一个字符串或数字转换为整型</h3>
<pre><code><code>print(int())  
print(int(&#39;12&#39;))  
print(int(3.6))  </code></pre>
<h3 id="float-将整数和字符串转换成浮点型">（7）float() :将整数和字符串转换成浮点型</h3>
<pre><code><code>print(float(3))
print(int(3))</code></pre>
<h3 id="complex-复数">（8）complex() :复数</h3>
<pre><code><code>print(complex(20))</code></pre>
<h3 id="bin-十进制转二进制-0b">（9）bin() :十进制转二进制 0b</h3>
<pre><code><code>print(bin(100))
</code></pre>
<h3 id="oct-十进制转八进制-0o">（10）oct() :十进制转八进制 0o</h3>
<pre><code><code>print(oct(10)) 
</code></pre>
<h3 id="hex-十进制转十六进制-0x">（11）hex() :十进制转十六进制 0x</h3>
<pre><code><code>print(hex(17))
</code></pre>
<h3 id="divmod-求商和余数-商余">（12）divmod() :求商和余数 （商，余）</h3>
<pre><code><code>print(divmod(5,2))
</code></pre>
<h3 id="round-保留小数位">（13）round() :保留小数位</h3>
<pre><code><code>print(round(3.534232,2)) 
</code></pre>
<h3 id="pow-幂运算pow-当是两个参数时是求幂三个参数时就是求幂取余">（14）pow() :幂运算pow 当是两个参数时是求幂，三个参数时就是求幂取余</h3>
<pre><code><code>print(pow(2,2))  #幂 pow 两个参数是求幂
print(pow(2,2,3))  #幂 pow 两个参数是求幂后的余
</code></pre>
<h3 id="bytes-将字符串进行编码用于不同编码之间的转化">（15）bytes() :将字符串进行编码，用于不同编码之间的转化</h3>
<pre><code><code>s = &quot;你好&quot;
s1 = bytes(s,encoding=&quot;utf-8&quot;)
print(&quot;s1&quot;)
</code></pre>
<h3 id="ord-通过元素获取当前表位的序号">（16）ord() :通过元素获取当前表位的序号</h3>
<pre><code><code>print(ord(&quot;你&quot;))
</code></pre>
<h3 id="chr-通过表位序号查找元素">（17）chr() :通过表位序号查找元素</h3>
<pre><code><code>print(chr(20320))
</code></pre>
<h3 id="repr-查看数据的源生态-给程序员使用的">（18）repr() :查看数据的源生态 ，给程序员使用的</h3>
<pre><code><code>a = &#39;alex&#39;
print(repr(a))   #查看你数据的原生态  -- 给程序员使用的
print(a)         # 给用户使用的
</code></pre>
<h3 id="all-判断容器中的元素是否都为真-and">（19）all() :判断容器中的元素是否都为真 (and)</h3>
<pre><code><code>lst = [1,2,0,4,5]
print(all(lst)) 
</code></pre>
<h3 id="any-判断容器中的元素是否有一个为真">（20）any() :判断容器中的元素是否有一个为真</h3>
<pre><code><code>lst = [1,2,3,0,1,23]  
print(any(lst))
</code></pre>
<h3 id="globals-查看全局变量">（21）globals() :查看全局变量</h3>
<pre><code><code>print(globals()) 
</code></pre>
<h3 id="locals-查看当前空间变量">（22）locals() :查看当前空间变量</h3>
<pre><code><code>a = 10
def func():
    a = 1
    print(locals())     #  查看当前空间变量
    print(1)

func()
</code></pre>
<h3 id="frozenset-冻结集合">（23）frozenset() :冻结集合</h3>
<h2 id="内置函数二">2、内置函数二</h2>
<h3 id="普通函数">（1）普通函数：</h3>
<h4 id="print-屏幕输出">&lt;1&gt; print() 屏幕输出</h4>
<pre><code><code>&#39;&#39;&#39; 源码分析
def print(self, *args, sep=&#39; &#39;, end=&#39;\n&#39;, file=None): # known special case of print
    &quot;&quot;&quot;
    print(value, ..., sep=&#39; &#39;, end=&#39;\n&#39;, file=sys.stdout, flush=False)
    file:  默认是输出到屏幕，如果设置为文件句柄，输出到文件
    sep:   打印多个值之间的分隔符，默认为空格
    end:   每一次打印的结尾，默认为换行符
    flush: 立即把内容输出到流文件，不作缓存
    &quot;&quot;&quot;
&#39;&#39;&#39;
</code></pre>
<pre><code><code>sep : 每一个元素之间分割的方法 默认 &quot; &quot;    ****
print(1,2,3,sep=&quot;|&quot;)

end :print执行完后的结束语句 默认\n        ****
print(1,2,3,end=&quot;&quot;)
print(4,5,6,end=&quot;&quot;)

file : 文件句柄 默认是显示到屏幕
print(1,2,3,4,file=open(&quot;test&quot;,&quot;w&quot;,encoding=&quot;utf-8&quot;))

print()  # flush 刷新
</code></pre>
<pre class="pythonpython"><code>print(111,222,333,sep=&#39;*&#39;)  # 111*222*333

print(111,end=&#39;&#39;)
print(222)  #两行的结果 111222

f = open(&#39;log&#39;,&#39;w&#39;,encoding=&#39;utf-8&#39;)
print(&#39;写入文件&#39;,fle=f,flush=True
</code></pre>
<h4 id="dir-查看当前对象的所有方法-返回的是列表">&lt;2&gt; dir() 查看当前对象的所有方法 返回的是列表</h4>
<pre><code><code>print(dir(list))  # 查看当前对象所有方法  返回的是列表print(dir(str))  # 查看当前对象所有方法
</code></pre>
<h4 id="format-格式转换">&lt;3&gt; format() 格式转换</h4>
<pre><code><code># 对齐方式
print(format(&quot;alex&quot;,&quot;&gt;20&quot;))  # 右对齐
print(format(&quot;alex&quot;,&quot;&lt;20&quot;))  # 左对齐
print(format(&quot;alex&quot;,&quot;^20&quot;))  # 居中

# 进制转换
print(format(10,&quot;b&quot;))      # bin  二进制
print(format(10,&quot;08b&quot;))
print(format(10,&quot;08o&quot;))    # oct  八进制
print(format(10,&quot;08x&quot;))    # hex  十六进制
print(format(0b1010,&quot;d&quot;))  # digit 十进制
</code></pre>
<h4 id="str-将字节转换成字符串">&lt;4&gt; str() 将字节转换成字符串</h4>
<pre><code><code>byte_str = bytes(&quot;你好&quot;,encoding=&quot;utf&quot;)
print(byte_str)
print(str(byte_str,encoding=&quot;utf-8&quot;))
</code></pre>
<h4 id="list-将一个可迭代的对象转换为列表">&lt;5&gt; list() 将一个可迭代的对象转换为列表</h4>
<pre><code><code>print(list(&quot;alex&quot;))
</code></pre>
<h4 id="tuple-讲一个可迭代的对象转换成元组">&lt;6&gt; tuple() 讲一个可迭代的对象转换成元组</h4>
<pre><code><code>print(tuple([1,2,3,4]))
</code></pre>
<h4 id="set-将可迭代对象转换成一个集合">&lt;7&gt;set() 将可迭代对象转换成一个集合</h4>
<pre><code><code>print(set(&quot;alex&quot;))
</code></pre>
<h4 id="dict-通过相应的方式创建字典">&lt;8&gt; dict() 通过相应的方式创建字典</h4>
<pre><code><code>print(dict([(1,2),(3,4)]))

print(dict(k=1,v=2,c=3))

dic1 = {&quot;key1&quot;:1,&quot;key2&quot;:2}
dic2 = {&quot;a&quot;:1,&quot;b&quot;:2}
dic2.update(dic1)
print(dic2)

print(dict(**dic1,**dic2))

</code></pre>
<h4 id="abs-返回绝对值">&lt;9&gt; abs() 返回绝对值</h4>
<pre><code><code>i = -5
print(abs(i))  # 5
</code></pre>
<h4 id="sum-求和">&lt;10&gt; sum() 求和</h4>
<pre><code><code>print(sum([1,2,3]))
print(sum((1,2,3),100))     # 从100开始加

</code></pre>
<h4 id="reversed-将一个序列翻转返回翻转序列的迭代器">&lt;11&gt; reversed() 将一个序列翻转，返回翻转序列的迭代器</h4>
<pre><code><code>print(list(reversed(&quot;alex&quot;)))

lst = [1,2,3,4,5]
print(list(reversed(lst)))  反转
print(lst)
</code></pre>
<h4 id="zip-拉链">&lt;12&gt; zip() 拉链</h4>
<p>用于将可迭代的对象作为参数,将对象中对应的元素打包成一个个元组，然后返回由这些元祖组成的内容,如果各个迭代器的元素个数不一致,则按照长度最短的返回。</p>
<pre><code><code>lst1 = [1,2,3]

lst2 = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;]

lst3 = (11,12,13,14,15)

for i in zip(lst1,lst2,lst3):

    print(i)
    

结果:

(1, &#39;a&#39;, 11)

(2, &#39;b&#39;, 12)

(3, &#39;c&#39;, 13)
</code></pre>
<h3 id="高阶函数">（2）高阶函数：</h3>
<h4 id="min-求最小值">&lt;1&gt; min() 求最小值</h4>
<pre><code><code>rint(min([1,2,3]))  # 返回此序列最小值

ret = min([1,2,-5,],key=abs)  # 按照绝对值的大小，返回此序列最小值
print(ret)
# 加key是可以加函数名，min自动会获取传入函数中的参数的每个元素，然后通过你设定的返回值比较大小，返回最小的传入的那个参数。
print(min(1,2,-5,6,-3,key=lambda x:abs(x)))  # 可以设置很多参数比较大小
dic = {&#39;a&#39;:3,&#39;b&#39;:2,&#39;c&#39;:1}
print(min(dic,key=lambda x:dic[x]))

# x为dic的key，lambda的返回值（即dic的值进行比较）返回最小的值对应的键
</code></pre>
<h4 id="max-求最大值">&lt;2&gt; max() 求最大值</h4>
<pre><code><code>print(max(10,12,13,15,16))
print(max([10,12,13,15,-16],key=abs))
</code></pre>
<h4 id="sorted-排序函数">&lt;3&gt; sorted() 排序函数</h4>
<pre><code><code>语法:sorted(iterable,key=None,reverse=False)

iterable : 可迭代对象

key: 排序规则(排序函数),在sorted内部会将可迭代对象中的每一个元素传递给这个函数的参数.根据函数运算的结果进行排序

reverse :是否是倒序,True 倒序 False 正序

lst = [1,3,2,5,4]
lst2 = sorted(lst)
print(lst)    #原列表不会改变
print(lst2)   #返回的新列表是经过排序的


lst3 = sorted(lst,reverse=True)
print(lst3)   #倒叙

结果:
[1, 3, 2, 5, 4]
[1, 2, 3, 4, 5]
[5, 4, 3, 2, 1]

字典使用sorted排序

dic = {1:&#39;a&#39;,3:&#39;c&#39;,2:&#39;b&#39;}
print(sorted(dic))   # 字典排序返回的就是排序后的key

结果:
[1,2,3]




和函数组合使用

# 定义一个列表,然后根据一元素的长度排序
lst = [&#39;天龙八部&#39;,&#39;西游记&#39;,&#39;红楼梦&#39;,&#39;三国演义&#39;]

# 计算字符串的长度
def func(s):
    return len(s)
print(sorted(lst,key=func))

# 结果:
# [&#39;西游记&#39;, &#39;红楼梦&#39;, &#39;天龙八部&#39;, &#39;三国演义&#39;]


和lambda组合使用

lst = [&#39;天龙八部&#39;,&#39;西游记&#39;,&#39;红楼梦&#39;,&#39;三国演义&#39;]

print(sorted(lst,key=lambda s:len(s)))

结果:
[&#39;西游记&#39;, &#39;红楼梦&#39;, &#39;天龙八部&#39;, &#39;三国演义&#39;]


lst = [{&#39;id&#39;:1,&#39;name&#39;:&#39;alex&#39;,&#39;age&#39;:18},
    {&#39;id&#39;:2,&#39;name&#39;:&#39;wusir&#39;,&#39;age&#39;:17},
    {&#39;id&#39;:3,&#39;name&#39;:&#39;taibai&#39;,&#39;age&#39;:16},]

# 按照年龄对学生信息进行排序

print(sorted(lst,key=lambda e:e[&#39;age&#39;]))

结果:
[{&#39;id&#39;: 3, &#39;name&#39;: &#39;taibai&#39;, &#39;age&#39;: 16}, {&#39;id&#39;: 2, &#39;name&#39;: &#39;wusir&#39;, &#39;age&#39;: 17}, {&#39;id&#39;: 1, &#39;name&#39;: &#39;alex&#39;, &#39;age&#39;: 18}]
</code></pre>
<h4 id="filter-筛选过滤">&lt;4&gt; filter() 筛选过滤</h4>
<pre><code><code>def func(a):
    return a == 1

print(list(filter(func,[1,2,3,4,6])))
1,指定过滤规则(函数名[函数的内存地址])  2,要过滤的数据

自己模拟

def filter(func,argv):
    lst = []
    for i in argv:
        ret = func(i)
        if ret:
            lst.append(i)
    return lst

def foo(a):
    return a&gt;2

print(filter(foo,[1,2,3,4])) # filter(foo,[1,2,3,4])

def func(a):
    return a&gt;1
print(list(filter(func,[1,2,3,4,5])))

print(list(filter(lambda a:a&gt;1,[1,2,3,4,5])))

</code></pre>
<pre><code><code>语法: filter(function,iterable)

function: 用来筛选的函数,在filter中会自动的把iterable中的元素传递给function,然后根据function返回的True或者False来判断是否保留此项数据

iterable:可迭代对象

lst = [{&#39;id&#39;:1,&#39;name&#39;:&#39;alex&#39;,&#39;age&#39;:18},
        {&#39;id&#39;:1,&#39;name&#39;:&#39;wusir&#39;,&#39;age&#39;:17},
        {&#39;id&#39;:1,&#39;name&#39;:&#39;taibai&#39;,&#39;age&#39;:16},]

ls = filter(lambda e:e[&#39;age&#39;] &gt; 16,lst)

print(list(ls))

结果:
[{&#39;id&#39;: 1, &#39;name&#39;: &#39;alex&#39;, &#39;age&#39;: 18},
 {&#39;id&#39;: 1, &#39;name&#39;: &#39;wusir&#39;, &#39;age&#39;: 17}]
</code></pre>
<h4 id="map-映射将可迭代对象中的每个元素执行到指定的函数">&lt;5&gt; map() 映射（将可迭代对象中的每个元素执行到指定的函数）</h4>
<pre><code><code>def func(a,b):
    return a+b
print(list(map(func,[1,2,3,4,5],[33,22,44,55])))


def map(argv,args):
    lst = []
    num = len(args) if len(args) &lt; len(argv) else len(argv)
    for i in range(num):
        lst.append(argv[i] + args[i])
    return lst
print(map([1,2,3,4],[3,4,5,6,7,8,9,0]))

print(list(map(lambda x,y:x+y,[1,2,3,4,5],[33,22,44,55])))
</code></pre>
<pre><code><code>语法: map(function,iterable) 可以对可迭代对象中的每一个元素进映射,分别取执行function

计算列表中每个元素的平方,返回新列表

lst = [1,2,3,4,5]

def func(s):

    return  s*s

mp = map(func,lst)

print(mp)

print(list(mp))




改写成lambda

lst = [1,2,3,4,5]

print(list(map(lambda s:s*s,lst)))




计算两个列表中相同位置的数据的和

lst1 = [1, 2, 3, 4, 5]

lst2 = [2, 4, 6, 8, 10]

print(list(map(lambda x, y: x+y, lst1, lst2)))

结果:

[3, 6, 9, 12, 15]
</code></pre>
<h5 id="高阶函数内部帮我们做了一个for循环">高阶函数内部帮我们做了一个for循环</h5>
<h3 id="reduce-累计算">3、reduce 累计算</h3>
<pre><code><code>from functools import reduce   # 累计算
从 functools工具箱中拿来了reduce工具
def func(x,y):
    return x+y
print(reduce(func,[1,2,3,4,5]))
print(reduce(lambda x,y:x+y,[1,2,3,4,5]))
</code></pre>
<pre><code><code>from functools import reduce
def func(x,y):
    return x + y

# reduce 的使用方式:
# reduce(函数名,可迭代对象)  # 这两个参数必须都要有,缺一个不行

ret = reduce(func,[3,4,5,6,7])
print(ret)  # 结果 25
reduce的作用是先把列表中的前俩个元素取出计算出一个值然后临时保存着,
接下来用这个临时保存的值和列表中第三个元素进行计算,求出一个新的值将最开始
临时保存的值覆盖掉,然后在用这个新的临时值和列表中第四个元素计算.依次类推

注意:我们放进去的可迭代对象没有更改
以上这个例子我们使用sum就可以完全的实现了.我现在有[1,2,3,4]想让列表中的数变成1234,就要用到reduce了.
普通函数版
from functools import reduce

def func(x,y):

    return x * 10 + y
    # 第一次的时候 x是1 y是2  x乘以10就是10,然后加上y也就是2最终结果是12然后临时存储起来了
    # 第二次的时候x是临时存储的值12 x乘以10就是 120 然后加上y也就是3最终结果是123临时存储起来了
    # 第三次的时候x是临时存储的值123 x乘以10就是 1230 然后加上y也就是4最终结果是1234然后返回了

l = reduce(func,[1,2,3,4])
print(l)


匿名函数版
l = reduce(lambda x,y:x*10+y,[1,2,3,4])
print(l)


在Python2.x版本中recude是直接 import就可以的, Python3.x版本中需要从functools这个包中导入

龟叔本打算将 lambda 和 reduce 都从全局名字空间都移除, 舆论说龟叔不喜欢lambda 和 reduce

最后lambda没删除是因为和一个人给龟叔写了好多封,进行交流然后把lambda保住了.
</code></pre>
<h3 id="section"></h3>

</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>