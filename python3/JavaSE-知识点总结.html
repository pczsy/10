<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修JavaSE-知识点总结' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>JavaSE-知识点总结</center></div><div class='banquan'>原文出处:本文由博客园博主远离颠倒梦想提供。<br/>
原文连接:https://www.cnblogs.com/Open-ing/p/11873019.html</div><br>
    <h1 style="text-align: center;">Java名词</h1>
<h3 class="md-end-block md-focus"><a href="#variable">变量</a>、<span class="md-expand"><a href="#operator">运算符</a>、</span><span class="md-expand"><a href="#clas">类</a>、</span><span class="md-expand"><a href="#interface">接口</a>、</span><span class="md-expand"><a href="#enum" target="_blank">枚举</a>、</span><span class="md-expand"><a href="#parameter">参数</a>、</span><span class="md-expand"><a href="#annotation">注解</a>、</span><span class="md-expand"><a href="#throwable">异常</a>、</span><span class="md-expand"><a href="#number">包装类</a>、</span><span class="md-expand"><a href="#thread">多线程</a>、</span><a href="#collection">&nbsp;集合</a>、<span class="md-expand"><a href="#IO">IO流</a>、</span><span class="md-expand"><a href="#socket">网络编程</a>、</span><span class="md-expand"><a href="#class">反射</a>、<a href="#lambda">Lambda</a>、<a href="https://www.cnblogs.com/Open-ing/p/11892237.html" target="_blank">API</a></span></h3>
<p>源文件：.java文件，存储Java源代码的文件</p>
<p>字节码文件：.class文件，由Java源代码编译后生成的.class文件，可以被JVM读取和执行的文件。</p>
<p>运行Java程序，其实就是执行.class字节码文件，由JVM把字节码数据再转为二进制的机器指令执行。</p>
<h3>数据类型</h3>
<p class="md-end-block"><span>基本<strong>数据类型</strong>：8种，byte,short,int,long,float,double,char,boolean</span></p>
<p class="md-end-block md-focus"><span>引用数据类型：类、接口、枚举、数组、注解</span></p>
<h2 class="md-end-block md-focus"><span><a name="variable"></a>变量</span></h2>
<p>变量根据数据类型的不同分为基本数据类型的变量和引用数据类型的变量。</p>
<p>变量根据声明位置不同分为成员变量和局部变量</p>
<p class="md-end-block md-focus"><span>（A）局部变量声明位置：</span></p>
<p class="md-end-block"><strong>①方法的形参列表</strong></p>
<p class="md-end-block"><strong>②方法体{}中</strong></p>
<p class="md-end-block"><strong>③代码块{}中</strong></p>
<p class="md-end-block"><span class="md-expand">成员变量声明位置：<strong>类中</strong>，方法和代码块外面，按照是否有static修饰分为：类变量(静态变量) 和 实例变量(非静态变量)</span></p>
<p class="md-end-block"><span>（B）内存存储的位置不同</span></p>
<p class="md-end-block"><span>局部变量：栈</span></p>
<p class="md-end-block"><span class="md-tab"> <span>实例变量：堆</span></span></p>
<p class="md-end-block"><span class="md-tab"> <span>类变量：方法区</span></span></p>
<p class="md-end-block"><span>（C）生命周期</span></p>
<p class="md-end-block"><span>局部变量</span></p>
<p class="md-end-block"><span class="md-tab"> <span class="md-expand">每一个线程每一次调用都是一次新的生命周期</span></span></p>
<p class="md-end-block"><span class="md-tab"> <span>实例变量：每一个对象的成员变量是独立的，和对象的生命周期一致</span></span></p>
<p class="md-end-block"><span class="md-tab"> <span>类变量：和类的生命周期一致</span></span></p>
<p class="md-end-block md-focus"><span>（D）作用域</span></p>
<p class="md-end-block"><span>局部变量：作用域非常小，从声明它的位置开始，到它所属的}结束，可能只属于某个if,for,方法等</span></p>
<p class="md-end-block"><span class="md-tab"> <span>类变量：整个类中</span></span></p>
<p class="md-end-block"><span class="md-tab"> <span>实例变量：整个类中除了静态方法和静态代码块中不能使用</span></span></p>
<p class="md-end-block"><span>（E）修饰符</span></p>
<p class="md-end-block"><span>局部变量：唯一可以有的修饰符是final</span></p>
<p class="md-end-block md-focus"><span class="md-expand">成员变量：权限修饰符、static、final、....</span></p>
<h2><span class="md-expand"><a name="operator"></a>运算符</span></h2>
<p>整数与整数相除，只保留整数部分</p>
<p>取模结果的正负号只看被模数</p>
<p class="md-end-block md-focus"><span class="md-expand">++/--在前的，就先自增/自减，后取值</span></p>
<p class="md-end-block md-focus">++/--在后的，就先取值，后自增/自减</p>
<p class="md-end-block md-focus"><span class="md-expand">所有的赋值运算符的=左边一定是一个变量，而且先算右边，然后<strong>最后把值赋值给左边的变量</strong></span></p>
<p class="md-end-block"><span>扩展赋值运算符+=右边的计算结果的类型如果比左边的大的话会强制类型转换，所以结果<strong>可能有风险</strong>。</span></p>
<p>比较表达式的运算结果一定只有<strong>true/false</strong></p>
<p><span class="md-expand">&amp;<span class="md-softbreak"> <span class="md-tab"> <span>只有左右两边都为true，结果才为true。</span></span></span></span></p>
<p><span class="md-expand">|<span class="md-softbreak"> <span class="md-tab"> <span>只要左右两边有一个为true，结果就为true。</span></span></span></span></p>
<p><span class="md-expand">^<span class="md-softbreak"> <span class="md-tab"> <span>只有左右两边不同，结果才为true。</span></span></span></span></p>
<p><span class="md-expand">!<span class="md-softbreak"> <span class="md-tab"> <span>布尔值取反</span></span></span></span></p>
<p>&amp;&amp;它和逻辑与不同的是当&amp;&amp;左边为false时，右边就不看了。</p>
<p>||它和逻辑或不同的时当||左边为true时，右边就不看了。</p>
<p>条件表达式 ？ 结果表达式1 : 结果表达式2　　　　//为true返回1，否则返回2</p>
<p class="md-end-block md-heading md-focus"><strong><span class="md-expand">位运算符：</span></strong><span class="md-expand">所有的位运算符的规则都是用数字的<strong>二进制补码</strong>形式进行运算的</span></p>
<p>&lt;&lt;　左移动几位，右边补0。左移几位就是乘以2的几次方</p>
<p>&gt;&gt;　右移动几位，左边补0或1，看最高位。右移几位就是除以2的几次方</p>
<p>&gt;&gt;&gt;　右移动几位，左边<strong>一律</strong>补0</p>
<p>按位与：&amp;&nbsp;运算规则，把两个数的二进制一一对应，对应位按位与。</p>
<p>按位或：|&nbsp;运算规则，把两个数的二进制一一对应，对应位按位或。</p>
<p>按位异或：^&nbsp;运算规则，把两个数的二进制一一对应，对应位按位或。</p>
<p>按位取反：~&nbsp;运算规则，把某个数的二进制，按位取反，<strong>注意</strong>：包括最高位也会取反，这个和从原码到反码是不一样的。</p>
<p>优先级：需要先计算的就用（）括起来</p>
<p>对象1 == 对象2&nbsp; &nbsp; //比较的是地址，而且对象1和对象2的<strong>类型要一致</strong>或者是<strong>父子类</strong>关系，否则编译不通过</p>
<p>对象&nbsp; <strong>instanceof</strong> 类型&nbsp;</p>
<p>只有当该对象属于这个类型才会返回true，而且要求该对象的编译时类型必须与要判断的类型一致或有父子类关系</p>
<p>引用数据类型的类型或对象，可以通过 <strong>.</strong> 来访问属性、方法等。</p>
<p><strong>()</strong>用于强制类型转换或<strong>优先计算强制类型转换</strong></p>
<p>&nbsp;流程：解决问题的步骤</p>
<p class="md-end-block md-focus"><span class="md-expand">（1）顺序语句：顺序结构</span></p>
<p class="md-end-block"><span class="md-tab"> <span>（2）分支语句：选择其中一个分支执行</span></span></p>
<p class="md-end-block"><span class="md-tab"> <span>（3）循环语句：重复执行某些代码</span></span></p>
<p><strong>&nbsp;凡是有[]的都是数组</strong></p>
<h2 class="md-end-block md-heading md-focus"><span class="md-expand"><a name="clas"></a>类（class）</span></h2>
<p>&nbsp;使用class声明的类型都是类</p>
<p>【修饰符】 class 类名 【extends 父类】 【implements 父接口n】{<br />    <br />}</p>
<p class="md-end-block"><span>类中可以包含5个部分：</span></p>
<p class="md-end-block"><span>（1）<strong>成员变量</strong>：</span></p>
<p class="md-end-block"><span class="md-tab"> <span>静态成员变量：存储类共享数据</span></span></p>
<p class="md-end-block"><span class="md-tab"> <span>非静态成员变量：存储对象独立数据</span></span></p>
<p class="md-end-block"><span>（2）<strong>成员方法</strong>：完成功能</span></p>
<p class="md-end-block"><span>（3）<strong>构造器</strong>：创建对象，是实例初始化的一部分</span></p>
<p class="md-end-block"><span>（4）代码块：</span></p>
<p class="md-end-block"><span class="md-tab"> <span>静态代码块：类初始化的一部分</span></span></p>
<p class="md-end-block"><span class="md-tab"> <span>非静态代码块：实例初始化的一部分</span></span></p>
<p class="md-end-block md-focus"><span class="md-expand">（5）成员内部类/成员内部接口：为外部类服务</span></p>
<h2 class="md-end-block md-heading md-focus"><span class="md-expand"><a name="interface"></a>接口（interface）</span></h2>
<p><span class="md-expand">使用interface声明的类型都是接口</span></p>
<p>【修饰符】 interface 接口 【extends 父接口们】{<br />    <br />}</p>
<p class="md-end-block"><span>接口中的成员有限制要求：</span></p>
<p class="md-end-block"><span>JDK1.8之前：</span></p>
<p class="md-end-block"><span class="md-tab"> <span>（1）公共的静态的常量：public static final</span></span></p>
<p class="md-end-block"><span class="md-tab"> <span>（2）公共的抽象方法：public abstract</span></span></p>
<p class="md-end-block"><span>JDK1.8之后，增加了：</span></p>
<p class="md-end-block"><span class="md-tab"> <span>（3）公共的静态方法：public static</span></span></p>
<p class="md-end-block md-focus"><span class="md-tab"> <span class="md-expand">（4）公共的默认方法：public default</span></span></p>
<h3 class="md-end-block md-focus"><span class="md-tab"><span class="md-expand">方法重写的要求</span></span></h3>
<p class="md-end-block md-focus"><span>（1）修饰符：&gt;=父类权限</span></p>
<p class="md-end-block"><span>（2）返回值类型</span></p>
<p class="md-end-block"><span class="md-tab"> <span>基本数据类型和void：必须相同</span></span></p>
<p class="md-end-block"><span class="md-tab"> <span>引用数据类型：&lt;=父类类型</span></span></p>
<p class="md-end-block"><span>（3）方法名：必须相同</span></p>
<p class="md-end-block"><span>（4） 形参列表：必须相同</span></p>
<p class="md-end-block"><span>（5）抛出的异常类型：&lt;=父类类型</span></p>
<p class="md-end-block"><span class="md-expand">（6）被重写的方法不能是：static,final,private等</span></p>
<h2 class="md-end-block md-heading md-focus"><span class="md-expand"><a name="enum"></a>枚举（enum）</span></h2>
<p><span class="md-expand">使用enum声明的类型都是枚举</span></p>
<p>【修饰符】 enum 枚举类型名 【implements 父接口们】{<br />}</p>
<p class="md-end-block"><span>枚举是一种特殊的类：</span></p>
<p class="md-end-block"><span>（1）枚举的首行必须是枚举的常量对象列表；</span></p>
<p class="md-end-block"><span>（2）枚举的构造器都是private</span></p>
<p class="md-end-block md-focus"><span class="md-expand">（3）枚举的直接父类一定是java.lang.Enum类</span></p>
<h2 class="md-end-block md-heading md-focus"><span class="md-expand"><a name="parameter"></a>参数</span></h2>
<p>&nbsp;参数就是一种传递数据的方式，所以参数就是一个变量，具有特殊作用的特殊位置的变量。</p>
<p class="md-end-block"><span class="md-expand">和参数相关的几个名词：</span></p>
<p class="md-end-block"><span class="md-tab"> <span>（1）形参（formal parameter）</span></span></p>
<p class="md-end-block"><span class="md-tab"><span>　　在声明方法时()中的参数</span></span></p>
<p class="md-end-block"><span class="md-tab"> <span>（2）实参（actual parameter）</span></span></p>
<p class="md-end-block"><span class="md-tab"><span>　　在调用方法时()中的参数，实参是给形参赋值的，所以实参的个数、类型、顺序必须与形参一一对应。</span></span></p>
<p class="md-end-block"><span class="md-tab"> <span>（3）有参（has parameter）</span></span></p>
<p class="md-end-block"><span class="md-tab"><span>　　声明方法时有形参列表，调用方法时有实参列表</span></span></p>
<p class="md-end-block"><span class="md-tab"> <span>（4）无参（no parameter）</span></span></p>
<p class="md-end-block"><span class="md-tab"><span>　　声明方法时没有形参列表，调用方法时没有实参列表</span></span></p>
<p class="md-end-block"><span class="md-tab"> <span>（5）命令行参数（command line parameter/ arguments）</span></span></p>
<p class="md-end-block"><span class="md-tab"><span>　　运行main时，给main传的参数</span></span></p>
<p class="md-end-block"><span class="md-tab"><span>　　java 类名&nbsp; 命令行参数1&nbsp; 命令行参数2 ....</span></span></p>
<p class="md-end-block"><span class="md-tab"> <span>（6）可变参数（variable parameter）</span></span></p>
<p class="md-end-block"><span class="md-tab"><span>　　声明：</span></span></p>
<p>　　【修饰符】 返回值类型 方法名(【非可变参数部分的形参列表,】 可变参数类型<strong>...</strong> args)throws 异常列表{<br />    　　　　for(int i=0; i&lt;args.length; i++){　　//可变参数部分当做<strong>数组</strong>使用<br />        　　　　　　//...<br />    　　　　}<br />　　}</p>
<p class="md-end-block"><span class="md-tab"> <span>（7）类型参数（type parameter，generic Type）</span></span></p>
<p class="md-end-block"><span class="md-tab"><span>　　凡是代码中出现在&lt;&gt;中的类型，就是类型参数。</span></span></p>
<p class="md-end-block"><span class="md-tab"> <span>（8）类型形参（type parameter）</span></span></p>
<p class="md-end-block"><span class="md-tab"><span>　　在声明<strong>类/接口</strong>时声明的类型参数，也称为泛型形参</span></span></p>
<p class="md-end-block">【修饰符】 class 类名/接口&lt;类型形参列表&gt;{}</p>
<p class="md-end-block">【修饰符】 class 类名/接口&lt;类型形参1 extends 父类上限 &amp; 父接口上限&gt;{}</p>
<p>　　在声明<strong>方法</strong>时声明的类型参数</p>
<p>【修饰符】 &lt;泛型形参列表&gt; 返回值类型 方法名(【数据形参列表】)【throws 异常列表】{}<br />【修饰符】 &lt;泛型形参 extends 父类上限 &amp; 父接口上限&gt;  返回值类型  方法名(【数据形参列表】)【throws 异常列表】{}</p>
<p class="md-end-block"><span class="md-tab"> <span>（9）类型实参（type arguments）</span></span></p>
<p class="md-end-block"><span class="md-tab"><span>　　在使用泛型类/接口时指定泛型类型的类型参数</span></span></p>
<p class="md-end-block"><span class="md-tab"><span>　　在使用泛型方法时传给泛型类的<strong>变量</strong>会自动识别变量类型，即为泛型方法实参</span></span></p>
<p class="md-end-block md-focus"><span class="md-tab"> <span>（10）传参（pass parameter）</span></span></p>
<p class="md-end-block"><span>凡是实参给形参赋值都是叫做传参。</span></p>
<p class="md-end-block md-focus"><span>记住：实参与形参的类型、个数、顺序<strong>一一对应</strong>即可。</span></p>
<h2 class="md-end-block md-heading md-focus"><span class="md-expand"><a name="annotation"></a>注解（annotation）</span></h2>
<p>使用@interface声明的类型都是注解，只要使用@标记符的都是注解</p>
<p>@元注解<br />【修饰符】 @interface 注解名{<br />    　　数据类型  参数名(); <br />    　　数据类型  参数名() default 默认值;<br />}</p>
<p class="md-end-block"><span class="md-expand">（1）如果注解有配置参数，那么在使用时，需要给配置参数赋值，除非有默认值</span></p>
<p class="md-end-block"><span>（2）给配置参数赋值的标准格式：参数名 = 参数值，但是如果注解的配置参数只有一个，而且名称是value，那么在赋值时可以省略value=</span></p>
<p class="md-end-block md-focus"><span>（3）如果配置参数是数组类型，那么赋值时可以用&ldquo;{多个值}&rdquo;</span></p>
<h4 class="md-end-block md-heading">@Override</h4>
<p class="md-end-block"><span class="md-tab">用于检测被修饰的方法为有效的重写方法，如果不是，则报编译错误!</span></p>
<p class="md-end-block"><span class="md-tab">只能标记在方法上。</span></p>
<p class="md-end-block md-heading md-focus"><strong><span class="md-expand">JUnit单元测试</span></strong></p>
<ul>
<li>@Test：标记在非静态的测试方法上。需导入junit包</li>










</ul>
<p class="md-end-block"><strong><span class="md-tab">文档注解:</span></strong></p>
<ul class="ul-list" data-mark="*">
<li class="md-list-item md-focus-container">
<p class="md-end-block md-focus">@author 标明开发该类模块的作者，多个作者之间使用,分割</p>










</li>
<li class="md-list-item">
<p class="md-end-block">@version 标明该类模块的版本</p>










</li>
<li class="md-list-item">
<p class="md-end-block">@see 参考转向，也就是相关主题</p>










</li>
<li class="md-list-item">
<p class="md-end-block">@since 从哪个版本开始增加的</p>










</li>
<li class="md-list-item">
<p class="md-end-block">@param 对方法中某参数的说明，如果没有参数就不能写</p>










</li>
<li class="md-list-item">
<p class="md-end-block"><span class="md-expand">@return 对方法返回值的说明，如果方法的返回值类型是void就不能写</span></p>










</li>
<li class="md-list-item">
<p class="md-end-block">@throws/@exception 对方法可能抛出的异常进行说明 ，如果方法没有用throws显式抛出的异常就不能写</p>
<ul class="ul-list" data-mark="*">
<li class="md-list-item">
<p class="md-end-block">其中 @param @return 和 @exception 这三个标记都是只用于方法的。</p>










</li>
<li class="md-list-item">
<p class="md-end-block">@param的格式要求：@param 形参名 形参类型 形参说明</p>










</li>
<li class="md-list-item">
<p class="md-end-block">@return 的格式要求：@return 返回值类型 返回值说明</p>










</li>
<li class="md-list-item">
<p class="md-end-block">@exception 的格式要求：@exception 异常类型 异常说明</p>










</li>
<li class="md-list-item">
<p class="md-end-block">@param和@exception可以并列多个</p>










</li>










</ul>










</li>










</ul>
<h2 class="md-end-block md-heading md-focus"><span class="md-expand"><a name="throwable"></a>异常（Exception）</span></h2>
<p class="md-end-block md-focus"><span>Java异常和错误的根父类：java.lang.<strong>Throwable</strong></span></p>
<p class="md-end-block"><span>（1）只有是这个类或它的子类的对象，才能被JVM或throw语句&ldquo;抛&rdquo;出</span></p>
<p class="md-end-block"><span>（2）也只有这个类或它的子类的对象，才能被catch给&ldquo;捕获&rdquo;</span></p>
<p class="md-end-block"><span>（3）如果用户需要自定义异常，那么必须继承Throwable或它的子类。</span></p>
<p class="md-end-block"><span>Java异常的分类：</span></p>
<ul>
<li class="md-end-block"><span class="md-tab"> <span>Error：错误，合理的应用程序不应该试图捕获的异常.</span></span></li>
<li class="md-end-block"><span class="md-tab"> <span>Exception：异常，合理的应用程序应该、想要捕获的异常。<span class="md-softbreak"> <span>Java异常的分类：</span></span></span></span></li>
<li class="md-end-block"><span class="md-tab"> <span>运行时异常（非受检异常）：RuntimeException及其子类，编译器不会提示你需要加try...catch处理</span></span></li>
<li class="md-end-block md-focus"><span class="md-tab"> <span class="md-expand">编译时异常（受检异常）：RuntimeException系列以外的，编译器一定会要求你加try...catch处理的</span></span></li>










</ul>
<p><span class="md-expand">不管是什么异常，最终都要进行处理，如果不处理，会导致程序终止运行</span></p>
<p><span class="md-expand"><strong>try：</strong>尝试执行某些代码，看是否会发生异常</span></p>
<p><span class="md-expand"><span class="md-softbreak"><span><strong>catch：</strong>尝试捕获某个异常，如果可以捕获，就处理它</span></span></span></p>
<p><span class="md-expand"><span class="md-softbreak"><span><span class="md-softbreak"><span><strong>finally：</strong>无论try中是否有异常发生，也不管catch是否可以捕获这个异常，<span class="md-softbreak"> <span class="md-tab"> <span>哪怕try或catch有return，都无法阻止我运行finally中的代码。</span></span></span></span></span></span></span></span></p>
<p><span class="md-expand"><span class="md-softbreak"><span><span class="md-softbreak"><span><span class="md-softbreak"><span class="md-tab"><span><span class="md-softbreak"><span><strong>throw：</strong>手动抛出异常对象</span></span></span></span></span></span></span></span></span></span></p>
<p><span class="md-expand"><span class="md-softbreak"><span><span class="md-softbreak"><span><span class="md-softbreak"><span class="md-tab"><span><span class="md-softbreak"><span><span class="md-softbreak"><span><strong>throws：</strong>在方法声明时，显式的说明该方法会抛出xx异常，提醒调用者要处理这些异常。</span></span></span></span></span></span></span></span></span></span></span></span></p>
<p><span class="md-expand"><span class="md-softbreak"><span><span class="md-softbreak"><span><span class="md-softbreak"><span class="md-tab"><span><span class="md-softbreak"><span><span class="md-softbreak"><span><strong>语法</strong>：</span></span></span></span></span></span></span></span></span></span></span></span></p>
<p> try{<br /> 　　}catch(...){<br /> 　　}finally{<br />     　　//无论try中是否发生异常，也无论catch是否捕获异常，也不管try和catch中是否有return语句，都一定会执行<br /> }<br /> 或<br />  try{<br /> 　　}finally{<br />     　　//无论try中是否发生异常，也不管try中是否有return语句，都一定会执行<br /> }</p>
<h4 class="md-end-block md-heading md-focus"><span class="md-expand">新try..catch</span></h4>
<p class="md-end-block">语法格式：</p>
<pre><code><span class="cm-keyword">try(<span class="cm-variable">需要关闭的资源对象的声明){<br /> &nbsp; &nbsp;<span class="cm-variable">业务逻辑代码<br />}<span class="cm-keyword">catch(<span class="cm-variable">异常类型 <span class="cm-variable">e){<br /> &nbsp; &nbsp;<span class="cm-variable">处理异常代码<span class="cm-keyword"><span class="cm-variable"><span class="cm-variable"><span class="cm-variable"><br />....</span></span></span></span></span></span></span></span></span></span></span></pre>
<p class="md-end-block md-focus">它没有finally，也不需要程序员去关闭资源对象，无论是否发生异常，都会关闭资源对象</p>
<h3><a href="https://www.cnblogs.com/Open-ing/articles/11914883.html" target="_blank">常见的异常类型</a></h3>
<h2 class="md-end-block md-heading md-focus"><span class="md-expand"><a name="number"></a>包装类</span></h2>
<p class="md-end-block md-focus"><span class="md-expand">char -&gt;Character</span></p>
<p class="md-end-block"><span>byte -&gt; Byte</span></p>
<p class="md-end-block"><span>short -&gt; Short</span></p>
<p class="md-end-block"><span>int -&gt; Integer</span></p>
<p class="md-end-block"><span>long -&gt; Long</span></p>
<p class="md-end-block"><span>float -&gt; Float</span></p>
<p class="md-end-block"><span>double -&gt; Double</span></p>
<p class="md-end-block"><span>boolean -&gt; Boolean</span></p>
<p class="md-end-block"><span>void -&gt; Void</span></p>
<p>装箱：把基本数据类型转为包装类对象。</p>
<p>拆箱：把包装类对象拆为基本数据类型。</p>
<p class="md-end-block md-heading md-focus"><span class="md-expand">包装类对象有<strong>缓存问题</strong></span></p>
<p>在缓存范围内的对象，缓冲的常量对象在方法区直接引用。没有缓存的对象，每一个都是新new的</p>
<h2 class="md-end-block md-heading md-focus"><span class="md-expand"><a name="thread"></a>多线程</span></h2>
<p class="md-end-block">创建<a title="更多" href="https://www.cnblogs.com/Open-ing/p/11953108.html" target="_blank">多线程</a>的两种方式（JavaSE阶段）</p>
<p class="md-end-block"><span>1、 继承<strong>Thread</strong>类</span></p>
<p class="md-end-block"><span>（1）编写线程类，继承Thread类</span></p>
<p class="md-end-block md-focus"><span class="md-expand">（2）必须重写public void run(){}</span></p>
<p class="md-end-block"><span>（3）创建自定义线程类的对象</span></p>
<p class="md-end-block"><span>（4）调用start()方法启动线程</span></p>
<p class="md-end-block"><span>2、实现<strong>Runnable</strong>接口</span></p>
<p class="md-end-block"><span>（1）编写线程类，实现Runnable接口</span></p>
<p class="md-end-block"><span>（2）必须重写public void run(){}</span></p>
<p class="md-end-block"><span>（3）创建自定义线程类的对象</span></p>
<p class="md-end-block md-focus"><span>（4）通过Thread类的<strong>代理对象</strong>，调用start()方法启动线程</span></p>
<p><strong>　　如：</strong>MyRunnable my = new MyRunnable();<br />	　　　　Thread t = new Thread(my);<br />	　　　　t.start();</p>
<h3 class="md-end-block md-heading md-focus"><span class="md-expand">线程安全问题</span></h3>
<p class="md-end-block"><span>1、什么情况下会有线程安全问题？<span class="md-softbreak"> 　　<span>多个线程使用了共享数据</span></span></span></p>
<p class="md-end-block md-focus"><span>2、如何解决线程安全问题？<span class="md-softbreak"> 　　　　　<span>SE阶段：<strong>synchronized</strong></span></span></span></p>
<p>（1）同步代码块</p>
<p>　　synchronized(锁对象){<br />    　　　　//在一个线程执行期间，不想要被其他线程打扰的代码，一般是一次事务的原子性操作。<br />　　}</p>
<p><strong>锁对象</strong>：自选的，但是要保证使用共享数据的这多个线程必须共用一个锁对象（监视器对象）</p>
<p>至于是否可以选用this作为锁对象，要看是否多个线程共用同一个this对象</p>
<p>（2）同步方法</p>
<p>　　【修饰符】 synchronized 返回值类型 方法名(【形参列表】){<br />	　　　　　//在一个线程执行期间，不想要被其他线程打扰的代码，一般是一次事务的原子性操作。<br />　　}</p>
<p><strong>锁对象：固定</strong>，非静态方法就是this，静态方法就是当前类的Class对象</p>
<p>多线程间的通信就是通过锁对象调用<strong>wait()</strong>等待与锁对象调用<strong>notify()</strong>唤醒来达到多线程间的调度</p>
<h2><a name="collection"></a>&nbsp;集合</h2>
<p><a title="更多" href="https://www.cnblogs.com/Open-ing/p/11991461.html" target="_blank">集合</a>：<span class="md-tab">是一种容器，用来装对象的容器，不能装基本数据类型。</span>也可以说是一种数据结构</p>
<p><code>Collection</code>中的集合称为单列集合，<code>Map</code>中的集合称为双列集合。</p>
<h3 class="md-end-block md-heading md-focus"><span class="md-plain md-expand">Iterator迭代器</span></h3>
<p>元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。</p>
<p class="md-end-block md-heading md-focus"><span class="md-plain md-expand">List 集合额外提供了一个ListIterator迭代器用来</span>专门操作 List 集合的一些方法</p>
<h3 class="md-end-block md-heading md-focus"><span class="md-plain md-expand">List</span></h3>
<ol>
<li><span class="md-plain md-expand">List集合所有的元素是以一种线性方式进行存储的</span></li>
<li><span class="md-plain md-expand">它是一个元素存取有序的集合。</span></li>
<li><span class="md-plain md-expand">它是一个带有索引的集合</span></li>
<li><span class="md-plain md-expand">集合中可以有重复的元素</span></li>

</ol>
<p><strong>ArrayList</strong>、Vector 顺序结构，线性的，动态数组的实现</p>
<p>Stock 链式结构，先进后出，栈结构</p>
<p><strong>LinkedList&nbsp;</strong>链式顺序结构，双端队列，双链表的实现，既可以用作FILO堆栈使用，又可以用作FIFO队列使用。</p>
<h3 class="md-end-block md-heading md-focus"><span class="md-plain md-expand">Set</span></h3>
<ol>
<li><span class="md-plain md-expand">Set接口是Collection的子接口，set接口没有提供额外的方法</span></li>
<li><span class="md-plain md-expand">Set 集合不允许包含相同的元素</span></li>

</ol>
<p><strong>HashSet</strong>、底层new的 HashMap</p>
<ul>
<li>HashSet 按 Hash 算法来存储集合中的元素，因此具有很好的存取和查找性能。</li>
<li>存储到HashSet的元素要重写hashCode和equals方法。</li>

</ul>
<p>LinkedHashSet 、底层new的 LinkedHashMap</p>
<ul>
<li>LinkedHashSet是HashSet的子类，增加两个属性before和after维护了结点的前后添加顺序</li>
<li>LinkedHashSet插入性能略低于 HashSet，但在迭代访问 Set 里的全部元素时有很好的性能。</li>

</ul>
<p>TreeSet&nbsp;底层new的TreeMap&nbsp;</p>
<ul>
<li><span class="md-plain md-expand">不允许重复</span></li>
<li><span class="md-plain md-expand"><span class="md-softbreak"> <span class="md-tab"> <span class="md-plain">实现排序<span class="md-softbreak"> <span class="md-tab"> <span class="md-plain md-expand">自然排序或定制排序</span></span></span></span></span></span></span></li>

</ul>
<h2>Map</h2>
<ol>
<li>Map中的集合不能包含重复的键，值可以重复；每个键只能对应一个值</li>
<li>Map.Entry是Map接口的内部接口，实际上是将Key----&gt;value的数据存储在Map.Entry接口的实例中，再在Map集合中插入Map.Entry的实例化对象</li>
<li>判断两个 key 相等的标准是：两个 key 的hashCode 值相等，并且 equals() 方法也返回 true，用作键的对象必须实现 hashCode 方法和 equals 方法</li>

</ol>
<p><strong>HashMap</strong>、Hashtable </p>
<ul>
<li>动态数组结构+链式结构或哈希结构,&nbsp;<span class="md-plain md-expand">是个散列表，其中维护了一个长度为<span><strong><span class="md-plain">2的幂次方</span></strong><span class="md-plain md-expand">的Entry类型的数组table，数组每个元素又</span></span></span>由链表或红黑树结构组成</li>

</ul>
<p>LinkedHashMap </p>
<ul>
<li>是HashMap的子类，与之不同的在于LinkedHashMap维护着一个运行于所有条目的双重链接列表，此链接列表定义了迭代顺序，该迭代顺序通常就是（插入顺序）</li>

</ul>
<p>TreeMap</p>
<ul>
<li>基于红黑树的 NavigableMap 接口实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。</li>

</ul>
<p><strong>Properties</strong></p>
<ul>
<li>是 Hashtable 的子类，Properties 可保存在流中或从流中加载。属性列表中每个键及其对应值都是一个字符串</li>

</ul>
<p><a title="更多" href="https://www.cnblogs.com/Open-ing/p/11991952.html" target="_blank"><strong>Collections</strong></a> 是一个操作 Set、List 和 Map 等<a title="框架图" href="https://www.cnblogs.com/Open-ing/p/11951499.html" target="_blank">集合</a>的工具类</p>
<h2 class="md-end-block md-heading md-focus"><span class="md-expand"><a name="IO"></a>IO流</span></h2>
<p>&nbsp;File类：文件和目录路径名的抽象表示形式。<code>File</code> 类的实例是<strong>不可变</strong>的</p>
<p>&nbsp;<a title="更多" href="https://www.cnblogs.com/Open-ing/p/12003457.html" target="_blank">IO流</a>是用于数据输入与输出</p>
<p class="md-end-block"><span>1、四大超类，抽象类</span></p>
<p class="md-end-block"><span>（1）InputStream：字节输入流</span></p>
<p class="md-end-block"><span>（2）OutputStream：字节输出流</span></p>
<p class="md-end-block"><span class="md-expand">（3）Reader：字符输入流</span></p>
<p class="md-end-block md-focus"><span>（4）Writer：字符输出流</span></p>
<p class="md-end-block"><span>2、常见IO流</span></p>
<p class="md-end-block"><span class="md-expand">（1）文件IO流</span></p>
<p class="md-end-block"><span>FileInputStream：文件字节输入流，可以读取任意类型的文件</span></p>
<p class="md-end-block"><span>FileOutputStream：文件字节输出流，可以把字节数据输出到任意类型的文件</span></p>
<p class="md-end-block"><span>FileReader：文件字符输入流，只能读取纯文本的文件。按照平台默认的字符编码进行解码。</span></p>
<p class="md-end-block md-focus"><span>FileWriter：文件字符输出流，只能把字符数据输出到纯文本文件。按照平台默认的字符编码进行编码。</span></p>
<p class="md-end-block"><span>（2）缓冲IO流</span></p>
<p class="md-end-block"><span class="md-expand">BufferedInputStream：字节输入缓冲流，给InputStream系列IO流增加缓冲效果</span></p>
<p class="md-end-block"><span class="md-expand"><span class="md-softbreak"> <span>BufferedOutputStream：字节输出缓冲流，给OutputStream系列IO流增加缓冲效果</span></span></span></p>
<p class="md-end-block"><span class="md-expand"><span class="md-softbreak"><span><span class="md-softbreak"><span>BufferedReader：字符输入缓冲流，给Reader系列IO流增加缓冲效果</span></span></span></span></span></p>
<blockquote>
<p class="md-end-block"><span>String readLine()：按行读取</span></p>






</blockquote>
<p class="md-end-block"><span>BufferedWriter：字符输出缓冲流，给Writer系列IO流增加缓冲效果</span></p>
<blockquote>
<p class="md-end-block"><span>void newLine()：输出换行符</span></p>
<p class="md-end-block md-focus"><span>void flush()</span></p>






</blockquote>
<p class="md-end-block"><span>（3）编码与解码的转换流</span></p>
<p class="md-end-block"><span>　　编码：OutputStreamWriter</span></p>
<p class="md-end-block"><span class="md-tab"> <span>可以把字符流转为字节流输出，并且可以指定字符编码。</span></span></p>
<p class="md-end-block"><span class="md-tab"><span><strong>应用场景</strong>：可将要写入的字符源为字节流的数据转为字符类型写入并可按指定字符集再编码成字节存储</span></span></p>
<p class="md-end-block"><span class="md-expand">　　解码：InputStreamReader</span></p>
<p class="md-end-block md-focus"><span class="md-tab"> <span>可以把字节输入流转为字符输入流，并且可以指定字符编码。</span></span></p>
<p class="md-end-block md-focus"><span class="md-tab"><span><strong>应用场景</strong>：读取源为字符类型的字节流可指定字符集解码成字符流，以便阅读</span></span></p>
<p class="md-end-block"><span>（4）数据IO流</span></p>
<p class="md-end-block"><span class="md-expand">DataInputStream：允许应用程序以与机器无关方式从底层输入流中读取基本 Java 数据类型。</span></p>
<p class="md-end-block"><span class="md-expand"><span class="md-softbreak"><span>DataOutputStream：允许应用程序以适当方式将基本 Java 数据类型写入输出流中。</span></span></span></p>
<blockquote>
<p class="md-end-block"><span>它俩必须配对使用，</span>读的顺序要与写的顺序一致</p>






</blockquote>
<p class="md-end-block"><span>（5）对象IO流，同上也需配对，读写顺序一致</span></p>
<p class="md-end-block"><span>ObjectOutputStream：对象序列化，输出对象，把对象转为字节序列输出</span></p>
<blockquote>
<p class="md-end-block"><span>void writeObject(Object obj)</span></p>






</blockquote>
<ul>
<li class="md-end-block md-focus"><span>所有要序列化的对象的类型都必须实现java.io.Serializable接口</span></li>






</ul>
<ul>
<li class="md-end-block _mce_tagged_br"><span>如果对象的属性类型也是引用数据类型，那么也要实现java.io.Serializable接口</span></li>






</ul>
<ul>
<li class="md-end-block"><span><span>希望类的修改对象反序列化不产生影响，需增加一个序列化版本ID</span></span>
<ul>
<li class="md-end-block _mce_tagged_br">private static final long serialVersionUID = 1L;</li>






</ul>






</li>
<li class="md-end-block"><span>如果有些属性不想要序列化，可以加transient</span></li>






</ul>
<ul>
<li class="md-end-block"><span class="md-expand">如果某个属性前面有static修饰，也不参与序列化</span></li>






</ul>
<p class="md-end-block"><span>ObjectInputStream：对象反序列化，读取对象，把字节序列重构成Java对象</span></p>
<blockquote>
<p class="md-end-block md-focus"><span>Object readObject()</span></p>






</blockquote>
<p class="md-end-block"><span>（6）打印流</span></p>
<div class="cnblogs_code">
<pre><code>PrintStream、PrintWriter：println()和 print()</pre>
</div>
<p class="md-end-block"><span>（7）文本扫描仪</span></p>
<p class="md-end-block md-focus"><span>Scanner</span></p>
<h2 class="md-end-block md-heading md-focus"><span class="md-expand"><a name="socket"></a>网络编程</span></h2>
<p><span class="md-expand">三要素：1.协议。2.IP地址。3.端口号</span></p>
<p><a title="更多" href="https://www.cnblogs.com/Open-ing/p/12006106.html" target="_blank">Socket</a>：通信的两端都要有Socket（也可以叫&ldquo;套接字&rdquo;），是两台机器间通信的端点。网络通信其实就是Socket间的通信。</p>
<h3>TCP</h3>
<p><span class="md-expand"><span class="md-expand">TCP协议是面向连接的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接,是一种面向连接的、可靠的、基于字节流的传输层的通信协议，可以连续传输大量的数据。</span></span></p>
<h4 class="md-end-block md-heading md-focus"><span class="md-expand">服务器端</span></h4>
<ul class="ul-list" data-mark="*">
<li class="md-list-item md-focus-container">
<p class="md-end-block md-focus"><span class="md-expand">调用 ServerSocket(int port) ：创建一个服务器端套接字，并绑定到指定端口上。用于监听客户端的请求。</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block"><span>调用 accept() ：监听连接请求，如果客户端请求连接，则接受连接，返回通信套接字对象。</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block"><span>调用 该Socket 类对象的 getOutputStream() 和 getInputStream () ：获取输出流和输入流，开始网络数据的发送和接收。</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-focus"><span>关闭Socket 对象：客户端访问结束，关闭通信套接字。</span></p>
</li>
</ul>
<h4 class="md-end-block md-heading md-focus"><span class="md-expand">客户端</span></h4>
<ul class="ul-list" data-mark="*">
<li class="md-list-item md-focus-container">
<p class="md-end-block md-focus"><span class="md-expand">创建 Socket ：根据指定服务端的 IP 地址或端口号构造 Socket 类对象。若服务器端响应，则建立客户端到服务器的通信线路。若连接失败，会出现异常。</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block"><span>打开连接到 Socket 的输入/ 出流： 使用 getInputStream()方法获得输入流，使用getOutputStream()方法获得输出流，进行数据传输</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block"><span>按照一定的协议对 Socket 进行读/ 写操作：通过输入流读取服务器放入线路的信息（但不能读取自己放入线路的信息），通过输出流将信息写入线路。</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-focus"><span>关闭 Socket ：断开客户端到服务器的连接，释放线路</span></p>
</li>
</ul>
<h3 class="md-end-block md-heading md-focus"><span class="md-expand">UDP</span></h3>
<p><span class="md-expand">UDP协议是一种<span><strong><span>面向非连接</span></strong><span>的协议，无连接的好处就是快，省内存空间和流量，因为维护连接需要创建大量的数据结构。UDP会尽最大努力交付数据，但不保证可靠交付，没有TCP的确认机制、重传机制，如果因为网络原因没有传送到对端，UDP也不会给应用层返回错误信息。</span></span></span></p>
<h2 class="md-end-block md-heading md-focus"><span class="md-expand"><a name="class"></a>反射</span></h2>
<p>类的加载又分为三个阶段</p>
<p>（1）加载：load　　（2）连接：link ①验证②准备③解析　　<span class="md-expand">（3）初始化：initialize（类初始化）即执行<span class="md-tag md-raw-inline">&lt;clinit&gt;<span>类初始化方法</span></span></span></p>
<p>不会导致类的初始化的情况，其他都会</p>
<p class="md-end-block"><span>　（1）使用某个类的静态的常量（static final）</span></p>
<p class="md-end-block"><span>　（2）通过子类调用父类的静态变量，静态方法，只会导致父类初始化，不会导致子类初始化，即只有声明静态成员的类才会初始化</span></p>
<p class="md-end-block"><span>　</span><span class="md-expand">（3）用某个类型声明数组并创建数组对象时，不会导致这个类初始化</span></p>
<p><strong><span>类加载器</span></strong></p>
<p>（1）引导类加载器（Bootstrap Classloader）又称为根类加载器</p>
<p>（2）扩展类加载器（Extension ClassLoader）</p>
<p>（3）应用程序类加载器（Application Classloader）</p>
<p>（4）自定义类加载器</p>
<p class="md-end-block md-heading md-focus"><strong><span class="md-expand">获取Class对象的四种方式</span></strong></p>
<p>（1）类型名.class</p>
<p>（2）对象.getClass()</p>
<p>（3）Class.forName(类型全名称)</p>
<p>（4）ClassLoader的类加载器对象.loadClass(类型全名称)</p>
<p class="md-end-block md-heading md-focus"><strong><span class="md-expand"><a title="更多" href="https://www.cnblogs.com/Open-ing/p/12031786.html" target="_blank">反射</a>可获取类型的详细信息</span></strong></p>
<p>可以获取：包、修饰符、类型名、父类（包括泛型父类）、父接口（包括泛型父接口）、成员（属性、构造器、方法）、注解（类上的、方法上的、属性上的）</p>
<p class="md-end-block md-heading md-focus"><strong><span class="md-expand">创建任意引用类型的对象两种方式</span></strong></p>
<p class="md-end-block"><span>1、直接通过Class对象来实例化（要求必须有无参构造）</span></p>
<p class="md-end-block md-focus"><span>2、通过获取构造器对象来进行实例化</span></p>
<p class="md-end-block md-heading md-focus"><strong><span class="md-expand">操作任意类型的属性</span></strong></p>
<p class="md-end-block"><span class="md-expand">（1）获取该类型的Class对象<span class="md-softbreak md-expand"> <span>Class clazz = Class.forName("com.atguigu.bean.User");</span></span></span></p>
<p class="md-end-block"><span>（2）获取属性对象<span class="md-softbreak"> <span>Field field = clazz.getDeclaredField("username");</span></span></span></p>
<p class="md-end-block"><span>（3）设置属性可访问&nbsp;</span>field.setAccessible(true);</p>
<p class="md-end-block"><span>（4）创建实例对象：如果操作的是非静态属性，需要创建实例对象<span class="md-softbreak"> <span>Object obj = clazz.newInstance();</span></span></span></p>
<p class="md-end-block"><span>（4）设置属性值&nbsp;</span>field.set(obj,"chai");</p>
<p class="md-end-block"><span class="md-softbreak">（5）获取属性值<span class="md-softbreak"> Object value = field.get(obj);</span></span></p>
<blockquote>
<p class="md-end-block md-focus"><span>如果操作静态变量，那么实例对象可以省略，用null表示</span></p>
</blockquote>
<p class="md-end-block md-heading md-focus"><strong><span class="md-expand">调用任意类型的方法</span></strong></p>
<p class="md-end-block md-focus"><span>（1）获取该类型的Class对象<span class="md-softbreak"> <span>Class clazz = Class.forName("com.atguigu.service.UserService");</span></span></span></p>
<p class="md-end-block md-focus"><span><span class="md-softbreak"><span><span class="md-softbreak"><span>（2）获取方法对象<span class="md-softbreak"> <span>Method method = clazz.getDeclaredMethod("login",String.class,String.class);</span></span></span></span></span></span></span></p>
<p class="md-end-block md-focus"><span><span class="md-softbreak"><span><span class="md-softbreak"><span><span class="md-softbreak"><span><span class="md-softbreak"><span>（3）创建实例对象<span class="md-softbreak"> <span>Object obj = clazz.newInstance();</span></span></span></span></span></span></span></span></span></span></span></p>
<p class="md-end-block md-focus"><span><span class="md-softbreak"><span><span class="md-softbreak"><span><span class="md-softbreak"><span><span class="md-softbreak"><span><span class="md-softbreak"><span><span class="md-softbreak"><span>（4）调用方法<span class="md-softbreak"> <span>Object result = method.invoke(obj,"chai","123);</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<blockquote>
<p class="md-end-block"><span>如果方法的权限修饰符修饰的范围不可见，也可以调用setAccessible(true)</span></p>
<p class="md-end-block"><span class="md-expand">如果方法是静态方法，实例对象也可以省略，用null代替</span></p>
</blockquote>
<h2 class="md-end-block md-focus"><a name="lambda"></a>&nbsp;Lambda</h2>
<p class="md-end-block md-heading md-focus"><strong><span class="md-plain md-expand">函数式编程思想：</span><span class="md-plain">强调做什么，而不是以什么形式做</span></strong></p>
<p class="md-end-block md-focus">&nbsp;只要能获取到结果,谁去做的,怎么做的都不重要,重视的是结果,不重视过程</p>
<h3 class="md-end-block md-heading md-focus"><span class="md-plain md-expand">函数式接口</span></h3>
<p class="md-end-block md-focus">&nbsp;标记了@FunctionalInterface</p>
<p class="md-end-block md-heading md-focus"><span class="md-plain md-expand">自定义函数式接口：只要确保接口中有且仅有一个抽象方法即可</span></p>
<p class="md-end-block md-focus">&nbsp;Java8新增了<a href="https://www.cnblogs.com/Open-ing/gallery/image/276908.html" target="_blank">四大类</a>，消费型、供给型、判断型、功能型。</p>
<p class="md-end-block md-focus"><strong>Lambda表达式语法格式</strong></p>
<div class="cnblogs_code">
<pre><code>(形参列表) -&gt; {Lambda体}</pre>
</div>
<p class="md-end-block md-p md-focus"><span class="md-plain">说明：</span></p>
<ul class="ul-list" data-mark="*">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">(形参列表)它就是你要赋值的函数式接口的抽象方法的(形参列表)，照抄</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">{Lambda体}就是实现这个抽象方法的方法体</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">-&gt;称为Lambda操作符（减号和大于号中间不能有空格，而且必须是英文状态下半角输入方式）</span></p>
</li>
</ul>
<p class="md-end-block md-p"><span class="md-plain">优化：Lambda表达式可以精简</span></p>
<ul class="ul-list" data-mark="*">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">当{Lambda体}中只有一句语句时，可以省略{}和{;}</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">当{Lambda体}中只有一句语句时，并且这个语句还是一个return语句，那么return也可以省略，但是如果{;}没有省略的话，return是不能省略的</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">(形参列表)的类型可以省略</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">当(形参列表)的形参个数只有一个，那么可以把数据类型和()一起省略，但是形参名不能省略</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain md-expand">当(形参列表)是空参时，()不能省略</span></p>
</li>
</ul>
<h3 class="md-end-block md-heading md-focus"><span class="md-plain md-expand">方法引用与构造器引用</span></h3>
<p class="md-end-block md-p md-focus"><span class="md-plain">方法引用的语法格式：</span></p>
<p class="md-end-block md-p"><span class="md-plain">（1）实例对象名::实例方法</span></p>
<p class="md-end-block md-p"><span class="md-plain">（2）类名::静态方法</span></p>
<p class="md-end-block md-p"><span class="md-plain md-expand">（3）类名::实例方法</span></p>
<p class="md-end-block md-p md-focus"><span class="md-plain">说明：</span></p>
<ul class="ul-list" data-mark="*">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">::称为方法引用操作符（两个:中间不能有空格，而且必须英文状态下半角输入）</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">Lambda表达式的形参列表，全部在Lambda体中使用上了，要么是作为调用方法的对象，要么是作为方法的实参。</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain md-expand">在整个Lambda体中没有额外的数据。</span></p>
</li>
</ul>
<p class="md-end-block md-p md-focus"><span class="md-plain">构造器引用的语法格式：</span></p>
<ul class="ul-list" data-mark="*">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">类名::new</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">数组类型名::new</span></p>
</li>
</ul>
<p class="md-end-block md-p md-focus"><span class="md-plain">（1）当Lambda表达式是创建一个对象，并且满足Lambda表达式形参，正好是给创建这个对象的构造器的实参列表。</span></p>
<p class="md-end-block md-p"><span class="md-plain">（2） 当Lambda表达式是创建一个数组对象，并且满足Lambda表达式形参，正好是给创建这个数组对象的长度</span></p>
<h3 class="md-end-block md-heading md-focus"><span class="md-plain md-expand">StreamAPI</span></h3>
<p class="md-end-block md-p"><span class="md-plain">①Stream 自己不会存储元素。</span></p>
<p class="md-end-block md-p"><span class="md-plain">②Stream 不会改变源对象。每次处理都会返回一个持有结果的新Stream。</span></p>
<p class="md-end-block md-p"><span class="md-plain">③Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。</span></p>
<p class="md-end-block md-focus">&nbsp;</p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>