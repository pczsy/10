<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修模块导入' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>模块导入</center></div><div class='banquan'>原文出处:本文由博客园博主626提供。<br/>
原文连接:https://www.cnblogs.com/fengqiang626/p/11245755.html</div><br>
    <div class="toc">
    <p class="toc-title">目录</p>
    <div class="toc-list">
        <ul>
        <li><a href="#模块的定义与分类">1.模块的定义与分类</a><ul>
        <li><a href="#模块是什么">1.1模块是什么？</a></li>
        <li><a href="#为什么要使用模块">1.2为什么要使用模块?</a></li>
        <li><a href="#模块的分类">1.3模块的分类</a></li>
        </ul></li>
        <li><a href="#import">2. import</a><ul>
        <li><a href="#import-使用">2.1 import 使用</a></li>
        <li><a href="#第一次导入模块执行三件事">2.2 第一次导入模块执行三件事</a></li>
        <li><a href="#被导入模块有独立的名称空间">2.3 被导入模块有独立的名称空间</a></li>
        <li><a href="#为模块起别名">2.4 为模块起别名</a></li>
        <li><a href="#导入多个模块">2.5 导入多个模块</a></li>
        </ul></li>
        <li><a href="#from-...-import-...">3.from ... import ...</a><ul>
        <li><a href="#from-...-import-...-使用">3.1 from ... import ... 使用</a></li>
        <li><a href="#from...import...-与import对比">3.2 from...import... 与import对比</a></li>
        <li><a href="#from-import也支持as">3.3 from … import也支持as</a></li>
        <li><a href="#一行导入多个">3.4 一行导入多个</a></li>
        <li><a href="#from-...-import">3.5 from ... import *</a></li>
        </ul></li>
        <li><a href="#py文件的两种功能">4.py文件的两种功能</a></li>
        <li><a href="#模块的搜索路径">5.模块的搜索路径</a></li>
        </ul>
    </div>
</div>
<h2 id="模块的定义与分类">1.模块的定义与分类</h2>
<h3 id="模块是什么">1.1模块是什么？</h3>
<p>​ 这几天，我们进入模块的学习。在学习模块之前，我们首先要知道，什么是模块？</p>
<p>​ 一个函数封装一个功能，你使用的软件可能就是由n多个函数组成的（先不考虑面向对象）。比如抖音这个软件，不可能将所有程序都写入一个文件，所以咱们应该将文件划分，这样其组织结构要好并且代码不冗余。假如分了10个文件，每个文件里面可能都有相同的功能（函数），怎么办？所以将这些相同的功能封装到一个文件中，那么这个存储着很多常用的功能的py文件，就是模块。 模块就是文件，存放一堆常用的函数，比如：我要在大草原上策马奔腾，应该怎么样？我应该骑马，你也要去浪，你是不是也要骑马。我们说一个函数就是一个功能，那么把一些常用的函数放在一个py文件中，这个文件就称之为模块，模块，就是一些列常用功能的集合体。</p>
<h3 id="为什么要使用模块">1.2为什么要使用模块?</h3>
<ol>
<li><p>从文件级别组织程序，更方便管理, 随着程序的发展，功能越来越多，为了方便管理，我们通常将程序分成一个个的文件，这样做程序的结构更清晰，这时我们不仅仅可以把这些文件当做脚本去执行，还可以把他们当做模块来导入到其他的模块中，实现了功能的重复利用</p></li>
<li><p>拿来主义，提升开发效率 同样的原理，我们也可以下载别人写好的模块然后导入到自己的项目中使用，这种拿来主义，可以极大地提升我们的开发效率，避免重复造轮子.</p>
<p><strong>人们常说的脚本是什么？</strong></p></li>
</ol>
<p>如果你在终端上编写的代码运行完后,退出python解释器然后重新进入，那么你之前定义的函数或者变量都将丢失，因此我们通常将程序写到文件中以便永久保存下来，需要时就通过python test.py方式去执行，此时test.py被称为脚本script。</p>
<p>所以，脚本就是一个python文件，比如你之前写的购物车，模拟博客园登录系统的文件等等。</p>
<h3 id="模块的分类">1.3模块的分类</h3>
<p>Python语言中，模块分为三类。</p>
<p>​ 第一类：内置模块，也叫做<strong>标准库</strong>。此类模块就是python解释器给你提供的，比如我们之前见过的time模块,os模块。标准库的模块非常多（200多个，每个模块又有很多功能），我们这几天就讲常用的十几种，后面课程中还会陆续的讲到。</p>
<p>​ 第二类：第三方模块，第三方库。一些python大神写的非常好用的模块，必须通过pip install 指令安装的模块，比如 Django,等等。大概有6000多个。</p>
<p>​ 第三类：自定义模块。我们自己在项目中定义的一些模块。</p>
<p>我们先定义一个模块，定义一个模块其实很简单就是写一个文件，里面写一些代码（变量，函数）即可。此文件的名字为test.py，文件内容如下：</p>
<pre><code><code>print(&#39;from the meet.py&#39;)
name = &#39;小冯&#39;
def read1():
    print(&#39;test模块：&#39;,name)
def read2():
    print(&#39;test模块&#39;)
    read1()
def change():
    global name
    name = &quot;啦啦&quot;</code></pre>
<h2 id="import">2. import</h2>
<h3 id="import-使用">2.1 import 使用</h3>
<p>import 翻译过来是一个导入的意思。</p>
<p>​ 模块可以包含可执行的语句和函数的定义，这些语句的目的是初始化模块，它们只在模块名第一次遇到导入import语句时才执行（import语句是可以在程序中的任意位置使用的,且针对同一个模块import很多次,为了防止你重复导入，python的优化手段是：第一次导入后就将模块名加载到内存了，后续的import语句仅是对已经加载到内存中的模块对象增加了一次引用，不会重新执行模块内的语句），如下 import test 只在第一次导入时才执行test.py内代码,此处的显式效果是只打印一次'from the test.py',当然其他的顶级代码也都被执行了,只不过没有显示效果.</p>
<pre><code><code>import test
import test
import test
import test
import test

# 执行结果：只是打印一次：
from the meet.py</code></pre>
<p><strong>重复导入会直接引用内存中已经加载好的结果</strong></p>
<h3 id="第一次导入模块执行三件事">2.2 第一次导入模块执行三件事</h3>
<p>​ 1.创建一个以模块名命名的名称空间。</p>
<p>​ 2.执行这个名称空间（即导入的模块）里面的代码。</p>
<p>​ 3.通过此模块名. 的方式引用该模块里面的内容（变量，函数名，类名等）。 这个名字和变量名没什么区别，都是‘第一类的’，且使用test名字的方式可以访问test.py文件中定义的名字，test.名字与test1.py中的名字来自两个完全不同的地方。</p>
<h3 id="被导入模块有独立的名称空间">2.3 被导入模块有独立的名称空间</h3>
<p>​ 每个模块都是一个独立的名称空间，定义在这个模块中的函数，把这个模块的名称空间当做全局名称空间，这样我们在编写自己的模块时，就不用担心我们定义在自己模块中全局变量会在被导入时，与使用者的全局变量冲突。</p>
<h3 id="为模块起别名">2.4 为模块起别名</h3>
<h4 id="好处可以将很长的模块名改成很短方便使用">2.41.好处可以将很长的模块名改成很短,方便使用</h4>
<pre><code><code>import tbjx as t
t.read1()</code></pre>
<h4 id="有利于代码的扩展和优化">2.4.2有利于代码的扩展和优化</h4>
<pre><code><code>#mysql.py
def sqlparse():
    print(&#39;from mysql sqlparse&#39;)
#oracle.py
def sqlparse():
    print(&#39;from oracle sqlparse&#39;)</code></pre>
<pre><code><code>#test.py
db_type=input(&#39;&gt;&gt;: &#39;)
if db_type == &#39;mysql&#39;:
    import mysql as db
elif db_type == &#39;oracle&#39;:
    import oracle as db

db.sqlparse()</code></pre>
<h3 id="导入多个模块">2.5 导入多个模块</h3>
<p>​ 我们以后再开发过程中，免不了会在一个文件中，导入多个模块，推荐写法是一个一个导入。</p>
<pre><code><code>import os,sys,json   # 这样写可以但是不推荐
推荐写法

import os
import sys
import json</code></pre>
<p><strong>多行导入：易于阅读 易于编辑 易于搜索 易于维护。</strong></p>
<h2 id="from-...-import-...">3.from ... import ...</h2>
<h3 id="from-...-import-...-使用">3.1 from ... import ... 使用</h3>
<pre><code><code>from ... import ... 的使用示例。

from test import name, read1
print(name)
read1()</code></pre>
<h3 id="from...import...-与import对比">3.2 from...import... 与import对比</h3>
<p>​ 唯一的区别就是：使用from...import...则是将spam中的名字直接导入到当前的名称空间中，所以在当前名称空间中，直接使用名字就可以了、无需加前缀：tbjx.</p>
<p>from...import...的方式有好处也有坏处</p>
<p>​ 好处：使用起来方便了</p>
<p>​ 坏处：容易与当前执行文件中的名字冲突</p>
<h4 id="执行文件有与模块同名的变量或者函数名会有覆盖效果">3.2.1执行文件有与模块同名的变量或者函数名，会有覆盖效果。</h4>
<pre><code><code>name = &#39;oldboy&#39;
from test import name, read1, read2
print(name)  
&#39;&#39;&#39;
执行结果：
小冯
&#39;&#39;&#39;
----------------------------------------
from test import name, read1, read2
name = &#39;oldboy&#39;
print(name)  

&#39;&#39;&#39;
执行结果：
oldboy
&#39;&#39;&#39;
----------------------------------------
def read1():
    print(666)
from meet import name, read1, read2
read1()

&#39;&#39;&#39;
执行结果：
test模块： 小冯
&#39;&#39;&#39;</code></pre>
<h4 id="当前位置直接使用read1和read2就好了执行时仍然以meet.py文件全局名称空间">3.2.2当前位置直接使用read1和read2就好了，执行时，仍然以meet.py文件全局名称空间</h4>
<pre><code><code>#测试一：导入的函数read1，执行时仍然回到meet.py中寻找全局变量 &#39;alex&#39;
#test.py
from meet import read1
name = &#39;alex&#39;
read1()
&#39;&#39;&#39;
执行结果:
from the meet.py
meet-&gt;read1-&gt;name = &#39;郭宝元&#39;
&#39;&#39;&#39;

#测试二:导入的函数read2，执行时需要调用read1(),仍然回到meet.py中找
#read1()

#test.py
from meet import read2
def read1():
    print(&#39;==========&#39;)
read2()

&#39;&#39;&#39;
执行结果:
from the meet.py
meet模块
meet模块： 郭宝元
&#39;&#39;&#39;</code></pre>
<h3 id="from-import也支持as">3.3 from … import也支持as</h3>
<p>通过这种方式引用模块也可以对模块进行改名。</p>
<pre><code><code>from meet import read1 as read
read()</code></pre>
<h3 id="一行导入多个">3.4 一行导入多个</h3>
<pre><code><code>from tbjx import read1,read2,name</code></pre>
<h3 id="from-...-import">3.5 from ... import *</h3>
<p>​ from meet import * 把meet中所有的不是以下划线(_)开头的名字都导入到当前位置</p>
<p>​ 大部分情况下我们的python程序不应该使用这种导入方式，因为*你不知道你导入什么名字，很有可能会覆盖掉你之前已经定义的名字。而且可读性极其的差，在交互式环境中导入时没有问题。</p>
<p>可以使用<strong>all</strong>来控制*（用来发布新版本），在meet.py中新增一行</p>
<pre><code><code>__all__=[&#39;name&#39;,&#39;read1&#39;] #这样在另外一个文件中用from spam import *就这能导入列表中规定的两个名字</code></pre>
<h2 id="py文件的两种功能">4.py文件的两种功能</h2>
<p>编写好的一个python文件可以有两种用途： 一：脚本，一个文件就是整个程序，用来被执行（比如你之前写的模拟博客园登录那个作业等） 二：模块，文件中存放着一堆功能，用来被导入使用 python为我们内置了全局变量__name__， 当文件被当做脚本执行时：<strong>name</strong> 等于'<strong>main</strong>' 当文件被当做模块导入时：__name__等于模块名 作用：用来控制.py文件在不同的应用场景下执行不同的逻辑（或者是在模块文件中测试代码）</p>
<pre><code><code>if __name__ == &#39;__main__&#39;:
print(&#39;from the meet.py&#39;)

__all__ = [&#39;name&#39;, &#39;read1&#39;,]

name = &#39;郭宝元&#39;

def read1():
   print(&#39;meet模块：&#39;,name)

def read2():
   print(&#39;meet模块&#39;)
   read1()

def change():
   global name
   name = &#39;宝浪&#39;

if __name__ == &#39;__main__&#39;:  
   # 在模块文件中测试read1()函数
   # 此模块被导入时 __name__ == meet 所以不执行
   read1()</code></pre>
<h2 id="模块的搜索路径">5.模块的搜索路径</h2>
<p>当你引用一个模块时，不见得每次都可以import到：</p>
<p>当咱们导入同一个目录下的模块的时候就能够使用import成功,不是同一个目录下的导入就会报错</p>
<p><img src="./images/模块导入0.png" alt="1" /></p>
<p>​ Python中引用模块是按照一定的规则以及顺序去寻找的，这个查询顺序为：先从内存中已经加载的模块进行寻找找不到再从内置模块中寻找，内置模块如果也没有，最后去sys.path中路径包含的模块中寻找。它只会按照这个顺序从这些指定的地方去寻找，如果最终都没有找到，那么就会报错。</p>
<p>​ <strong>内存中已经加载的模块-&gt;内置模块-&gt;sys.path路径中包含的模块</strong></p>
<p><strong>模块的查找顺序</strong></p>
<ol>
<li>在第一次导入某个模块时（比如meet），会先检查该模块是否已经被加载到内存中（当前执行文件的名称空间对应的内存），如果有则直接引用（ps：python解释器在启动时会自动加载一些模块到内存中，可以使用sys.modules查看）</li>
<li>如果没有，解释器则会查找同名的内置模块</li>
<li>如果还没有找到就从sys.path给出的目录列表中依次寻找meet.py文件。</li>
</ol>
<p><strong>需要特别注意的是：我们自定义的模块名不应该与系统内置模块重名。虽然每次都说，但是仍然会有人不停的犯错</strong></p>
<pre><code><code>#在初始化后，python程序可以修改sys.path,路径放到前面的优先于标准库被加载。

import sys
sys.path.append(&#39;/a/b/c/d&#39;)
sys.path.insert(0,&#39;/x/y/z&#39;) #排在前的目录，优先被搜索
# 注意：搜索时按照sys.path中从左到右的顺序查找，位于前的优先被查找，sys.path中还可能包含.zip归档文件和.egg文件，python会把.zip归档文件当成一个目录去处理，

#首先制作归档文件：zip module.zip foo.py bar.py 
import sys
sys.path.append(&#39;module.zip&#39;)
import foo,bar

#也可以使用zip中目录结构的具体位置
sys.path.append(&#39;module.zip/lib/python&#39;)

#windows下的路径不加r开头，会语法错误
sys.path.insert(0,r&#39;C:\Users\Administrator\PycharmProjects\a&#39;)

#至于.egg文件是由setuptools创建的包，这是按照第三方python库和扩展时使用的一种常见格式，.egg文件实际上只是添加了额外元数据(如版本号，依赖项等)的.zip文件。

#需要强调的一点是：只能从.zip文件中导入.py，.pyc等文件。使用C编写的共享库和扩展块无法直接从.zip文件中加载（此时setuptools等打包系统有时能提供一种规避方法），且从.zip中加载文件不会创建.pyc或者.pyo文件，因此一定要事先创建他们，来避免加载模块是性能下降。
</code></pre>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>