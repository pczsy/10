<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修Python基础（十一）' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>Python基础（十一）</center></div><div class='banquan'>原文出处:本文由博客园博主天狼大大提供。<br/>
原文连接:https://www.cnblogs.com/tianlangdada/p/11567942.html</div><br>
    <h1 id="今日主要内容">今日主要内容</h1>
<ul>
<li>补充：三目运算</li>
<li>f-strings</li>
<li>迭代器</li>
<li>生成器</li>
</ul>
<h1 id="补充三目运算">补充：三目运算</h1>
<ol>
<li>三目运算（三元运算）结构：</li>
</ol>
<ul>
<li><code>表达式1 if 条件表达式 else 表达式2</code></li>
<li><code>c = a if a &gt; b else b</code></li>
</ul>
<ol>
<li><p>执行流程：</p>
<ul>
<li>判断条件，如果条件正确将a赋值给c</li>
<li>如果条件不正确将b赋值给c</li>
</ul>
<pre><code><code>a = 10
b = 20
c = a if a &gt; b else b  # 三目运算
print(c)

运行结果：
20</code></pre></li>
</ol>
<h1 id="一f-strings">一、f-strings</h1>
<ul>
<li>f-strings之前我们已经说过了，python3.6以上的版本可以使用，用来格式化输出，非常的方便，今天来详细说一下</li>
</ul>
<ol>
<li><p>f-strings的格式：</p>
<ul>
<li><code>f&quot;xxxx{传入的变量}xxxx&quot;</code>（建议使用<code>f</code>）</li>
<li><code>F&quot;xxxx{传入的变量}xxxx&quot;</code>（不建议使用<code>F</code>）</li>
</ul>
<pre><code><code>name = &quot;zxd&quot;
age = 23
print(f&quot;姓名:{name} 年龄:{age}&quot;)

运行结果：
姓名:zxd 年龄:23</code></pre></li>
<li><p>引号中如果需要大括号<code>{}</code>时，用两个<code>{{}}</code>代表</p>
<pre><code><code>print(f&quot;{{&#39;a&#39;}}&quot;)  # 用两个大括号表示

运行结果：
{&#39;a&#39;}</code></pre></li>
<li><p>引号中需要使用引号时，一定用两个单引号<code>''</code>表示</p>
<pre><code><code>print(f&quot;{{&#39;a&#39;}}&quot;)  # 用单引号表示

运行结果：
{&#39;a&#39;}</code></pre></li>
<li><p>传入的参数可以是三目表达式</p>
<pre><code><code>a = 10
b = 10
print(f&quot;{a if a &gt; b else b}&quot;)

运行结果：
10</code></pre></li>
</ol>
<h1 id="二迭代器">二、迭代器</h1>
<h2 id="一可迭代对象">（一）可迭代对象</h2>
<ul>
<li><p>说迭代器之前咱们来看一看可迭代对象，什么是可迭代对象？</p>
<ul>
<li>可以一个一个取值的对象就是可迭代对象</li>
</ul>
<pre><code><code>s = &quot;12345&quot;
lst = [1, 2, 3, 4, 5]
dic = {1: 1, 2: 2, 3: 3}
.......

# 这些都是可迭代对象</code></pre>
<ul>
<li>他们共有的一个特点就是可以被for循环</li>
</ul>
<pre><code><code>s = &quot;12345&quot;
lst = [1, 2, 3, 4, 5]
dic = {1: 1, 2: 2, 3: 3}

for el in s:
  print(el)
for el in lst:
  print(el)
for el in dic:
  print(el)   </code></pre></li>
</ul>
<ol>
<li><p>查看可迭代对象的官方方法：</p>
<ul>
<li>查看对象是否有<code>__iter__()</code>方法，只要使用有此方法的对象全部都是可迭代对象</li>
<li><code>dir()</code>函数可以查看对象所有的方法</li>
</ul>
<pre><code><code>lst = [1, 2, 3, 4, 5]
print(&quot;__iter__&quot; in dir(lst))

运行结果：
True</code></pre></li>
<li><p>可迭代对象的特点:</p>
<ul>
<li>空间换时间的理念（用大量的空间节省时间）</li>
<li>优点：
<ul>
<li>使用灵活，每个可迭代对象都有自己的方法</li>
<li>能够直接查看元素个数</li>
<li>可以重复取值</li>
</ul></li>
<li>缺点：
<ul>
<li>占内存</li>
</ul></li>
</ul></li>
<li><p>应用：内存空间大，当数据量比较少，建议使用可迭代对象</p></li>
</ol>
<h2 id="二迭代器-1">（二）迭代器</h2>
<ul>
<li>迭代器可以理解成可迭代对象的实体化，它只继承了迭代性（可以一个一个取值），同时节约了内存（唯一的优点）</li>
<li>文件句柄就是一个迭代器</li>
</ul>
<ol>
<li><p>迭代器的生成方法：</p>
<ul>
<li>两种生成方法效果相同</li>
<li><code>iter(可迭代对象)</code>
<ul>
<li>生成可迭代对象的迭代器</li>
<li>打印的是迭代器的地址</li>
</ul></li>
</ul>
<pre><code><code>lst = [1, 2, 3, 4, 5]
l = iter(lst)
print(l)

运行结果：
&lt;list_iterator object at 0x0000020BAFCEA940&gt;
</code></pre>
<ul>
<li><code>可迭代对象.__iter__()</code>
<ul>
<li>生成可迭代对象的迭代器</li>
<li>打印的是迭代器的地址</li>
</ul></li>
</ul>
<pre><code><code>lst = [1, 2, 3, 4, 5]
l = lst.__iter__()
print(l)

运行结果：
&lt;list_iterator object at 0x000002490EFDA8D0&gt;
</code></pre></li>
<li><p>迭代器的取值</p>
<ul>
<li>迭代器最大的特点就是惰性机制，如果不主动向迭代器取值，迭代器是不会给你值的，同时也正因为惰性机制节约了内存</li>
<li><code>next(迭代器)</code></li>
</ul>
<pre><code><code>lst = [1, 2, 3, 4, 5]
l = iter(lst)
print(next(l))
print(next(l))
print(next(l))
print(next(l))
print(next(l))

运行结果：
1 2 3 4 5
</code></pre>
<ul>
<li><code>迭代器.__next__()</code></li>
</ul>
<pre><code><code>lst = [1, 2, 3, 4, 5]
l = lst.__iter__()
print(l.__next__())
print(l.__next__())
print(l.__next__())
print(l.__next__())
print(l.__next__())

运行结果：
1 2 3 4 5
</code></pre>
<ul>
<li>每次执行取值函数只向迭代器取一个值，按顺序向下取值，不能重复取值，迭代器中有多少个元素就只能next多少次，超出最大个数会报错</li>
</ul>
<pre><code><code>lst = [1, 2, 3, 4, 5]
l = lst.__iter__()
print(l.__next__())
print(l.__next__())
print(l.__next__())
print(l.__next__())
print(l.__next__())
print(l.__next__())

运行结果：
1 2 3 4 5
StopIteration
</code></pre></li>
<li><p>迭代器的特点：</p>
<ul>
<li>时间换空间理念（用大量的时间去节省空间）</li>
<li>节省内存</li>
<li><strong>惰性机制</strong></li>
<li>只能向下取值，不能往复</li>
</ul></li>
<li><p>for循环的本质就是一个迭代器</p>
<ul>
<li>捕获异常：向迭代器取值超出迭代器元素数量时，会捕获StopIteration异常，从而终止while循环</li>
</ul>
<pre><code><code>lst = [1, 2, 3, 4, 5]
l = iter(lst)
while True:
 try:
     print(next(l))
 except StopIteration:  # 捕获异常
     break
</code></pre></li>
<li><p>向同一个迭代器取值，迭代器内部会记录取值位置，赋值给变量，变量会指向地址和上次取值位置</p>
<pre><code><code>lst = [1, 2, 3, 4, 5]
l_iter = iter(lst)
print(next(l_iter))
print(next(l_iter))
print(next(l_iter))
print(next(l_iter))
print(next(l_iter))  # l_iter指向取值记录位置

运行结果：
1 2 3 4 5
</code></pre>
<ul>
<li><code>l_iter</code>指向迭代器的地址，每一次取值，<code>l_iter</code>指向上一次取值位置</li>
<li>可以理解成通过熟人买东西，每次买都是上次的优惠价</li>
</ul></li>
<li><p>向同一个迭代器取值，迭代器内部会记录取值位置，若不赋值，每一次取值都从开头取值，相当于每次寻址后都从头开始</p>
<pre><code><code>lst = [1, 2, 3, 4, 5]
print(next(iter(lst)))
print(next(iter(lst)))
print(next(iter(lst)))
print(next(iter(lst)))
print(next(iter(lst)))
print(next(iter(lst)))  # 每次都从头开始取值

运行结果：
1 1 1 1 1
</code></pre>
<ul>
<li>没有赋值每次通过<code>func()</code>直接寻址，都从头部开始取值</li>
<li>可以理解成没有熟人了，每次买东西都是原价</li>
</ul></li>
<li><p>应用：内存小，数据量巨大时，建议使用迭代器</p></li>
</ol>
<h2 id="三两者关系">（三）两者关系</h2>
<ul>
<li>迭代器一定是可迭代对象，可迭代对象不一定是迭代器</li>
<li>迭代器可以通过<code>iter(可迭代对象)</code>和<code>可迭代对象.__iter__()</code>得到</li>
</ul>
<h1 id="三生成器">三、生成器</h1>
<h2 id="一什么是生成器">（一）什么是生成器</h2>
<ul>
<li><p>生成器的本质就是迭代器</p></li>
<li><p>生成器就是一个自己写的迭代器，而迭代器只能通过<code>iter()</code>函数得到</p></li>
<li><p>生成器的目的是不通过数据转换实现，通过代码实现</p>
<ul>
<li>列表转换成了迭代器，但是列表依旧加载到了内存，没有达到省内存的效果</li>
</ul>
<pre><code><code>lst = [1, 2, 3, 4, 5]
l_iter = iter(lst)
print(next(l_iter))
print(next(l_iter))
print(next(l_iter))
print(next(l_iter))
print(next(l_iter))

运行结果：
1 2 3 4 5
</code></pre>
<ul>
<li>通过生成器真正达到省内存的效果</li>
</ul>
<pre><code><code>def func():
  yield 1
  yield 2
  yield 3
  yield 4
  yield 5

f_gen = func()
print(next(f_gen))
print(next(f_gen))
print(next(f_gen))
print(next(f_gen))
print(next(f_gen))

运行结果：
1 2 3 4 5
</code></pre></li>
</ul>
<h2 id="二生成器">（二）生成器</h2>
<ol>
<li><p>通过函数实现生成器</p>
<ul>
<li>先来看一个函数</li>
</ul>
<pre><code><code>def func():
 print(1)
 return 1

print(func())

运行结果：
1 1
</code></pre>
<ul>
<li>将函数中<code>return</code>替换成<code>yield</code>就变成了一个生成器</li>
</ul>
<pre><code><code>def func():
 print(1)
 yield 1

print(func())

运行结果：
&lt;generator object func at 0x000001B27042C50&gt;
</code></pre>
<ul>
<li>如果定义的是函数，函数名加括号是<strong>调用函数</strong>；而如果定义的是生成器，函数名加括号是得到的是<strong>生成器的内存地址</strong></li>
<li><code>yield</code>：
<ul>
<li>yield能返回多个值，以元组形式存储</li>
<li>yield能返回各种数据类型</li>
<li>yield能够写多个并且都能执行</li>
<li>yield能够记录执行位置</li>
<li>yield后面不写内容，默认返回None</li>
<li>yield只能向下进行，不能往复，一次性取值</li>
</ul></li>
</ul></li>
<li><p>生成器的取值</p>
<ul>
<li><code>next(生成器)</code></li>
</ul>
<pre><code><code>def func():
yield 1
 yield 2
yield 3
 yield 4
yield 5

f_gen = func()
print(next(f_gen))
print(next(f_gen))
print(next(f_gen))
print(next(f_gen))
print(next(f_gen))

运行结果：
1 2 3 4 5
</code></pre>
<ul>
<li><code>生成器.__next__()</code></li>
</ul>
<pre><code><code>def func():
 yield 1
yield 2
 yield 3
 yield 4
 yield 5

print(func().__next__())
print(func().__next__())
print(func().__next__())
print(func().__next__())
print(func().__next__())

运行结果：
1 2 3 4 5
</code></pre></li>
<li><p>生成器的本质就是一个迭代器，所以它拥有迭代器的所有特点</p>
<ul>
<li>时间换空间理念（用大量的时间去节省空间）</li>
<li>节省内存</li>
<li>惰性机制</li>
<li>只能向下取值，不能往复</li>
</ul></li>
<li><p>向同一个生成器取值，yield会记录取值位置，赋值给变量，变量会指向地址和上次取值位置</p>
<pre><code><code>def func():
 yield 1
 yield 2
 yield 3
 yield 4
 yield 5

f_gen = func()
print(next(f_gen))
print(next(f_gen))
print(next(f_gen))
print(next(f_gen))
print(next(f_gen))  # f_gen指向生成器地址和yiele记录的位置

运行结果：
1 2 3 4 5
</code></pre></li>
<li><p>向同一个生成器取值，yield会记录取值位置，若不赋值，每一次取值都从开头取值，相当于每次寻址后都从头开始</p>
<pre><code><code>def func():
 yield 1
 yield 2
 yield 3
 yield 4
 yield 5

print(next(func()))
print(next(func()))
print(next(func()))
print(next(func()))
print(next(func()))  # 每次都从头开始取值

运行结果：
1 2 3 4 5
</code></pre></li>
<li><p>若yield的值是个可迭代对象，还可以将其对象逐个返回</p>
<ul>
<li><code>yield from</code></li>
</ul>
<pre><code><code>def func():
 yield from [1, 2, 3]
 yield from [4, 5, 6]

print(next(func()))
print(next(func()))
print(next(func()))
print(next(func()))
print(next(func()))
print(next(func()))

运行结果：
1 2 3 4 5 6
</code></pre></li>
</ol>
<h1 id="四三者区分">四、三者区分</h1>
<h2 id="一可迭代对象-1">（一）可迭代对象</h2>
<ul>
<li>只要是可以使用<code>__iter__()</code>方法的对象都是可迭代对象</li>
<li>迭代器和生成器都是可迭代对象</li>
</ul>
<h2 id="二迭代器-2">（二）迭代器</h2>
<ul>
<li>查看对象的内存地址，如果有<code>iterator</code>就是一个迭代器</li>
<li>拥有<code>__iter__()</code>和<code>__next__()</code>放法的就是一个迭代器</li>
</ul>
<h2 id="三生成器-1">（三）生成器</h2>
<ul>
<li>查看对象的内存地址，如果有<code>generator</code>就是一个生成器</li>
<li>可以使用<code>send()</code>方法的就是一个生成器</li>
</ul>

</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>