<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修python之并发编程(理论部分)' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>python之并发编程(理论部分)</center></div><div class='banquan'>原文出处:本文由博客园博主追梦NAN提供。<br/>
原文连接:https://www.cnblogs.com/zdqc/p/11377799.html</div><br>
    <h1 id="第一章-操作系统">第一章 操作系统</h1>
<ol>
<li><p>管理控制协调计算机中硬件与软件的关系.</p></li>
<li><p>操作系统的作用?</p>
<p><strong>第一个作用</strong>: ：隐藏了丑陋的硬件调用接口,为应用程序员提供调用硬件资源的更好，更简单，更清晰的模型（系统调用接口）</p>
<p><strong>第二个作用</strong>: 将应用程序对硬件资源的静态请求变得有序化</p>
<p>阻塞: input read write sleep recv accept sendto recvfrom .....</p></li>
</ol>
<h2 id="操作系统的发展史">1.操作系统的发展史</h2>
<p>最早出现的计算机: 算盘.</p>
<p>电子类的计算机发展史:</p>
<h3 id="第一代计算机19401955">第一代计算机1940~1955</h3>
<pre><code><code>在大学里出现了机房,想使用计算机必须预约.
先连接调配各个硬件,1.5小时, 真空管, 然后在插上程序调试.效率低.

优点: 个人独享整个计算机资源.

缺点: 
1. 硬件调试插线,耗时
2. 所有人都是串行执行.</code></pre>
<h3 id="第二代计算机-磁带存储---批处理系统-19551965">第二代计算机 磁带存储---批处理系统 1955~1965</h3>
<pre><code><code>优点: 
程序员不用亲自对硬件进行插线操控,效率提高.
可以进行批量处理代码.

缺点:
程序员不能独自使用计算机.
你的所有程序还是串行.</code></pre>
<h3 id="第三代计算机集成电路多道程序系统">第三代计算机:集成电路,多道程序系统</h3>
<p>大背景:</p>
<pre><code><code>1.集成电路: 把所用的硬件变小,线路板.
2.将两套不同的生产线合并成一条生产线.</code></pre>
<p>技术上的更新: <strong>多道技术.</strong></p>
<pre><code><code>1. 空间上的复用:
将内存分区域,一个内存可以同时加载多个进程.
2. 时间上的复用:
当进程遇到IO阻塞,或者长时间运行,操作系统会将此进程挂起,保留状态.将cpu强行切换到另一个进程</code></pre>
<p>几乎所有的程序又有IO阻塞</p>
<p>同时加载到内存 3个任务,3个进程,每个进程都有阻塞情况,只要cpu运行一个进程时,遇到IO阻塞立马回切换,长时间占用cpu也会切换.</p>
<p><strong>提升效率,最大限度的使用cpu.</strong></p>
<p><strong>如果是一个IO密集型进程,来回切换提升效率.</strong></p>
<p><strong>如果是一个计算密集型,来回切换降低效率.</strong></p>
<p>第三代计算机广泛采用了必须的保护硬件（程序之间的内存彼此隔离）之后，第三代计算机应用而生:</p>
<p>每个人占用计算机的时间有限的,</p>
<p>多人(少于10个) 共同使用一个计算机主机,</p>
<h3 id="第四代计算机-1980---至今">第四代计算机: 1980 - 至今</h3>
<p><strong>1.个人计算机操作系统</strong></p>
<p>　　　　个人计算机上的操作系统是联机交互的单用户操作系统，它提供的联机交互功能与通用分时系统提供的功能很相似。</p>
<p>　　　　由于是个人专用，因此一些功能会简单得多。然而，由于个人计算机的应用普及，对于提供更方便友好的用户接口和丰富功能的文件系统的要求会愈来愈迫切。</p>
<p><strong>2.网络操作系统</strong></p>
<p>　　　　计算机网络：通过通信设施，将地理上分散的、具有自治功能的多个计算机系统互连起来，实现信息交换、资源共享、互操作和协作处理的系统。</p>
<p>　　　　网络操作系统：在原来各自计算机操作系统上，按照网络体系结构的各个协议标准增加网络管理模块，其中包括：通信、资源共享、系统安全和各种网络应用服务。</p>
<p>　　　 就是添加了一些网络方面的功能。</p>
<p><strong>3.分布式操作系统</strong></p>
<p>　　　　表面上看，分布式系统与计算机网络系统没有多大区别。分布式操作系统也是通过通信网络，将地理上分散的具有自治功能的数据处理系统或计算机系统互连起来，实现信息交换和资源共享，协作完成任务。——硬件连接相同。</p>
<p>　　　　分布式：将一个大的任务拆分成几个小的任务，分配给不同的任务处理机制，具体怎么分配是由系统中的算法决定的，大家同时来运行自己的任务，然后各自将人物的返回结果再返回给你这个大的任务。</p>
<p>　　　　但有如下一些明显的区别：</p>
<p>　　　　　　（1）分布式系统要求一个统一的操作系统，实现系统操作的统一性。</p>
<p>　　　　　　（2）分布式操作系统管理分布式系统中的所有资源，它负责全系统的资源分配和调度、任务划分、信息传输和控制协调工作，并为用户提供一个统一的界面。</p>
<p>　　　　　　（3）用户通过这一界面，实现所需要的操作和使用系统资源，至于操作定在哪一台计算机上执行，或使用哪台计算机的资源，则是操作系统完成的，用户不必知道，此谓：系统的透明性。</p>
<p>　　　　　　（4）分布式系统更强调分布式计算和处理，因此对于多机合作和系统重构、坚强性和容错能力有更高的要求，希望系统有：更短的响应时间、高吞吐量和高可靠性。</p>
<p>　　　　分布式系统已经很普遍了，一般个人用不到，企业在处理比较大的任务</p>
<h1 id="第二章-进程">第二章 进程</h1>
<p>1.程序</p>
<pre><code><code>一堆静态的代码文件.</code></pre>
<p>2.进程</p>
<pre><code><code>一个正在运行的程序进程. 抽象的概念.

由操作系统操控调用交于CPU运行 被CPU运行.</code></pre>
<h2 id="并发和并行">1. 并发和并行</h2>
<p>无论是并行还是并发，在用户看来都是'同时'运行的，不管是进程还是线程，都只是一个任务而已，真是干活的是cpu，cpu来做这些任务，而一个cpu同一时刻只能执行一个任务</p>
<pre><code><code>串行: 所有的任务一个一个的完成.
并发: 一个cpu完成多个任务.看起来像是同时完成.
并行: 多个cpu执行多个任务,真正的同时完成.</code></pre>
<p><img src="./images/python之并发编程(理论部分)0.png" /></p>
<h2 id="同步异步and阻塞非阻塞">2. 同步|异步and阻塞|非阻塞</h2>
<p>同步: 发起同步调用后，就在原地等着任务结束，根本不考虑任务是在计算还是在io阻塞，总之就是一股脑地等任务结束</p>
<p>异步: 发起异步调用后，并不会等待任务结束才返回，相反，会立即获取一个临时结果（并不是最终的结果，可能是封装好的一个对象）</p>
<p>阻塞: cpu遇到IO就是阻塞.</p>
<p>非阻塞: 没有IO,就叫非阻塞.</p>
<h2 id="进程的创建">3. 进程的创建:</h2>
<p>一个子进程必须依赖于一个主进程才可以开启.</p>
<p>一个主进程可以开启多个子进程.</p>
<pre><code><code>unix: fork创建子进程.
unix(linux,mac): 创建一个子进程会完完全全复制一个主进程所有的资源,初始资源不变.
windows:  操作系统调用CreateProcess 处理进程的创建.
windows:创建一个子进程,会copy主进程所有的资源,但是会改变一些资源.</code></pre>
<h2 id="进程的终止">4. 进程的终止</h2>
<pre><code><code>1. 正常退出（自愿，如用户点击交互式页面的叉号，或程序执行完毕调用发起系统调用正常退出，在linux中用exit，在windows中用ExitProcess）
2. 出错退出（自愿，python a.py中a.py不存在）
3. 严重错误（非自愿，执行非法指令，如引用不存在的内存，1/0等，可以捕捉异常，try...except...）
4. 被其他进程杀死（非自愿，如kill -9）</code></pre>
<h2 id="进程的层次结构">5. 进程的层次结构</h2>
<pre><code><code>无论UNIX还是windows，进程只有一个父进程，不同的是：

　　1. 在UNIX中所有的进程，都是以init进程为根，组成树形结构。父子进程共同组成一个进程组，这样，当从键盘发出一个信号时，该信号被送给当前与键盘相关的进程组中的所有成员。

　　2. 在windows中，没有进程层次的概念，所有的进程都是地位相同的，唯一类似于进程层次的暗示，是在创建进程时，父进程得到一个特别的令牌（称为句柄）,该句柄可以用来控制子进程，但是父进程有权把该句柄传给其他子进程，这样就没有层次了。</code></pre>
<h2 id="进程的状态">6. 进程的状态:</h2>
<p>tail -f access.log |grep '404'</p>
<p>　　执行程序tail，开启一个子进程，执行程序grep，开启另外一个子进程，两个进程之间基于管道'|'通讯，将tail的结果作为grep的输入。</p>
<p>　　进程grep在等待输入（即I/O）时的状态称为阻塞，此时grep命令都无法运行</p>
<p>　　其实在两种情况下会导致一个进程在逻辑上不能运行，</p>
<ol>
<li>进程挂起是自身原因，遇到I/O阻塞，便要让出CPU让其他进程去执行，这样保证CPU一直在工作</li>
<li>与进程无关，是操作系统层面，可能会因为一个进程占用时间过多，或者优先级等原因，而调用其他的进程去使用CPU。</li>
</ol>
<p>　　因而一个进程由三种状态</p>
<p><img src="./images/python之并发编程(理论部分)1.png" /></p>
<h2 id="进程并发的实现">7. 进程并发的实现</h2>
<p>进程并发的实现在于，硬件中断一个正在运行的进程，把此时进程运行的所有状态保存下来，为此，操作系统维护一张表格，即进程表（process table），每个进程占用一个进程表项（这些表项也称为进程控制块）</p>
<p><img src="./images/python之并发编程(理论部分)2.png" alt="img" /></p>
<p>　　该表存放了进程状态的重要信息：程序计数器、堆栈指针、内存分配状况、所有打开文件的状态、帐号和调度信息，以及其他在进程由运行态转为就绪态或阻塞态时，必须保存的信息，从而保证该进程在再次启动时，就像从未被中断过一样。</p>
<h1 id="第三章-线程">第三章 线程</h1>
<h2 id="什么是线程">1.什么是线程</h2>
<p><strong>进程是用来把资源集中到一起（进程只是一个资源单位，或者说资源集合），而线程是cpu上的执行单位。</strong></p>
<p>描述开启一个进程:</p>
<p>​ 开启一个进程:进程会在内存中开辟一个进程空间,将主进程的资料数据全部复制一份,线程会执行里面的代码.</p>
<p>多线程（即多个控制线程）的概念是，在一个进程中存在多个控制线程，多个控制线程共享该进程的地址空间，相当于一个车间内有多条流水线，都共用一个车间的资源。</p>
<h2 id="线程和进程">2.线程和进程</h2>
<pre><code><code>1. 开启进程的开销非常大,比开启线程的开销大很多.
2. 开启线程的速度非常快.要快几十倍到上百倍.
3. 线程线程之间可以共享数据,进程与进程之间需借助队列等方法实现通信.</code></pre>
<h2 id="为什么要用多线程">3.为什么要用多线程？</h2>
<p>多线程指的是，在一个进程中开启多个线程，简单的讲：如果多个任务共用一块地址空间，那么必须在一个进程内开启多个线程。详细的讲分为4点：</p>
<ol>
<li>多线程共享一个进程的地址空间</li>
</ol>
<p>​ 2. 线程比进程更轻量级，线程比进程更容易创建可撤销，在许多操作系统中，创建一个线程比创建一个进程要快10-100倍，在有大量线程需要动态和快速修改时，这一特性很有用</p>
<pre><code><code>   3. 若多个线程都是cpu密集型的，那么并不能获得性能上的增强，但是如果存在大量的计算和大量的I/O处理，拥有多个线程允许这些活动彼此重叠运行，从而会加快程序执行的速度。</code></pre>

</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>