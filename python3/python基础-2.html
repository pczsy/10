<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修python基础-2' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>python基础-2</center></div><div class='banquan'>原文出处:本文由博客园博主屈冠文提供。<br/>
原文连接:https://www.cnblogs.com/quguanwen/p/11158033.html</div><br>
    <p>1.文件操作</p>
<p>　　mode的常用种类r w a rb wb ab ,带b标识不用指定编码格式全都是byte类型 ,用于非文本文件(图 音 视频)　　</p>
<p>　　r模式下仅读取</p>
<p>　　w模式下当文件没有可以创建 ,但是会覆盖写入</p>
<p>　　a模式下可以追加</p>
<p>　　readline() 读取一行,不占用内存　　　</p>
<p>　　readlines() 将文件所有行读取放入一个list中</p>
<div class="cnblogs_code">
<pre><code># 文件读取<br />f = open('json.txt',mode='r',encoding="utf-8")  # 读取文件编码<br />print(f.readline())<br />print(f.readline())         # 从文件中读取一行一行读取<br />print(f.read())             # 将管道文件内容一次读取出来<br />f.seek(0)                   # 移动光标 ,0到最开始位置 1光标当前位置 2文件尾部<br />print(f.read())<br />f.flush()                   # 清空管道<br />f.close()                   # 关闭管道<br /><br /># 文件复制写入<br />with open('json.txt', mode='rb') as f1,open('copy.txt', mode='wb') as f2:      # with可以帮助做管道优化<br />    for line in f1:                     # for循环按文件行循环<br />        f2.write(line)<br /><br /># 文件修改(所有的编辑器都是如此)<br /># 文件修改的步骤: 1.文件修改仅将源文件读出 2.变更操作写入新文件 3.源文件删除 4.新文件重命名<br />import os<br />with open("test1.txt", mode="r", encoding="utf-8") as f1, \<br />     open("test1.txt_副本", mode="w", encoding="utf-8") as f2:<br />    # 代码块(with), 当这个代码块结束的时候. 自动的关闭f1和f2<br />    for line in f1:<br />        s = line.replace("centos", "redhat")<br />        f2.write(s)<br />os.remove("test1.txt")<br />os.rename("test1.txt_副本", "test1.txt")</pre>
</div>
<p>&nbsp;</p>
<p>2.三种推导式</p>
<p>　　推导式是可以从一个数据序列构建另一个新的数据序列的结构体(三种:list dict set推导式)</p>
<p>　<strong>　list推导式</strong>&nbsp; &nbsp; &nbsp; &nbsp; [表达式 for 循环 if 条件] 　　　　　　 #换成圆括号变生成器</p>
<div class="cnblogs_code">
<pre><code>#推导式<br />list1 = [x*x <span style="color: #0000ff;">for</span> x <span style="color: #0000ff;">in</span> range(1,10<span style="color: #000000;">)]
<br />#普通
list1</span>=<span style="color: #000000;">[]
</span><span style="color: #0000ff;">for</span> x <span style="color: #0000ff;">in</span> range(1,10<span style="color: #000000;">):
    list1.append(x</span>*x)</pre>
</div>
<p><strong>　　dict推导式&nbsp; &nbsp; &nbsp;&nbsp;</strong> {key:value for循环 if判断}　　　　　　　</p>
<div class="cnblogs_code">
<pre><code># 推导式<br />dict1 = {x:x**x for x in range(0, 10) if x &lt; 9}<br /><br /># 普通<br />dict3={}<br />for k in  range(0,10):<br />    if k &lt; 9:<br />        dict3[k]=k**k</pre>
<pre><code># key values 互换<br />dict1 = {1: 'n1', 2: 'n2'}<br />dict2 = {v: k+1 for k, v in dict1.items()}</pre>
</div>
<p>　　<strong>set推导式</strong>　　{表达式 for 循环 if 条件}　　　　　# 与列表推导式的扩号不同　　　&nbsp;</p>
<div class="cnblogs_code">
<pre><code>set1 = {x**x:2 <span style="color: #0000ff;">for</span> x <span style="color: #0000ff;">in</span> range(0, 10) <span style="color: #0000ff;">if</span> x &lt; 9}</pre>
</div>
<p>&nbsp;</p>
<p>3.闭包</p>
<p>　　　闭包在python中 ,可以简单理解为 ,内函数绑定外函数的局部变量 ,外函数返回内函数内存地址　</p>
<div class="cnblogs_code">
<pre><code># 匿名函数的闭包写法<br />fun = [lambda x: x*i for i in range(4)]　　　　　　　　　　# 典型闭包 ,外函数的i最后会是3,内函数lambda从外函数没有定义i的值 ,最后生成列表都是函数</pre>
<p>&nbsp; for item in fun:</p>
<p>&nbsp; print(item(1))</p>
<pre><code><br /># def函数的闭包写法<br />def func():<br />    # 定义一个空列表<br />    fun_lambda_list = []<br />    # 循环<br />    for i in range(4):<br />        # 定义一个内函数,没被调用也不会去拿i的值 ,所以返回值一直都是x*i<br />        def lambda_(x):<br />            # 返回x*i<br />            return x * i<br />        # 将内函数追加到列表中<br />        fun_lambda_list.append(lambda_)<br />    return fun_lambda_list　　　　　　　　　　　　　　　　#列表中有四个函数(一个都没有执行[x*i,x*i,x*i,x*i]) ,当fun被调用的那一刻开始i被定格为3<br /><br /><br /><br /># 将内函数中加入每次i的值就可以了,这样获得的函数列表就是[x*0,x*1,x*2,x*3]</pre>
<pre><code>fun = [lambda x,i=i:x*i for i in range(4)]</pre>
</div>
<p>&nbsp;</p>
<p>4.模块-包</p>
<p>　　内置标准模块</p>
<p>　　　　random模块</p>
<div class="cnblogs_code">
<pre><code>import random<br /><br />print(random.random())  # 随机0-1的浮点<br />print(random.uniform(1, 3))  # 随机1-3的浮点<br />print(random.randint(1, 10))  # 随机取1-10的整数<br /><br />print(random.randrange(1, 9, 2))  # 随机取1-9之间的数步长为2,不顾尾<br />print(random.choice([1, 2, 3, [2, 3]]))  # 随机选择可迭代对象元素<br />print(random.sample([1, 2, 3, 4, 'hh'], 3))  # 列表任意X个元素组成新列表,这里X是3</pre>
</div>
<p>　　　　time模块　　</p>
<div class="cnblogs_code">
<pre><code>import time<br /><br />print(time.localtime())     #打印当前日期<br />print(time.time())          #打印时间戳 19701.1. 00:00:00的偏移量<br />print(time.strftime("%Y-%m-%d %H:%M:%S",time.localtime()))      #格式化当前日期(format ,日期)</pre>
</div>
<p>　　　　re模块</p>
<p>　　　　　　正则</p>
<div class="cnblogs_code">
<pre><code># .　　 　匹配任意单个字符<br /># ^　　　　匹配字符串起始部分<br /># $　　　　匹配字符串终止位置<br /># *　　 　匹配前一个字符0或多次<br /># + 　    匹配前一个字符1次或多次<br /># ?　　　　匹配前一个字符1次或0次<br /># {N}　 　匹配前一个字符N次　<br /># {N,}　　匹配前一个字符N次　<br /># {M,N}　 匹配前一个字符N,M次<br /># [...]　 匹配任意字符集中单个字符<br /># [x-y]　　匹配范围内任意单个字符<br /># [^..]　 匹配出去字符集中任意单个字符　<br /># \d　　  匹配任意一个10机制数字<br /># \w　　　　匹配任意字母数字<br /># \s　　　　匹配任何空字符<br /># \b　　　　匹配字符边界<br /># ()　　   分组 ,<br /># \N　　　　匹配保存的分组<br /># \　　　　 转义符<br /><br />1.<br />2.<br />3.<br />4.<br />5.</pre>
</div>
<p>　　　　　　re常用方法</p>
<p>　　　　　　　　re.match('正则表达式', 要匹配的字符串)　　　　　　　　　　　　#如果匹配成功返回一个对象 ,否则返回None&nbsp;</p>
<p>　　　　os模块</p>
<div class="cnblogs_code">
<pre><code>import os<br /><br />os.path.abspath('..')  　　　　　　　　　　　　　　　　     # 获取父目录绝对路径<br /><br />os.path.abspath('.')  　　　　　　　　　　　　　　　　　　   # 获取当前绝对路径</pre>
<pre><code>os.path.abspath(__file__)　　　　　　　　　　　　　　　　　　#获取当前文件的路径和文件名</pre>
<pre><code>dir1 = 'C:\\boruoboluomi\\a1\\b1\\a.txt'<br /><br />os.path.dirname(os.path.dirname(os.path.abspath(dir1))) #dirname可以将路径 一层一层脱掉<br /><br />os.path.split(dir1) 　　　　　　　　　　　　　　　　　　　　 # 切割路径 ，将路径与文件分离<br /><br />os.path.join('C:\\boruoboluomi\\a1\\b1', 'a.txt') 　　　　 # 拼接路径 ， 将路径与文件拼接<br /><br />os.path.exists(dir1)    　　　　　　　　　　　　　　　　　　# 判断该文件是否存在<br /><br />os.remove('绝对路径文件')  　　　　　　　　　　　　　　　　# 删除文件<br /><br />os.system('ls /etc/profile')  　　　　　　　　　　　# 执行shell命令</pre>
<pre><code>os.getcwd() 　　　　　　　　　　　　　　　　　　　　 # 获取pwd当前绝对路径</pre>
<pre><code>os.path.getsize()　　　　　　　　　　　　　　　　　　#获取文件大小</pre>
</div>
<p>　　　　sys模块</p>
<div class="cnblogs_code">
<pre><code>import sys<br /><br />print(sys.modules)      　　　　　　#查看解释器运行时自动加载的所有模块</pre>
<pre><code>print(sys.path)　　　　　　　　　　　　#查看第三方模块的路径 ,该路径下的模块都可以使用import导入使用,也可以使用sys.path.append()追加路径<br /><br />print(sys.argv[1])　　　　　　　　　　#拿出脚本的参数</pre>
</div>
<p>　　　　math模块</p>
<div class="cnblogs_code">
<pre><code>import math<br /><br />t1 = 6.6<br /><br />print(math.ceil(t1)) 　　　　　　　　　　# 向上取整<br /><br />print(math.floor(t1))  　　　　　　　　# 向下取整<br /><br />print(math.pow(t1, 2))  　　　　　　　　# t1的2次方<br /><br />print(math.fabs(t1)) 　　　　　　　　　　 # t1的绝对值</pre>
</div>
<p>　　　　json模块　　　　</p>
<p>　　　　　　序列化模块 ,json可以将python数据类型序列化为可传输的字符串 ,对方接受到后通过反序列化可获得自己可读语言数据类型</p>
<div class="cnblogs_code">
<pre><code>import<span>  json        　

#用于网络传输的dumps ,loads
<span>
dic = {'name':'小咪','age':12,'sex':'公'}  #定义一个字典dic
<span>
ret = json.dumps(dic)    　　　　　　　　  #序列化过程:将dic变成json格式的ret(特殊字符串)
<span>
ret1 = json.loads(ret)    　　　　　　　　#反序列化过程:将ret这个json格式反解成为ret1(还原为字典)

print<span>(ret,type(ret))

print<span>(ret1,type(ret1))

#用于文件存储数据的dump ,load
list1 = [1, 2, 3, 4<span>]  

f1 = open('json.txt', mode='w')  　　　　# 打开一个文件,文件仅支持字符串写入
<span>
json.dump(list1, f1)  　　　　　　　　　　# dump方法可以将py数据类型和文件句柄当做参数传入,做序列化
<span>
f1.close()

f1 = open('json.txt', mode='r'<span>)

ret = json.load(f1)  　　　　　　　　　　# dump方法将文件中内容反序列化取出

print(ret, type(ret))  　　　　　　　　# 反序列化后数据类型和序列化之前一模一样</span></span></span></span></span></span></span></span></span></span></pre>
</div>
<p>　　　　rsa模块 &amp; base64模块</p>
<p>　　　　　　1.生成一组非对称秘钥对 ,该秘钥对最大加密数据长度是128字节 ,其中11个自己加密使用 ,被加密数据仅有117</p>
<p>　　　　　　2.base64编码的原因是因为网络传输错误会降低</p>
<p>　　　　　　3.定义加密函数 ,将数据以117步长切割加密 ,放入列表 ,发送到对端</p>
<p>　　　　　　4.定义解密函数 ,将数据以128步长解密拼接 ,即可获得原数据</p>
<p>　　　　　　5.调用rsa加密必须是byte的数据</p>
<div class="cnblogs_code">
<pre><code>import<span> rsa
import<span> base64

####生成一组秘钥对####
pub_key_obj, priv_key_obj = rsa.newkeys(1024)  # 最大加密value的字节数是  1024/8 - 11(自己用) = 117(可用加密字节)

# 将对象转换为字符串类型
pub_key_str =<span> pub_key_obj.save_pkcs1()
priv_key_str =<span> priv_key_obj.save_pkcs1()

# 再通过base64编码
pub_key_code =<span> base64.standard_b64encode(pub_key_str)
priv_key_code =<span> base64.standard_b64encode(priv_key_str)

print<span>(pub_key_code)
print<span>(priv_key_code)


####数据加密####
def<span> encrypt(bytes_value):
    values_list =<span> []
    key_str =<span> base64.standard_b64decode(pub_key_code)
    pk =<span> rsa.PublicKey.load_pkcs1(key_str)
    length =<span> len(bytes_value)

    for i in range(0, length, 117<span>):
        val = rsa.encrypt(bytes_value[i: i + 117<span>], pk)
        values_list.append(val)
    val = b''<span>.join(values_list)

    return<span> val


####数据解密####
def<span> decrypt(value):
    values_list =<span> []
    key_str =<span> base64.standard_b64decode(priv_key_code)
    pk =<span> rsa.PrivateKey.load_pkcs1(key_str)
    length =<span> len(value)
    for i in range(0, length, 128<span>):
        val = rsa.decrypt(value[i: i + 128<span>], pk)
        values_list.append(val)
    val = b''<span>.join(values_list)
    # val = rsa.decrypt(value, pk)
    return<span> val

###调用
string = 'alex' * 100<span>
ret = encrypt(string.encode('utf-8'))  # 加密数据要求byte类型
print<span>(ret)
print(decrypt(ret).decode('utf-8'))    # 数据encode编码-&gt;加密 -&gt;解密-&gt;decode解码</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre>
</div>
<p>　　自定义模块</p>
<p>　　　　自定义日志模块</p>
<p>　　　　　　1.__init__方法定义logger对象 ,定义info ,error方法 ,实例化Logger类获得单例模式的对象&nbsp;</p>
<p>　　　　　　2.使用直接from&nbsp; 文件 import logger 加载对象</p>
<p>　　　　　　3.调用 logger.info(日志即可)</p>
<div class="cnblogs_code">
<pre><code>import<span> logging
from conf import<span> settings

class<span> Logger:
    def __init__(self, file_name, log_name, level=<span>logging.INFO):
        # 定义使用文件介质存储（FileHandler） ，该文件名和编码格式
        file_handler = logging.FileHandler(file_name, encoding='utf-8'<span>)
        # 定义格式（Formatter）
        fmt = logging.Formatter(fmt="%(asctime)s - %(name)s - %(levelname)s -%(module)s:  %(message)s"<span>)
        # 为文件介质定义格式（setFormatter）
<span>        file_handler.setFormatter(fmt)

        # 定义logger对象，给实例化的对象 ,定义日志对象名与最低显示等级
        self.logger = logging.Logger(log_name, level=<span>level)
        self.logger.addHandler(file_handler)

    def<span> info(self, msg):
        return<span> self.logger.info(msg)

    def<span> error(self, msg):
        return<span> self.logger.error(msg)

logger = Logger(settings.LOGGER_PATH, settings.LOGGER_NAME)</span></span></span></span></span></span></span></span></span></span></span></span></pre>
</div>
<p>　　包</p>
<p>　　　　包就是有__init__.py文件标识的文件夹</p>
<p>　　精准导入方式</p>
<p>　　　　from lib.disk. import Pack1Class　　　　　　　　　　#推荐使用</p>
<p>　　　　import Root.Pack1.Pack1Class</p>
<p>&nbsp;</p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>