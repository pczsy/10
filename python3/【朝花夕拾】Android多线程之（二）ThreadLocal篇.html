<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修【朝花夕拾】Android多线程之（二）ThreadLocal篇' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>【朝花夕拾】Android多线程之（二）ThreadLocal篇</center></div><div class='banquan'>原文出处:本文由博客园博主宋者为王提供。<br/>
原文连接:https://www.cnblogs.com/andy-songwei/p/12040372.html</div><br>
    <p>&nbsp; &nbsp; &nbsp; &nbsp;如果转载请声明，转自【<a href="https://www.cnblogs.com/andy-songwei/p/12040372.html" target="_blank">https://www.cnblogs.com/andy-songwei/p/12040372.html</a>】，谢谢！</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;本文的主要内容为：</p>
<p><img style="display: block; margin-left: auto; margin-right: auto;" src="./images/【朝花夕拾】Android多线程之（二）ThreadLocal篇0.png" alt="" /></p>
<p>&nbsp;</p>
<p><strong>1、一个生活中的场景</strong></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;鉴于普罗大众都喜欢看热闹，咱们先来看个热闹再开工吧！</p>
<p style="text-align: center;">&nbsp;<img src="./images/【朝花夕拾】Android多线程之（二）ThreadLocal篇1.png" alt="" width="454" height="194" /></p>
<div class="cnblogs_code">
<pre><code><span style="color: #000000;">场景一： 

 <em>中午了， 张三、李四和王五一起去食堂大菜吃饭。食堂刚经营不久，还很简陋，负责打菜的只有一位老阿姨。

 张三：我要一份鸡腿。

 李四：我要一份小鸡炖蘑菇。

 张三：我再要一份红烧肉。

 王五：我要一份红烧排骨。

 李四：我不要小鸡炖蘑菇了，换成红烧鲫鱼。

 王五：我再要一份椒盐虾。

 张三：我再要一份梅菜扣肉。

 ......

 张三：我点的红烧肉，为啥给我打红烧鲫鱼？

 李四：我的红烧鲫鱼呢？

 王五：我有点红烧肉吗？

 ......

 李四：我点了15元的菜，为啥扣我20？

 王五：我点了20元的菜，只扣了我15元，赚了，窃喜！

 张三：我已经刷了卡了，怎么还叫我刷卡？

 ......

 老阿姨毕竟上了年纪，不那么利索，这几个小伙子咋咋呼呼，快言快语，老阿姨也被搅晕了，手忙脚乱，忙中出错，这仨小伙也是怨声载道。

 </em>场景二：<em>

 食堂领导看到这个场景，赶紧要求大家排队，一个一个来。后来，老阿姨轻松多了，也没有再犯错了。

 但是，新的问题又来了，打菜的人当中，很多妹子很磨叽，点个菜犹犹豫豫想半天。

 张三：太慢了，我快饿死了！

 李四：再这么慢，下次去别家！

 王五：我等得花儿都谢啦！

 赵六：啥？我点了啥菜，花了多少钱，其它人怎么都知道？是阿姨多嘴了，还是其它人偷偷关注我很久了？太不安全了，一点隐私都没有，以后不来了。

 ......

 </em>场景三：<em>

  领导听到这些怨言，心里很不是滋味，大手一挥：扩大经营，以后为你们每一个人开一个流动窗口并请一位私人阿姨，只为你一个人服务！

  从此，再也没有怨言，阿姨也没有再犯错了，皆大欢喜......</em></span></pre>
</div>
<p>&nbsp; &nbsp; &nbsp; &nbsp;场景一就像多个线程同时去操作一个数据，最终的结果就是混乱。于是出现了同步锁synchronized，同一时刻只运行一个线程操作，就像场景二，大家先来后到排队，混乱的问题解决了。但是此时一个线程在操作的时候，其它线程只能闲等着，而且这些数据是共享的，每个线程希望拥有只能自己操作的私人数据，ThreadLocal就正好满足了这个需求。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;所以，相比于synchronized，Threadlocal通过牺牲空间来换取时间和效率。</p>
<p>&nbsp;</p>
<p><strong>2、ThreadLocal简介&nbsp;</strong></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;ThreadLocal官方的介绍为：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;">1</span> <span style="color: #008000;">/**</span>
<span style="color: #008080;">2</span> <span style="color: #008000;"> * This class provides thread-local variables.  These variables differ from
</span><span style="color: #008080;">3</span> <span style="color: #008000;"> * their normal counterparts in that each thread that accesses one (via its
</span><span style="color: #008080;">4</span> <span style="color: #008000;"> * {</span><span style="color: #808080;">@code</span><span style="color: #008000;"> get} or {</span><span style="color: #808080;">@code</span><span style="color: #008000;"> set} method) has its own, independently initialized
</span><span style="color: #008080;">5</span> <span style="color: #008000;"> * copy of the variable.  {</span><span style="color: #808080;">@code</span><span style="color: #008000;"> ThreadLocal} instances are typically private
</span><span style="color: #008080;">6</span> <span style="color: #008000;"> * static fields in classes that wish to associate state with a thread (e.g.,
</span><span style="color: #008080;">7</span> <span style="color: #008000;"> * a user ID or Transaction ID).
</span><span style="color: #008080;">8</span>  <span style="color: #008000;">*/</span></pre>
</div>
<p>&nbsp; &nbsp; &nbsp; &nbsp;大致意思是：ThreadLocal提供了线程本地变量。这些变量与一般变量相比，其不同之处在于，通过它的get()和set()方法，每个线程可以访问自己独立拥有的初始变量副本。翻译成人话就是，ThreadLocal为每一个线程开辟了一个独立的存储器，只有对应的线程才能够访问其数据，其它线程则无法访问。对应于前文的场景，就像食堂为每一个人安排了一个窗口和专属阿姨为其打菜，这个过程中，这个窗口和阿姨就是其专属的独立的资源，其他人就无从知道他点了什么菜，花了多少钱。</p>
<p>&nbsp;</p>
<p><strong>3、ThreadLocal的简单使用示例&nbsp;</strong></p>
<p>&nbsp; &nbsp; 是骡子是马，先拉出来溜溜！先直观看看它的能耐，再来了解它丰富的内心：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> <span style="color: #008000;">//</span><span style="color: #008000;"> =========实例3.1========</span>
<span style="color: #008080;"> 2</span> <span style="color: #0000ff;">private</span> ThreadLocal&lt;String&gt; mThreadLocal = <span style="color: #0000ff;">new</span> ThreadLocal&lt;&gt;<span style="color: #000000;">();
</span><span style="color: #008080;"> 3</span> <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">void</span> testThreadLocal() <span style="color: #0000ff;">throws</span><span style="color: #000000;"> InterruptedException {
</span><span style="color: #008080;"> 4</span>     mThreadLocal.set("main-thread"<span style="color: #000000;">);
</span><span style="color: #008080;"> 5</span>     Log.i("threadlocaldemo", "result-1=" +<span style="color: #000000;"> mThreadLocal.get());
</span><span style="color: #008080;"> 6</span>     Thread thread_1 = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Thread() {
</span><span style="color: #008080;"> 7</span> <span style="color: #000000;">        @Override
</span><span style="color: #008080;"> 8</span>         <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() {
</span><span style="color: #008080;"> 9</span>             <span style="color: #0000ff;">super</span><span style="color: #000000;">.run();
</span><span style="color: #008080;">10</span>             mThreadLocal.set("thread_1"<span style="color: #000000;">);
</span><span style="color: #008080;">11</span>             Log.i("threadlocaldemo", "result-2=" +<span style="color: #000000;"> mThreadLocal.get());
</span><span style="color: #008080;">12</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">13</span> <span style="color: #000000;">    };
</span><span style="color: #008080;">14</span> <span style="color: #000000;">    thread_1.start();
</span><span style="color: #008080;">15</span>     <span style="color: #008000;">//</span><span style="color: #008000;">该句表示thread_1执行完后才会继续执行</span>
<span style="color: #008080;">16</span> <span style="color: #000000;">    thread_1.join();
</span><span style="color: #008080;">17</span>     Thread thread_2 = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Thread() {
</span><span style="color: #008080;">18</span> <span style="color: #000000;">        @Override
</span><span style="color: #008080;">19</span>         <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() {
</span><span style="color: #008080;">20</span>             <span style="color: #0000ff;">super</span><span style="color: #000000;">.run();
</span><span style="color: #008080;">21</span>             Log.i("threadlocaldemo", "result-3=" +<span style="color: #000000;"> mThreadLocal.get());
</span><span style="color: #008080;">22</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">23</span> <span style="color: #000000;">    };
</span><span style="color: #008080;">24</span> <span style="color: #000000;">    thread_2.start();
</span><span style="color: #008080;">25</span>     <span style="color: #008000;">//</span><span style="color: #008000;">该句表示thread_2执行完后才会继续执行</span>
<span style="color: #008080;">26</span> <span style="color: #000000;">    thread_2.join();
</span><span style="color: #008080;">27</span>     Log.i("threadlocaldemo", "result-4=" +<span style="color: #000000;"> mThreadLocal.get());
</span><span style="color: #008080;">28</span> }</pre>
</div>
<p>&nbsp;在主线程中调用这个方法，运行结果：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;">1</span> 12-13 13:42:50.117 25626-25626/com.example.demos I/threadlocaldemo: result-1=main-<span style="color: #000000;">thread
</span><span style="color: #008080;">2</span> 12-13 13:42:50.119 25626-25689/com.example.demos I/threadlocaldemo: result-2=<span style="color: #000000;">thread_1
</span><span style="color: #008080;">3</span> 12-13 13:42:50.119 25626-25690/com.example.demos I/threadlocaldemo: result-3=<span style="color: #0000ff;">null</span>
<span style="color: #008080;">4</span> 12-13 13:42:50.120 25626-25626/com.example.demos I/threadlocaldemo: result-4=main-thread</pre>
</div>
<p>&nbsp; &nbsp; &nbsp; &nbsp;看到这个结果会不会惊掉下巴呢？明明在第9行中set了值，第10行中也得到了对应的值，但第20行的get得到的却是null，第26行得到的是第3行set的值。这就是ThreadLocal的神奇功效，主线程set的值，只能在主线程get到；thread_1内部set的值，thread_1中才能get；thread_2中没有set，所以get到的就是null。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;而实现这，不要999，也不要99，只要3......三步即可：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;">1</span> ThreadLocal&lt;T&gt; mThreadLocal = <span style="color: #0000ff;">new</span> ThreadLocal&lt;&gt;<span style="color: #000000;">();
</span><span style="color: #008080;">2</span> <span style="color: #000000;">mThreadLocal.set(T);
</span><span style="color: #008080;">3</span> mThreadLocal.get();</pre>
</div>
<p>就是这么方便，就是这么简洁！</p>
<p>&nbsp;</p>
<p><strong>4、提供的4个主要接口</strong></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;ThreadLocal以其使用简单，风格简洁让人一见倾心。它对外提供的接口很少，当前SDK中，主要有4个：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;">1</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> set(T value) { }  
</span><span style="color: #008080;">2</span> <span style="color: #0000ff;">public</span><span style="color: #000000;"> T get() { }  
</span><span style="color: #008080;">3</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> remove() { }  
</span><span style="color: #008080;">4</span> <span style="color: #0000ff;">protected</span> T initialValue() { }  </pre>
</div>
<p>为了保持对这些方法说明的原滋原味，我们直接通过源码中对其的注释说明来认识它们。</p>
<p>&nbsp;（1）set()</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> <span style="color: #008000;">/**</span>
<span style="color: #008080;"> 2</span> <span style="color: #008000;"> * Sets the current thread's copy of this thread-local variable
</span><span style="color: #008080;"> 3</span> <span style="color: #008000;"> * to the specified value.  Most subclasses will have no need to
</span><span style="color: #008080;"> 4</span> <span style="color: #008000;"> * override this method, relying solely on the {</span><span style="color: #808080;">@link</span><span style="color: #008000;"> #initialValue}
</span><span style="color: #008080;"> 5</span> <span style="color: #008000;"> * method to set the values of thread-locals.
</span><span style="color: #008080;"> 6</span> <span style="color: #008000;"> *
</span><span style="color: #008080;"> 7</span> <span style="color: #008000;"> * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> value the value to be stored in the current thread's copy of
</span><span style="color: #008080;"> 8</span> <span style="color: #008000;"> *        this thread-local.
</span><span style="color: #008080;"> 9</span>  <span style="color: #008000;">*/</span>
<span style="color: #008080;">10</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> set(T value)</pre>
</div>
<p>设置当前线程的ThreadLocal值为指定的value。大部分子类没有必要重写该方法，可以依赖initialValue()方法来设置ThreadLocal的值。</p>
<p>&nbsp; （2）get()</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;">1</span> <span style="color: #008000;">/**</span>
<span style="color: #008080;">2</span> <span style="color: #008000;"> * Returns the value in the current thread's copy of this
</span><span style="color: #008080;">3</span> <span style="color: #008000;"> * thread-local variable.  If the variable has no value for the
</span><span style="color: #008080;">4</span> <span style="color: #008000;"> * current thread, it is first initialized to the value returned
</span><span style="color: #008080;">5</span> <span style="color: #008000;"> * by an invocation of the {</span><span style="color: #808080;">@link</span><span style="color: #008000;"> #initialValue} method.
</span><span style="color: #008080;">6</span> <span style="color: #008000;"> *
</span><span style="color: #008080;">7</span> <span style="color: #008000;"> * </span><span style="color: #808080;">@return</span><span style="color: #008000;"> the current thread's value of this thread-local
</span><span style="color: #008080;">8</span>  <span style="color: #008000;">*/</span>
<span style="color: #008080;">9</span> <span style="color: #0000ff;">public</span> T get()</pre>
</div>
<p>用于获取当前线程所对应的ThreadLocal值。如果当前线程下，该变量没有值，会通过调用initialValue()方法返回的值对其进行初始化。</p>
<p>&nbsp; （3）remove()</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> <span style="color: #008000;">/**</span>
<span style="color: #008080;"> 2</span> <span style="color: #008000;"> * Removes the current thread's value for this thread-local
</span><span style="color: #008080;"> 3</span> <span style="color: #008000;"> * variable.  If this thread-local variable is subsequently
</span><span style="color: #008080;"> 4</span> <span style="color: #008000;"> * {</span><span style="color: #808080;">@linkplain</span><span style="color: #008000;"> #get read} by the current thread, its value will be
</span><span style="color: #008080;"> 5</span> <span style="color: #008000;"> * reinitialized by invoking its {</span><span style="color: #808080;">@link</span><span style="color: #008000;"> #initialValue} method,
</span><span style="color: #008080;"> 6</span> <span style="color: #008000;"> * unless its value is {</span><span style="color: #808080;">@linkplain</span><span style="color: #008000;"> #set set} by the current thread
</span><span style="color: #008080;"> 7</span> <span style="color: #008000;"> * in the interim.  This may result in multiple invocations of the
</span><span style="color: #008080;"> 8</span> <span style="color: #008000;"> * {</span><span style="color: #808080;">@code</span><span style="color: #008000;"> initialValue} method in the current thread.
</span><span style="color: #008080;"> 9</span> <span style="color: #008000;"> *
</span><span style="color: #008080;">10</span> <span style="color: #008000;"> * </span><span style="color: #808080;">@since</span><span style="color: #008000;"> 1.5
</span><span style="color: #008080;">11</span>  <span style="color: #008000;">*/</span>
<span style="color: #008080;">12</span>  <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> remove()</pre>
</div>
<p>&nbsp; &nbsp; &nbsp; &nbsp;该接口是从JDK1.5开始提供的，用于删除当前线程对应的ThreadLocal值，从而减少内存占用。在同一线程中，如果该方法被调用了，随后再调用get()方法时，会使得initialValue()被调用，从而ThreadLocal的值被重新初始化，除非此时在调用get()前调用了set()来赋值。该方法可能导致initialValue()被多次调用。该方法可以不用显示调用，因为当线程结束后，系统会自动回收线程局部变量值。所以该方法不是必须调用的，只不过显示调用可以加快内存回收。</p>
<p>&nbsp; （4）initialValue()</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> <span style="color: #008000;">/**</span>
<span style="color: #008080;"> 2</span> <span style="color: #008000;"> * Returns the current thread's "initial value" for this
</span><span style="color: #008080;"> 3</span> <span style="color: #008000;"> * thread-local variable.  This method will be invoked the first
</span><span style="color: #008080;"> 4</span> <span style="color: #008000;"> * time a thread accesses the variable with the {</span><span style="color: #808080;">@link</span><span style="color: #008000;"> #get}
</span><span style="color: #008080;"> 5</span> <span style="color: #008000;"> * method, unless the thread previously invoked the {</span><span style="color: #808080;">@link</span><span style="color: #008000;"> #set}
</span><span style="color: #008080;"> 6</span> <span style="color: #008000;"> * method, in which case the {</span><span style="color: #808080;">@code</span><span style="color: #008000;"> initialValue} method will not
</span><span style="color: #008080;"> 7</span> <span style="color: #008000;"> * be invoked for the thread.  Normally, this method is invoked at
</span><span style="color: #008080;"> 8</span> <span style="color: #008000;"> * most once per thread, but it may be invoked again in case of
</span><span style="color: #008080;"> 9</span> <span style="color: #008000;"> * subsequent invocations of {</span><span style="color: #808080;">@link</span><span style="color: #008000;"> #remove} followed by {</span><span style="color: #808080;">@link</span><span style="color: #008000;"> #get}.
</span><span style="color: #008080;">10</span> <span style="color: #008000;"> *
</span><span style="color: #008080;">11</span> <span style="color: #008000;"> * &lt;p&gt;This implementation simply returns {</span><span style="color: #808080;">@code</span><span style="color: #008000;"> null}; if the
</span><span style="color: #008080;">12</span> <span style="color: #008000;"> * programmer desires thread-local variables to have an initial
</span><span style="color: #008080;">13</span> <span style="color: #008000;"> * value other than {</span><span style="color: #808080;">@code</span><span style="color: #008000;"> null}, {</span><span style="color: #808080;">@code</span><span style="color: #008000;"> ThreadLocal} must be
</span><span style="color: #008080;">14</span> <span style="color: #008000;"> * subclassed, and this method overridden.  Typically, an
</span><span style="color: #008080;">15</span> <span style="color: #008000;"> * anonymous inner class will be used.
</span><span style="color: #008080;">16</span> <span style="color: #008000;"> *
</span><span style="color: #008080;">17</span> <span style="color: #008000;"> * </span><span style="color: #808080;">@return</span><span style="color: #008000;"> the initial value for this thread-local
</span><span style="color: #008080;">18</span>  <span style="color: #008000;">*/</span>
<span style="color: #008080;">19</span> <span style="color: #0000ff;">protected</span><span style="color: #000000;"> T initialValue() {
</span><span style="color: #008080;">20</span>     <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span><span style="color: #000000;">;
</span><span style="color: #008080;">21</span> }</pre>
</div>
<p>&nbsp; &nbsp; &nbsp; &nbsp;返回当前线程对应的ThreadLocal的初始值。当当前线程是通过get()方法第一次对ThreadLocal进行访问时，该方法将会被调用，除非当前线程之前调用过set()方法，在这种情况下initialValue()方法将不会被当前线程所调用。一般而言，该方法最多只会被每个线程调用一次，除非随后在当前线程中调用remove()方法，然后调用get()方法。该实现会简单地返回null；如果程序员希望ThreadLocal拥有一个初始值，而不是null，ThreadLocal需要定义一个子类，并且在子类中重写initialValue()方法。比较典型的做法是使用一个匿名内部类。该方法由protected修饰，可见其这样设计通常是为了供用户重写，从而自定义初始值。后面会再通过实例来演示该方法的使用。</p>
<p>&nbsp;</p>
<p><strong>5、ThreadLocal工作机制</strong></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;ThreadLocal使用起来非常简单，但它是如何实现为每一个Thread保存一份独立的数据的呢？我们先结合实例3.1来看set()方法都做了些什么：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;">1</span> <span style="color: #008000;">//</span><span style="color: #008000;">=========ThreadLocal=======源码5.1</span>
<span style="color: #008080;">2</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> set(T value) {
</span><span style="color: #008080;">3</span>     Thread t =<span style="color: #000000;"> Thread.currentThread();
</span><span style="color: #008080;">4</span>     ThreadLocalMap map =<span style="color: #000000;"> getMap(t);
</span><span style="color: #008080;">5</span>     <span style="color: #0000ff;">if</span> (map != <span style="color: #0000ff;">null</span><span style="color: #000000;">)
</span><span style="color: #008080;">6</span>         map.set(<span style="color: #0000ff;">this</span><span style="color: #000000;">, value);
</span><span style="color: #008080;">7</span>     <span style="color: #0000ff;">else</span>
<span style="color: #008080;">8</span> <span style="color: #000000;">        createMap(t, value);
</span><span style="color: #008080;">9</span> }</pre>
</div>
<p>&nbsp; &nbsp; &nbsp; &nbsp;首先就是获取当前的线程，然后根据当前线程来获取一个ThreadLocalMap，如果map不为null，就往map中插入指定值，注意这的key是ThreadLocal实例；如果map为null，就创建一个map。看看第4行getMap(t)做了啥：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> <span style="color: #008000;">//</span><span style="color: #008000;">=========ThreadLocal=======源码5.2</span>
<span style="color: #008080;"> 2</span> <span style="color: #008000;">/**</span>
<span style="color: #008080;"> 3</span> <span style="color: #008000;"> * Get the map associated with a ThreadLocal. 
</span><span style="color: #008080;"> 4</span> <span style="color: #008000;"> * ......
</span><span style="color: #008080;"> 5</span>  <span style="color: #008000;">*/</span>
<span style="color: #008080;"> 6</span> <span style="color: #000000;">ThreadLocalMap getMap(Thread t) {
</span><span style="color: #008080;"> 7</span>     <span style="color: #0000ff;">return</span><span style="color: #000000;"> t.threadLocals;
</span><span style="color: #008080;"> 8</span> <span style="color: #000000;">}
</span><span style="color: #008080;"> 9</span> 
<span style="color: #008080;">10</span> <span style="color: #008000;">/**</span>
<span style="color: #008080;">11</span> <span style="color: #008000;"> * ThreadLocalMap is a customized hash map suitable only for
</span><span style="color: #008080;">12</span> <span style="color: #008000;"> * maintaining thread local values......
</span><span style="color: #008080;">13</span>  <span style="color: #008000;">*/</span>
<span style="color: #008080;">14</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> ThreadLocalMap {
</span><span style="color: #008080;">15</span> <span style="color: #000000;">     ......
</span><span style="color: #008080;">16</span> <span style="color: #000000;">}
</span><span style="color: #008080;">17</span> 
<span style="color: #008080;">18</span> <span style="color: #008000;">//</span><span style="color: #008000;">==========Thread========</span>
<span style="color: #008080;">19</span> ThreadLocal.ThreadLocalMap threadLocals = <span style="color: #0000ff;">null</span>;</pre>
</div>
<p>&nbsp; &nbsp; &nbsp; &nbsp;getMap()返回的是指定线程（也就是当前线程）的threadLocals变量，这个变量是ThreadLocal.ThreadLocalMap类型的，而ThreadLocalMap是一个仅适用于维护线程本地变量值的自定义的HashMap。简单来说，就是返回当前线程下的一个自定义HashMap。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;下面我抽取了ThreadLocalMap的部分代码，先来总体上认识它（这里我们不需要读懂其中的每一行代码，知道它里面主要做了哪些事就可以了）：</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('2d3789ac-56c8-4452-bb40-72b17ead2270')"><img id="code_img_closed_2d3789ac-56c8-4452-bb40-72b17ead2270" class="code_img_closed" src="./images/【朝花夕拾】Android多线程之（二）ThreadLocal篇2.png" alt="" /><img id="code_img_opened_2d3789ac-56c8-4452-bb40-72b17ead2270" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('2d3789ac-56c8-4452-bb40-72b17ead2270',event)" src="./images/【朝花夕拾】Android多线程之（二）ThreadLocal篇3.png" alt="" />
<div id="cnblogs_code_open_2d3789ac-56c8-4452-bb40-72b17ead2270" class="cnblogs_code_hide">
<pre><code><span style="color: #008080;">  1</span> <span style="color: #008000;">//</span><span style="color: #008000;">=========源码5.3========</span>
<span style="color: #008080;">  2</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> ThreadLocalMap {
</span><span style="color: #008080;">  3</span> 
<span style="color: #008080;">  4</span>     <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">class</span> Entry <span style="color: #0000ff;">extends</span> WeakReference&lt;ThreadLocal&lt;?&gt;&gt;<span style="color: #000000;"> {
</span><span style="color: #008080;">  5</span>         <span style="color: #008000;">/**</span><span style="color: #008000;"> The value associated with this ThreadLocal. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">  6</span> <span style="color: #000000;">        Object value;
</span><span style="color: #008080;">  7</span> 
<span style="color: #008080;">  8</span>         Entry(ThreadLocal&lt;?&gt;<span style="color: #000000;"> k, Object v) {
</span><span style="color: #008080;">  9</span>             <span style="color: #0000ff;">super</span><span style="color: #000000;">(k);
</span><span style="color: #008080;"> 10</span>             value =<span style="color: #000000;"> v;
</span><span style="color: #008080;"> 11</span> <span style="color: #000000;">        }
</span><span style="color: #008080;"> 12</span> <span style="color: #000000;">    }
</span><span style="color: #008080;"> 13</span> 
<span style="color: #008080;"> 14</span>     <span style="color: #008000;">/**</span>
<span style="color: #008080;"> 15</span> <span style="color: #008000;">     * The initial capacity -- MUST be a power of two.
</span><span style="color: #008080;"> 16</span>      <span style="color: #008000;">*/</span>
<span style="color: #008080;"> 17</span>     <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">int</span> INITIAL_CAPACITY = 16<span style="color: #000000;">;
</span><span style="color: #008080;"> 18</span> 
<span style="color: #008080;"> 19</span>     <span style="color: #008000;">/**</span>
<span style="color: #008080;"> 20</span> <span style="color: #008000;">     * The table, resized as necessary.
</span><span style="color: #008080;"> 21</span> <span style="color: #008000;">     * table.length MUST always be a power of two.
</span><span style="color: #008080;"> 22</span>      <span style="color: #008000;">*/</span>
<span style="color: #008080;"> 23</span>     <span style="color: #0000ff;">private</span><span style="color: #000000;"> Entry[] table;
</span><span style="color: #008080;"> 24</span> 
<span style="color: #008080;"> 25</span>     <span style="color: #008000;">/**</span>
<span style="color: #008080;"> 26</span> <span style="color: #008000;">     * The number of entries in the table.
</span><span style="color: #008080;"> 27</span>      <span style="color: #008000;">*/</span>
<span style="color: #008080;"> 28</span>     <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">int</span> size = 0<span style="color: #000000;">;
</span><span style="color: #008080;"> 29</span> 
<span style="color: #008080;"> 30</span>     <span style="color: #008000;">/**</span>
<span style="color: #008080;"> 31</span> <span style="color: #008000;">     * The next size value at which to resize.
</span><span style="color: #008080;"> 32</span>      <span style="color: #008000;">*/</span>
<span style="color: #008080;"> 33</span>     <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">int</span> threshold; <span style="color: #008000;">//</span><span style="color: #008000;"> Default to 0</span>
<span style="color: #008080;"> 34</span> 
<span style="color: #008080;"> 35</span>     <span style="color: #008000;">/**</span>
<span style="color: #008080;"> 36</span> <span style="color: #008000;">     * Set the resize threshold to maintain at worst a 2/3 load factor.
</span><span style="color: #008080;"> 37</span>      <span style="color: #008000;">*/</span>
<span style="color: #008080;"> 38</span>     <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">void</span> setThreshold(<span style="color: #0000ff;">int</span><span style="color: #000000;"> len) {
</span><span style="color: #008080;"> 39</span>         threshold = len * 2 / 3<span style="color: #000000;">;
</span><span style="color: #008080;"> 40</span> <span style="color: #000000;">    }
</span><span style="color: #008080;"> 41</span>     
<span style="color: #008080;"> 42</span>     ThreadLocalMap(ThreadLocal&lt;?&gt;<span style="color: #000000;"> firstKey, Object firstValue) {
</span><span style="color: #008080;"> 43</span>         table = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Entry[INITIAL_CAPACITY];
</span><span style="color: #008080;"> 44</span>         <span style="color: #0000ff;">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1<span style="color: #000000;">);
</span><span style="color: #008080;"> 45</span>         table[i] = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Entry(firstKey, firstValue);
</span><span style="color: #008080;"> 46</span>         size = 1<span style="color: #000000;">;
</span><span style="color: #008080;"> 47</span> <span style="color: #000000;">        setThreshold(INITIAL_CAPACITY);
</span><span style="color: #008080;"> 48</span> <span style="color: #000000;">    }
</span><span style="color: #008080;"> 49</span>     
<span style="color: #008080;"> 50</span>     <span style="color: #008000;">/**</span>
<span style="color: #008080;"> 51</span> <span style="color: #008000;">     * Get the entry associated with key.
</span><span style="color: #008080;"> 52</span> <span style="color: #008000;">     * ......
</span><span style="color: #008080;"> 53</span>      <span style="color: #008000;">*/</span>
<span style="color: #008080;"> 54</span>     <span style="color: #0000ff;">private</span> Entry getEntry(ThreadLocal&lt;?&gt;<span style="color: #000000;"> key) {
</span><span style="color: #008080;"> 55</span>         <span style="color: #0000ff;">int</span> i = key.threadLocalHashCode &amp; (table.length - 1<span style="color: #000000;">);
</span><span style="color: #008080;"> 56</span>         Entry e =<span style="color: #000000;"> table[i];
</span><span style="color: #008080;"> 57</span>         <span style="color: #0000ff;">if</span> (e != <span style="color: #0000ff;">null</span> &amp;&amp; e.get() ==<span style="color: #000000;"> key)
</span><span style="color: #008080;"> 58</span>             <span style="color: #0000ff;">return</span><span style="color: #000000;"> e;
</span><span style="color: #008080;"> 59</span>         <span style="color: #0000ff;">else</span>
<span style="color: #008080;"> 60</span>             <span style="color: #0000ff;">return</span><span style="color: #000000;"> getEntryAfterMiss(key, i, e);
</span><span style="color: #008080;"> 61</span> <span style="color: #000000;">    }
</span><span style="color: #008080;"> 62</span> 
<span style="color: #008080;"> 63</span>     <span style="color: #008000;">/**</span>
<span style="color: #008080;"> 64</span> <span style="color: #008000;">     * Set the value associated with key.
</span><span style="color: #008080;"> 65</span> <span style="color: #008000;">     * ......
</span><span style="color: #008080;"> 66</span>      <span style="color: #008000;">*/</span>
<span style="color: #008080;"> 67</span>     <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">void</span> set(ThreadLocal&lt;?&gt;<span style="color: #000000;"> key, Object value) {
</span><span style="color: #008080;"> 68</span> 
<span style="color: #008080;"> 69</span>         <span style="color: #008000;">//</span><span style="color: #008000;"> We don't use a fast path as with get() because it is at
</span><span style="color: #008080;"> 70</span>         <span style="color: #008000;">//</span><span style="color: #008000;"> least as common to use set() to create new entries as
</span><span style="color: #008080;"> 71</span>         <span style="color: #008000;">//</span><span style="color: #008000;"> it is to replace existing ones, in which case, a fast
</span><span style="color: #008080;"> 72</span>         <span style="color: #008000;">//</span><span style="color: #008000;"> path would fail more often than not.</span>
<span style="color: #008080;"> 73</span> 
<span style="color: #008080;"> 74</span>         Entry[] tab =<span style="color: #000000;"> table;
</span><span style="color: #008080;"> 75</span>         <span style="color: #0000ff;">int</span> len =<span style="color: #000000;"> tab.length;
</span><span style="color: #008080;"> 76</span>         <span style="color: #0000ff;">int</span> i = key.threadLocalHashCode &amp; (len-1<span style="color: #000000;">);
</span><span style="color: #008080;"> 77</span> 
<span style="color: #008080;"> 78</span>         <span style="color: #0000ff;">for</span> (Entry e =<span style="color: #000000;"> tab[i];
</span><span style="color: #008080;"> 79</span>              e != <span style="color: #0000ff;">null</span><span style="color: #000000;">;
</span><span style="color: #008080;"> 80</span>              e = tab[i =<span style="color: #000000;"> nextIndex(i, len)]) {
</span><span style="color: #008080;"> 81</span>             ThreadLocal&lt;?&gt; k =<span style="color: #000000;"> e.get();
</span><span style="color: #008080;"> 82</span> 
<span style="color: #008080;"> 83</span>             <span style="color: #0000ff;">if</span> (k ==<span style="color: #000000;"> key) {
</span><span style="color: #008080;"> 84</span>                 e.value =<span style="color: #000000;"> value;
</span><span style="color: #008080;"> 85</span>                 <span style="color: #0000ff;">return</span><span style="color: #000000;">;
</span><span style="color: #008080;"> 86</span> <span style="color: #000000;">            }
</span><span style="color: #008080;"> 87</span> 
<span style="color: #008080;"> 88</span>             <span style="color: #0000ff;">if</span> (k == <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
</span><span style="color: #008080;"> 89</span> <span style="color: #000000;">                replaceStaleEntry(key, value, i);
</span><span style="color: #008080;"> 90</span>                 <span style="color: #0000ff;">return</span><span style="color: #000000;">;
</span><span style="color: #008080;"> 91</span> <span style="color: #000000;">            }
</span><span style="color: #008080;"> 92</span> <span style="color: #000000;">        }
</span><span style="color: #008080;"> 93</span> 
<span style="color: #008080;"> 94</span>         tab[i] = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Entry(key, value);
</span><span style="color: #008080;"> 95</span>         <span style="color: #0000ff;">int</span> sz = ++<span style="color: #000000;">size;
</span><span style="color: #008080;"> 96</span>         <span style="color: #0000ff;">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;=<span style="color: #000000;"> threshold)
</span><span style="color: #008080;"> 97</span> <span style="color: #000000;">            rehash();
</span><span style="color: #008080;"> 98</span> <span style="color: #000000;">    }
</span><span style="color: #008080;"> 99</span> 
<span style="color: #008080;">100</span>     <span style="color: #008000;">/**</span>
<span style="color: #008080;">101</span> <span style="color: #008000;">     * Remove the entry for key.
</span><span style="color: #008080;">102</span>      <span style="color: #008000;">*/</span>
<span style="color: #008080;">103</span>     <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">void</span> remove(ThreadLocal&lt;?&gt;<span style="color: #000000;"> key) {
</span><span style="color: #008080;">104</span>         Entry[] tab =<span style="color: #000000;"> table;
</span><span style="color: #008080;">105</span>         <span style="color: #0000ff;">int</span> len =<span style="color: #000000;"> tab.length;
</span><span style="color: #008080;">106</span>         <span style="color: #0000ff;">int</span> i = key.threadLocalHashCode &amp; (len-1<span style="color: #000000;">);
</span><span style="color: #008080;">107</span>         <span style="color: #0000ff;">for</span> (Entry e =<span style="color: #000000;"> tab[i];
</span><span style="color: #008080;">108</span>              e != <span style="color: #0000ff;">null</span><span style="color: #000000;">;
</span><span style="color: #008080;">109</span>              e = tab[i =<span style="color: #000000;"> nextIndex(i, len)]) {
</span><span style="color: #008080;">110</span>             <span style="color: #0000ff;">if</span> (e.get() ==<span style="color: #000000;"> key) {
</span><span style="color: #008080;">111</span> <span style="color: #000000;">                e.clear();
</span><span style="color: #008080;">112</span> <span style="color: #000000;">                expungeStaleEntry(i);
</span><span style="color: #008080;">113</span>                 <span style="color: #0000ff;">return</span><span style="color: #000000;">;
</span><span style="color: #008080;">114</span> <span style="color: #000000;">            }
</span><span style="color: #008080;">115</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">116</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">117</span> 
<span style="color: #008080;">118</span>     <span style="color: #008000;">/**</span>
<span style="color: #008080;">119</span> <span style="color: #008000;">     * Double the capacity of the table.
</span><span style="color: #008080;">120</span>      <span style="color: #008000;">*/</span>
<span style="color: #008080;">121</span>     <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> resize() {
</span><span style="color: #008080;">122</span> <span style="color: #000000;">       ......
</span><span style="color: #008080;">123</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">124</span> }</pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>&nbsp; &nbsp; &nbsp; &nbsp;这里面维护了一个Entry[] table数组，初始容量为16，当数据超过当前容量的2/3时，就开始扩容，容量增大一倍。每一个Entry的K为ThreadLocal对象，V为要存储的值。每一个Entry在数组中的位置，是根据其K（即ThreadLocal对象）的hashCode &amp; (len - 1)来确定，如第44行所示，这里K的hashCode是系统给出的一个算法计算得到的。如果碰到K的hashCode值相同，即hash碰撞的场景，会采用尾插法形成链表。当对这个map进行set，get，remove操作的时候，也是通过K的hashCode来确定该Entry在table中的位置的，采用hashCode来查找数据，效率比较高。这也是HashMap底层实现的基本原理，如果研究过HashMap源码，这段代码就应该比较容易理解了。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;继续看源码5.1，第一次调用的时候，显然map应该是null，就要执行第8行createMap了，</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;">1</span> <span style="color: #008000;">//</span><span style="color: #008000;">==========ThreadLocal=========源码5.4</span>
<span style="color: #008080;">2</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> createMap(Thread t, T firstValue) {
</span><span style="color: #008080;">3</span>     t.threadLocals = <span style="color: #0000ff;">new</span> ThreadLocalMap(<span style="color: #0000ff;">this</span><span style="color: #000000;">, firstValue);
</span><span style="color: #008080;">4</span> }</pre>
</div>
<p>&nbsp; &nbsp; &nbsp; &nbsp;结合ThreadLocalMap源码第41行的构造方法，就清楚了这个方法创建了一个ThreadLocalMap对象，并存储了一个Entry&lt;当前的ThreadLocal对象，value&gt;。此时，在当前的线程下拥有了一个ThreadLocalMap，这个ThreadLocalMap中维护了一个容量为16的table，table中存储了一个以当前的ThreadLocal对象为K，value值为V的Entry。Thread、ThreadLocalMap、ThreadLocal、Entry之间的关系可以表示为下图：</p>
<p style="text-align: center;">&nbsp;<img src="./images/【朝花夕拾】Android多线程之（二）ThreadLocal篇4.png" alt="" width="363" height="302" /></p>
<p style="text-align: center;">&nbsp;图5.1</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;而如果当前Thread的map已经存在了，源码5.1就会执行第6行了，进而执行ThreadLocalMap中的set方法。结合前面对ThreadLocalMap的介绍，想必这个set方法也容易理解了，大致过程是：</p>
<p>&nbsp; &nbsp; 1）根据Thread找到map；</p>
<p>&nbsp; &nbsp; 2）通过传入的this(即ThreadLocal对象)，得到hashCode；</p>
<p>&nbsp; &nbsp; 3）根据hashCode &amp; (len - 1)确定对应Entry在table中的位置；</p>
<p>&nbsp; &nbsp; 4）如果该Entry存在，则替换Value，否则新建（ThreadLocalMap源码第78~92行表示在具有相同hashCode的Entry链表上找到对应的Entry，这和hash碰撞有关）。</p>
<p>&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;在调用ThreadLocal的get方法时又做了什么呢？看看其源码：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> <span style="color: #008000;">//</span><span style="color: #008000;">=========ThreadLocal======源码5.5</span>
<span style="color: #008080;"> 2</span> <span style="color: #0000ff;">public</span><span style="color: #000000;"> T get() {
</span><span style="color: #008080;"> 3</span>     Thread t =<span style="color: #000000;"> Thread.currentThread();
</span><span style="color: #008080;"> 4</span>     ThreadLocalMap map =<span style="color: #000000;"> getMap(t);
</span><span style="color: #008080;"> 5</span>     <span style="color: #0000ff;">if</span> (map != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
</span><span style="color: #008080;"> 6</span>         ThreadLocalMap.Entry e = map.getEntry(<span style="color: #0000ff;">this</span><span style="color: #000000;">);
</span><span style="color: #008080;"> 7</span>         <span style="color: #0000ff;">if</span> (e != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
</span><span style="color: #008080;"> 8</span>             @SuppressWarnings("unchecked"<span style="color: #000000;">)
</span><span style="color: #008080;"> 9</span>             T result =<span style="color: #000000;"> (T)e.value;
</span><span style="color: #008080;">10</span>             <span style="color: #0000ff;">return</span><span style="color: #000000;"> result;
</span><span style="color: #008080;">11</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">12</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">13</span>     <span style="color: #0000ff;">return</span><span style="color: #000000;"> setInitialValue();
</span><span style="color: #008080;">14</span> }</pre>
</div>
<p>&nbsp; &nbsp; &nbsp; &nbsp;现在，第12行及以前的代码应该很容易理解了，结合ThreadLocalMap中的get源码，我们再梳理一下：</p>
<p>&nbsp; &nbsp; 1）根据Thread找到自己的map；</p>
<p>&nbsp; &nbsp; 2）在map中通过this（即ThreadLocal对象）得到hashCode；</p>
<p>&nbsp; &nbsp; 3）通过hashCode &amp; （len-1）找到对应Entry在table中的位置；</p>
<p>&nbsp; &nbsp; 4）返回Entry的value。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;而如果map为null，或者在map中找到的Entry为null，那么就执行第20行了。</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> <span style="color: #008000;">//</span><span style="color: #008000;">==========ThreadLocal========源码5.6</span>
<span style="color: #008080;"> 2</span> <span style="color: #0000ff;">private</span><span style="color: #000000;"> T setInitialValue() {
</span><span style="color: #008080;"> 3</span>     T value =<span style="color: #000000;"> initialValue();
</span><span style="color: #008080;"> 4</span>     Thread t =<span style="color: #000000;"> Thread.currentThread();
</span><span style="color: #008080;"> 5</span>     ThreadLocalMap map =<span style="color: #000000;"> getMap(t);
</span><span style="color: #008080;"> 6</span>     <span style="color: #0000ff;">if</span> (map != <span style="color: #0000ff;">null</span><span style="color: #000000;">)
</span><span style="color: #008080;"> 7</span>         map.set(<span style="color: #0000ff;">this</span><span style="color: #000000;">, value);
</span><span style="color: #008080;"> 8</span>     <span style="color: #0000ff;">else</span>
<span style="color: #008080;"> 9</span> <span style="color: #000000;">        createMap(t, value);
</span><span style="color: #008080;">10</span>     <span style="color: #0000ff;">return</span><span style="color: #000000;"> value;
</span><span style="color: #008080;">11</span> <span style="color: #000000;">}
</span><span style="color: #008080;">12</span> 
<span style="color: #008080;">13</span> <span style="color: #0000ff;">protected</span><span style="color: #000000;"> T initialValue() {
</span><span style="color: #008080;">14</span>     <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span><span style="color: #000000;">;
</span><span style="color: #008080;">15</span> }</pre>
</div>
<pre><code>第13行的initialValue()方法，前面介绍过，可以让子类重写，即给ThreadLocal指定初始值；如果没有重写，那返回值就是null。第4~9行前面也介绍过了，使用或者创建map来存入该值。</pre>
<p>最后还一个remove()方法</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;">1</span> <span style="color: #008000;">//</span><span style="color: #008000;">======ThreadLocal======</span>
<span style="color: #008080;">2</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> remove() {
</span><span style="color: #008080;">3</span>     ThreadLocalMap m =<span style="color: #000000;"> getMap(Thread.currentThread());
</span><span style="color: #008080;">4</span>     <span style="color: #0000ff;">if</span> (m != <span style="color: #0000ff;">null</span><span style="color: #000000;">)
</span><span style="color: #008080;">5</span>         m.remove(<span style="color: #0000ff;">this</span><span style="color: #000000;">);
</span><span style="color: #008080;">6</span> }</pre>
</div>
<p>结合ThrealLocalMap中的remove方法，完成对ThreadLocal值的删除。其大致流程为：</p>
<p>&nbsp; &nbsp; 1）根据当前Thread找到其map；</p>
<p>&nbsp; &nbsp; 2）根据ThreadLocal对象得到hashCode；</p>
<p>&nbsp; &nbsp; 3）通过hashCode &amp; (len -1)找到在table中的位置；</p>
<p>&nbsp; &nbsp; 4）在table中查找对应的Entry，如果存在则删除。</p>
<p>&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;总结：通过对提供的4个接口方法的分析，我们应该就能清楚了，ThreadLocal之所以能够为每一个线程维护一个副本，是因为每个线程都拥有一个map，这个map就是每个线程的专属空间。也就是存在下面的关系图（不用怀疑，该图和图5.1相比，只是少了容量大小）：</p>
<p style="text-align: center;"><img src="./images/【朝花夕拾】Android多线程之（二）ThreadLocal篇5.png" alt="" /></p>
<p>结合这一节对ThreadLocal机制的介绍，实例3.1执行后的就存在如下的数据结构了：</p>
<p style="text-align: center;">&nbsp;<img src="./images/【朝花夕拾】Android多线程之（二）ThreadLocal篇6.png" alt="" /></p>
<p>&nbsp;</p>
<p><strong>6、ThreadLocal在Looper中的使用</strong></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;ThreadLocal在系统源码中有很多地方使用，最典型的地方就是Handler的Looper中了。这里结合Looper中的源码，来了解一下ThreadLocal在系统源码中的使用。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;我们知道，在一个App进程启动的时候，会在ActiivtyThread类的main方法，也就是App的入口方法中，会为主线程准备一个Looper，如下代码所示：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;">1</span> <span style="color: #008000;">//</span><span style="color: #008000;">======ActivityTread======源码6.1</span>
<span style="color: #008080;">2</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
</span><span style="color: #008080;">3</span> <span style="color: #000000;">      ......
</span><span style="color: #008080;">4</span> <span style="color: #000000;">      Looper.prepareMainLooper();
</span><span style="color: #008080;">5</span> <span style="color: #000000;">      ......
</span><span style="color: #008080;">6</span> }</pre>
</div>
<p>而在子线程中实例Handler的时候，总是需要显示调用Looper.prepare()方法来为当前线程生成一个Looper对象，以及通过Looper.myLooper()来得到自己线程的Looper来传递给Handler。</p>
<p>Looper中相关的关键源码如下：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> <span style="color: #008000;">//</span><span style="color: #008000;">==========Looper========源码6.2
</span><span style="color: #008080;"> 2</span> 
<span style="color: #008080;"> 3</span> <span style="color: #008000;">//</span><span style="color: #008000;"> sThreadLocal.get() will return null unless you've called prepare().</span>
<span style="color: #008080;"> 4</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span style="color: #0000ff;">new</span> ThreadLocal&lt;Looper&gt;<span style="color: #000000;">();
</span><span style="color: #008080;"> 5</span> <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span><span style="color: #000000;"> Looper sMainLooper;
</span><span style="color: #008080;"> 6</span> 
<span style="color: #008080;"> 7</span> <span style="color: #008000;">/**</span>
<span style="color: #008080;"> 8</span> <span style="color: #008000;"> * Initialize the current thread as a looper, marking it as an
</span><span style="color: #008080;"> 9</span> <span style="color: #008000;"> * application's main looper. The main looper for your application
</span><span style="color: #008080;">10</span> <span style="color: #008000;"> * is created by the Android environment, so you should never need
</span><span style="color: #008080;">11</span> <span style="color: #008000;"> * to call this function yourself.  See also: {</span><span style="color: #808080;">@link</span><span style="color: #008000;"> #prepare()}
</span><span style="color: #008080;">12</span>  <span style="color: #008000;">*/</span>
<span style="color: #008080;">13</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> prepareMainLooper() {
</span><span style="color: #008080;">14</span>     prepare(<span style="color: #0000ff;">false</span><span style="color: #000000;">);
</span><span style="color: #008080;">15</span>     <span style="color: #0000ff;">synchronized</span> (Looper.<span style="color: #0000ff;">class</span><span style="color: #000000;">) {
</span><span style="color: #008080;">16</span>         <span style="color: #0000ff;">if</span> (sMainLooper != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
</span><span style="color: #008080;">17</span>             <span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> IllegalStateException("The main Looper has already been prepared."<span style="color: #000000;">);
</span><span style="color: #008080;">18</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">19</span>         sMainLooper =<span style="color: #000000;"> myLooper();
</span><span style="color: #008080;">20</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">21</span> <span style="color: #000000;">}
</span><span style="color: #008080;">22</span> 
<span style="color: #008080;">23</span> <span style="color: #008000;">/**</span>
<span style="color: #008080;">24</span> <span style="color: #008000;"> * Return the Looper object associated with the current thread.  Returns
</span><span style="color: #008080;">25</span> <span style="color: #008000;"> * null if the calling thread is not associated with a Looper.
</span><span style="color: #008080;">26</span>  <span style="color: #008000;">*/</span>
<span style="color: #008080;">27</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span><span style="color: #000000;"> @Nullable Looper myLooper() {
</span><span style="color: #008080;">28</span>     <span style="color: #0000ff;">return</span><span style="color: #000000;"> sThreadLocal.get();
</span><span style="color: #008080;">29</span> <span style="color: #000000;">}
</span><span style="color: #008080;">30</span> 
<span style="color: #008080;">31</span> <span style="color: #008000;">/**</span><span style="color: #008000;"> Initialize the current thread as a looper.
</span><span style="color: #008080;">32</span> <span style="color: #008000;">  * ......
</span><span style="color: #008080;">33</span>   <span style="color: #008000;">*/</span>
<span style="color: #008080;">34</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> prepare() {
</span><span style="color: #008080;">35</span>     prepare(<span style="color: #0000ff;">true</span><span style="color: #000000;">);
</span><span style="color: #008080;">36</span> <span style="color: #000000;">}
</span><span style="color: #008080;">37</span> <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> prepare(<span style="color: #0000ff;">boolean</span><span style="color: #000000;"> quitAllowed) {
</span><span style="color: #008080;">38</span>     <span style="color: #0000ff;">if</span> (sThreadLocal.get() != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
</span><span style="color: #008080;">39</span>         <span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> RuntimeException("Only one Looper may be created per thread"<span style="color: #000000;">);
</span><span style="color: #008080;">40</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">41</span>     sThreadLocal.set(<span style="color: #0000ff;">new</span><span style="color: #000000;"> Looper(quitAllowed));
</span><span style="color: #008080;">42</span> <span style="color: #000000;">}
</span><span style="color: #008080;">43</span> 
<span style="color: #008080;">44</span> <span style="color: #008000;">/**</span>
<span style="color: #008080;">45</span> <span style="color: #008000;"> * Returns the application's main looper, which lives in the main thread of the application.
</span><span style="color: #008080;">46</span>  <span style="color: #008000;">*/</span>
<span style="color: #008080;">47</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span><span style="color: #000000;"> Looper getMainLooper() {
</span><span style="color: #008080;">48</span>     <span style="color: #0000ff;">synchronized</span> (Looper.<span style="color: #0000ff;">class</span><span style="color: #000000;">) {
</span><span style="color: #008080;">49</span>         <span style="color: #0000ff;">return</span><span style="color: #000000;"> sMainLooper;
</span><span style="color: #008080;">50</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">51</span> }</pre>
</div>
<p>我们可以看到不少ThreadLocal的影子，Looper也正是通过ThreadLocal来为每个线程维护一份Looper实例的。通过我们前文的介绍，这里应该能够轻而易举理解其中的运作机制了吧，这里就再不啰嗦了。</p>
<p>&nbsp;</p>
<p><strong>7、实践是检验真理的唯一标准</strong></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 前面介绍了ThreadLocal提供的四个接口，以及详细讲解了它的工作原理。现在我们将实例3.1做一些修改，将各个接口的功能都包含进来，并稍微增加一点复杂度，如果能够看懂这个实例，就算是真的理解ThreadLocal了。</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> <span style="color: #008000;">//</span><span style="color: #008000;">=========实例7.1=======</span>
<span style="color: #008080;"> 2</span> <span style="color: #0000ff;">private</span> ThreadLocal&lt;String&gt; mStrThreadLocal = <span style="color: #0000ff;">new</span> ThreadLocal&lt;String&gt;<span style="color: #000000;">() {
</span><span style="color: #008080;"> 3</span> <span style="color: #000000;">    @Override
</span><span style="color: #008080;"> 4</span>     <span style="color: #0000ff;">protected</span><span style="color: #000000;"> String initialValue() {
</span><span style="color: #008080;"> 5</span>         Log.i("threadlocaldemo", "initialValue"<span style="color: #000000;">);
</span><span style="color: #008080;"> 6</span>         <span style="color: #0000ff;">return</span> "initName"<span style="color: #000000;">;
</span><span style="color: #008080;"> 7</span> <span style="color: #000000;">    }
</span><span style="color: #008080;"> 8</span> <span style="color: #000000;">};
</span><span style="color: #008080;"> 9</span> <span style="color: #0000ff;">private</span> ThreadLocal&lt;Long&gt; mLongThreadLocal = <span style="color: #0000ff;">new</span> ThreadLocal&lt;&gt;<span style="color: #000000;">();
</span><span style="color: #008080;">10</span> <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">void</span> testThreadLocal() <span style="color: #0000ff;">throws</span><span style="color: #000000;"> InterruptedException {
</span><span style="color: #008080;">11</span>     mStrThreadLocal.set("main-thread"<span style="color: #000000;">);
</span><span style="color: #008080;">12</span> <span style="color: #000000;">    mLongThreadLocal.set(Thread.currentThread().getId());
</span><span style="color: #008080;">13</span>     Log.i("threadlocaldemo", "result-1:name=" + mStrThreadLocal.get() + ";id=" +<span style="color: #000000;"> mLongThreadLocal.get());
</span><span style="color: #008080;">14</span>     Thread thread_1 = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Thread() {
</span><span style="color: #008080;">15</span> <span style="color: #000000;">        @Override
</span><span style="color: #008080;">16</span>         <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() {
</span><span style="color: #008080;">17</span>             <span style="color: #0000ff;">super</span><span style="color: #000000;">.run();
</span><span style="color: #008080;">18</span>             mStrThreadLocal.set("thread_1"<span style="color: #000000;">);
</span><span style="color: #008080;">19</span> <span style="color: #000000;">            mLongThreadLocal.set(Thread.currentThread().getId());
</span><span style="color: #008080;">20</span>             Log.i("threadlocaldemo", "result-2:name=" + mStrThreadLocal.get() + ";id=" +<span style="color: #000000;"> mLongThreadLocal.get());
</span><span style="color: #008080;">21</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">22</span> <span style="color: #000000;">    };
</span><span style="color: #008080;">23</span> <span style="color: #000000;">    thread_1.start();
</span><span style="color: #008080;">24</span>     <span style="color: #008000;">//</span><span style="color: #008000;">该句表示thread_1执行完后才会继续执行</span>
<span style="color: #008080;">25</span> <span style="color: #000000;">    thread_1.join();
</span><span style="color: #008080;">26</span>     Thread thread_2 = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Thread() {
</span><span style="color: #008080;">27</span> <span style="color: #000000;">        @Override
</span><span style="color: #008080;">28</span>         <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() {
</span><span style="color: #008080;">29</span>             <span style="color: #0000ff;">super</span><span style="color: #000000;">.run();
</span><span style="color: #008080;">30</span>             Log.i("threadlocaldemo", "result-3:name=" + mStrThreadLocal.get() + ";id=" +<span style="color: #000000;"> mLongThreadLocal.get());
</span><span style="color: #008080;">31</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">32</span> <span style="color: #000000;">    };
</span><span style="color: #008080;">33</span> <span style="color: #000000;">    thread_2.start();
</span><span style="color: #008080;">34</span>     <span style="color: #008000;">//</span><span style="color: #008000;">该句表示thread_2执行完后才会继续执行</span>
<span style="color: #008080;">35</span> <span style="color: #000000;">    thread_2.join();
</span><span style="color: #008080;">36</span> <span style="color: #000000;">    mStrThreadLocal.remove();
</span><span style="color: #008080;">37</span>     Log.i("threadlocaldemo", "result-4:name=" + mStrThreadLocal.get() + ";id=" +<span style="color: #000000;"> mLongThreadLocal.get());
</span><span style="color: #008080;">38</span> }</pre>
</div>
<p>在主线程中运行该方法，执行结果为：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;">1</span> 12-14 16:25:40.662 4844-4844/com.example.demos I/threadlocaldemo: result-1:name=main-thread;id=2
<span style="color: #008080;">2</span> 12-14 16:25:40.668 4844-5351/com.example.demos I/threadlocaldemo: result-2:name=thread_1;id=926
<span style="color: #008080;">3</span> 12-14 16:25:40.669 4844-5353/com.example.demos I/<span style="color: #000000;">threadlocaldemo: initialValue
</span><span style="color: #008080;">4</span> 12-14 16:25:40.669 4844-5353/com.example.demos I/threadlocaldemo: result-3:name=initName;id=<span style="color: #0000ff;">null</span>
<span style="color: #008080;">5</span> 12-14 16:25:40.669 4844-4844/com.example.demos I/<span style="color: #000000;">threadlocaldemo: initialValue
</span><span style="color: #008080;">6</span> 12-14 16:25:40.669 4844-4844/com.example.demos I/threadlocaldemo: result-4:name=initName;id=2</pre>
</div>
<p>此时存在的数据结构为：</p>
<p style="text-align: center;"><img src="./images/【朝花夕拾】Android多线程之（二）ThreadLocal篇7.png" alt="" /></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;对于这份log和数据结构图，这里就不再一一讲解了，如果前面都看懂了，这些都是小菜一碟。</p>
<p>&nbsp;</p>
<p><strong>结语</strong></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;对ThreadLocal的讲解这里就结束了，能读到这里，也足以说明你是人才，一定前途无量，祝你好运，早日走上人生巅峰！</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;由于经验和水平有限，有描述不当或不准确的地方，还请不吝赐教，谢谢！</p>
<p>&nbsp;</p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>