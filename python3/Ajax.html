<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修Ajax' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>Ajax</center></div><div class='banquan'>原文出处:本文由博客园博主changxin7提供。<br/>
原文连接:https://www.cnblogs.com/changxin7/p/11601850.html</div><br>
    <h1 id="一-ajax简介">一 Ajax简介</h1>
<h2 id="简介"><strong>1.简介</strong></h2>
<p>　　　　AJAX（Asynchronous Javascript And XML）翻译成中文就是“异步的Javascript和XML”。即使用Javascript语言与服务器进行异步交互，传输的数据为XML（当然，传输的数据不只是XML,现在更多使用json数据）。</p>
<p>　　　　AJAX 不是新的编程语言，而是一种使用现有标准的新方法。</p>
<p>　　　　AJAX 最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。（这一特点给用户的感受是在不知不觉中完成请求和响应过程）</p>
<p>　　　　AJAX 不需要任何浏览器插件，但需要用户允许JavaScript在浏览器上执行。</p>
<p>　　　　　　a.同步交互：客户端发出一个请求后，需要等待服务器响应结束后，才能发出第二个请求；</p>
<p>　　　　　　b.异步交互：客户端发出一个请求后，无需等待服务器响应结束，就可以发出第二个请求。</p>
<p>　　AJAX除了<strong>异步</strong>的特点外，还有一个就是：浏览器页面<strong>局部刷新</strong>；（这一特点给用户的感受是在不知不觉中完成请求和响应过程</p>
<h2 id="示例">2.示例</h2>
<p>　　　　<strong>页面输入两个整数，通过AJAX传输到后端计算出结果并返回。</strong></p>
<p>　　　　html文件名称为ajax_demo1.html，内容如下</p>
<pre><code><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;
  &lt;title&gt;AJAX局部刷新实例&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;input type=&quot;text&quot; id=&quot;i1&quot;&gt;+
&lt;input type=&quot;text&quot; id=&quot;i2&quot;&gt;=
&lt;input type=&quot;text&quot; id=&quot;i3&quot;&gt;
&lt;input type=&quot;button&quot; value=&quot;AJAX提交&quot; id=&quot;b1&quot;&gt;

&lt;script src=&quot;/static/jquery-3.2.1.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  $(&quot;#b1&quot;).on(&quot;click&quot;, function () {
    $.ajax({
      url:&quot;/ajax_add/&quot;, //别忘了加双引号
      type:&quot;GET&quot;,  
      data:{&quot;i1&quot;:$(&quot;#i1&quot;).val(),&quot;i2&quot;:$(&quot;#i2&quot;).val()}, //object类型，键值形式的，可以不给键加引号
      success:function (data) {
        $(&quot;#i3&quot;).val(data);
      }
    })
  })
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>　　　　views.py里面的内容：</p>
<pre><code><code>def ajax_demo1(request):
    return render(request, &quot;ajax_demo1.html&quot;)


def ajax_add(request):    #time.sleep(10)  #不影响页面发送其他的请求
    i1 = int(request.GET.get(&quot;i1&quot;))
    i2 = int(request.GET.get(&quot;i2&quot;))
    ret = i1 + i2
    return JsonResponse(ret, safe=False)    #return render(request,&#39;index.html&#39;)  #返回一个页面没有意义，就是一堆的字符串，拿到了这个页面，你怎么处理，你要做什么事情，根本就没有意义</code></pre>
<p>　　　　urls.py里面的内容</p>
<pre><code><code>urlpatterns = [
    ...
    url(r&#39;^ajax_add/&#39;, views.ajax_add),
    url(r&#39;^ajax_demo1/&#39;, views.ajax_demo1),
    ...   
]</code></pre>
<p>　　　启动django项目，然后运行看看效果，页面不刷新</p>
<h2 id="ajax常见应用情景"><strong>3.AJAX常见应用情景</strong></h2>
<p>　　　　搜索引擎根据用户输入的关键字，自动提示检索关键字。</p>
<p>　　　　还有一个很重要的应用场景就是注册时候的用户名的查重。</p>
<p>　　　　其实这里就使用了AJAX技术！当文件框发生了输入变化时，使用AJAX技术向服务器发送一个请求，然后服务器会把查询到的结果响应给浏览器，最后再把后端返回的结果展示出来。</p>
<p>　　　　　　a.整个过程中页面没有刷新，只是刷新页面中的局部位置而已！</p>
<p>　　　　　　b.当请求发出后，浏览器还可以进行其他操作，无需等待服务器的响应！</p>
<p>​ 　　　　<img src="./images/Ajax0.png" alt="img" /></p>
<p>　　　　当输入用户名后，把光标移动到其他表单项上时，浏览器会使用AJAX技术向服务器发出请求，服务器会查询名为lemontree7777777的用户是否存在，最终服务器返回true表示名为lemontree7777777的用户已经存在了，浏览器在得到结果后显示“用户名已被注册！”。</p>
<p>　　　　a.整个过程中页面没有刷新，只是局部刷新了；</p>
<p>　　　　b.在请求发出后，浏览器不用等待服务器响应结果就可以进行其他操作；</p>
<h2 id="ajax的优缺点"><strong>4.AJAX的优缺点</strong></h2>
<p>优点：</p>
<p>　　　　　　1.AJAX使用JavaScript技术向服务器发送异步请求；</p>
<p>　　　　　　2.AJAX请求无须刷新整个页面；</p>
<p>　　　　　　3.因为服务器响应内容不再是整个页面，而是页面中的部分内容，所以AJAX性能高；</p>
<h2 id="作业">5.作业</h2>
<p>　　　　写一个登陆认证页面，登陆失败不刷新页面，提示用户登陆失败，登陆成功自动跳转到网站首页。</p>
<p>　　　　login.html，内容如下：</p>
<pre><code><code>{% load static %}
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div&gt;
    用户名:&lt;input type=&quot;text&quot; id=&quot;username&quot;&gt;
    密码:&lt;input type=&quot;text&quot; id=&quot;pwd&quot;&gt;
    {% csrf_token %}
    &lt;button id=&quot;sub&quot;&gt;提交&lt;/button&gt;
    &lt;span style=&quot;color: red;font-size: 12px;&quot; id=&quot;error&quot;&gt;&lt;/span&gt;
&lt;/div&gt;

&lt;script src=&quot;{% static &#39;jquery.js&#39; %}&quot;&gt;&lt;/script&gt;

&lt;script&gt;
    $(&#39;#sub&#39;).click(function () {
        $.ajax({
            url:&quot;{% url &#39;login&#39; %}&quot;,
            type:&#39;post&#39;,
            data:{username:$(&#39;#username&#39;).val(),pwd:$(&#39;#pwd&#39;).val(),csrfmiddlewaretoken:$(&#39;[name=csrfmiddlewaretoken]&#39;).val()},

            success:function (data) {
                data = JSON.parse(data);
                console.log(data,typeof data);
                if (data[&#39;status&#39;]){

                    location.href=data[&#39;home_url&#39;];
                }
                else {
                    $(&#39;#error&#39;).text(&#39;用户名或者密码错误！&#39;)
                }
            }

        })


    })



&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>　　　　base.html，内容如下：</p>
<pre><code><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h1&gt;
    欢迎来到xxx官网
&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>　　　　urls.py,内容如下</p>
<pre><code><code>url(r&#39;^login/&#39;, views.login,name=&#39;login&#39;),
url(r&#39;^home/&#39;, views.home,name=&#39;home&#39;),</code></pre>
<p>　　　　views.py，内容如下</p>
<pre><code><code>def login(request):
    res_dict = {&#39;status&#39;:None,&#39;home_url&#39;:None}
    if request.method == &#39;GET&#39;:
        return render(request,&#39;login.html&#39;)
    else:
        uname = request.POST.get(&#39;username&#39;)
        pwd = request.POST.get(&#39;pwd&#39;)

        user_obj = models.UserInfo.objects.filter(name=uname,password=pwd).exists()
        import json
        if user_obj:

            res_dict[&#39;status&#39;] = True
            res_dict[&#39;home_url&#39;] = reverse(&#39;home&#39;)
            res_json_dict = json.dumps(res_dict)

            return HttpResponse(res_json_dict) #直接回复字典格式是不可以的，必须转换成json字符串，转换成普通字符串也是不行的，因为前端需要对json进行反序列获得这个字典，在通过字典的形式来操作数据。
        else:
            res_dict[&#39;status&#39;] = False
            res_json_dict = json.dumps(res_dict)
            return HttpResponse(res_json_dict)
　　　　　　# 如果你就是不使用JsonResponse的话，也可以给HttpResponse添加一个参数，content_type=&#39;application/json&#39;，那么前端ajax拿到数据之后，也是不需要反序列化的，ajax的回调函数就收到的就是一个反序列化之后的一个对象，因为ajax接受到数据后，通过这个data_type或者content_type发现你发送来的是个json格式的数据，那么ajax内容就自动将这个数据反序列化得到了js的数据对象，然后通过对象可以直接操作数据。　　　　　　# return HttpResponse(res_json_dict,data_type=&#39;application/json&#39;)　　　　　　# return JsonResponse(res_dict)
def home(request):

    return render(request,&#39;base.html&#39;)</code></pre>
<p>　　　　还有一点注意一下，如果你想通过ajax来删除表格中某条记录，并且ajax里面的url不写死的情况下（url反向解析），那么就需要下面这种方式，实现url里面参数的动态：</p>
<p>　　　　　　　　<img src="./images/Ajax1.png" alt="img" /></p>
<p>　　　　还有一个细节要注意：</p>
<p>　　　　　　<img src="./images/Ajax2.png" alt="img" /></p>
<p>　　　　　　并且删除一条数据的时候，后端删除成功之后，你通过后端给你的返回值判断后端是否删除成功，如果删除成功，你有两种方式来删除前端页面的对应一行的记录，1：刷新页面，2：如果不让刷新页面，那么你就需要找到你点击的这个按钮的那一行的tr标签，通过dom操作把它删除</p>
<p>　　　　　ajax里面写$(this)时要注意的问题：还有一点注意，如果你添加某些dom对象的时候，如果你想在不刷新页面的情况下来添加这个对象，那么你要注意，如果这个对象也需要绑定事件的话，你需要用on来给和他相同的标签对象来绑定事件。</p>
<p>　　　　　　<img src="./images/Ajax3.png" alt="img" /></p>
<p>　　在这里补充个事情：</p>
<p>　　　　settings配置文件里面加上下面这句话，意思是说，告诉django，如果别人请求我的路径的时候，你不要自己处理别人输入的路径最后面的/了，如果这个值为True，而我们假如写了一个url为url('^index/',views.test)，如果用户输入的时127.0.0.1：8000/index的话，django会让浏览器重新再发一次请求，并且在这个路径后面加上/，也就成了127.0.0.1：8000/index/，此时和我们的url就能匹配上了，因为我们的url正则写的就加了/，如果你将下面这个值设置成false，那么django就不会自动帮你做这个事情了，那么用户在输入127.0.0.1：8000/index，没有最后那个斜杠的路径时，就无法和我们的url正则匹配上了，所以就找不到url了，就会报错，但是注意，django只能帮你重定向让浏览器再发一个get请求，如果你是post请求（非get请求），django就没有办法了，他还是帮你重新定向发送get请求，不能满足你的需求，所以如果你用post方法提交数据的时候，就像上面这个ajax里面的那个url写的必须和你后端配置的那个url对应好，所以别忘了如果你后端url上url('^index/',views.test)这个index后面加了/，那么你写ajax往这个路径下提交数据的时候，ajax里面的url参数后面别忘了写上/，让这个url和后端url正则规则对应好。</p>
<p>　　　　　　<img src="./images/Ajax4.png" alt="img" /></p>
<p>　　　　</p>
<h1 id="二-ajax的使用">二 Ajax的使用</h1>
<h2 id="基于jquery的实现">1.基于jQuery的实现</h2>
<p>　　　　看代码：</p>
<pre><code><code>&lt;button class=&quot;send_Ajax&quot;&gt;send_Ajax&lt;/button&gt;
&lt;script&gt;

       $(&quot;.send_Ajax&quot;).click(function(){

           $.ajax({
               url:&quot;/handle_Ajax/&quot;,
               type:&quot;POST&quot;,
               data:{username:&quot;chao&quot;,password:123},
               success:function(data){
                   console.log(data)
               },
         　　　　　　
               error: function (jqXHR, textStatus, err) {
                        console.log(arguments);
                    },

               complete: function (jqXHR, textStatus) {
                        console.log(textStatus);
                },

               statusCode: {
                    &#39;403&#39;: function (jqXHR, textStatus, err) {
                          console.log(arguments);
                     },

                    &#39;400&#39;: function (jqXHR, textStatus, err) {
                        console.log(arguments);
                    }
                }

           })

       })

&lt;/script&gt;</code></pre>
<h2 id="基于原生js实现">2.基于原生js实现</h2>
<p>　　　　看代码</p>
<pre><code><code>var b2 = document.getElementById(&quot;b2&quot;);
  b2.onclick = function () {
    // 原生JS
    var xmlHttp = new XMLHttpRequest();
    xmlHttp.open(&quot;POST&quot;, &quot;/ajax_test/&quot;, true);
    xmlHttp.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;);
    xmlHttp.send(&quot;username=chao&amp;password=123456&quot;);
    xmlHttp.onreadystatechange = function () {
      if (xmlHttp.readyState === 4 &amp;&amp; xmlHttp.status === 200) {
        alert(xmlHttp.responseText);
      }
    };
  };</code></pre>
<h2 id="ajax服务器ajax流程图">3.Ajax－服务器－Ajax流程图</h2>
<p>　　 　　<img src="./images/Ajax5.png" alt="img" /></p>
<h2 id="ajax参数">4.ajax参数</h2>
<p>　　　　请求参数：</p>
<pre><code><code>######################------------data---------################

       data: 当前ajax请求要携带的数据，是一个json的object对象，ajax方法就会默认地把它编码成某种格式
             (urlencoded:?a=1&amp;b=2)发送给服务端；此外，ajax默认以get方式发送请求。

             function testData() {
               $.ajax(&quot;/test&quot;,{     //此时的data是一个json形式的对象
                  data:{
                    a:1,
                    b:2
                  }
               });                   //?a=1&amp;b=2
######################------------processData---------################

processData：声明当前的data数据是否进行转码或预处理，默认为true，即预处理；if为false，
             那么对data：{a:1,b:2}会调用json对象的toString()方法，即{a:1,b:2}.toString()
             ,最后得到一个［object，Object］形式的结果。
            
######################------------contentType---------################

contentType：默认值: &quot;application/x-www-form-urlencoded&quot;。发送信息至服务器时内容编码类型。
             用来指明当前请求的数据编码格式；urlencoded:?a=1&amp;b=2；如果想以其他方式提交数据，
             比如contentType:&quot;application/json&quot;，即向服务器发送一个json字符串：
               $.ajax(&quot;/ajax_get&quot;,{
             
                  data:JSON.stringify({
                       a:22,
                       b:33
                   }),
                   contentType:&quot;application/json&quot;,
                   type:&quot;POST&quot;,
             
               });                          //{a: 22, b: 33}

             注意：contentType:&quot;application/json&quot;一旦设定，data必须是json字符串，不能是json对象

             views.py:   json.loads(request.body.decode(&quot;utf8&quot;))


######################------------traditional---------################

traditional：一般是我们的data数据有数组时会用到 ：data:{a:22,b:33,c:[&quot;x&quot;,&quot;y&quot;]},
              traditional为false会对数据进行深层次迭代；  </code></pre>
<p>　　　　响应参数：</p>
<pre><code><code>dataType：  预期服务器返回的数据类型,服务器端返回的数据会根据这个值解析后，传递给回调函数。
            默认不需要显性指定这个属性，ajax会根据服务器返回的content Type来进行转换；
            比如我们的服务器响应的content Type为json格式，这时ajax方法就会对响应的内容
            进行一个json格式的转换，if转换成功，我们在success的回调函数里就会得到一个json格式
            的对象；转换失败就会触发error这个回调函数。如果我们明确地指定目标类型，就可以使用
            data Type。
            dataType的可用值：html｜xml｜json｜text｜script
            见下dataType实例</code></pre>
<h1 id="三-ajax请求设置csrf_token">三 Ajax请求设置csrf_token</h1>
<h2 id="方式1">方式1</h2>
<p>　　　　通过获取隐藏的input标签中的csrfmiddlewaretoken值，放置在data中发送。</p>
<pre><code><code>$.ajax({
  url: &quot;/cookie_ajax/&quot;,
  type: &quot;POST&quot;,
  data: {
    &quot;username&quot;: &quot;chao&quot;,
    &quot;password&quot;: 123456,
    &quot;csrfmiddlewaretoken&quot;: $(&quot;[name = &#39;csrfmiddlewaretoken&#39;]&quot;).val()  // 使用jQuery取出csrfmiddlewaretoken的值，拼接到data中
  },
  success: function (data) {
    console.log(data);
  }
})</code></pre>
<h2 id="方式2">方式2</h2>
<pre><code><code>$.ajaxSetup({
    data: {csrfmiddlewaretoken: &#39;{{ csrf_token }}&#39; },
});</code></pre>
<h2 id="方式3后面再说"><strong>方式3（后面再说）</strong></h2>
<p>　　　　通过获取返回的cookie中的字符串 放置在请求头中发送。</p>
<p>　　　　注意：需要引入一个jquery.cookie.js插件。</p>
<pre><code><code>&lt;script src=&quot;{% static &#39;js/jquery.cookie.js&#39; %}&quot;&gt;&lt;/script&gt;

$.ajax({
 
headers:{&quot;X-CSRFToken&quot;:$.cookie(&#39;csrftoken&#39;)}, #其实在ajax里面还有一个参数是headers，自定制请求头，可以将csrf_token加在这里，我们发contenttype类型数据的时候，csrf_token就可以这样加
 
})</code></pre>
<p>　　详述CSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。攻击者通过HTTP请求江数据传送到服务器，从而盗取回话的cookie。盗取回话cookie之后，攻击者不仅可以获取用户的信息，还可以修改该cookie关联的账户信息。</p>
<p>　　<img src="./images/Ajax6.png" alt="img" /></p>
<p>　　所以解决csrf攻击的最直接的办法就是生成一个随机的csrftoken值，保存在用户的页面上，每次请求都带着这个值过来完成校验。</p>
<p>　　那么django中csrf认证怎么玩的呢？</p>
<p>　　　　官方文档中说到，检验token时，只比较secret是否和cookie中的secret值一样，而不是比较整个token。<br />
　　　　我又有疑问了，同一次登录，form表单中的token每次都会变，而cookie中的token不便，django把那个salt存储在哪里才能保证验证通过呢。直到看到源码。</p>
<pre><code><code>def _compare_salted_tokens(request_csrf_token, csrf_token):
    # Assume both arguments are sanitized -- that is, strings of
    # length CSRF_TOKEN_LENGTH, all CSRF_ALLOWED_CHARS.
    return constant_time_compare(
        _unsalt_cipher_token(request_csrf_token),
        _unsalt_cipher_token(csrf_token),
    )

def _unsalt_cipher_token(token):
    &quot;&quot;&quot;
    Given a token (assumed to be a string of CSRF_ALLOWED_CHARS, of length
    CSRF_TOKEN_LENGTH, and that its first half is a salt), use it to decrypt
    the second half to produce the original secret.
    &quot;&quot;&quot;
    salt = token[:CSRF_SECRET_LENGTH]
    token = token[CSRF_SECRET_LENGTH:]
    chars = CSRF_ALLOWED_CHARS
    pairs = zip((chars.index(x) for x in token), (chars.index(x) for x in salt))
    secret = &#39;&#39;.join(chars[x - y] for x, y in pairs)  # Note negative values are ok
    return secret</code></pre>
<p>　　</p>
<p>　　　　token字符串的前32位是salt， 后面是加密后的token， 通过salt能解密出唯一的secret。<br />
　　　　django会验证表单中的token和cookie中token是否能解出同样的secret，secret一样则本次请求合法。<br />
　　　　同样也不难解释，为什么ajax请求时，需要从cookie中拿取token添加到请求头中。</p>
<pre><code><code>    Cookies Hashing：每一个表单请求中都加入随机的Cookie，由于网站中存在XSS漏洞而被偷窃的危险。 
    HTTP refer：可以对服务器获得的请求来路进行欺骗以使得他们看起来合法，这种方法不能够有效防止攻击。 
    验证码：用户提交的每一个表单中使用一个随机验证码，让用户在文本框中填写图片上的随机字符串，并且在提交表单后对其进行检测。 
    令牌Token：一次性令牌在完成他们的工作后将被销毁，比较安全。
    ...等等吧，还有很多其他的。</code></pre>
<p>　　　　</p>
<pre><code><code>$.ajax({
  url: &quot;/cookie_ajax/&quot;,
  type: &quot;POST&quot;,
  headers: {&quot;X-CSRFToken&quot;: $.cookie(&#39;csrftoken&#39;)},  // 从Cookie取csrftoken，并设置到请求头中
  data: {&quot;username&quot;: &quot;chao&quot;, &quot;password&quot;: 123456},
  success: function (data) {
    console.log(data);
  }
})
</code></pre>
<p>　　　　或者用自己写一个getCookie方法：</p>
<pre><code><code>function getCookie(name) {
    var cookieValue = null;
    if (document.cookie &amp;&amp; document.cookie !== &#39;&#39;) {
        var cookies = document.cookie.split(&#39;;&#39;);
        for (var i = 0; i &lt; cookies.length; i++) {
            var cookie = jQuery.trim(cookies[i]);
            // Does this cookie string begin with the name we want?
            if (cookie.substring(0, name.length + 1) === (name + &#39;=&#39;)) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
            }
        }
    }
    return cookieValue;
}
var csrftoken = getCookie(&#39;csrftoken&#39;);
</code></pre>
<p>　　　　每一次都这么写太麻烦了，可以使用$.ajaxSetup()方法为ajax请求统一设置。</p>
<pre><code><code>function csrfSafeMethod(method) {
  // these HTTP methods do not require CSRF protection
  return (/^(GET|HEAD|OPTIONS|TRACE)$/.test(method));
}

$.ajaxSetup({
  beforeSend: function (xhr, settings) {
    if (!csrfSafeMethod(settings.type) &amp;&amp; !this.crossDomain) {
      xhr.setRequestHeader(&quot;X-CSRFToken&quot;, csrftoken);
    }
  }
});
</code></pre>
<p>　　　　注意：</p>
<p>　　　　　　如果使用从cookie中取csrftoken的方式，需要确保cookie存在csrftoken值。</p>
<p>　　　　　　如果你的视图渲染的HTML文件中没有包含 {% csrf_token %}，Django可能不会设置CSRFtoken的cookie。</p>
<p>　　　　　　这个时候需要使用ensure_csrf_cookie()装饰器强制设置Cookie。</p>
<pre><code><code>django.views.decorators.csrf import ensure_csrf_cookie


@ensure_csrf_cookie
def login(request):
    pass
</code></pre>
<p>　　　　更多细节详见：<a href="https://docs.djangoproject.com/en/1.11/ref/csrf/">Djagno官方文档中关于CSRF的内容</a></p>
<h1 id="四-ajax文件上传">四 Ajax文件上传</h1>
<h2 id="请求头contenttype">请求头ContentType</h2>
<p>　　　　ContentType指的是请求体的编码类型，常见的类型共有3种：</p>
<h3 id="applicationx-www-form-urlencoded看下图">1 application/x-www-form-urlencoded（看下图）</h3>
<p>　　　　　　这应该是最常见的 POST 提交数据的方式了。浏览器的原生 <form> 表单，如果不设置 <code>enctype</code> 属性，那么最终就会以 默认格式application/x-www-form-urlencoded 方式提交数据，ajax默认也是这个。请求类似于下面这样（无关的请求头在本文中都省略掉了）：</p>
<pre><code><code>POST http://www.example.com HTTP/1.1
Content-Type: application/x-www-form-urlencoded;charset=utf-8

user=yuan&amp;age=22   #这就是上面这种contenttype规定的数据格式，后端对应这个格式来解析获取数据，不管是get方法还是post方法，都是这样拼接数据，大家公认的一种数据格式，但是如果你contenttype指定的是urlencoded类型，但是post请求体里面的数据是下面那种json的格式，那么就出错了，服务端没法解开数据。
</code></pre>
<p>　　　　　　看network来查看我们发送的请求体：</p>
<p>　　　　　　　　<img src="./images/Ajax7.png" alt="img" /></p>
<p>　　　　　　点击一下上面红框的内容，你就会看到，这次post请求发送数据的原始格式</p>
<p>　　　　　　　　<img src="./images/Ajax8.png" alt="img" /></p>
<h3 id="multipartform-data">2 multipart/form-data</h3>
<p>　　　　　　这又是一个常见的 POST 数据提交的方式。我们使用表单上传文件时，必须让 <form> 表单的 <code>enctype</code> 等于 multipart/form-data，form表单不支持发json类型的contenttype格式的数据，而ajax什么格式都可以发，也是ajax应用广泛的一个原因。直接来看一个请求示例：（了解）</p>
<pre><code><code>POST http://www.example.com HTTP/1.1
Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA

------WebKitFormBoundaryrGKCBY7qhFd3TrwA
Content-Disposition: form-data; name=&quot;user&quot;

chao
------WebKitFormBoundaryrGKCBY7qhFd3TrwA
Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;chrome.png&quot;
Content-Type: image/png

PNG ... content of chrome.png ...
------WebKitFormBoundaryrGKCBY7qhFd3TrwA--
</code></pre>
<p>　　　　　　这个例子稍微复杂点。首先生成了一个 boundary 用于分割不同的字段，为了避免与正文内容重复，boundary 很长很复杂。然后 Content-Type 里指明了数据是以 multipart/form-data 来编码，本次请求的 boundary 是什么内容。消息主体里按照字段个数又分为多个结构类似的部分，每部分都是以 <code>--boundary</code> 开始，紧接着是内容描述信息，然后是回车，最后是字段具体内容（文本或二进制）。如果传输的是文件，还要包含文件名和文件类型信息。消息主体最后以 <code>--boundary--</code> 标示结束。关于 multipart/form-data 的详细定义，请前往 <a href="http://www.ietf.org/rfc/rfc1867.txt">rfc1867</a> 查看。</p>
<p>　　　　　　这种方式一般用来上传文件，各大服务端语言对它也有着良好的支持。</p>
<p>　　　　　　上面提到的这两种 POST 数据的方式，都是浏览器原生支持的，而且现阶段标准中原生 <form> 表单也<a href="http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4">只支持这两种方式</a>（通过 <form> 元素的 <code>enctype</code> 属性指定，默认为 <code>application/x-www-form-urlencoded</code>。其实 <code>enctype</code> 还支持 <code>text/plain</code>，不过用得非常少）。</p>
<p>　　　　　　随着越来越多的 Web 站点，尤其是 WebApp，全部使用 Ajax 进行数据交互之后，我们完全可以定义新的数据提交方式，给开发带来更多便利。</p>
<h3 id="applicationjson">3 application/json</h3>
<p>　　　　　　application/json 这个 Content-Type 作为响应头大家肯定不陌生。实际上，现在越来越多的人把它作为请求头，用来告诉服务端消息主体是序列化后的 JSON 字符串。由于 JSON 规范的流行，除了低版本 IE 之外的各大浏览器都原生支持 JSON.stringify，服务端语言也都有处理 JSON 的函数，使用 JSON 不会遇上什么麻烦。</p>
<p>　　　　　　JSON 格式支持比键值对复杂得多的结构化数据，这一点也很有用。记得以前做过一个项目时，需要提交的数据层次非常深，我就是把数据 JSON 序列化之后来提交的。不过当时我是把 JSON 字符串作为 val，仍然放在键值对里，以 x-www-form-urlencoded 方式提交。</p>
<p>　　　　　　　<img src="./images/Ajax9.png" alt="img" /></p>
<p>　　　　如果在ajax里面写上这个contenttype类型，那么data参数对应的数据，就不能是个object类型数据了，必须是json字符串，contenttype:'json'，简写一个json，它也能识别是application/json类型</p>
<p>　　　　　　　　<img src="./images/Ajax10.png" alt="img" /></p>
<p>　　　　　　　　服务端接受到数据之后，通过contenttype类型的值来使用不同的方法解析数据，其实就是服务端框架已经写好了针对这几个类型的不同的解析数据的方法，通过contenttype值来找对应方法解析，如果有一天你写了一个contenttype类型，定义了一个消息格式，各大语言及框架都支持，那么别人也会写一个针对你的contenttype值来解析数据的方法，django里面不能帮我们解析contenttype值为json的数据格式，你知道他能帮你解析application/x-www-form-urlencoded 和multipart/form-data(文件上传会用到)就行了，如果我们传json类型的话，需要我们自己来写一个解析数据的方法，其实不管是什么类型，我们都可以通过原始发送来的数据来进行加工处理，解析出自己想要的数据，这个事情我们在前面自己写web框架的时候在获取路径那里就玩过了，还记得吗？</p>
<p>　　　　　　　　　　<img src="./images/Ajax11.png" alt="img" /></p>
<pre><code><code>　　$.ajax({
            url:&quot;{% url &#39;home&#39; %}&quot;,
            type:&#39;post&#39;,
            headers:{
                &quot;X-CSRFToken&quot;:$.cookie(&#39;csrftoken&#39;), #现在先记住，等学了cookies你就明白了
                contentType:&#39;json&#39;,
            },

            data:JSON.stringify({ //如果我们发送的是json数据格式的数据，那么csrf_token就不能直接写在data里面了，没有效果，必须通过csrf的方式3的形式来写，写在hearders（请求头，可以写一些自定制的请求头）里面，注意，其实contentType也是headers里面的一部分，写在里面外面都可以
                name:name,
                //csrfmiddlewaretoken:$(&quot;[name=&#39;csrfmiddlewaretoken&#39;]&quot;).val()，
            }),
            success:function (response) {

            }

        })
</code></pre>
<h2 id="基于form表单的文件上传">基于form表单的文件上传</h2>
<h3 id="模板部分">模板部分</h3>
<pre><code><code>&lt;form action=&quot;&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; #上面说的其他两种contenttype都是键值的形式发送数据，这种form_data的格式一般是把大数据一段一段隔开的
      用户名 &lt;input type=&quot;text&quot; name=&quot;user&quot;&gt;
      头像 &lt;input type=&quot;file&quot; name=&quot;avatar&quot;&gt;  #如果不用form_data格式来发，那么默认的是urlencoded的格式，这个标签的数据会组成avatar:文件名字来进行发送
    &lt;input type=&quot;submit&quot;&gt;
&lt;/form&gt;
</code></pre>
<h3 id="视图部分">视图部分</h3>
<pre><code><code>def index(request):
    print(request.body)   # 原始的请求体数据
    print(request.GET)    # GET请求数据
    print(request.POST)   # POST请求数据
    print(request.FILES)  # 上传的文件数据


    return render(request,&quot;index.html&quot;)
</code></pre>
<p>　　upload.py，内容如下：</p>
<pre><code><code>def upload(request):

    if request.method == &#39;GET&#39;:

        return render(request,&#39;upload.html&#39;)
    else:
        print(request.POST)
        username = request.POST.get(&#39;user&#39;)
        file_obj = request.FILES.get(&#39;file_obj&#39;) #获得文件数据对象
        print(&#39;&gt;&gt;&gt;&#39;,file_obj,type(file_obj))
        #&gt;&gt;&gt; jaden博客.txt &lt;class &#39;django.core.files.uploadedfile.InMemoryUploadedFile&#39;&gt;,一个文件对象,可以理解为一个文件句柄
        file_name = file_obj.name #jaden博客.txt
        print(file_name)
        # 将数据写到文件里面,需要名字，需要数据
        with open(file_name,&#39;wb&#39;) as f: #直接把文件名字放这里，那么文件将直接生成在django的整个项目目录下，因为django配置的系统搜索的根路径就是咱们的项目文件夹路径，那个BASE_DIR,一般我们需要自己建立一个文件夹专门存放上传的文件　　　　　　#所以需要我们自己来拼接一个路径放到这里，os.path.join(settings.BASE_DIR,&#39;media&#39;,&#39;img&#39;,file_name)
            # f.write()  #不能一下写进去，占用的内容太多，要一点一点写
            for data in file_obj: #读数据
                f.write(data)  #每次读取的data不是固定长度的，和读取其他文件一样，每次读一行，识别符为\r  \n  \r\n，遇到这几个符号就算是读了一行
　　　　　　　#for chunks in file_obj.chunks(): #chunks()默认一次返回大小为经测试为65536B，也就是64KB，最大为2.5M，是一个生成器    　　　　 #　 f.write(chunks)
</code></pre>
<p>　　　　通过js来找文件对象</p>
<p>　　　　　　<img src="./images/Ajax12.png" alt="img" /></p>
<h2 id="基于ajax的文件上传">基于Ajax的文件上传</h2>
<h3 id="模板">模板</h3>
<pre><code><code>&lt;form&gt; #用不用form没关系，这里就是个盒子的作用，一般写form标签是为了提示别人，这个地方的内容是要提交的
　　　　　　{% csrf_token %}      用户名 &lt;input type=&quot;text&quot; id=&quot;user&quot;&gt;
      头像 &lt;input type=&quot;file&quot; id=&quot;avatar&quot;&gt;
     &lt;input type=&quot;button&quot; id=&quot;ajax-submit&quot; value=&quot;ajax-submit&quot;&gt;
&lt;/form&gt;

&lt;script&gt;

    $(&quot;#ajax-submit&quot;).click(function(){
        var formdata=new FormData(); #ajax上传文件的时候，需要这个类型，它会将添加给它的键值对加工成formdata的类型
        formdata.append(&quot;user&quot;,$(&quot;#user&quot;).val());  #添加键值的方法是append，注意写法，键和值之间是逗号
　　　　 formData.append(&quot;csrfmiddlewaretoken&quot;, $(&quot;[name=&#39;csrfmiddlewaretoken&#39;]&quot;).val()); #别忘了csrf_token
        formdata.append(&quot;avatar_img&quot;,$(&quot;#avatar&quot;)[0].files[0]);
        $.ajax({

            url:&quot;&quot;,
            type:&quot;post&quot;,
            data:formdata, #将添加好数据的formdata放到data这里
            processData: false ,    // 不处理数据
            contentType: false,    // 不设置内容类型

            success:function(data){
                console.log(data)
            }
        })

    })

&lt;/script&gt;
</code></pre>
<p>　　　　　　或者使用</p>
<pre><code><code>var form = document.getElementById(&quot;form1&quot;);
var fd = new FormData(form);
</code></pre>
<p>　　　　　　这样也可以直接通过ajax 的 send() 方法将 fd 发送到后台。</p>
<p>　　　　　　注意：由于 FormData 是 XMLHttpRequest Level 2 新增的接口，现在 低于IE10 的IE浏览器不支持 FormData。</p>
<h3 id="视图">视图</h3>
<pre><code><code>def index(request):

    if request.is_ajax():

        print(request.body)   # 原始的请求体数据
        print(request.GET)    # GET请求数据
        print(request.POST)   # POST请求数据
        print(request.FILES)  # 上传的文件数据

        return HttpResponse(&quot;ok&quot;)


    return render(request,&quot;index.html&quot;)
</code></pre>
<p>　　检查浏览器的请求头：</p>
<pre><code><code>Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryaWl9k5ZMiTAzx3FT
</code></pre>
<p>　　　　关于django后端代码接受上传文件的方法</p>
<pre><code><code>当Django处理上传一个文件的时候，文件数据被放在request.FILES中。这个文档解释文件怎么样被存储在磁盘上或者内存中，怎样定制默认的行为。
基本文件上传
考虑一个包含FileField的简单的表单：
from  django  import  forms
classUploadFileForm(forms.Form):
   title=forms.CharField(max_length=50)
   file=forms.FileField()
一个处理这个表单的视图将在request.FILES中接受文件数据 ,request.FILES是一个字典,它对每个FileField(或者是ImageField,或者是其他的FileField的子类)都包含一个key.所以 从上面的表单中来的数据将可以通过request.FILES[&#39;file&#39;]键来访问.
注意request.FILES只有 在request方法是POST并且发出POST请求的

有属性enctype=&quot;multipart/form-data&quot;.否则，request。FILES将是空的。
看另一个简单的；
from fdjango.http improt HttpResponseRedirect
from django.shortcuts import render_to_response
from somewhere import handle_uploaded_file
def upload_file(request):
    if request.method == &#39;post&#39;:
        form =  UploadFileForm(rquest.POST,request.FILES)
        if form.is_valid():
            handle_uploaded_file(request.FILES[&#39;file&#39;])
            return HttpResponseRedirect(&#39;/success/ur/&#39;)
   else:
        form = UploadFileForm()
    return render_to_response(&#39;upload.html&#39;,{&#39;form&#39;:form})
要注意，我们必须将request.FILES传递到表单的构造器中；这就是文件数据怎样和表单沾上边的 。
处理上传的文件
最后的难题是怎样处理从request.FILES中获得的真实的文件。这个字典的每个输入都是一个UploadedFile对象——一个上传之后的文件的简单的包装。
你通常会使用下面的几个方法来访问被上传的内容：
UploadedFile.read（）：从文件中读取整个上传的数据。小心整个方法：如果这个文件很大，你把它读到内存中会弄慢你的系统。你可以想要使用chunks（）来代替，看下面；
UploadedFile.multiple_chunks()：如果上传的文件足够大需要分块就返回真。默认的这个值是2.5兆，当然这个值是可以调节的，看下面的UploadedFile.chunks()：一个产生器，返回文件的块。如果multiple_chunks()是真的话，你应该在一个循环中使用这个方法，而不是使用read（）；
UploadedFile.name：上传文件的名字（比如m_file.txt）
UploadedFile.size：以bytes表示的上传的文件的大小。
还有其他的几个方法和属性。你可以自己去查。
把他们放在一起，这里是一个你处理上传文件的通常方法：
def handle_uploaded_file(f):
    destination = open(&#39;some/file/name.txt&#39;,&#39;wb+&#39;)
    for chunk in f.chunks(): 
        destination.write(chunk)
    destination.close()
在UploadedFile.chunks()上循环而不是用read()保证大文件不会大量使用你的系统内存。
上传的数据存在哪里？
在你保存上传的文件之前，数据需要被保存在某些地方。默认呢的，如果一个上传的文件小于2.5兆，Django会将上传的东西放在内存里。这意味着只要从内存读取数据并保存到硬盘上，所以很快。然而，如果一个上传的文件太大，Django将将上传的文件写到一个临时的文件中，这个文件在你的临时文件路径中。在Unix-like的平台上意味着你可以预见Django产生一个文件保存为/tmp/tmpzfp6I6.upload的文件。如果这个文件足够大，你可以观察到这个文件的大小在增大。
很多细节--2.5M;/tmp；等 等 都是简单的看上去合理的默认值。继续阅读看看你怎么样个性化或者完全替代掉上传行为。
改变上传处理行为
三个设置改变Django的上传处理行为：
FILE_UPLOAD_MAX_MEMORY_SIZE:以bytes为单位的到内存中的最大大小，。比这个值大的文件将被先存到磁盘上。默认是2.5兆
FILE_UPLOAD_TEMP_DIR:比FILE_UPLOAD_MAX_MEMORY_SIZE大的文件将被临时保存的地方。默认是系统标准的临时路径。
FILE_UPLOAD_PERMISSIONS:如果这个没有给出或者是None，你将获得独立于系统的行为。大多数平台，临时文件有一个0600模式，从内存保存的文件将使用系统标准umask。
FILE_UPLOAD_HANDLERS：上传文件的处理器。改变这个设置允许完全个性化——甚至代替——Django的上传过程。
默认是：
(&quot;django.core.files.uploadhandler.MemoryFileUploadHandler&quot;,
 &quot;django.core.files.uploadhandler.TemporaryFileUploadHandler&quot;,)
UploadedFile 对象
class UploadedFile
作为那些重File继承的补充，素有的UploadedFile对象定义了下面的方法和属性：
UploadedFile.content_type
文件的content_type头（比如text/plain
 orapplication/pdf
）。像用户提供的任何数据一样，你不应该信任上传的数据就是这个类型。你仍然要验证这个文件包含这个头声明的content-type——“信任但是验证”。
UploadedFile.charset
对于text/*的content-types，浏览器提供的字符集。再次，“信任但是验证”是最好的策略。
UploadedFile.temporary_file_path()：只有被传到磁盘上的文件才有这个方法，它返回临时上传文件的全路径。
注意：
 像通常的Python文件，你可以迭代上传的文件来一行一行得读取文件：
for line in uploadedfile:
    do_something_with(line)
然而，不同于标准Python文件，UploadedFile值懂得/n（也被称为Unix风格）的结尾。如果你知道你需要处理有不同风格结尾的文件的时候，你要在你的视图中作出处理。
上传处理句柄：
当一个用户上传一个文件，Django敬爱那个这个文件数据传递给上传处理句柄——一个处理随着文件上传处理文件的小类。上传处理句柄被FILE_UPLOAD_HANDLERS初始化定义，默认是：
(
&quot;django.core.files.uploadhandler.MemoryFileUploadHandler&quot;
,
 &quot;django.core.files.uploadhandler.TemporaryFileUploadHandler&quot;
,)
这两个提供了Django处理小文件和大文件的默认上产行为。
你可以个性化处理句柄来个性化Django处理文件的行为。比如你可以使用个性化的处理句柄来强制用户配额，实时地压缩数据，渲染进度条，甚至在保存在本地的同时向另一个存储地发送数据。
实时修改上传处理句柄
有的时候某些视图要使用不同的上传行为。这种情况下，你可以重写一个上传处理句柄，通过request.upload_handlers来修改。默认的，这个列表包含FILE_UPLOAD_HANDLERS提供的处理句柄，但是你可以像修改其他列表一样修改这个列表。
比如，加入你写了一个叫做
ProgressBarUploadHandler
 的处理句柄。你可以通过下面的形式加到你的上传处理句柄中：
request.upload_handlers.insert（0，ProgressBarUploadHandler（））
你赢使用list.insert()在这种情况下。因为进度条处理句柄需要首先执行。记住，处理句柄按照顺序执行。
如果你像完全代替掉上传处理句柄，你可以赋值一个新的列表：
request.upload_handlers=[ProgressBarUploadHandler()]
注意：你只能在访问request.POST或者request.FILES之前修改上传处理句柄。——如果上传处理开始后再改就没用了。如果你在修改reqeust.uplaod_handlers之前访问了request.POST
 or request.FILES
 ，Django将抛出一个错误。
所以，在你的视图中尽早的修改上传处理句柄。

写自定义的上传处理句柄：

所有的上传处理句柄都应 是 django.core.files.uploadhandler.FileUploadHandler的子类。你可以在任何你需要的地方定义句柄。
需要的方法：

自定义的上传处理句柄必须定义一下的方法：

FileUploadHandler.receive_data_chunk(self,raw_data,start)：从文件上传中接收块。

raw_data是已经上传的字节流

start是raw_data块开始的位置

你返回的数据将被传递到下一个处理句柄的receive_data_chunk方法中。这样一个处理句柄就是另一个的过滤器了。

返回None将阻止后面的处理句柄获得这个块，当你 自己存储这个数据，而不想其他处理句柄存储拷贝时很有用。

如果你触发一个StopUpload或者SkipFile异常，上传将被放弃或者文件被完全跳过。

FileUploadHandler.file_complete(self, file_size)


当 文件上传完毕时调用。

处理句柄应该返回一个UploadFile对象，可以存储在request.FILES中。处理句柄也可以返回None来使得UploadFile对象应该来自后来的上传处理句柄。


剩下的就是可选的一些方法实现。


FILE_UPLOAD_MAX_MEMORY_SIZE = 209715200 
FILE_UPLOAD_MAX_MEMORY_SIZE = 209715200


在你本机先好好测试一下，它是如何占用内存，什么时候开始存入temp目录，怎么迁移到upload目录底下的

文件上传的时候，如果一个上传的文件小于2.5兆，Django会将上传的东西放在内存里，如果上传的文件大于2.5M，Django将整个上传的文件写到一个临时的文件中,这个文件在临时文件路径中。上传完毕后，将调用View中的_Upload()方法将临时文件夹中的临时文件分块写到上传文件的存放路径下，每块的大小为64K,写完后临时文件将被删除。


UploadedFile.multiple_chunks()：如果上传的文件足够大需要分块就返回真。默认的这个值是2.5兆，当然这个值是可以调节的，看下面的UploadedFile.chunks()：一个产生器，返回文件的块。如果multiple_chunks()是真的话，你应该在一个循环中使用这个方法，而不是使用read（）；

在你保存上传的文件之前，数据需要被保存在某些地方。默认呢的，如果一个上传的文件小于2.5兆，Django会将上传的东西放在内存里。这意味着只要从内存读取数据并保存到硬盘上，所以很快。然而，如果一个上传的文件太大，Django将上传的文件写到一个临时的文件中，这个文件在你的临时文件路径中。在Unix-like的平台上意味着你可以预见Django产生一个文件保存为/tmp/tmpzfp6I6.upload的文件。如果这个文件足够大，你可以观察到这个文件的大小在增大。

三个设置改变Django的上传处理行为：
FILE_UPLOAD_MAX_MEMORY_SIZE:以bytes为单位的到内存中的最大大小，。比这个值大的文件将被先存到磁盘上。默认是2.5兆
FILE_UPLOAD_TEMP_DIR:比FILE_UPLOAD_MAX_MEMORY_SIZE大的文件将被临时保存的地方。默认是系统标准的临时路径。
FILE_UPLOAD_PERMISSIONS:如果这个没有给出或者是None，你将获得独立于系统的行为。大多数平台，临时文件有一个0600模式，从内存保存的文件将使用系统标准umask。
</code></pre>
<h2 id="练习用户名是否已被注册">练习（用户名是否已被注册）</h2>
<h3 id="功能介绍">功能介绍</h3>
<p>　　　　　　在注册表单中，当用户填写了用户名后，把光标移开后，会自动向服务器发送异步请求。服务器返回这个用户名是否已经被注册过。</p>
<h3 id="案例分析">案例分析</h3>
<ul>
<li>页面中给出注册表单；</li>
<li>在username input标签中绑定onblur事件处理函数。</li>
<li>当input标签失去焦点后获取 username表单字段的值，向服务端发送AJAX请求；</li>
<li>django的视图函数中处理该请求，获取username值，判断该用户在数据库中是否被注册，如果被注册了就返回“该用户已被注册”，否则响应“该用户名可以注册”。</li>
</ul>
<pre><code><code>def index(request):

    if request.method == &#39;POST&#39;:
        print(request.POST)
        print(&#39;files&#39;,request.FILES)
        # book_objs = models.Book.objects.all()
        # ret = serializers.serialize(&#39;json&#39;, book_objs,cls=JsonCustomEncoder) #同样无法序列化时间
        # ret = serializers.serialize(&#39;json&#39;, book_objs,cls=JsonCustomEncoder) #同样无法序列化时间,无法和json一样引入cls=JsonCustomEncoder这个类来解决日期时间格式数据的序列化
        #得到的结果[{&quot;model&quot;: &quot;app01.book&quot;, &quot;pk&quot;: 1, &quot;fields&quot;: {&quot;name&quot;: &quot;python&quot;, &quot;date&quot;: null, &quot;img&quot;: &quot;&quot;}}, {&quot;model&quot;: &quot;app01.book&quot;, &quot;pk&quot;: 2, &quot;fields&quot;: {&quot;name&quot;: &quot;linux&quot;, &quot;date&quot;: null, &quot;img&quot;: &quot;&quot;}}]
        #得到的结果的格式也是比较繁琐，所以不推荐使用django自带的serializers序列化器来序列化我们的queryset类型的数据
        #推荐写法：
        ret = models.Book.objects.all().values()
        print(ret)
        # print(request.body)
        import json
        ret = json.dumps(list(ret),cls=JsonCustomEncoder)
        print(ret)
        print(type(ret))
        # return HttpResponse(ret,content_type=&#39;application\json&#39;)
        return JsonResponse(ret,safe=False)
</code></pre>
<h1 id="五-关于json">五 关于json</h1>
<h2 id="什么是json">1.什么是json</h2>
<ul>
<li>JSON 指的是 JavaScript 对象表示法（JavaScript Object Notation）</li>
<li>JSON 是轻量级的文本数据交换格式</li>
<li>JSON 独立于语言 *</li>
<li><p>JSON 具有自我描述性，更易理解</p></li>
<li><p>JSON 使用 JavaScript 语法来描述数据对象，但是 JSON 仍然独立于语言和平台。JSON 解析器和 JSON 库支持许多不同的编程语言。</p></li>
</ul>
<p>　　　　啥都别多说了，上图吧！</p>
<p><img src="./images/Ajax13.png" alt="img" /></p>
<p>　　　　　　json数据类型和python数据类型的对比：</p>
<p>　　　　　　<img src="./images/Ajax14.png" alt="img" /></p>
<p>　　　　　　　object和python的dict类型是差不多的，但是要求里面必须是双引号，string和list、tuple等也是一样的，都是双引号。python中的datetime等时间日期类型是不能进行json序列化的，因为json没有对应的格式，上面的这几种数据类型虽然进行json.dumps序列化之后都是个字符串，但是也是有格式的</p>
<p>　　　　　　　　<img src="./images/Ajax15.png" alt="img" /></p>
<p>　　　　　　　　</p>
<p>　　　　前端ajax拿到后端返回的一个python的json模块序列化之后的一个json字符串，那么js通过自己的json接口，将接受到的json字符串来反序列化为js自己语言能够识别的数据类型，然后再进行操作。　　　　　　</p>
<p>　　　　相当于我有一个json方法，你有一个json方法，你给我发数据必须是json字符串的格式，那么你就需要将你的数据类型序列化为json的字符串，那么序列化的时候，就把你的数据序列化为了符合json标准的字符串，然后我接收到这个字符串之后，我通过我的json方法，将数据转换为我的语言支持的数据类型。在进行反序列化的时候，如果你的字符串不符合json的格式，那么反序列化的时候就会报错，所以只要你是通过json序列化成的字符串，都是能够json反序列化的，因为json序列化的时候，就把你的数据改为了符合json标准的字符串形式，例如：里面的单引号，序列化后变成了双引号。</p>
<p>　　　　合格的json对象：</p>
<pre><code><code>[&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]
{ &quot;one&quot;: 1, &quot;two&quot;: 2, &quot;three&quot;: 3 } #这就是一个json的object类型，符合json的标准格式，就可以通过dumps来进行序列化
{&quot;names&quot;: [&quot;张三&quot;, &quot;李四&quot;] }
[ { &quot;name&quot;: &quot;张三&quot;}, {&quot;name&quot;: &quot;李四&quot;} ]　
</code></pre>
<p>　　　　不合格的json对象：</p>
<pre><code><code>{ name: &quot;张三&quot;, &#39;age&#39;: 32 }  // 属性名必须使用双引号
[32, 64, 128, 0xFFF] // 不能使用十六进制值
{ &quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: undefined }  // 不能使用undefined
{ &quot;name&quot;: &quot;张三&quot;,
  &quot;birthday&quot;: new Date(&#39;Fri, 26 Aug 2011 07:13:10 GMT&#39;),
  &quot;getName&quot;:  function() {return this.name;}  // 不能使用函数和日期对象
}
</code></pre>
<p>　　　　看一下普通字符串和json字符串，在进行序列化的时候的区别</p>
<pre><code><code>import json
# s = &quot;{&#39;name&#39;:&#39;chao&#39;,&#39;age&#39;:18}&quot; #普通字符串，每加引号的没问题，加了引号的，必须是双引号才能使用json.loads()。
s = &#39;{&quot;name&quot;:&quot;chao&quot;,&quot;age&quot;:18}&#39;   #json字符串，里面必须是双引号
ret = json.loads(s)
print(ret)
print(ret[&#39;name&#39;])
</code></pre>
<h2 id="js的stringify与parse方法">2.js的stringify与parse方法</h2>
<p>　　　　JavaScript中关于JSON对象和字符串转换的两个方法：</p>
<p>　　　　JSON.parse(): 用于将一个 JSON 字符串转换为 JavaScript 对象　</p>
<pre><code><code>JSON.parse(&#39;{&quot;name&quot;:&quot;chao&quot;}&#39;);
JSON.parse(&#39;{name:&quot;chao&quot;}&#39;) ;   // 错误
JSON.parse(&#39;[18,undefined]&#39;) ;   // 错误
</code></pre>
<p>　　　　JSON.stringify(): 用于将 JavaScript 值转换为 JSON 字符串。　</p>
<pre><code><code>JSON.stringify({&quot;name&quot;:&quot;chao&quot;})
</code></pre>
<h2 id="和xml的比较">3.和XML的比较</h2>
<p>　　　　JSON 格式于2001年由 Douglas Crockford 提出，目的就是取代繁琐笨重的 XML 格式。</p>
<p>　　　　JSON 格式有两个显著的优点：书写简单，一目了然；符合 JavaScript 原生语法，可以由解释引擎直接处理，不用另外添加解析代码。所以，JSON迅速被接受，已经成为各大网站交换数据的标准格式，并被写入ECMAScript 5，成为标准的一部分。</p>
<p>　　　　XML和JSON都使用结构化方法来标记数据，下面来做一个简单的比较。</p>
<p>用XML表示中国部分省市数据如下：</p>
<pre><code><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;country&gt;
    &lt;name&gt;中国&lt;/name&gt;
    &lt;province&gt;
        &lt;name&gt;黑龙江&lt;/name&gt;
        &lt;cities&gt;
            &lt;city&gt;哈尔滨&lt;/city&gt;
            &lt;city&gt;大庆&lt;/city&gt;
        &lt;/cities&gt;
    &lt;/province&gt;
    &lt;province&gt;
        &lt;name&gt;广东&lt;/name&gt;
        &lt;cities&gt;
            &lt;city&gt;广州&lt;/city&gt;
            &lt;city&gt;深圳&lt;/city&gt;
            &lt;city&gt;珠海&lt;/city&gt;
        &lt;/cities&gt;
    &lt;/province&gt;
    &lt;province&gt;
        &lt;name&gt;台湾&lt;/name&gt;
        &lt;cities&gt;
            &lt;city&gt;台北&lt;/city&gt;
            &lt;city&gt;高雄&lt;/city&gt;
        &lt;/cities&gt;
    &lt;/province&gt;
    &lt;province&gt;
        &lt;name&gt;新疆&lt;/name&gt;
        &lt;cities&gt;
            &lt;city&gt;乌鲁木齐&lt;/city&gt;
        &lt;/cities&gt;
    &lt;/province&gt;
&lt;/country&gt;
</code></pre>
<p>　　　　用JSON表示如下：</p>
<pre><code><code>{
    &quot;name&quot;: &quot;中国&quot;,
    &quot;province&quot;: [{
        &quot;name&quot;: &quot;黑龙江&quot;,
        &quot;cities&quot;: {
            &quot;city&quot;: [&quot;哈尔滨&quot;, &quot;大庆&quot;]
        }
    }, {
        &quot;name&quot;: &quot;广东&quot;,
        &quot;cities&quot;: {
            &quot;city&quot;: [&quot;广州&quot;, &quot;深圳&quot;, &quot;珠海&quot;]
        }
    }, {
        &quot;name&quot;: &quot;台湾&quot;,
        &quot;cities&quot;: {
            &quot;city&quot;: [&quot;台北&quot;, &quot;高雄&quot;]
        }
    }, {
        &quot;name&quot;: &quot;新疆&quot;,
        &quot;cities&quot;: {
            &quot;city&quot;: [&quot;乌鲁木齐&quot;]
        }
    }]
}
</code></pre>
<p>　　　　</p>
<p>　　　　由上面的两端代码可以看出，JSON 简单的语法格式和清晰的层次结构明显要比 XML 容易阅读，并且在数据交换方面，由于 JSON 所使用的字符要比 XML 少得多，可以大大得节约传输数据所占用得带宽。</p>
<h2 id="ajax和服务端的数据交互时的序列化问题">4.ajax和服务端的数据交互时的序列化问题</h2>
<p>　　当我们给ajax回复的不是一个字符串，而是其他数据类型的时候，需要我们将数据转换为json字符串进行发送，这样好配合js进行json字符串的处理，不然发送或者接受的是普通字符串的话，没办法处理成原来的数据类型。</p>
<p>　　这就用到了我们前面的视图函数中那个JsonResponse了，<a href="https://www.cnblogs.com/clschao/articles/10409764.html">看博客</a>，里面response的部分</p>
<p>　　还要注意ajax中的data参数：</p>
<p>　　　　data参数中的键值对，如果值值不为字符串，需要将其转换成字符串类型。</p>
<pre><code><code>$(&quot;#b1&quot;).on(&quot;click&quot;, function () {
    $.ajax({
      url:&quot;/ajax_add/&quot;,
      type:&quot;GET&quot;,
      data:{&quot;i1&quot;:$(&quot;#i1&quot;).val(),&quot;i2&quot;:$(&quot;#i2&quot;).val(),&quot;hehe&quot;: JSON.stringify([1, 2, 3])},
      success:function (data) {
        $(&quot;#i3&quot;).val(data);
      }
    })
  })
</code></pre>
<h2 id="django内置的serializers做序列化">5.Django内置的serializers做序列化</h2>
<p>　　　　看代码：</p>
<pre><code><code>def books_json(request):
    book_list = models.Book.objects.all()[0:10]
    from django.core import serializers
    ret = serializers.serialize(&quot;json&quot;, book_list)
    return HttpResponse(ret)
</code></pre>
<p>　　通过json学列化时间日期格式数据的时候需要注意，不能直接序列化，我写了一个类，可以借用：</p>
<p>　　</p>
<pre><code><code>import json
from datetime import datetime
from datetime import date

#对含有日期格式数据的json数据进行转换
class JsonCustomEncoder(json.JSONEncoder):
    def default(self, field):
        if isinstance(field,datetime):
            return field.strftime(&#39;%Y-%m-%d %H:%M:%S&#39;)
        elif isinstance(field,date):
            return field.strftime(&#39;%Y-%m-%d&#39;)
        else:
            return json.JSONEncoder.default(self,field)


d1 = datetime.now()

dd = json.dumps(d1,cls=JsonCustomEncoder)
print(dd)
</code></pre>
<h1 id="六-补充一个sweetalert插件示例">六 补充一个SweetAlert插件示例</h1>
<p>看效果：</p>
<p>　　　　<img src="./images/Ajax16.png" alt="img" /></p>
<p>　　点击下载<a href="https://github.com/lipis/bootstrap-sweetalert">Bootstrap-sweetalert项目</a>。</p>
<pre><code><code>$(&quot;.btn-danger&quot;).on(&quot;click&quot;, function () {
  swal({
    title: &quot;你确定要删除吗？&quot;,
    text: &quot;删除可就找不回来了哦！&quot;,
    type: &quot;warning&quot;,
    showCancelButton: true,
    confirmButtonClass: &quot;btn-danger&quot;,
    confirmButtonText: &quot;删除&quot;,
    cancelButtonText: &quot;取消&quot;,
    closeOnConfirm: false
    },
    function () {
      var deleteId = $(this).parent().parent().attr(&quot;data_id&quot;);
      $.ajax({
        url: &quot;/delete_book/&quot;,
        type: &quot;post&quot;,
        data: {&quot;id&quot;: deleteId},
        success: function (data) {
          if (data.status === 1) {
            swal(&quot;删除成功!&quot;, &quot;你可以准备跑路了！&quot;, &quot;success&quot;);
          } else {
            swal(&quot;删除失败&quot;, &quot;你可以再尝试一下！&quot;, &quot;error&quot;)
          }
        }
      })
    });
})
</code></pre>
<p>　　项目中简单应用：</p>
<pre><code><code>{% load static %}
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;{% static &#39;bootstrap-3.3.0-dist/dist/css/bootstrap.min.css&#39; %}&quot;&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;{% static &#39;bootstrap-sweetalert-master/dist/sweetalert.css&#39; %}&quot;&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div&gt;
    &lt;button class=&quot;btn btn-danger&quot;&gt;删除&lt;/button&gt;
&lt;/div&gt;

&lt;/body&gt;
&lt;script src=&quot;{% static &#39;bootstrap-3.3.0-dist/dist/jQuery/jquery-3.1.1.js&#39; %}&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;{% static &#39;bootstrap-3.3.0-dist/dist/js/bootstrap.min.js&#39; %}&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;{% static &#39;bootstrap-sweetalert-master/dist/sweetalert.js&#39; %}&quot;&gt;&lt;/script&gt;
&lt;script&gt;

    $(&quot;.btn-danger&quot;).on(&quot;click&quot;, function () {
        swal({
                title: &quot;你确定要删除吗？&quot;,
                text: &quot;删除可就找不回来了哦！&quot;,
                type: &quot;warning&quot;,
                showCancelButton: true,
                confirmButtonClass: &quot;btn-danger&quot;,
                confirmButtonText: &quot;我已经下定决心&quot;,
                cancelButtonText: &quot;容我三思&quot;,
                closeOnConfirm: false
            },
            function () {
                var deleteId = $(this).parent().parent().attr(&quot;data_id&quot;);
                $.ajax({
                    url: &quot;/delete_book/&quot;,
                    type: &quot;post&quot;,
                    data: {&quot;id&quot;: deleteId},
                    success: function (data) {
                        console.log(data,typeof data);
                        if (data === &#39;1&#39;) {
                            swal(&quot;删除成功!&quot;, &quot;你可以准备跑路了！&quot;, &quot;success&quot;);
                        } else {
                            swal(&quot;删除失败&quot;, &quot;你可以再尝试一下！&quot;, &quot;error&quot;)
                        }
                    }
                })
            });
    })
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<p><a><img src="./images/Ajax17.png" alt="复制代码" /></a></p>
<p>urls.py</p>
<pre><code><code>url(r&#39;^delete_book/&#39;, views.delete_book,name=&#39;delete_book&#39;),
</code></pre>
<p>views.py</p>
<pre><code><code>def delete_book(request):

    import random
    ret = str(random.randint(1,2))
    return HttpResponse(ret)
</code></pre>
<h1 id="七-同源策略与jsonp">七 同源策略与Jsonp</h1>
<h2 id="同源策略">同源策略</h2>
<p>　　　　同源策略（Same origin policy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。</p>
<p>　　　　同源策略，它是由Netscape提出的一个著名的安全策略。现在所有支持JavaScript 的浏览器都会使用这个策略。所谓同源是指，域名，协议，端口相同。当一个浏览器的两个tab页中分别打开来 百度和谷歌的页面当浏览器的百度tab页执行一个脚本的时候会检查这个脚本是属于哪个页面的，即检查是否同源，只有和百度同源的脚本才会被执行。如果非同源，那么在请求数据时，浏览器会在控制台中报一个异常，提示拒绝访问。</p>
<h3 id="示例项目1">示例<strong>项目1:</strong>　　</h3>
<p>　　　　　　　　</p>
<pre><code><code>==================================http://127.0.0.1:8001项目的index
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;script src=&quot;http://code.jquery.com/jquery-latest.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;


&lt;button&gt;ajax&lt;/button&gt;
{% csrf_token %}

&lt;script&gt;
    $(&quot;button&quot;).click(function(){


        $.ajax({
            url:&quot;http://127.0.0.1:7766/SendAjax/&quot;,
            type:&quot;POST&quot;,
            data:{&quot;username&quot;:&quot;yuan&quot;,&quot;csrfmiddlewaretoken&quot;:$(&quot;[name=&#39;csrfmiddlewaretoken&#39;]&quot;).val()},
            success:function(data){
                alert(123);
                alert(data)
            }
        })
    })
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;


==================================http://127.0.0.1:8001项目的views

def index(request):


    return render(request,&quot;index.html&quot;)


def ajax(request):
    import json
    print(request.POST,&quot;+++++++++++&quot;)
    return HttpResponse(json.dumps(&quot;hello&quot;))
</code></pre>
<h3 id="示例项目2">示例<strong>项目2:</strong></h3>
<pre><code><code>==================================http://127.0.0.1:8002项目的index
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;script src=&quot;http://code.jquery.com/jquery-latest.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;


&lt;button&gt;sendAjax&lt;/button&gt;

{% csrf_token %}

&lt;script&gt;
    $(&quot;button&quot;).click(function(){


        $.ajax({
            url:&quot;/SendAjax/&quot;,
            type:&quot;POST&quot;,
            data:{&quot;username&quot;:&quot;yuan&quot;,&quot;csrfmiddlewaretoken&quot;:$(&quot;[name=&#39;csrfmiddlewaretoken&#39;]&quot;).val()},
            success:function(data){
                alert(data)
            }
        })
    })
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;


==================================http://127.0.0.1:8002项目的views

def index(request):

    return render(request,&quot;index.html&quot;)

from django.views.decorators.csrf import csrf_exempt

@csrf_exempt


def SendAjax(request):

    import json

    print(&quot;++++++++&quot;)

    return HttpResponse(json.dumps(&quot;hello2&quot;))
</code></pre>
<p>　　　　　　当点击项目1的按钮时，发送了请求，但是会发现报错如下：</p>
<pre><code><code>已拦截跨源请求：同源策略禁止读取位于 http://127.0.0.1:7766/SendAjax/ 的远程资源。（原因：CORS 头缺少 &#39;Access-Control-Allow-Origin&#39;）。
</code></pre>
<p>　　　　　　但是注意，项目2中的访问已经发生了，说明是浏览器对非同源请求返回的结果做了拦截。</p>
<h2 id="jsonp">Jsonp</h2>
<p>　　　　jsonp是json用来跨域的一个东西。原理是通过script标签的跨域特性来绕过同源策略。</p>
<p>　　　　思考：这算怎么回事？</p>
<pre><code><code>&lt;script src=&quot;http://code.jquery.com/jquery-latest.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>　　　　借助script标签，实现跨域请求，示例：</p>
<pre><code><code># =============================http://127.0.0.1:8001/index


&lt;button&gt;ajax&lt;/button&gt;
{% csrf_token %}

&lt;script&gt;
    function func(name){
        alert(name)
    }
&lt;/script&gt;

&lt;script src=&quot;http://127.0.0.1:7766/SendAjax/&quot;&gt;&lt;/script&gt;


# =============================http://127.0.0.1:8002/
from django.views.decorators.csrf import csrf_exempt

@csrf_exempt


def SendAjax(request):

    import json

    print(&quot;++++++++&quot;)
    # dic={&quot;k1&quot;:&quot;v1&quot;}
    return HttpResponse(&quot;func(&#39;yuan&#39;)&quot;)  # return HttpResponse(&quot;func(&#39;%s&#39;)&quot;%json.dumps(dic))
</code></pre>
<p>　　　　这其实就是JSONP的简单实现模式，或者说是JSONP的原型：创建一个回调函数，然后在远程服务上调用这个函数并且将JSON 数据形式作为参数传递，完成回调。</p>
<p>　　　　将JSON数据填充进回调函数，这就是JSONP的JSON+Padding的含义。</p>
<p>​ 　　一般情况下，我们希望这个script标签能够动态的调用，而不是像上面因为固定在html里面所以没等页面显示就执行了，很不灵活。我们可以通过javascript动态的创建script标签，这样我们就可以灵活调用远程服务了。</p>
<pre><code><code>&lt;button onclick=&quot;f()&quot;&gt;sendAjax&lt;/button&gt;

&lt;script&gt;
    function addScriptTag(src){
         var script = document.createElement(&#39;script&#39;);
         script.setAttribute(&quot;type&quot;,&quot;text/javascript&quot;);
         script.src = src;
         document.body.appendChild(script);
         document.body.removeChild(script);
    }


    function func(name){
        alert(&quot;hello&quot;+name)
    }

    function f(){
         addScriptTag(&quot;http://127.0.0.1:7766/SendAjax/&quot;)
    }
&lt;/script&gt;
</code></pre>
<p>　　　　为了更加灵活，现在将你自己在客户端定义的回调函数的函数名传送给服务端，服务端则会返回以你定义的回调函数名的方法，将获取的json数据传入这个方法完成回调：</p>
<p>　　　　将8001的f()改写为：</p>
<pre><code><code>function f(){
         addScriptTag(&quot;http://127.0.0.1:7766/SendAjax/?callbacks=func&quot;)
    }
</code></pre>
<p>　　　　8002的views改为：</p>
<pre><code><code>def SendAjax(request):
 
    import json
 
    dic={&quot;k1&quot;:&quot;v1&quot;}
 
    print(&quot;callbacks:&quot;,request.GET.get(&quot;callbacks&quot;))
    callbacks=request.GET.get(&quot;callbacks&quot;)
 
    return HttpResponse(&quot;%s(&#39;%s&#39;)&quot;%(callbacks,json.dumps(dic)))
</code></pre>
<h2 id="jquery对jsonp的实现">jQuery对JSONP的实现</h2>
<h3 id="getjson">getJSON</h3>
<p>　　　　　　jQuery框架也当然支持JSONP，可以使用$.getJSON(url,[data],[callback])方法</p>
<p>　　　　　　8001的html改为：</p>
<pre><code><code>&lt;button onclick=&quot;f()&quot;&gt;sendAjax&lt;/button&gt;

&lt;script&gt;

    function f(){
          $.getJSON(&quot;http://127.0.0.1:7766/SendAjax/?callbacks=?&quot;,function(arg){
            alert(&quot;hello&quot;+arg)
        });
    }
    
&lt;/script&gt;
</code></pre>
<p>　　　　　　8002的views不改动。</p>
<p>　　　　　　结果是一样的，要注意的是在url的后面必须添加一个callback参数，这样getJSON方法才会知道是用JSONP方式去访问服务，callback后面的那个问号是内部自动生成的一个回调函数名。</p>
<p>​ 　　　　此外，如果说我们想指定自己的回调函数名，或者说服务上规定了固定回调函数名该怎么办呢？我们可以使用$.ajax方法来实现</p>
<h3 id="ajax">$.ajax</h3>
<p>　　　　　　8001的html改为：</p>
<pre><code><code>&lt;script&gt;

    function f(){
          $.ajax({
                url:&quot;http://127.0.0.1:7766/SendAjax/&quot;,
                dataType:&quot;jsonp&quot;,
                jsonp: &#39;callbacks&#39;,
                jsonpCallback:&quot;SayHi&quot;
           });

       }

    function SayHi(arg){
                alert(arg);
            }

&lt;/script&gt;
</code></pre>
<p>　　　　　　8002的views不改动。</p>
<p>　　　　　　<strong>当然，最简单的形式还是通过回调函数来处理：</strong></p>
<pre><code><code>&lt;script&gt;

    function f(){

            $.ajax({
               url:&quot;http://127.0.0.1:7766/SendAjax/&quot;,
               dataType:&quot;jsonp&quot;,            //必须有，告诉server，这次访问要的是一个jsonp的结果。
               jsonp: &#39;callbacks&#39;,          //jQuery帮助随机生成的：callbacks=&quot;wner&quot;
               success:function(data){
                   alert(&quot;hi &quot;+data)
              }
         });

       }

&lt;/script&gt;
</code></pre>
<p>　　　　　　jsonp: 'callbacks'就是定义一个存放回调函数的键，jsonpCallback是前端定义好的回调函数方法名'SayHi'，server端接受callback键对应值后就可以在其中填充数据打包返回了;</p>
<p>　　　　　　jsonpCallback参数可以不定义，jquery会自动定义一个随机名发过去，那前端就得用回调函数来处理对应数据了。利用jQuery可以很方便的实现JSONP来进行跨域访问。　　</p>
<p>　　　　　　注意 JSONP一定是GET请求</p>
<h3 id="应用">应用</h3>
<pre><code><code>&lt;input type=&quot;button&quot; onclick=&quot;AjaxRequest()&quot; value=&quot;跨域Ajax&quot; /&gt;


&lt;div id=&quot;container&quot;&gt;&lt;/div&gt;


    &lt;script type=&quot;text/javascript&quot;&gt;
        function AjaxRequest() {
            $.ajax({
                url: &#39;http://www.jxntv.cn/data/jmd-jxtv2.html?callback=list&amp;_=1454376870403&#39;,
                type: &#39;GET&#39;,
                dataType: &#39;jsonp&#39;,
                jsonp: &#39;callback&#39;,
                jsonpCallback: &#39;list&#39;,
                success: function (data) {
                    
                    $.each(data.data,function(i){
                        var item = data.data[i];
                        var str = &quot;&lt;p&gt;&quot;+ item.week +&quot;&lt;/p&gt;&quot;;
                        $(&#39;#container&#39;).append(str);
                        $.each(item.list,function(j){
                            var temp = &quot;&lt;a href=&#39;&quot; + item.list[j].link +&quot;&#39;&gt;&quot; + item.list[j].name +&quot; &lt;/a&gt;&lt;br/&gt;&quot;;
                            $(&#39;#container&#39;).append(temp);
                        });
                        $(&#39;#container&#39;).append(&quot;&lt;hr/&gt;&quot;);
                    })

                }
            });
        }
&lt;/script&gt;
</code></pre>
<h1 id="八-cors">八 CORS</h1>
<p>　　</p>
<h2 id="一简介">一、简介</h2>
<p>　　　　CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。</p>
<p>　　　　整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。</p>
<p>　　　　因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</p>
<h2 id="二两种请求">二、两种请求</h2>
<p>　　　　浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。</p>
<p>　　　　只要同时满足以下两大条件，就属于简单请求。</p>
<pre><code><code>（1) 请求方法是以下三种方法之一：
HEAD
GET
POST
（2）HTTP的头信息不超出以下几种字段：
Accept
Accept-Language
Content-Language
Last-Event-ID
Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain
</code></pre>
<p>　　　　凡是不同时满足上面两个条件，就属于非简单请求。</p>
<p>　　　　浏览器对这两种请求的处理，是不一样的。</p>
<pre><code><code>* 简单请求和非简单请求的区别？

   简单请求：一次请求
   非简单请求：两次请求，在发送数据之前会先发一次请求用于做“预检”，只有“预检”通过后才再发送一次请求用于数据传输。
* 关于“预检”

- 请求方式：OPTIONS
- “预检”其实做检查，检查如果通过则允许传输数据，检查不通过则不再发送真正想要发送的消息
- 如何“预检”
     =&gt; 如果复杂请求是PUT等请求，则服务端需要设置允许某请求，否则“预检”不通过
        Access-Control-Request-Method
     =&gt; 如果复杂请求设置了请求头，则服务端需要设置允许某请求头，否则“预检”不通过
        Access-Control-Request-Headers
</code></pre>
<p>　　<strong>支持跨域，简单请求</strong></p>
<p>　　　　服务器设置响应头：Access-Control-Allow-Origin = '域名' 或 '*'</p>
<p>　　<strong>支持跨域，复杂请求</strong></p>
<p>　　　　由于复杂请求时，首先会发送“预检”请求，如果“预检”成功，则发送真实数据。</p>
<ul>
<li>“预检”请求时，允许请求方式则需服务器设置响应头：Access-Control-Request-Method</li>
<li>“预检”请求时，允许请求头则需服务器设置响应头：Access-Control-Request-Headers</li>
</ul>

</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>