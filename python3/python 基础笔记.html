<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修python 基础笔记' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>python 基础笔记</center></div><div class='banquan'>原文出处:本文由博客园博主feel_different提供。<br/>
原文连接:https://www.cnblogs.com/bind/p/11516938.html</div><br>
    <h1 align="left">一、继承</h1>
<div class="cnblogs_code">
<pre><code>'''
1、什么是继承
    继承是一种新建类的方式，新建的类称之为子类，被继承的类称之为基类、父类、超类
    继承描述的是一种&ldquo;遗传&rdquo;的关系:子类可以重用父类的属性

在python中的继承注意两点：
   1. 在python中支持一个子类同时继承多个父类，
   2. python中类分为两种：
            新式类：但凡继承object的类，以及该类的子类。。。都是新式类
                在python3中一个类如果没有继承人类类，默认继承object类，即python3中所有的类都是新式类

            经典类: 没有继承object的类，以及该类的子类。。。都是经典类
                在python2中才区分新式类与经典类

2、为何要用继承
     减少代码冗余</pre>
<pre><code>3、如何用继承

<span style="color: #0000ff;">class</span> Parent1(object):
    pass
<span style="color: #0000ff;">class</span> Parent2:
    pass
<span style="color: #0000ff;">class</span> Subclass1(Parent1,Parent2):
    pass
<span style="color: #0000ff;">print</span>(Subclass1.__bases__)


# 2、在继承的背景下，属性查找的优先级
      #当类是经典类时，多继承的情况下，在要查找的属性不存在时，会按照深度优先的方式查找下去
      #当类是新式类时，多继承的情况下，在要查找的属性不存在时，会按照广度优先的方式查找下去
</pre>
</div>
<p><span style="font-family: 宋体; font-size: small;">继承解决的是类与类之间的代码冗余问题，一定是一个类是另外一个类的子类,总结对象之间的相似之处得到类，总结类与类之间的相似之处就得到了类们的父类</span><span style="font-family: 宋体; font-size: small;"><br /></span></p>
<pre><code>多继承背景下属性查找的顺序：对象-》对象的类-》按照从左往右的顺序一个一个的分支找下去</pre>
<pre><code># 一旦出现菱形继承问题，新式类与经典类在属性查找上的区别是<br /># 新式类：广度优先查找，在最后一个分支查找顶级类<br /># 经典类：深度优先查找，在第一个分支就查找顶级类</pre>
<p><span style="font-size: small;"><br /></span><span style="font-family: 宋体; font-size: small;"># 在子类派生出的新方法中重用父类功能的方式一：<br /># 指名道姓地访问某一个类的函数<br /># 注意：<br /># 1. 该方式与继承是没有关系的<br /># 2. 访问是某一个类的函数，没有自动传值的效果</span></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('460be0f9-ab47-4608-9433-98b6ca4feef9')"><span style="font-family: 宋体; font-size: small;"><img id="code_img_closed_460be0f9-ab47-4608-9433-98b6ca4feef9" class="code_img_closed" src="./images/python 基础笔记0.png" alt="" /><img id="code_img_opened_460be0f9-ab47-4608-9433-98b6ca4feef9" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('460be0f9-ab47-4608-9433-98b6ca4feef9',event)" src="./images/python 基础笔记1.png" alt="" /> </span>
<div id="cnblogs_code_open_460be0f9-ab47-4608-9433-98b6ca4feef9" class="cnblogs_code_hide"><span style="font-family: 宋体;"><span style="font-size: small;"><span style="color: #0000ff;">class</span> OldboyPeople:
    school='Oldboy'

    <span style="color: #0000ff;">def</span> __init__(self, <span style="color: #0000ff;">name</span>, age, sex):
        self.<span style="color: #0000ff;">name</span> = <span style="color: #0000ff;">name</span>
        self.age = age
        self.sex = sex


<span style="color: #0000ff;">class</span> OldboyStudent(OldboyPeople):

    #           stu1,'李特丹',18,'female'
    <span style="color: #0000ff;">def</span> __init__(self,<span style="color: #0000ff;">name</span>,age,sex,num=0):
        OldboyPeople.__init__(self,<span style="color: #0000ff;">name</span>,age,sex) #OldboyPeople.__init__(stu1,李特丹',18,'female')

        self.score=num

    <span style="color: #0000ff;">def</span> choose_course(self):
        <span style="color: #0000ff;">print</span>('%s is choosing course' %self.<span style="color: #0000ff;">name</span>)



<span style="color: #0000ff;">class</span> OldboyTeacher(OldboyPeople):

    <span style="color: #0000ff;">def</span> __init__(self,<span style="color: #0000ff;">name</span>,age,sex,level):
        OldboyPeople.__init__(self,<span style="color: #0000ff;">name</span>,age,sex)

        self.level=level

    <span style="color: #0000ff;">def</span> score(self,stu,num):
        stu.score=num


stu1=OldboyStudent('李特丹',18,'female') #OldboyStudent.__init__(stu1,'李特丹',18,'female')
<span style="color: #0000ff;">print</span>(stu1.__dict__)

tea1=OldboyTeacher('egon',18,'male',10) ##OldboyTeacher.__init__(tea1,'egon',18,'male',10)
<span style="color: #0000ff;">print</span>(tea1.__dict__)
</span></span></div>

<span style="font-family: 宋体;"><span style="font-size: small;"> <span class="cnblogs_code_collapse">code</span></span></span></div>
<p><span style="font-family: 宋体; font-size: small;">在子类派生出的新方法中重用父类功能的方式二：只能在子类中用<br />在python2：super(自己的类名,对象自己)<br />在python3：super()<br />调用super()会得到一个特殊的对象，该特殊的对象是专门用来引用父类中的属性的，!!!完全参照mro列表!!!<br />注意：<br /># 1. 该方式与继承严格依赖于继承的mro列表<br /># 2. 访问是绑定方法，有自动传值的效果</span></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('77fa1c61-fee8-4aa0-b240-a21bd61fadcb')"><img id="code_img_closed_77fa1c61-fee8-4aa0-b240-a21bd61fadcb" class="code_img_closed" src="./images/python 基础笔记0.png" alt="" /><img id="code_img_opened_77fa1c61-fee8-4aa0-b240-a21bd61fadcb" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('77fa1c61-fee8-4aa0-b240-a21bd61fadcb',event)" src="./images/python 基础笔记1.png" alt="" />
<div id="cnblogs_code_open_77fa1c61-fee8-4aa0-b240-a21bd61fadcb" class="cnblogs_code_hide">
<pre><code><span style="color: #0000ff;">class</span> OldboyPeople:
    school='Oldboy'

    <span style="color: #0000ff;">def</span> __init__(self, <span style="color: #0000ff;">name</span>, age, sex):
        self.<span style="color: #0000ff;">name</span> = <span style="color: #0000ff;">name</span>
        self.age = age
        self.sex = sex


<span style="color: #0000ff;">class</span> OldboyStudent(OldboyPeople):


    <span style="color: #0000ff;">def</span> __init__(self,<span style="color: #0000ff;">name</span>,age,sex,num=0):
        # OldboyPeople.__init__(self,<span style="color: #0000ff;">name</span>,age,sex) #OldboyPeople.__init__(stu1,李特丹',18,'female')
        super(OldboyStudent,self).__init__(<span style="color: #0000ff;">name</span>,age,sex)

        self.score=num

    <span style="color: #0000ff;">def</span> choose_course(self):
        <span style="color: #0000ff;">print</span>('%s is choosing course' %self.<span style="color: #0000ff;">name</span>)



<span style="color: #0000ff;">class</span> OldboyTeacher(OldboyPeople):

    <span style="color: #0000ff;">def</span> __init__(self,<span style="color: #0000ff;">name</span>,age,sex,level):
        super().__init__(<span style="color: #0000ff;">name</span>,age,sex)

        self.level=level

    <span style="color: #0000ff;">def</span> score(self,stu,num):
        stu.score=num

#例子
<span style="color: #0000ff;">class</span> A:
    <span style="color: #0000ff;">def</span> test(self):
        <span style="color: #0000ff;">print</span>('A.test()')
        super().test()

<span style="color: #0000ff;">class</span> B:
    <span style="color: #0000ff;">def</span> test(self):
        <span style="color: #0000ff;">print</span>('from B')

<span style="color: #0000ff;">class</span> C(A,B):
    pass

obj=C()
<span style="color: #0000ff;">print</span>(C.mro())
#[&lt;<span style="color: #0000ff;">class</span> '<span style="color: #0000ff;">__main__</span>.C'&gt;, &lt;<span style="color: #0000ff;">class</span> '<span style="color: #0000ff;">__main__</span>.A'&gt;, &lt;<span style="color: #0000ff;">class</span> '<span style="color: #0000ff;">__main__</span>.B'&gt;, &lt;<span style="color: #0000ff;">class</span> 'object'&gt;]
obj.test()
'''
A.test()
from B
'''
</pre>
</div>
<span class="cnblogs_code_collapse">code</span></div>
<pre><code></pre>
<p>类的继承有两层意义：</p>
<p>1.改变&nbsp;&nbsp;&nbsp;&nbsp; 2.扩展</p>
<p><span style="font-family: 宋体; font-size: small;"> 组合指的是一个对象拥有某一个属性，该属性的值是另外一个类的对象</span><span style="font-family: 宋体; font-size: small;"> 利用组合可以减少类与类之间代码冗余</span></p>
<p>&nbsp;</p>
<h1 align="left"><strong>二、多态</strong></h1>
<p><span style="font-family: 宋体; font-size: small;">1 多态<br />    多态指的是同一种事物的多种形态<br />2 多态性:<br />    可以在不用考虑对象具体类型的情况下而直接使用对象<br />优点:归一化,简化对象的使用</span></p>
<p><span style="font-family: 宋体; font-size: small;">&nbsp; 多态就是类的这两层意义的一个具体的实现机制,即，调用不同的类实例化得对象下的相同的方法，实现的过程不一样</span></p>
<p><span style="font-family: 宋体; font-size: small;">&nbsp;&nbsp; python中的标准类型就是多态概念的一个很好的示范</span></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('d407fd9f-95ae-4015-a48f-0cbad26495b4')"><img id="code_img_closed_d407fd9f-95ae-4015-a48f-0cbad26495b4" class="code_img_closed" src="./images/python 基础笔记0.png" alt="" /><img id="code_img_opened_d407fd9f-95ae-4015-a48f-0cbad26495b4" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('d407fd9f-95ae-4015-a48f-0cbad26495b4',event)" src="./images/python 基础笔记1.png" alt="" />
<div id="cnblogs_code_open_d407fd9f-95ae-4015-a48f-0cbad26495b4" class="cnblogs_code_hide">
<pre><code><span style="color: #0000ff;">import</span> abc
<span style="color: #0000ff;">class</span> Animal(metaclass=abc.ABCMeta):
    @abc.abstractmethod
    <span style="color: #0000ff;">def</span> speak(self):
        pass
    @abc.abstractmethod
    <span style="color: #0000ff;">def</span> run(self):
        pass
# 抽象基类:是用来指定规范,但凡继承该类的子都必须实现speak和run,而名字必须叫speak和run
# 注意:不能实例化抽象基类
Animal()

<span style="color: #0000ff;">class</span> People(Animal):
    <span style="color: #0000ff;">def</span> speak(self):
        <span style="color: #0000ff;">print</span>('say hello')
    <span style="color: #0000ff;">def</span> run(self):
        pass
<span style="color: #0000ff;">class</span> Dog(Animal):
    <span style="color: #0000ff;">def</span> speak(self):
        <span style="color: #0000ff;">print</span>('汪汪汪')
    <span style="color: #0000ff;">def</span> run(self):
        pass
<span style="color: #0000ff;">class</span> Pig(Animal):
    <span style="color: #0000ff;">def</span> speak(self):
        <span style="color: #0000ff;">print</span>('哼哼哼哼哼')
    <span style="color: #0000ff;">def</span> run(self):
        pass
obj1=People()
obj2=Dog()
obj3=Pig()
# obj1,obj2,obj3都是动物
obj1.speak()
obj2.speak()
obj3.speak()
<span style="color: #0000ff;">def</span> speak(animal):
    animal.speak()
speak(obj1)
speak(obj2)
speak(obj3)
obj1=[1,2,3]
obj2='hello'
obj3={'x':1}
<span style="color: #0000ff;">print</span>(obj1.__len__())
<span style="color: #0000ff;">print</span>(obj2.__len__())
<span style="color: #0000ff;">print</span>(obj3.__len__())
<span style="color: #0000ff;">print</span>(len(obj1))
<span style="color: #0000ff;">print</span>(len(obj2))
<span style="color: #0000ff;">print</span>(len(obj3))
</pre>
</div>
<span class="cnblogs_code_collapse">code</span></div>
<h1 align="left">三、封装</h1>
<p><span style="font-family: 宋体; font-size: small;">1 什么是封装<br />    装就是将数据属性或者函数属性存放到一个名称空间里<br />    封指的是隐藏,该隐藏是为了明确地区分内外,即该隐藏是对外不对内(在类外部无法直接访问隐藏的属性,而在类内部是可以访问)<br />2 为何要封装<br />    1. 封数据属性:???<br />    2. 封函数属性:???<br />3 如何封装???<br />    在类内定义的属性前加__开头</span></p>
<p><span style="font-family: 宋体; font-size: small;">第一个层面的封装：类就是麻袋，这本身就是一种封装</span></p>
<p><span style="font-family: 宋体; font-size: small;">第二个层面的封装：类中定义私有的，只在类的内部使用，外部无法访问</span></p>
<p><span style="font-family: 宋体; font-size: small;">第三个层面的封装：明确区分内外，内部的实现逻辑，外部无法知晓，并且为封装到内部的逻辑提供一个访问接口给外部使用（这才是真正的封装）</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span> People:
    __country='China' #_People__country='China'
    __n=111           #_People__n=111

    <span style="color: #0000ff;">def</span> __init__(self,<span style="color: #0000ff;">name</span>):
        self.__name=<span style="color: #0000ff;">name</span> #self._People__name=<span style="color: #0000ff;">name</span>

    <span style="color: #0000ff;">def</span> run(self):
        <span style="color: #0000ff;">print</span>('%s is running' %self.__name) #self._People__name

<span style="color: #0000ff;">print</span>(People.__country)

obj=People('egon')
<span style="color: #0000ff;">print</span>(obj.__name)
<span style="color: #0000ff;">print</span>(obj.run)
obj.run()

<span style="color: #0000ff;">print</span>(People.__dict__)
<span style="color: #0000ff;">print</span>(People._People__country)
<span style="color: #0000ff;">print</span>(obj.__dict__)
<span style="color: #0000ff;">print</span>(obj._People__name)</pre>
</div>
<p><span style="font-family: 宋体; font-size: small;">需要注意的问题:<br />1. 这种隐藏只是一种语法上的变形,并没有真的限制访问<br />2. 这种变形只在类定义阶段检测语法时变形一次,类定义阶段之后新增的__开头的属性不会发生变形</span><span style="font-family: 宋体; font-size: small;">3. 在继承中，父类如果不想让子类覆盖自己的方法，可以在该方法前加__开头</span><span style="font-family: 宋体; font-size: small;">封装的真实意图:</span><span style="font-family: 宋体; font-size: small;">把数据属性或函数属性装起来就是为了以后使用的,封起来即藏起来是为不让外部直接使用<br />    1.封数据属性:把数据属性藏起来,是为了不让外部直接操作隐藏的属性,而通过类内开辟的接口来间接地操作属性,我们可以在接口之上附加任意的控制逻辑来严格控制使用者对属性的操作</span><span style="font-family: 宋体; font-size: small;">    2. 封函数属性: 隔离复杂度</span></p>
<h1 align="left">四、类方法与装饰器</h1>
<pre><code> 类中定义的函数有两大类(3小种)用途,一类是绑定方法,另外一类是非绑定方法<br /><br /># 1. 绑定方法:<br /># 特点:绑定给谁就应该由谁来调用,谁来调用就会将谁当作第一个参数自动传入<br /># 1.1 绑定给对象的:类中定义的函数默认就是绑定对象的<br /># 1.2 绑定给类的:在类中定义的函数上加一个装饰器classmethod<br /><br /><br /># 2. 非绑定方法<br /># 特点: 既不与类绑定也不与对象绑定,意味着对象或者类都可以调用,但无论谁来调用都是一个普通函数,根本没有自动传值一说</pre>
<div class="cnblogs_code">
<pre><code>class Foo:
    def func1(self):
        print('绑定给对象的方法',self)

    @classmethod
    def func2(cls):
        print('绑定给类的方法: ',cls)

    @staticmethod
    def func3():
        print('普通函数')

obj=Foo()
obj.func1()
print(obj)

Foo.func2()

# 绑定方法
print(obj.func1)
print(Foo.func2)

# 非绑定方法
print(obj.func3)
print(Foo.func3)</pre>
</div>
<h2><strong>一 什么是装饰器?</strong></h2>
<p>器即函数,装饰即修饰，意指为其他函数添加新功能</p>
<p>装饰器定义：本质就是函数，功能是为其他函数添加新功能</p>
<pre><code>property装饰器就是将一个函数属性伪装成一个数据属性</pre>
<p>1.不修改被装饰函数的源代码（开放封闭原则）</p>
<p>2.为被装饰函数添加新功能后，不修改被修饰函数的调用方式</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('f549c83b-6d35-4280-b475-ad28b045a6a4')"><img id="code_img_closed_f549c83b-6d35-4280-b475-ad28b045a6a4" class="code_img_closed" src="./images/python 基础笔记0.png" alt="" /><img id="code_img_opened_f549c83b-6d35-4280-b475-ad28b045a6a4" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('f549c83b-6d35-4280-b475-ad28b045a6a4',event)" src="./images/python 基础笔记1.png" alt="" />
<div id="cnblogs_code_open_f549c83b-6d35-4280-b475-ad28b045a6a4" class="cnblogs_code_hide">
<pre><code>user_list=[
    {'name':'alex','passwd':'123'},
    {'name':'linhaifeng','passwd':'123'},
    {'name':'wupeiqi','passwd':'123'},
    {'name':'yuanhao','passwd':'123'},
]

current_user={'username':None,'login':False}
def auth(auth_type='file'):
    def auth_deco(func):
        def wrapper(*args,**kwargs):
            if auth_type == 'file':
                if current_user['username'] and current_user['login']:
                    res=func(*args,**kwargs)
                    return res
                username=input('用户名: ').strip()
                passwd=input('密码: ').strip()

                for index,user_dic in enumerate(user_list):
                    if username == user_dic['name'] and passwd == user_dic['passwd']:
                        current_user['username']=username
                        current_user['login']=True
                        res=func(*args,**kwargs)
                        return res
                else:
                    print('用户名或者密码错误,重新登录')
            elif auth_type == 'ldap':
                print('巴拉巴拉小魔仙')
                res=func(*args,**kwargs)
                return res
        return wrapper
    return auth_deco


#auth(auth_type='file')就是在运行一个函数,然后返回auth_deco,所以@auth(auth_type='file')
#就相当于@auth_deco,只不过现在,我们的auth_deco作为一个闭包的应用,外层的包auth给它留了一个auth_type='file'参数
@auth(auth_type='ldap')
def index():
    print('欢迎来到主页面')

@auth(auth_type='ldap')
def home():
    print('这里是你家')

def shopping_car():
    print('查看购物车啊亲')

def order():
    print('查看订单啊亲')

# print(user_list)
index()
# print(user_list)
home()

# 带参装饰器</pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<div class="cnblogs_code" onclick="cnblogs_code_show('0d36ec6a-a7a8-4e3b-8506-1183e83f9a4a')"><img id="code_img_closed_0d36ec6a-a7a8-4e3b-8506-1183e83f9a4a" class="code_img_closed" src="./images/python 基础笔记0.png" alt="" /><img id="code_img_opened_0d36ec6a-a7a8-4e3b-8506-1183e83f9a4a" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('0d36ec6a-a7a8-4e3b-8506-1183e83f9a4a',event)" src="./images/python 基础笔记1.png" alt="" />
<div id="cnblogs_code_open_0d36ec6a-a7a8-4e3b-8506-1183e83f9a4a" class="cnblogs_code_hide">
<pre><code>def deco(func):
    print('---')
    func.x=1
    func.y=2
    func.z=3
    return func

#一切皆对象
@deco    #test=deco(test)
def test():
    print('test_func_run')
test.x=1
print(test.__dict__)

@deco  #Foo=deco(Foo)
class Foo:
    pass

f1=Foo()
print(f1.__dict__)
print(Foo.__dict__)
print(f1.x)</pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<div class="cnblogs_code" onclick="cnblogs_code_show('d3476fd5-17d1-45ac-bd35-6c69bed3c798')"><img id="code_img_closed_d3476fd5-17d1-45ac-bd35-6c69bed3c798" class="code_img_closed" src="./images/python 基础笔记0.png" alt="" /><img id="code_img_opened_d3476fd5-17d1-45ac-bd35-6c69bed3c798" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('d3476fd5-17d1-45ac-bd35-6c69bed3c798',event)" src="./images/python 基础笔记1.png" alt="" />
<div id="cnblogs_code_open_d3476fd5-17d1-45ac-bd35-6c69bed3c798" class="cnblogs_code_hide">
<pre><code>def Typed(**kwargs):
    def deco(obj):
        # print('+++++',kwargs)
        # print('obj_name',obj)
        for key,val in kwargs.items():
            # obj.__dict__[key]=[val]
            # obj.key=val
            setattr(obj,key,val)
        return obj
    # print('---',kwargs)
    return deco

@Typed(x=1,y=2,z=3)   #Typed(x=1,y=2,x=3)---&gt; @deco ----&gt;Foo=deco(Foo)
class Foo:
    pass
print(Foo.__dict__)

# @deco
@Typed(name='egon')
class Bar:
    pass
print(Bar.name)</pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>装饰器=高阶函数+函数嵌套+闭包</p>
<div class="cnblogs_code">
<pre><code>@timer  #@timer就等同于cal=timer(cal)
def cal(array):
    res=0
    for i in array:
        res+=i
    return res

cal(range(10))</pre>
</div>
<div class="cnblogs_code">
<pre><code>'''
闭包:在一个作用域里放入定义变量,相当于打了一个包
'''
def father(name):
    def son():
        # name='alex'
        print('我爸爸是 [%s]' %name)
        def grandson():
            # name='wupeiqi'
            print('我爷爷是 [%s]' %name)
        grandson()
    son()

father('XXX')</pre>
</div>
<div class="cnblogs_code" onclick="cnblogs_code_show('b779470e-9f14-49b0-9e12-35de43285740')"><img id="code_img_closed_b779470e-9f14-49b0-9e12-35de43285740" class="code_img_closed" src="./images/python 基础笔记0.png" alt="" /><img id="code_img_opened_b779470e-9f14-49b0-9e12-35de43285740" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('b779470e-9f14-49b0-9e12-35de43285740',event)" src="./images/python 基础笔记1.png" alt="" />
<div id="cnblogs_code_open_b779470e-9f14-49b0-9e12-35de43285740" class="cnblogs_code_hide">
<pre><code>class Room:
    tag="mmp"
    def __init__(self,name,owner,width,length,heigh):
        self.name=name
        self.owner=owner
        self.width=width
        self.length=length
        self.heigh=heigh

    @property
    def cal_area(self):
        # print('%s 住的 %s 总面积是%s' %(self.owner,self.name,self.width*self.length))
        return self.width*self.length
    @property
    def cal_tiji(self):
        return self.length*self.width*self.heigh


    def test(cls):
        print('from test',self.name)

    @classmethod  # 专门供类使用的方法
    def tell_info(cls):
        print(cls)
        print('-----&gt;',cls.tag)


r1=Room('厕所','av',100,100,10000)
r2=Room('公共厕所','abc',10,10,10)

Room.tell_info()  #有特殊意义，类在调用自己函数属性是跟实例绑定在一起


print(Room.tag)
# print('%s 住的 %s 总面积是%s' %(r1.owner,r1.name,r1.width*r1.length))

print(r1.cal_area)
print(r2.cal_area)
print(r1.cal_tiji)
print(r1.name)
print(r2.name)</pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<div class="cnblogs_code" onclick="cnblogs_code_show('838a2e30-ffb0-43ff-9f7f-eed860093d53')"><img id="code_img_closed_838a2e30-ffb0-43ff-9f7f-eed860093d53" class="code_img_closed" src="./images/python 基础笔记0.png" alt="" /><img id="code_img_opened_838a2e30-ffb0-43ff-9f7f-eed860093d53" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('838a2e30-ffb0-43ff-9f7f-eed860093d53',event)" src="./images/python 基础笔记1.png" alt="" />
<div id="cnblogs_code_open_838a2e30-ffb0-43ff-9f7f-eed860093d53" class="cnblogs_code_hide">
<pre><code>class Room:
    tag="mmp"
    def __init__(self,name,owner,width,length,heigh):
        self.name=name
        self.owner=owner
        self.width=width
        self.length=length
        self.heigh=heigh

    @property  #属性方法
    def cal_area(self):
        # print('%s 住的 %s 总面积是%s' %(self.owner,self.name,self.width*self.length))
        return self.width*self.length
    @property
    def cal_tiji(self):
        return self.length*self.width*self.heigh


    @classmethod  # 类方法，专门供类使用的方法
    def tell_info(cls,x):
        print(cls)
        print('-----&gt;',cls.tag,x)

    # def test(x,y):
    #     print(x,y)


    @staticmethod   #静态方法，类的从工具包
    def wash_body(a,b,c):
        print('%s %s %s 洗澡',(a,b,c))

Room.wash_body('alex','yuanhao','wupenqi')


r1=Room('厕所','alex',100,100,10000)
</pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<h1 align="left">五、属性方法</h1>
<div class="cnblogs_code" onclick="cnblogs_code_show('7050b016-4519-4c04-90b4-e12a65745cf2')"><img id="code_img_closed_7050b016-4519-4c04-90b4-e12a65745cf2" class="code_img_closed" src="./images/python 基础笔记0.png" alt="" /><img id="code_img_opened_7050b016-4519-4c04-90b4-e12a65745cf2" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('7050b016-4519-4c04-90b4-e12a65745cf2',event)" src="./images/python 基础笔记1.png" alt="" />
<div id="cnblogs_code_open_7050b016-4519-4c04-90b4-e12a65745cf2" class="cnblogs_code_hide">
<pre><code>class List(list):
    def append(self, object):
        if type(object)  is str:
            # self.append(object)
            # list.append(self,object)
            super().append(object)
        else:
            print('只能添加字符串')
    def show_midlle(self):
        mid_index=int(len(self)/2)
        return  self[mid_index]

l1=List('helloworld')
l1.append('SB')
print(l1)</pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<div class="cnblogs_code" onclick="cnblogs_code_show('5a4975de-82f3-47bc-a646-2b37e95dbb9c')"><img id="code_img_closed_5a4975de-82f3-47bc-a646-2b37e95dbb9c" class="code_img_closed" src="./images/python 基础笔记0.png" alt="" /><img id="code_img_opened_5a4975de-82f3-47bc-a646-2b37e95dbb9c" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('5a4975de-82f3-47bc-a646-2b37e95dbb9c',event)" src="./images/python 基础笔记1.png" alt="" />
<div id="cnblogs_code_open_5a4975de-82f3-47bc-a646-2b37e95dbb9c" class="cnblogs_code_hide">
<pre><code>class Chinese:
    country='China'
    def __init__(self,name):
        self.name=name

    def play_ball(self,ball):
        print('%s 打 %s' %(self.name,ball))

p1=Chinese('alex')
print(p1.__dict__)

#查看
print(p1.name)
p1.play_ball('篮球')

#增加

p1.age=18
print(p1.__dict__)
print(p1.age)

def test(self):
    print('实例函数属性')
p1.test=test
print(p1.__dict__)
p1.test(p1)

# #不要修改底层的属性字典
# p1.__dict__['sex']='male'
# print(p1.__dict__)
# print(p1.sex)

#修改
p1.age=19
print(p1.__dict__)
print(p1.age)

#删除
del p1.age
print(p1.__dict__)</pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<div class="cnblogs_code" onclick="cnblogs_code_show('7314ebde-4225-4704-bf4d-98642a40309a')"><img id="code_img_closed_7314ebde-4225-4704-bf4d-98642a40309a" class="code_img_closed" src="./images/python 基础笔记0.png" alt="" /><img id="code_img_opened_7314ebde-4225-4704-bf4d-98642a40309a" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('7314ebde-4225-4704-bf4d-98642a40309a',event)" src="./images/python 基础笔记1.png" alt="" />
<div id="cnblogs_code_open_7314ebde-4225-4704-bf4d-98642a40309a" class="cnblogs_code_hide">
<pre><code>class Chinese:
    contry='China'
    dang='gongchandang'
    def __init__(self,name):
        self.name=name

    def play_ball(self,ball):
        print('%s 正在打 %s'%(self,name))
#查看
print(Chinese.contry)

#修改
Chinese.contry='japan'
print(Chinese.contry)
p1=Chinese('alex')
print(p1.__dict__)
print(p1.contry)

#删除
del Chinese.dang
del Chinese.contry
print(Chinese.__dict__)

#增加
def eat_food(self,food):
    Chinese.eat=eat_food()
    print(Chinese.__dict__)

    p1.eat('aaa')</pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<pre><code>内置方法：</pre>
<div class="cnblogs_code">
<pre><code>__str__：在对象被打印时自动触发，然后将该绑定方法的返回值(必须是字符串类型)当做本次打印的结果
class People:
    def __init__(self,name,age):
        self.name=name
        self.age=age

    def __str__(self):
        return '<span style="color: #0000ff;">&lt;</span><span style="color: #c71585;">name</span>:%s age:%s<span style="color: #0000ff;">&gt;</span>' %(self.name,self.age)

obj1=People('egon',18)
obj2=People('lxx',38)

print(obj1) #print(obj1.__str__())
print(obj2) #print(obj2.__str__())

__del__：在对象被删除前自动触发, 在该方法内应该执行与该对象有关的系统资源的回收操作
class Foo:
    def __init__(self,filename,encoding='utf-8'):
        self.f=open(filename,'r',encoding=encoding)

    def __del__(self):
        # print('run.....')
        self.f.close()

obj=Foo()
del obj #obj.__del__()

#obj.__del__()

</pre>
</div>
<pre><code></pre>
<h1 align="left">六、高阶函数、迭代器、生成器</h1>
<pre><code>高阶函数定义<br />1、函数接收的参数是一个函数名<br />2、函数的返回值是一个函数名<br />3、满足上述条件任意一个，都可称为高阶函数</pre>
<pre><code></pre>
<div class="cnblogs_code">
<pre><code>import  time
def Foo():
    print('------')

def test(func):
    print(func)
    start_time=time.time()
    func()
    stop_time=time.time()
    print('func_runtime %s' %(stop_time-start_time))

Foo()
test(Foo)  #修改函数调用方式</pre>
</div>
<div class="cnblogs_code">
<pre><code>def run():
    print('from_run')

run()

def test():
    yield 1 #暂停，入口
    print('from_run')
    yield 2
    print('from_run')

t=test() 产生生成器对象
#唤醒迭代器
t.__next__()
next(t)  # yield10
t.send('123')<br /><br /><br /><span class="hl-reserved">def<span class="hl-code"> <span class="hl-identifier">fab<span class="hl-brackets">(<span class="hl-identifier">max<span class="hl-brackets">)<span class="hl-code">: <br /><span class="hl-identifier">　　n<span class="hl-code">, <span class="hl-identifier">a<span class="hl-code">, <span class="hl-identifier">b<span class="hl-code"> = <span class="hl-number">0<span class="hl-code">, <span class="hl-number">0<span class="hl-code">, <span class="hl-number">1<span class="hl-code"> <br /><span class="hl-reserved">while<span class="hl-code"> <span class="hl-identifier">n<span class="hl-code"> &lt; <span class="hl-identifier">max<span class="hl-code">: <br /><span class="hl-reserved">　　yield<span class="hl-code"> <span class="hl-identifier">b<span class="hl-code"> <br /><span class="hl-comment">　　# 使用 yield<span class="hl-code"> <br /><span class="hl-comment">　　# print b <span class="hl-code"> <br /><span class="hl-identifier">　　a<span class="hl-code">, <span class="hl-identifier">b<span class="hl-code"> = <span class="hl-identifier">b<span class="hl-code">, <span class="hl-identifier">a<span class="hl-code"> + <span class="hl-identifier">b<br /><span class="hl-code"> 　　<span class="hl-identifier">n<span class="hl-code"> = <span class="hl-identifier">n<span class="hl-code"> + <span class="hl-number">1<span class="hl-code"> <br /><span class="hl-reserved">for<span class="hl-code"> <span class="hl-identifier">n<span class="hl-code"> <span class="hl-reserved">in<span class="hl-code"> <span class="hl-identifier">fab<span class="hl-brackets">(<span class="hl-number">5<span class="hl-brackets">)<span class="hl-code">: <br />　　　　<span class="hl-reserved">print<span class="hl-code"> <span class="hl-identifier">n</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><br />yield 的作用就是把一个函数变成一个 generator，带有 yield 的函数不再是一个普通函数，<br />Python 解释器会将其视为一个 generator，调用 fab(5) 不会执行 fab 函数，而是返回一个 iterable 对象！<br />在 for 循环执行时，每次循环都会执行 fab 函数内部的代码，执行到 yield b 时，fab 函数就返回一个迭代值，<br />下次迭代时，代码从 yield b 的下一条语句继续执行，而函数的本地变量看起来和上次中断执行前是完全一样的，<br />于是函数继续执行，直到再次遇到 yield。</pre>
</div>
<div class="cnblogs_code">
<pre><code>age=10
res=True if age&gt;10 else False
# if 形式三元表达式
l=['a' for i in range(10)]  #列表解析
g_l=('a' for i in range(10)) #生成器表达式
print(l)
def test():
    for i in range(4):
        yield 1

t=test()</pre>
</div>
<div class="cnblogs_code" onclick="cnblogs_code_show('551fd546-284a-40fc-bad5-87b451466962')"><img id="code_img_closed_551fd546-284a-40fc-bad5-87b451466962" class="code_img_closed" src="./images/python 基础笔记0.png" alt="" /><img id="code_img_opened_551fd546-284a-40fc-bad5-87b451466962" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('551fd546-284a-40fc-bad5-87b451466962',event)" src="./images/python 基础笔记1.png" alt="" />
<div id="cnblogs_code_open_551fd546-284a-40fc-bad5-87b451466962" class="cnblogs_code_hide">
<pre><code>class Foo:
    def __init__(self,n):
        self.n=n
    def __iter__(self):
        return self
    def __next__(self):
        if self.n&gt;=100:
            raise StopIteration
        self.n+=1
        return self.n
# l = list('hello')
# for i in l:
    # print(i)


f1 = Foo(10)
for i in f1: #f1.__iter__()-----------&gt;iter(f1)
    print(i)</pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<h1 align="left">七、反射</h1>
<p><strong>反射是指程序可以访问、检测和修改它本身状态或行为的一种能力（自省）。</strong></p>
<p>isinstance(obj,cls)检查是否obj是否是类 cls 的对象</p>
<p><strong>issubclass(sub, super)检查sub类是否是 super 类的派生类</strong></p>
<p>&nbsp;</p>
<p><strong>python面向对象中的反射：通过字符串的形式操作对象相关的属性。python中的一切事物都是对象（都可以使用反射）</strong></p>
<p>四个可以实现自省的函数</p>
<div class="cnblogs_code">
<pre><code>hasattr(object,<span style="color: #0000ff;">name</span>)
判断object中有没有一个name字符串对应的方法或属性

getattr(object,<span style="color: #0000ff;">name</span>,default=None)
从对象中获取命名属性;getattr(x， 'y')等价于x.y。
当给出一个默认参数时，当属性没有给出时，返回该参数
不存在，在这种情况下就会引发异常。

setattr(x,y,v)
将给定对象上的命名属性设置为指定值。
setattr(x， 'y'， v)等于' x.y = v

delattr(x,y)
从给定对象中删除命名属性。
delattr(x， 'y')等价于' del x.y'</pre>
</div>
<p>&nbsp;</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('47883214-c3ef-42e2-b7c2-a2e6e00fbe46')"><img id="code_img_closed_47883214-c3ef-42e2-b7c2-a2e6e00fbe46" class="code_img_closed" src="./images/python 基础笔记0.png" alt="" /><img id="code_img_opened_47883214-c3ef-42e2-b7c2-a2e6e00fbe46" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('47883214-c3ef-42e2-b7c2-a2e6e00fbe46',event)" src="./images/python 基础笔记1.png" alt="" />
<div id="cnblogs_code_open_47883214-c3ef-42e2-b7c2-a2e6e00fbe46" class="cnblogs_code_hide">
<pre><code><span style="color: #0000ff;">class</span> Foo:
     pass

<span style="color: #0000ff;">class</span> Bar(Foo):
    pass

obj=Bar()

 <span style="color: #0000ff;">print</span>(isinstance(obj,Bar))
<span style="color: #0000ff;">print</span>(isinstance([],list))

<span style="color: #0000ff;">print</span>(issubclass(Bar,Foo))



# 反射:指的是通过字符串来操作属性
<span style="color: #0000ff;">class</span> Foo:
    <span style="color: #0000ff;">def</span> __init__(self,<span style="color: #0000ff;">name</span>):
        self.<span style="color: #0000ff;">name</span>=<span style="color: #0000ff;">name</span>


obj=Foo('eg')


# hasattr()
# <span style="color: #0000ff;">print</span>(hasattr(obj,'<span style="color: #0000ff;">name</span>')) #'<span style="color: #0000ff;">name</span>' in obj.__dict__

# getattr()
# <span style="color: #0000ff;">print</span>(getattr(obj,'<span style="color: #0000ff;">name</span>')) #obj.__dict__['<span style="color: #0000ff;">name</span>']
# <span style="color: #0000ff;">print</span>(getattr(obj,'age')) #obj.__dict__['age']
# <span style="color: #0000ff;">print</span>(getattr(obj,'age',None)) #obj.__dict__['age']

# setattr()
# setattr(obj,'age',18) #obj.age=18
# setattr(obj,'<span style="color: #0000ff;">name</span>','EG') #obj.<span style="color: #0000ff;">name</span>='EG'
# <span style="color: #0000ff;">print</span>(obj.__dict__)

# delattr()
# delattr(obj,'<span style="color: #0000ff;">name</span>')# del obj.<span style="color: #0000ff;">name</span>
# <span style="color: #0000ff;">print</span>(obj.__dict__)</pre>
</div>
<span class="cnblogs_code_collapse">code</span></div>
<p>导入其他模块，利用反射查找该模块是否存在某个方法</p>
<p>&nbsp;</p>
<p><strong>反射的好处</strong></p>
<p>好处一：</p>
<p>实现可插拔机制,可以事先定义好接口，接口只有在被完成后才会真正执行，这实现了即插即用，这其实是一种&lsquo;后期绑定&rsquo;，什么意思？即你可以事先把主要的逻辑写好（只定义接口），然后后期再去实现接口的功能</p>
<p>好处二：</p>
<p>动态导入模块（基于反射当前模块成员）</p>
<div class="cnblogs_code">
<pre><code>module_abc=__import__('dic.a.b.c')#从字符串中提取文件名
# module_abc 拿到最顶层dic模块
module_abc.a.b.c</pre>
</div>
<h1>八、__setattr__,__delattr__,__getattr__</h1>
<p>&nbsp;</p>
<p>三者的用法演示:</p>
<div class="cnblogs_code">
<pre><code>class Foo:
    x=1
    def __init__(self,y):
        self.y=y

    def __getattr__(self, item):
        print('----&gt; from getattr:你找的属性不存在')


    def __setattr__(self, key, value):
        print('----&gt; from setattr')
        # self.key=value #这就无限递归了,你好好想想
        # self.__dict__[key]=value #应该使用它

    def __delattr__(self, item):
        print('----&gt; from delattr')
        # del self.item #无限递归了
        self.__dict__.pop(item)

#__setattr__添加/修改属性会触发它的执行
f1=Foo(10)
print(f1.__dict__) # 因为你重写了__setattr__,凡是赋值操作都会触发它的运行,你啥都没写,就是根本没赋值,除非你直接操作属性字典,否则永远无法赋值
f1.z=3
print(f1.__dict__)

#__delattr__删除属性的时候会触发
f1.__dict__['a']=3#我们可以直接修改属性字典,来完成添加/修改属性的操作
del f1.a
print(f1.__dict__)

#__getattr__只有在使用调用属性且属性不存在的时候才会触发
f1.xxxxxx</pre>
</div>
<h2><strong>授权</strong>：</h2>
<p>&nbsp;&nbsp;&nbsp;&nbsp; 授权是包装的一个特性, 包装一个类型通常是对已存在的类型的一些定制,这种做法可以新建,修改或删除原有产品的功能。其它的则保持原样。授权的过程,即是所有更新的功能都是由新类的某部分来处理,但已存在的功能就授权给对象的默认属性。</p>
<p>实现授权的关键点就是覆盖__getattr__方法</p>
<pre><code><strong><span style="font-size: large;">授权的方式主要在于__getattr__将没有定义的方法映射到真正的内建函数file里面</span></strong></pre>
<div class="cnblogs_code">
<pre><code>import time
class FileHandle:
    def __init__(self,filename,mode='r',encoding='utf-8'):
        self.file=open(filename,mode,encoding=encoding)
        self.mode=mode
        self.encoding=encoding
    def write(self,line):
        print('---------',line)
        t=time.strftime('%Y-%m-%d %X')
        self.file.write('%s %s' %(t,line))

    def __getattr__(self, item):
        # print(item,type(item))
        return getattr(self.file,item)

    # def read(self):
    #     pass


f1=FileHandle('a.txt','r+')
print(f1.__dict__)
print('&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&gt;',f1.read) # 触发 getattr
# print(f1.write)
f1.write('11111111211111\n')
# f1.seek(0)
# sys_f=open('b.txt','w+')
#授权的方式主要在于__getattr__将没有定义的方法映射到真正的内建函数file里面</pre>
</div>
<div class="cnblogs_code">
<pre><code>class List:
    def __init__(self,seq,permission=False):
        self.seq=seq
        self.permission=permission
    def clear(self):
        if not self.permission:
            raise PermissionError('not allow the operation')
        self.seq.clear()

    def __getattr__(self, item):
        return getattr(self.seq,item)

    def __str__(self):
        return str(self.seq)
l=List([1,2,3])
# l.clear() #此时没有权限，抛出异常


l.permission=True
print(l)
l.clear()
print(l)

#基于授权，获得insert方法
l.insert(0,-123)
print(l)</pre>
</div>
<h1 align="left">九、__getattribute__</h1>
<p>回顾__getattr__</p>
<div class="cnblogs_code">
<pre><code>class Foo:
    def __init__(self,x):
        self.x=x

    def __getattr__(self, item):
        print('执行的是我')
        # return self.__dict__[item]

f1=Foo(10)
print(f1.x)
f1.xxxxxx #不存在的属性访问，触发__getattr__

</pre>
</div>
<div class="cnblogs_code">
<pre><code>class Foo:
    def __init__(self,x):
        self.x=x

    def __getattribute__(self, item):
        print('不管是否存在,我都会执行')

f1=Foo(10)
f1.x
f1.xxxxxx

__getattribute__</pre>
</div>
<p>&nbsp;<strong> 当__getattribute__与__getattr__同时存在,只会执行__getattrbute__,除非__getattribute__在执行过程中抛出异常AttributeError</strong></p>
<p>二者同时出现</p>
<div class="cnblogs_code">
<pre><code>class Foo:
    def __init__(self,x):
        self.x=x

    def __getattr__(self, item):
        print('执行的是我')
        # return self.__dict__[item]
    def __getattribute__(self, item):
        print('不管是否存在,我都会执行')
        raise AttributeError('哈哈')

f1=Foo(10)
f1.x
f1.xxxxxx</pre>
</div>
<p>&nbsp;</p>
<h1 align="left">十、描述符(__get__,__set__,__delete__)</h1>
<p>&nbsp;</p>
<h2>1、 描述符是什么:</h2>
<p>描述符本质就是一个新式类,在这个新式类中,至少实现了__get__(),__set__(),__delete__()中的一个,这也被称为描述符协议。</p>
<p>__get__():调用一个属性时,触发<br />__set__():为一个属性赋值时,触发<br />__delete__():采用del删除属性时,触发</p>
<div class="cnblogs_code">
<pre><code>class Foo: #在python3中Foo是新式类,它实现了三种方法,这个类就被称作一个描述符
    def __get__(self, instance, owner):
        pass
    def __set__(self, instance, value):
        pass
    def __delete__(self, instance):
        pass</pre>
</div>
<p>描述符的作用是用来代理另外一个类的属性的(必须把描述符定义成这个类的类属性，不能定义到构造函数中)</p>
<div class="cnblogs_code">
<pre><code>class Foo:
    def __get__(self, instance, owner):
        print('触发get')
    def __set__(self, instance, value):
        print('触发set')
    def __delete__(self, instance):
        print('触发delete')

#包含这三个方法的新式类称为描述符,由这个类产生的实例进行属性的调用/赋值/删除,并不会触发这三个方法
f1=Foo()
f1.name='egon'
f1.name
del f1.name
#疑问:何时,何地,会触发这三个方法的执行

</pre>
</div>
<div class="cnblogs_code">
<pre><code>class Foo:
    def __get__(self, instance, owner):
        print('---get方法')

    def __set__(self, instance, value):
        print('---set方法')
        instance.__dict__['x']=value

    def __delete__(self, instance):
        print('---delete方法')

class Bar:
    x=Foo()#定义成另外一个类的类属性
    def __init__(self,n):
        self.x=n

b1=Bar(10)
print(b1.__dict__)
</pre>
</div>
<p>&nbsp;</p>
<p>一 数据描述符:至少实现了__get__()和__set__()</p>
<div class="cnblogs_code">
<pre><code>class Foo:
   def __set__(self, instance, value):
      print('set')
   def __get__(self, instance, owner):
      print('get')</pre>
</div>
<p>二 非数据描述符:没有实现__set__()</p>
<div class="cnblogs_code">
<pre><code> class Foo:
     def __get__(self, instance, owner):
         print('get')</pre>
</div>
<p>&nbsp;</p>
<h2>注意事项:</h2>
<p><br />一 描述符本身应该定义成新式类,被代理的类也应该是新式类<br />二 必须把描述符定义成这个类的类属性，不能为定义到构造函数中<br />三 要严格遵循该优先级,优先级由高到底分别是</p>
<p>1.类属性<br />2.数据描述符<br />3.实例属性<br />4.非数据描述符<br />5.找不到的属性触发__getattr__()</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('fdd2419d-1a04-4b9e-8c03-8f2db5f8f3f0')"><img id="code_img_closed_fdd2419d-1a04-4b9e-8c03-8f2db5f8f3f0" class="code_img_closed" src="./images/python 基础笔记0.png" alt="" /><img id="code_img_opened_fdd2419d-1a04-4b9e-8c03-8f2db5f8f3f0" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('fdd2419d-1a04-4b9e-8c03-8f2db5f8f3f0',event)" src="./images/python 基础笔记1.png" alt="" />
<div id="cnblogs_code_open_fdd2419d-1a04-4b9e-8c03-8f2db5f8f3f0" class="cnblogs_code_hide">
<pre><code>#描述符Str
class Str:
    def __get__(self, instance, owner):
        print('Str调用')
    def __set__(self, instance, value):
        print('Str设置...')
    def __delete__(self, instance):
        print('Str删除...')

class People:
    name=Str()
    def __init__(self,name,age): #name被Str类代理,age被Int类代理,
        self.name=name
        self.age=age


#基于上面的演示,我们已经知道,在一个类中定义描述符它就是一个类属性,存在于类的属性字典中,而不是实例的属性字典

#那既然描述符被定义成了一个类属性,直接通过类名也一定可以调用吧,没错
People.name #恩,调用类属性name,本质就是在调用描述符Str,触发了__get__()

People.name='egon' #那赋值呢,我去,并没有触发__set__()
del People.name #赶紧试试del,我去,也没有触发__delete__()
#结论:描述符对类没有作用--------&gt;傻逼到家的结论

'''
原因:描述符在使用时被定义成另外一个类的类属性,因而类属性比二次加工的描述符伪装而来的类属性有更高的优先级
People.name #恩,调用类属性name,找不到就去找描述符伪装的类属性name,触发了__get__()

People.name='egon' #那赋值呢,直接赋值了一个类属性,它拥有更高的优先级,相当于覆盖了描述符,肯定不会触发描述符的__set__()
del People.name #同上
'''

类属性&gt;数据描述符</pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<div class="cnblogs_code" onclick="cnblogs_code_show('75cd646f-74a2-4053-bd8b-0913fdbb1a07')"><img id="code_img_closed_75cd646f-74a2-4053-bd8b-0913fdbb1a07" class="code_img_closed" src="./images/python 基础笔记0.png" alt="" /><img id="code_img_opened_75cd646f-74a2-4053-bd8b-0913fdbb1a07" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('75cd646f-74a2-4053-bd8b-0913fdbb1a07',event)" src="./images/python 基础笔记1.png" alt="" />
<div id="cnblogs_code_open_75cd646f-74a2-4053-bd8b-0913fdbb1a07" class="cnblogs_code_hide">
<pre><code>#描述符Str
class Str:
    def __get__(self, instance, owner):
        print('Str调用')
    def __set__(self, instance, value):
        print('Str设置...')
    def __delete__(self, instance):
        print('Str删除...')

class People:
    name=Str()
    def __init__(self,name,age): #name被Str类代理,age被Int类代理,
        self.name=name
        self.age=age


p1=People('egon',18)

#如果描述符是一个数据描述符(即有__get__又有__set__),那么p1.name的调用与赋值都是触发描述符的操作,于p1本身无关了,相当于覆盖了实例的属性
p1.name='egonnnnnn'
p1.name
print(p1.__dict__)#实例的属性字典中没有name,因为name是一个数据描述符,优先级高于实例属性,查看/赋值/删除都是跟描述符有关,与实例无关了
del p1.name

数据描述符&gt;实例属性</pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>描述符应用</p>
<p>python是弱类型语言，即参数的赋值没有类型限制，可以通过描述符机制来实现类型限制功能</p>
<div class="cnblogs_code">
<pre><code>class Type:
    def __init__(self,key,expected_type):
        self.key=key
        self.expected_type=expected_type

    def __get__(self, instance, owner):
        print('get_methods')
        # print('getinstance参数[%s]'%instance)
        # print('owner参数[%s]'%owner)
        return instance.__dict__[self.key]

    def __set__(self, instance, value):
        print('set_methods')
        # print('setinstance参数[%s]' % instance)
        # print('value参数[%s]' % value)
        if not isinstance(value,self.expected_type) :
            # print('你传入的类型不是字符串，错误')
            # return
            raise TypeError('你传入的不是字符串')
        instance.__dict__[self.key]=value

    def __delete__(self, instance):
        print('delete_methods')
        # print('instance_arg[%s]'%instance)
        instance.__dict__.pop(self.key)

class People:
    name=Type('name',str)
    age=Type(18,int)
    def __init__(self,name,age,salary):
        self.name=name
        self.age=age
        self.salary=salary

p1=People('egon',18,33.3)
p1.name='alex'
print(p1.__dict__)
p1.age</pre>
</div>
<p>总结：</p>
<p>描述符是可以实现大部分python类特性中的底层功能,包括@classmethod,@staticmethd,@property甚至是__slots__属性</p>
<p>描述父是很多高级库和框架的重要工具之一,描述符通常是使用到装饰器或者元类的大型框架中的一个组件.</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('0bee356a-56ec-4d3c-91a1-58c2086ed605')"><img id="code_img_closed_0bee356a-56ec-4d3c-91a1-58c2086ed605" class="code_img_closed" src="./images/python 基础笔记0.png" alt="" /><img id="code_img_opened_0bee356a-56ec-4d3c-91a1-58c2086ed605" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('0bee356a-56ec-4d3c-91a1-58c2086ed605',event)" src="./images/python 基础笔记1.png" alt="" />
<div id="cnblogs_code_open_0bee356a-56ec-4d3c-91a1-58c2086ed605" class="cnblogs_code_hide">
<pre><code>class ClassMethod:
    def __init__(self,func):
        self.func=func

    def __get__(self, instance, owner): #类来调用,instance为None,owner为类本身,实例来调用,instance为实例,owner为类本身,
        def feedback():
            print('在这里可以加功能啊...')
            return self.func(owner)
        return feedback

class People:
    name='linhaifeng'
    @ClassMethod # say_hi=ClassMethod(say_hi)
    def say_hi(cls):
        print('你好啊,帅哥 %s' %cls.name)

People.say_hi()

p1=People()
p1.say_hi()
#疑问,类方法如果有参数呢,好说,好说

class ClassMethod:
    def __init__(self,func):
        self.func=func

    def __get__(self, instance, owner): #类来调用,instance为None,owner为类本身,实例来调用,instance为实例,owner为类本身,
        def feedback(*args,**kwargs):
            print('在这里可以加功能啊...')
            return self.func(owner,*args,**kwargs)
        return feedback

class People:
    name='linhaifeng'
    @ClassMethod # say_hi=ClassMethod(say_hi)
    def say_hi(cls,msg):
        print('你好啊,帅哥 %s %s' %(cls.name,msg))

People.say_hi('你是那偷心的贼')

p1=People()
p1.say_hi('你是那偷心的贼')

自己做一个@classmethod</pre>
</div>
<span class="cnblogs_code_collapse">定制@ClassMethod</span></div>
<div class="cnblogs_code" onclick="cnblogs_code_show('f6a5ca03-f307-465b-9d6e-987b283c663c')"><img id="code_img_closed_f6a5ca03-f307-465b-9d6e-987b283c663c" class="code_img_closed" src="./images/python 基础笔记0.png" alt="" /><img id="code_img_opened_f6a5ca03-f307-465b-9d6e-987b283c663c" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('f6a5ca03-f307-465b-9d6e-987b283c663c',event)" src="./images/python 基础笔记1.png" alt="" />
<div id="cnblogs_code_open_f6a5ca03-f307-465b-9d6e-987b283c663c" class="cnblogs_code_hide">
<pre><code>class StaticMethod:
    def __init__(self,func):
        self.func=func

    def __get__(self, instance, owner): #类来调用,instance为None,owner为类本身,实例来调用,instance为实例,owner为类本身,
        def feedback(*args,**kwargs):
            print('在这里可以加功能啊...')
            return self.func(*args,**kwargs)
        return feedback

class People:
    @StaticMethod# say_hi=StaticMethod(say_hi)
    def say_hi(x,y,z):
        print('------&gt;',x,y,z)

People.say_hi(1,2,3)

p1=People()
p1.say_hi(4,5,6)

</pre>
</div>
<span class="cnblogs_code_collapse">定制@StaticMethod</span></div>
<h1 align="left">十一、item系列方法</h1>
<div class="cnblogs_code">
<pre><code>class Foo:
    def __getitem__(self, item):
        print('getitem')
        return self.__dict__[item]

    def __setitem__(self, key, value):
        print('setitem')
        self.__dict__[key]=value

    def __delitem__(self, key):
        print('delitem')
        self.__dict__.pop(key)

#字典操作触发 item
#. 触发  attr
f1= Foo()
print(f1.__dict__)
f1['name']='egon'
f1['22']='2222'

print(f1.__dict__)</pre>
</div>
<div class="cnblogs_code">
<pre><code>class Foo:
    def __init__(self,name):
        self.name=name

    def __getitem__(self, item):
        print(self.__dict__[item])

    def __setitem__(self, key, value):
        self.__dict__[key]=value
    def __delitem__(self, key):
        print('del obj[key]时,我执行')
        self.__dict__.pop(key)
    def __delattr__(self, item):
        print('del obj.key时,我执行')
        self.__dict__.pop(item)

f1=Foo('sb')
f1['age']=18
f1['age1']=19
del f1.age1
del f1['age']
f1['name']='alx'
print(f1.__dict__)</pre>
</div>
<p>&nbsp;</p>
<h1 align="left">十二、property</h1>
<p align="center">一个静态属性<strong>property</strong>本质就是实现了get，set，delete三种方法</p>
<div class="cnblogs_code">
<pre><code>#实现类型检测功能

#第一关：
class People:
    def __init__(self,name):
        self.name=name

    @property
    def name(self):
        return self.name

# p1=People('alex') #property自动实现了set和get方法属于数据描述符,比实例属性优先级高,所以你这面写会触发property内置的set,抛出异常


#第二关：修订版

class People:
    def __init__(self,name):
        self.name=name #实例化就触发property

    @property
    def name(self):
        # return self.name #无限递归
        print('get------&gt;')
        return self.DouNiWan

    @name.setter
    def name(self,value):
        print('set------&gt;')
        self.DouNiWan=value

    @name.deleter
    def name(self):
        print('delete------&gt;')
        del self.DouNiWan

p1=People('alex') #self.name实际是存放到self.DouNiWan里
print(p1.name)
print(p1.name)
print(p1.name)
print(p1.__dict__)

p1.name='egon'
print(p1.__dict__)

del p1.name
print(p1.__dict__)


#第三关:加上类型检查
class People:
    def __init__(self,name):
        self.name=name #实例化就触发property

    @property
    def name(self):
        # return self.name #无限递归
        print('get------&gt;')
        return self.DouNiWan

    @name.setter
    def name(self,value):
        print('set------&gt;')
        if not isinstance(value,str):
            raise TypeError('必须是字符串类型')
        self.DouNiWan=value

    @name.deleter
    def name(self):
        print('delete------&gt;')
        del self.DouNiWan

p1=People('alex') #self.name实际是存放到self.DouNiWan里
p1.name=1
</pre>
</div>
<p align="center">&nbsp;</p>
<h1>十三、__str__,__repr__,__format__,__slots__</h1>
<p>改变对象的字符串显示__str__,__repr__</p>
<p>自定制格式化字符串__format__</p>
<div class="cnblogs_code">
<pre><code>format_dict={
    'nat':'{obj.name}-{obj.addr}-{obj.type}',#学校名-学校地址-学校类型
    'tna':'{obj.type}:{obj.name}:{obj.addr}',#学校类型:学校名:学校地址
    'tan':'{obj.type}/{obj.addr}/{obj.name}',#学校类型/学校地址/学校名
}
class School:
    def __init__(self,name,addr,type):
        self.name=name
        self.addr=addr
        self.type=type

    def __repr__(self):
        return 'School(%s,%s)' %(self.name,self.addr)
    def __str__(self):
        return '(%s,%s)' %(self.name,self.addr)

    def __format__(self, format_spec):
        # if format_spec
        if not format_spec or format_spec not in format_dict:
            format_spec='nat'
        fmt=format_dict[format_spec]
        return fmt.format(obj=self)

s1=School('oldboy1','北京','私立')
print('from repr: ',repr(s1))
print('from str: ',str(s1))
print(s1)

'''
str函数或者print函数---&gt;obj.__str__()
repr或者交互式解释器---&gt;obj.__repr__()
如果__str__没有被定义,那么就会使用__repr__来代替输出
注意:这俩方法的返回值必须是字符串,否则抛出异常
'''
print(format(s1,'nat'))
print(format(s1,'tna'))
print(format(s1,'tan'))
print(format(s1,'asfdasdffd'))</pre>
</div>
<p><span style="font-family: 宋体; font-size: small;"><strong>1.__slots__是什么:</strong></span></p>
<p><span style="font-family: 宋体; font-size: small;"> 是一个类变量,变量值可以是列表,元祖,或者可迭代对象,也可以是一个字符串(意味着所有实例只有一个数据属性) 使用点<strong>.</strong>来访问属性本质就是在访问类或者对象的__dict__属性字典(类的字典是共享的,而每个实例的是独立的) </span></p>
<p><span style="font-family: 宋体; font-size: small;"><strong>2.为何使用__slots__:</strong></span><span style="font-family: 宋体; font-size: small;"> <strong>字典会占用大量内存,如果你有一个属性很少的类,但是有很多实例,为了节省内存可以使用__slots__取代实例的__dict__ 当你定义__slots__后,__slots__就会为实例使用一种更加紧凑的内部表示。实例通过一个很小的固定大小的数组来构建,而不是为每个实例定义一个字典,这跟元组或列表很类似。在__slots__中列出的属性名在内部被映射到这个数组的指定小标上。使用__slots__一个不好的地方就是我们不能再给实例添加新的属性了,只能使用在__slots__中定义的那些属性名。</strong></span></p>
<p><span style="font-family: 宋体; font-size: small;"><strong>3.注意事项:</strong></span><span style="font-family: 宋体; font-size: small;"> __slots__的很多特性都依赖于普通的基于字典的实现。另外,定义了__slots__后的类不再 支持一些普通类特性了,比如多继承。大多数情况下,你应该只在那些经常被使用到的用作数据结构的类上定义__slots__比如在程序中需要创建某个类的几百万个实例对象 。 关于__slots__的一个常见误区是它可以作为一个封装工具来防止用户给实例增加新的属性。尽管使用__slots__可以达到这样的目的,但是这个并不是它的初衷。更多的是用来作为一个内存优化工具。</span></p>
<div class="cnblogs_code">
<pre><code>class Foo:
    __slots__='x'


f1=Foo()
f1.x=1
f1.y=2#报错
print(f1.__slots__) #f1不再有__dict__

class Bar:
    __slots__=['x','y']

n=Bar()
n.x,n.y=1,2
n.z=3#报错</pre>
</div>
<div class="cnblogs_code">
<pre><code>class Foo:
    __slots__=['name','age']

f1=Foo()
f1.name='alex'
f1.age=18
print(f1.__slots__)

f2=Foo()
f2.name='egon'
f2.age=19
print(f2.__slots__)

print(Foo.__dict__)
#f1与f2都没有属性字典__dict__了,统一归__slots__管,节省内存</pre>
</div>
<h1 align="left">十四、__next__、__iter__、__doc__</h1>
<p>斐波那契数列</p>
<div class="cnblogs_code">
<pre><code>class Fib:
    def __init__(self):
        self._a=0
        self._b=1

    def __iter__(self):
        return self

    def __next__(self):
        self._a,self._b=self._b,self._a + self._b
        return self._a

f1=Fib()

print(f1.__next__())
print(next(f1))
print(next(f1))

for i in f1:
    if i &gt; 100:
        break
    print('%s ' %i,end='')

</pre>
</div>
<div class="cnblogs_code">
<pre><code>class Foo:
    '我是描述信息'
    pass

class Bar(Foo):
    pass
print(Bar.__doc__) #该属性无法继承给子类

</pre>
</div>
<h1>十五、__module__、__class__、__del__</h1>
<p>&nbsp;</p>
<p>__module__ 表示当前操作的对象在那个模块</p>
<p>__class__&nbsp;&nbsp;&nbsp;&nbsp; 表示当前操作的对象的类是什么</p>
<div class="cnblogs_code">
<pre><code>from lib.aa import C

obj = C()
print obj.__module__  # 输出 lib.aa，即：输出模块
print obj.__class__      # 输出 lib.aa.C，即：输出类

</pre>
</div>
<pre><code></pre>
<p><span style="font-family: 宋体; font-size: small;">__del__析构方法，当对象在内存中被释放时，自动触发执行。</span><span style="font-family: 宋体; font-size: small;">注：如果产生的对象仅仅只是python程序级别的（用户级），那么无需定义__del__,如果产生的对象的同时还会向操作系统发起系统调用，即一个对象有用户级与内核级两种资源，比如（打开一个文件，创建一个数据库链接），则必须在清除对象的同时回收系统资源，这就用到了__del__</span></p>
<p><span style="font-family: 宋体; font-size: small;">典型的应用场景：</span></p>
<p><span style="font-family: 宋体; font-size: small;">创建数据库类，用该类实例化出数据库链接对象，对象本身是存放于用户空间内存中，而链接则是由操作系统管理的，存放于内核空间内存中</span></p>
<p><span style="font-family: 宋体; font-size: small;">当程序结束时，python只会回收自己的内存空间，即用户态内存，而操作系统的资源则没有被回收，这就需要我们定制__del__，在对象被删除前向操作系统发起关闭数据库链接的系统调用，回收资源</span></p>
<div class="cnblogs_code">
<pre><code>f=open('a.txt') #做了两件事，在用户空间拿到一个f变量，在操作系统内核空间打开一个文件
del f #只回收用户空间的f，操作系统的文件还处于打开状态

#所以我们应该在del f之前保证f.close()执行,即便是没有del，程序执行完毕也会自动del清理资源，于是文件操作的正确用法应该是
f=open('a.txt')
读写...
f.close()
很多情况下大家都容易忽略f.close,这就用到了with上下文管理</pre>
</div>
<h1 align="left">十六、__enter__、__exit__、__call__</h1>
<p>在操作文件对象的时候</p>
<div class="cnblogs_code">
<pre><code>with open('a.txt') as f:
 　　'代码块'</pre>
</div>
<p>叫做上下文管理协议，即with语句，为了让一个对象兼容with语句，必须在这个对象的类中声明__enter__和__exit__方法</p>
<h2>上下文管理协议：</h2>
<div class="cnblogs_code">
<pre><code>class Open:
    def __init__(self,name):
        self.name=name

    def __enter__(self):
        print('出现with语句,对象的__enter__被触发,有返回值则赋值给as声明的变量')
        # return self
    def __exit__(self, exc_type, exc_val, exc_tb):
        print('with中代码块执行完毕时执行我啊')


with Open('a.txt') as f:
    print('=====&gt;执行代码块')
    # print(f,f.name)

</pre>
</div>
<p>__exit__()中的三个参数分别代表异常类型，异常值和追溯信息,with语句中代码块出现异常，则with后的代码都无法执行</p>
<p>如果__exit()返回值为True,那么异常会被清空，就好像啥都没发生一样，with后的语句正常执行</p>
<div class="cnblogs_code">
<pre><code>class Open:
    def __init__(self,filepath,mode='r',encoding='utf-8'):
        self.filepath=filepath
        self.mode=mode
        self.encoding=encoding

    def __enter__(self):
        # print('enter')
        self.f=open(self.filepath,mode=self.mode,encoding=self.encoding)
        return self.f

    def __exit__(self, exc_type, exc_val, exc_tb):
        # print('exit')
        self.f.close()
        return True
    def __getattr__(self, item):
        return getattr(self.f,item)

with Open('a.txt','w') as f:
    print(f)
    f.write('aaaaaa')#授权
    f.wasdf #抛出异常，交给__exit__处理</pre>
</div>
<p>用途：</p>
<p>1.使用with语句的目的就是把代码块放入with中执行，with结束后，自动完成清理工作，无须手动干预</p>
<p>2.在需要管理一些资源比如文件，网络连接和锁的编程环境中，可以在__exit__中定制自动释放资源的机制，你无须再去关系这个问题，这将大有用处</p>
<p><strong><span style="font-size: large;">对象后面加括号，触发执行 __call__</span></strong></p>
<p>注：构造方法的执行是由创建对象触发的，即：对象 = 类名() ；而对于 __call__ 方法的执行是由对象后加括号触发的，即：对象() 或者 类()()</p>
<div class="cnblogs_code">
<pre><code>class Foo:

    def __init__(self):
        pass

    def __call__(self, *args, **kwargs):

        print('__call__')


obj = Foo() # 执行 __init__
obj()       # 执行 __call__</pre>
</div>
<h1 align="left">十七、元类 metaclass</h1>
<p><span style="font-family: 宋体; font-size: small;">python中一切皆为对象。</span></p>
<p><span style="font-family: 宋体; font-size: small;">所有的对象都是实例化或者说调用类而得到的（调用类的过程称为类的实例化）</span></p>
<p><span style="font-family: 宋体; font-size: small;">类的产生过程其实就是元类的调用过程</span></p>
<p><span style="font-family: 宋体; font-size: small;">&nbsp;</span></p>
<p><span style="font-family: 宋体; font-size: small;">class关键字在帮我们创建类时，调用了元类type(...)，那调用type时传入类的关键组成部分，一个类有三大组成部分，分别是</span></p>
<p><span style="font-family: 宋体; font-size: small;">1、类名class_name='xxxx'</span></p>
<p><span style="font-family: 宋体; font-size: small;">2、基类们class_bases=(object,)</span></p>
<p><span style="font-family: 宋体; font-size: small;">3、类的名称空间class_dic，类的名称空间是执行类体代码而得到的</span></p>
<p><span style="font-family: 宋体; font-size: small;">调用type时会依次传入以上三个参数</span></p>
<p><span style="font-family: 宋体; font-size: small;">&nbsp;</span></p>
<p><span style="font-family: 宋体; font-size: small;">一个类没有声明自己的元类，默认他的元类就是type，除了使用内置元类type，我们也可以通过继承type来自定义元类，然后使用metaclass关键字参数为一个类指定元类,用class自定义的类也全都是对象（包括object类本身也是元类type的 一个实例，可以用type(object)查看）</span></p>
<p><span style="font-family: 宋体; font-size: small;">&nbsp;</span></p>
<p><span style="font-family: 宋体; font-size: small;">&nbsp;</span></p>
<p><span style="font-family: 宋体; font-size: small;">&nbsp;</span></p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>