<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修进程相关' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>进程相关</center></div><div class='banquan'>原文出处:本文由博客园博主林染提供。<br/>
原文连接:https://www.cnblogs.com/zengyi1995/p/11330891.html</div><br>
    <h3 class="md-end-block md-heading"><span style="font-size: 1.17em;">一、基本概念</span></h3>
<ul>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">定义：运行中的程序</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">程序和进程之间的区别：</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain md-expand">程序只是一个文件</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">进程是这个文件被CPU运行起来了</span></p>
</li>
</ul>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">进程是计算机中最小的资源分配单位</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">在操作系统中的唯一标识符 ：pid</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">进程调度：</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">操作系统调度进程的算法</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">短作业优先算法</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">先来先服务算法</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">时间片轮转算法</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">多级反馈算法</span></p>
</li>
</ul>
</li>
</ul>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">并行与并发</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">并行</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">两个程序 两个CPU 每个程序分别占用一个CPU自己执行自己的</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">看起来是同时执行，实际在每一个时间点上都在各自执行着</span></p>
</li>
</ul>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">并发</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">两个程序 一个cpu 每个程序交替的在一个cpu上执行</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">看起来在同时执行，但是实际上仍然是串行</span></p>
</li>
</ul>
</li>
</ul>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">同步 / 异步 / 阻塞 / 非阻塞</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">同步：一个任务的完成需要依赖另外一个任务时，只有等待被依赖的任务完成后，依赖的任务才能算完成，这是一种可靠的任务序列，要么成功都成功，失败都失败，两个任务的状态可以保持一致</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">异步：不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了，至于被依赖的任务最终是否真正完成，依赖它的任务无法确定，所以它是不可靠的任务序列</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">阻塞：cpu不工作</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">非阻塞：cpu工作</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">同步阻塞</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">conn.recv</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">socket 阻塞的tcp协议的时候</span></p>
</li>
</ul>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">同步非阻塞</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">func() 没有io操作</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">socket 非阻塞的tcp协议的时候</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">调用函数（这个函数内部不存在io操作）</span></p>
</li>
</ul>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">异步非阻塞</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">把func扔到其他任务里去执行了</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">我本身的任务和func任务各自执行各自的 没有io操作</span></p>
</li>
</ul>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">异步阻塞</span></p>
</li>
</ul>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">进程的三状态</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">就绪(Ready)状态</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">当进程已分配到除CPU以外的所有必要的资源，只要获得处理机便立即执行，这时的进程状态称为就绪状态</span></p>
</li>
</ul>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">执行/运行（Running）</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">状态当进程已获得处理机，其程序正在处理机上执行，此时的进程状态称为执行状态</span></p>
</li>
</ul>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">阻塞(Blocked)状态</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">正在执行的进程，由于等待某个事件发生而无法执行时，便放弃处理机而处于阻塞状态。引起进程阻塞的事件可有多种，例如，等待I/O完成、申请缓冲区不能满足、等待信件(信号)等</span></p>
</li>
</ul>
</li>
</ul>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">子进程 / 父进程 </span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">在父进程中创建子进程</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">在pycharm中启动的所有py程序都是pycharm的子进程</span></p>
</li>
</ul>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">os模块</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">os.getpid()：获取子进程的pid</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">os.getppid()：获取父进程的pid</span></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 class="md-end-block md-heading"><span class="md-plain">二、进程模块</span></h3>
<ul>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">开启进程</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">#</span><span style="color: #008000;"> 面向函数方式：</span>
<span style="color: #0000ff;">import</span><span style="color: #000000;"> os
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> time
</span><span style="color: #0000ff;">from</span> multiprocessing <span style="color: #0000ff;">import</span><span style="color: #000000;"> Process
​
</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> eat():
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">start eating</span><span style="color: #800000;">'</span><span style="color: #000000;">,os.getpid())
    time.sleep(</span>1<span style="color: #000000;">)
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">end eating</span><span style="color: #800000;">'</span><span style="color: #000000;">,os.getpid())
​
</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> sleep():
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">start sleeping</span><span style="color: #800000;">'</span><span style="color: #000000;">,os.getpid())
    time.sleep(</span>1<span style="color: #000000;">)
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">end sleeping</span><span style="color: #800000;">'</span><span style="color: #000000;">,os.getpid())
​
</span><span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">'</span><span style="color: #800000;">__main__</span><span style="color: #800000;">'</span><span style="color: #000000;">:
    p1 </span>= Process(target=eat)    <span style="color: #008000;">#</span><span style="color: #008000;"> 创建一个即将要执行eat函数的进程对象</span>
    p1.start()                  <span style="color: #008000;">#</span><span style="color: #008000;"> 异步 调用开启进程的方法 但是并不等待这个进程真的开启</span>
    p2 = Process(target=sleep)  <span style="color: #008000;">#</span><span style="color: #008000;"> 创建一个即将要执行sleep函数的进程对象</span>
    p2.start()                  <span style="color: #008000;">#</span><span style="color: #008000;"> 异步 调用开启进程的方法 但是并不等待这个进程真的开启</span>
    <span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">main :</span><span style="color: #800000;">'</span><span style="color: #000000;">,os.getpid())
</span><span style="color: #008000;">#</span><span style="color: #008000;"> 面向对象方式：</span>
<span style="color: #0000ff;">import</span><span style="color: #000000;"> os
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> time
</span><span style="color: #0000ff;">from</span> multiprocessing <span style="color: #0000ff;">import</span><span style="color: #000000;"> Process
​
</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> MyProcecss1(Process):
    </span><span style="color: #0000ff;">def</span> <span style="color: #800080;">__init__</span><span style="color: #000000;">(self,x,y):
        self.x </span>=<span style="color: #000000;"> x
        self.y </span>=<span style="color: #000000;"> y
        super().</span><span style="color: #800080;">__init__</span><span style="color: #000000;">()
    </span><span style="color: #0000ff;">def</span><span style="color: #000000;"> run(self):
        </span><span style="color: #0000ff;">print</span><span style="color: #000000;">(self.x,self.y,os.getpid())
        </span><span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span> range(5<span style="color: #000000;">):
            </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">in son2</span><span style="color: #800000;">'</span><span style="color: #000000;">)
​
</span><span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">'</span><span style="color: #800000;">__main__</span><span style="color: #800000;">'</span><span style="color: #000000;">:
    mp </span>= MyProcecss1(1,2<span style="color: #000000;">)
    mp.daemon </span>=<span style="color: #000000;"> True
    mp.start()
    </span><span style="color: #0000ff;">print</span><span style="color: #000000;">(mp.is_alive())
    time.sleep(</span>1<span style="color: #000000;">)
    mp.terminate()</span></pre>
</div>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">操作系统创建进程的方式不同</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">windows操作系统执行开启进程的代码</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">实际上新的子进程需要通过import父进程的代码来完成数据的导入工作</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">所以有一些内容我们只希望在父进程中完成，就写在if <span><strong>name</strong><span class="md-plain"> == '<span><strong>main</strong><span class="md-plain">':下面</span></span></span></span></span></p>
</li>
</ul>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">ios linux操作系统创建进程 fork</span></p>
</li>
</ul>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">主进程和子进程之间的关系</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">主进程的结束逻辑</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">主进程的代码结束</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">所有的子进程结束</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">给子进程回收资源</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">主进程结束</span></p>
</li>
</ul>
</li>
</ul>
<div class="cnblogs_code" onclick="cnblogs_code_show('57981186-f529-4f9e-a9e6-52d792b0f121')"><img id="code_img_closed_57981186-f529-4f9e-a9e6-52d792b0f121" class="code_img_closed" src="./images/进程相关0.png" alt="" /><img id="code_img_opened_57981186-f529-4f9e-a9e6-52d792b0f121" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('57981186-f529-4f9e-a9e6-52d792b0f121',event)" src="./images/进程相关1.png" alt="" />
<div id="cnblogs_code_open_57981186-f529-4f9e-a9e6-52d792b0f121" class="cnblogs_code_hide">
<pre><code><span style="color: #0000ff;">import</span><span style="color: #000000;"> os
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> time
</span><span style="color: #0000ff;">from</span> multiprocessing <span style="color: #0000ff;">import</span><span style="color: #000000;"> Process
</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> func():
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">start</span><span style="color: #800000;">'</span><span style="color: #000000;">,os.getpid())
    time.sleep(</span>10<span style="color: #000000;">)
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">end</span><span style="color: #800000;">'</span><span style="color: #000000;">,os.getpid())
​
</span><span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">'</span><span style="color: #800000;">__main__</span><span style="color: #800000;">'</span><span style="color: #000000;">:
    p </span>= Process(target=<span style="color: #000000;">func)
    p.start()   </span><span style="color: #008000;">#</span><span style="color: #008000;"> 异步 调用开启进程的方法 但是并不等待这个进程真的开启</span>
    <span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">main :</span><span style="color: #800000;">'</span><span style="color: #000000;">,os.getpid())
    </span><span style="color: #008000;">#</span><span style="color: #008000;"> 主进程没结束 ：等待子进程结束</span>
    <span style="color: #008000;">#</span><span style="color: #008000;"> 主进程负责回收子进程的资源</span>
    <span style="color: #008000;">#</span><span style="color: #008000;"> 如果子进程执行结束，父进程没有回收资源，那么这个子进程会变成一个僵尸进程</span></pre>
</div>
<span class="cnblogs_code_collapse">示例</span></div>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">主进程怎么知道子进程结束了的呢？</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">基于网络、文件</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">join方法 ：阻塞，直到子进程结束就结束</span></p>
</li>
</ul>
<div class="cnblogs_code" onclick="cnblogs_code_show('80bfcede-41ab-4b86-91b3-817fcc178c35')"><img id="code_img_closed_80bfcede-41ab-4b86-91b3-817fcc178c35" class="code_img_closed" src="./images/进程相关0.png" alt="" /><img id="code_img_opened_80bfcede-41ab-4b86-91b3-817fcc178c35" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('80bfcede-41ab-4b86-91b3-817fcc178c35',event)" src="./images/进程相关1.png" alt="" />
<div id="cnblogs_code_open_80bfcede-41ab-4b86-91b3-817fcc178c35" class="cnblogs_code_hide">
<pre><code><span style="color: #0000ff;">import</span><span style="color: #000000;"> time
</span><span style="color: #0000ff;">from</span> multiprocessing <span style="color: #0000ff;">import</span><span style="color: #000000;"> Process
</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> send_mail():
    time.sleep(</span>3<span style="color: #000000;">)
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">发送了一封邮件</span><span style="color: #800000;">'</span><span style="color: #000000;">)
</span><span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">'</span><span style="color: #800000;">__main__</span><span style="color: #800000;">'</span><span style="color: #000000;">:
    p </span>= Process(target=<span style="color: #000000;">send_mail)
    p.start()   </span><span style="color: #008000;">#</span><span style="color: #008000;"> 异步 非阻塞</span>
    <span style="color: #008000;">#</span><span style="color: #008000;"> time.sleep(5)</span>
    <span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">join start</span><span style="color: #800000;">'</span><span style="color: #000000;">)
    p.join()    </span><span style="color: #008000;">#</span><span style="color: #008000;"> 同步 阻塞 直到p对应的进程结束之后才结束阻塞</span>
    <span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">5000封邮件已发送完毕</span><span style="color: #800000;">'</span>)</pre>
</div>
<span class="cnblogs_code_collapse">示例一</span></div>
<div class="cnblogs_code" onclick="cnblogs_code_show('584f9abf-2925-4396-abd3-8b041e1bd396')"><img id="code_img_closed_584f9abf-2925-4396-abd3-8b041e1bd396" class="code_img_closed" src="./images/进程相关0.png" alt="" /><img id="code_img_opened_584f9abf-2925-4396-abd3-8b041e1bd396" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('584f9abf-2925-4396-abd3-8b041e1bd396',event)" src="./images/进程相关1.png" alt="" />
<div id="cnblogs_code_open_584f9abf-2925-4396-abd3-8b041e1bd396" class="cnblogs_code_hide">
<pre><code><span style="color: #008000;">#</span><span style="color: #008000;"> 开启10个进程，给公司的5000个人发邮件，发送完邮件之后，打印一个消息&ldquo;5000封邮件已发送完毕&rdquo;</span>
<span style="color: #0000ff;">import</span><span style="color: #000000;"> time
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> random
</span><span style="color: #0000ff;">from</span> multiprocessing <span style="color: #0000ff;">import</span><span style="color: #000000;"> Process
</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> send_mail(a):
    time.sleep(random.random())
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">发送了一封邮件</span><span style="color: #800000;">'</span><span style="color: #000000;">,a)
​
</span><span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">'</span><span style="color: #800000;">__main__</span><span style="color: #800000;">'</span><span style="color: #000000;">:
    l </span>=<span style="color: #000000;"> []
    </span><span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span> range(10<span style="color: #000000;">):
        p </span>= Process(target=send_mail,args=<span style="color: #000000;">(i,))
        p.start()
        l.append(p)
    </span><span style="color: #0000ff;">print</span><span style="color: #000000;">(l)
    </span><span style="color: #0000ff;">for</span> p <span style="color: #0000ff;">in</span><span style="color: #000000;"> l:p.join()
    </span><span style="color: #008000;">#</span><span style="color: #008000;"> 阻塞 直到上面的十个进程都结束</span>
    <span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">5000封邮件已发送完毕</span><span style="color: #800000;">'</span>)</pre>
</div>
<span class="cnblogs_code_collapse">示例二</span></div>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">总结：</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">如何创建一个进程对象</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">对象和进程之间的关系</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">进程对象和进程并没有直接的关系</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">只是存储了一些和进程相关的内容</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">此时此刻，操作系统还没有接到创建进程的指令</span></p>
</li>
</ul>
</li>
</ul>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">如何开启一个进程</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">通过p.start()开启了一个进程--这个方法相当于给了操作系统一条指令</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">start方法的非阻塞和异步的特点</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">在执行开启进程这个方法的时候</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">我们既不等待这个进程开启，也不等待操作系统给我们的响应</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">这里只是负责通知操作系统去开启一个进程</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">开启了一个子进程之后，主进程的代码和子进程的代码完全异步</span></p>
</li>
</ul>
</li>
</ul>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">父进程和子进程</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">为了回收子进程的资源，父进程会等待着所有的子进程结束之后才结束</span></p>
</li>
</ul>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">进程开启的过程中windows和 linux / ios之间的区别</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">windows 通过（模块导入）再一次执行父进程文件中的代码来获取父进程中的数据</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">所以只要是不希望被子进程执行的代码，就写在if <span><strong>name</strong><span class="md-plain"> == '<span><strong>main</strong><span class="md-plain">'下</span></span></span></span></span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">因为在进行导入的时候父进程文件中的<span><strong>name</strong><span class="md-plain"> != '<span><strong>main</strong><span class="md-plain">'</span></span></span></span></span></p>
</li>
</ul>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">linux/ios</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">正常的写就可以，没有if <span><strong>name</strong><span class="md-plain"> == '<span><strong>main</strong><span class="md-plain">'这件事情了</span></span></span></span></span></p>
</li>
</ul>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">补充</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">'</span><span style="color: #800000;">__main__</span><span style="color: #800000;">'</span><span style="color: #000000;">:
    </span><span style="color: #008000;">#</span><span style="color: #008000;"> 控制当这个py文件被当作脚本直接执行的时候，就执行这里面的代码</span>
    <span style="color: #008000;">#</span><span style="color: #008000;"> 当这个py文件被当作模块导入的时候，就不执行这里面的代码</span>
    <span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">hello hello</span><span style="color: #800000;">'</span><span style="color: #000000;">)
</span><span style="color: #800080;">__name__</span> == <span style="color: #800000;">'</span><span style="color: #800000;">__main__</span><span style="color: #800000;">'</span>  <span style="color: #008000;">#</span><span style="color: #008000;"> 执行的文件就是__name__所在的文件</span>
<span style="color: #800080;">__name__</span> == <span style="color: #800000;">'</span><span style="color: #800000;">文件名</span><span style="color: #800000;">'</span>     <span style="color: #008000;">#</span><span style="color: #008000;"> __name__所在的文件被导入执行的时候</span></pre>
</div>
</li>
</ul>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">join方法</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">把一个进程的结束事件封装成一个join方法</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">执行join方法的效果就是阻塞，直到这个子进程执行结束就结束阻塞</span></p>
</li>
</ul>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">#</span><span style="color: #008000;"> 在多个子进程中使用join</span>
p_l=<span style="color: #000000;"> []
</span><span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span> range(10<span style="color: #000000;">):
    p </span>= Process(target=函数名,args=<span style="color: #000000;">(参数1,参数2))
    p.start()
    p_l.append(p)
</span><span style="color: #0000ff;">for</span> p <span style="color: #0000ff;">in</span><span style="color: #000000;"> p_l:p.join()
</span><span style="color: #008000;">#</span><span style="color: #008000;"> 所有的子进程都结束之后要执行的代码写在这里</span></pre>
</div>
</li>
</ul>
</li>
</ul>
<h3 class="md-end-block md-heading"><span class="md-plain">三、守护进程</span></h3>
<ul>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">方式：有一个参数可以把一个子进程设置为一个守护进程</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">p.daemon = True</span></p>
</li>
</ul>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">import</span><span style="color: #000000;"> time
</span><span style="color: #0000ff;">from</span> multiprocessing <span style="color: #0000ff;">import</span><span style="color: #000000;"> Process
​
</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> son1(a,b):
    </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> True:
        </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">is alive</span><span style="color: #800000;">'</span><span style="color: #000000;">)
        time.sleep(</span>0.5<span style="color: #000000;">)
​
</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> son2():
    </span><span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span> range(5<span style="color: #000000;">):
        </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">in son2</span><span style="color: #800000;">'</span><span style="color: #000000;">)
        time.sleep(</span>1<span style="color: #000000;">)
​
</span><span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">'</span><span style="color: #800000;">__main__</span><span style="color: #800000;">'</span><span style="color: #000000;">:
    p </span>= Process(target=son1,args=(1,2<span style="color: #000000;">))
    p.daemon </span>=<span style="color: #000000;"> True
    p.start()      </span><span style="color: #008000;">#</span><span style="color: #008000;"> 把p子进程设置成了一个守护进程</span>
    p2 = Process(target=<span style="color: #000000;">son2)
    p2.start()
    time.sleep(</span>2)</pre>
</div>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">结束：守护进程是随着主进程的代码结束而结束的</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">所有的子进程都必须在主进程结束之前结束，由主进程来负责回收资源</span></p>
</li>
</ul>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">应用场景：</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">生产者消费者模型</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">和守护线程做对比</span></p>
</li>
</ul>
</li>
</ul>
<h3 class="md-end-block md-heading"><span class="md-plain">四、生产者消费者模型</span></h3>
<ul>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">解耦：把写在一起的大的功能分开成多个小的功能处理</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">优点：修改 复用 可读性</span></p>
</li>
</ul>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">组成：</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">producer：生产者，生产数据</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">consumer：消费者，处理数据</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">生产者和消费者之间的容器就是队列</span></p>
</li>
</ul>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">什么是生产者消费者模型？</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">把一个产生数据并且处理数据的过程解耦，让生产的数据的过程和处理数据的过程达到一个工作效率上的平衡，</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">中间的容器，在多进程中我们使用队列或者可被join的队列，做到控制数据的量</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">当数据过剩的时候，队列的大小会控制这生产者的行为</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">当数据严重不足的时候，队列会控制消费者的行为</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">并且我们还可以通过定期检查队列中元素的个数来调节生产者消费者的个数</span></p>
</li>
</ul>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">比如说：一个爬虫，或者一个web程序的server端</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">爬虫：请求网页的平均时间是0.3s，处理网页代码的时候是0.003s</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">100倍，每启动100个线程生产数据，启动一个线程来完成处理数据</span></p>
</li>
</ul>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">web程序的server端：每秒钟有6w条请求，一个服务每s中只能处理2000条</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">先写一个web程序，只负责一件事情，就是接收请求，然后把请求放到队列中</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">再写很多个server端，从队列中获取请求，然后处理，然后返回结果</span></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">生产者消费者模型</span></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('b5d8bde1-81f4-4a73-a22b-abd3f27845b5')"><img id="code_img_closed_b5d8bde1-81f4-4a73-a22b-abd3f27845b5" class="code_img_closed" src="./images/进程相关0.png" alt="" /><img id="code_img_opened_b5d8bde1-81f4-4a73-a22b-abd3f27845b5" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('b5d8bde1-81f4-4a73-a22b-abd3f27845b5',event)" src="./images/进程相关1.png" alt="" />
<div id="cnblogs_code_open_b5d8bde1-81f4-4a73-a22b-abd3f27845b5" class="cnblogs_code_hide">
<pre><code><span style="color: #0000ff;">import</span><span style="color: #000000;"> time
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> random
</span><span style="color: #0000ff;">from</span> multiprocessing <span style="color: #0000ff;">import</span><span style="color: #000000;"> Process,Queue
​
</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> producer(q,name,food):
    </span><span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span> range(10<span style="color: #000000;">):
        time.sleep(random.random())
        fd </span>= <span style="color: #800000;">'</span><span style="color: #800000;">%s%s</span><span style="color: #800000;">'</span>%<span style="color: #000000;">(food,i)
        q.put(fd)
        </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">%s生产了一个%s</span><span style="color: #800000;">'</span>%<span style="color: #000000;">(name,food))
​
</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> consumer(q,name):
    </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> True:
        food </span>=<span style="color: #000000;"> q.get()
        </span><span style="color: #0000ff;">if</span> <span style="color: #0000ff;">not</span> food:<span style="color: #0000ff;">break</span><span style="color: #000000;">
        time.sleep(random.randint(</span>1,3<span style="color: #000000;">))
        </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">%s吃了%s</span><span style="color: #800000;">'</span>%<span style="color: #000000;">(name,food))
​
</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> cp(c_count,p_count):
    q </span>= Queue(10<span style="color: #000000;">)
    </span><span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span><span style="color: #000000;"> range(c_count):
        Process(target</span>=consumer, args=(q, <span style="color: #800000;">'</span><span style="color: #800000;">alex</span><span style="color: #800000;">'</span><span style="color: #000000;">)).start()
    p_l </span>=<span style="color: #000000;"> []
    </span><span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span><span style="color: #000000;"> range(p_count):
        p1 </span>= Process(target=producer, args=(q, <span style="color: #800000;">'</span><span style="color: #800000;">wusir</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">泔水</span><span style="color: #800000;">'</span><span style="color: #000000;">))
        p1.start()
        p_l.append(p1)
    </span><span style="color: #0000ff;">for</span> p <span style="color: #0000ff;">in</span><span style="color: #000000;"> p_l:p.join()
    </span><span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span><span style="color: #000000;"> range(c_count):
        q.put(None)
</span><span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">'</span><span style="color: #800000;">__main__</span><span style="color: #800000;">'</span><span style="color: #000000;">:
    cp(</span>2,3)</pre>
</div>
<span class="cnblogs_code_collapse">生产者消费者模型</span></div>
<div class="cnblogs_code" onclick="cnblogs_code_show('11d640c2-262b-4065-a2ee-77549165a9d8')"><img id="code_img_closed_11d640c2-262b-4065-a2ee-77549165a9d8" class="code_img_closed" src="./images/进程相关0.png" alt="" /><img id="code_img_opened_11d640c2-262b-4065-a2ee-77549165a9d8" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('11d640c2-262b-4065-a2ee-77549165a9d8',event)" src="./images/进程相关1.png" alt="" />
<div id="cnblogs_code_open_11d640c2-262b-4065-a2ee-77549165a9d8" class="cnblogs_code_hide">
<pre><code><span style="color: #0000ff;">import</span><span style="color: #000000;"> re
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> requests
</span><span style="color: #0000ff;">from</span> multiprocessing <span style="color: #0000ff;">import</span><span style="color: #000000;"> Process,Queue
​
</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> producer(q,url):
    response </span>=<span style="color: #000000;"> requests.get(url)
    q.put(response.text)
​
</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> consumer(q):
    </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> True:
        s </span>=<span style="color: #000000;"> q.get()
        </span><span style="color: #0000ff;">if</span> <span style="color: #0000ff;">not</span> s:<span style="color: #0000ff;">break</span><span style="color: #000000;">
        com </span>=<span style="color: #000000;"> re.compile(
            </span><span style="color: #800000;">'</span><span style="color: #800000;">&lt;div class="item"&gt;.*?&lt;div class="pic"&gt;.*?&lt;em .*?&gt;(?P&lt;id&gt;\d+).*?&lt;span class="title"&gt;(?P&lt;title&gt;.*?)&lt;/span&gt;</span><span style="color: #800000;">'</span>
            <span style="color: #800000;">'</span><span style="color: #800000;">.*?&lt;span class="rating_num" .*?&gt;(?P&lt;rating_num&gt;.*?)&lt;/span&gt;.*?&lt;span&gt;(?P&lt;comment_num&gt;.*?)评价&lt;/span&gt;</span><span style="color: #800000;">'</span><span style="color: #000000;">, re.S)
        ret </span>=<span style="color: #000000;"> com.finditer(s)
        </span><span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span><span style="color: #000000;"> ret:
            </span><span style="color: #0000ff;">print</span><span style="color: #000000;">({
                </span><span style="color: #800000;">"</span><span style="color: #800000;">id</span><span style="color: #800000;">"</span>: i.group(<span style="color: #800000;">"</span><span style="color: #800000;">id</span><span style="color: #800000;">"</span><span style="color: #000000;">),
                </span><span style="color: #800000;">"</span><span style="color: #800000;">title</span><span style="color: #800000;">"</span>: i.group(<span style="color: #800000;">"</span><span style="color: #800000;">title</span><span style="color: #800000;">"</span><span style="color: #000000;">),
                </span><span style="color: #800000;">"</span><span style="color: #800000;">rating_num</span><span style="color: #800000;">"</span>: i.group(<span style="color: #800000;">"</span><span style="color: #800000;">rating_num</span><span style="color: #800000;">"</span><span style="color: #000000;">),
                </span><span style="color: #800000;">"</span><span style="color: #800000;">comment_num</span><span style="color: #800000;">"</span>: i.group(<span style="color: #800000;">"</span><span style="color: #800000;">comment_num</span><span style="color: #800000;">"</span><span style="color: #000000;">)}
            )
​
</span><span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">'</span><span style="color: #800000;">__main__</span><span style="color: #800000;">'</span><span style="color: #000000;">:
    count </span>=<span style="color: #000000;"> 0
    q </span>= Queue(3<span style="color: #000000;">)
    p_l </span>=<span style="color: #000000;"> []
    </span><span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span> range(10<span style="color: #000000;">):
        url </span>= <span style="color: #800000;">'</span><span style="color: #800000;">https://movie.douban.com/top250?start=%s&amp;filter=</span><span style="color: #800000;">'</span>%<span style="color: #000000;">count
        count </span>+= 25<span style="color: #000000;">
        p </span>= Process(target=producer,args=<span style="color: #000000;">(q,url,))
        p.start()
        p_l.append(p)
    Process(target</span>=consumer, args=<span style="color: #000000;">(q,)).start()
    </span><span style="color: #0000ff;">for</span> p <span style="color: #0000ff;">in</span><span style="color: #000000;"> p_l:p.join()
    q.put(None)</span></pre>
</div>
<span class="cnblogs_code_collapse">生产者消费者模型实现的爬虫示例</span></div>
</li>
</ul>
<ul>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain md-expand">joinablequeue</span></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('c238db75-635e-4bd3-aa49-b62044c1cf5a')"><img id="code_img_closed_c238db75-635e-4bd3-aa49-b62044c1cf5a" class="code_img_closed" src="./images/进程相关0.png" alt="" /><img id="code_img_opened_c238db75-635e-4bd3-aa49-b62044c1cf5a" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('c238db75-635e-4bd3-aa49-b62044c1cf5a',event)" src="./images/进程相关1.png" alt="" />
<div id="cnblogs_code_open_c238db75-635e-4bd3-aa49-b62044c1cf5a" class="cnblogs_code_hide">
<pre><code><span style="color: #0000ff;">import</span><span style="color: #000000;"> time
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> random
</span><span style="color: #0000ff;">from</span>  multiprocessing <span style="color: #0000ff;">import</span><span style="color: #000000;"> JoinableQueue,Process
​
</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> producer(q,name,food):
    </span><span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span> range(10<span style="color: #000000;">):
        time.sleep(random.random())
        fd </span>= <span style="color: #800000;">'</span><span style="color: #800000;">%s%s</span><span style="color: #800000;">'</span>%<span style="color: #000000;">(food,i)
        q.put(fd)
        </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">%s生产了一个%s</span><span style="color: #800000;">'</span>%<span style="color: #000000;">(name,food))
    q.join()
​
</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> consumer(q,name):
    </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> True:
        food </span>=<span style="color: #000000;"> q.get()
        time.sleep(random.random())
        </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">%s吃了%s</span><span style="color: #800000;">'</span>%<span style="color: #000000;">(name,food))
        q.task_done()
​
</span><span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">'</span><span style="color: #800000;">__main__</span><span style="color: #800000;">'</span><span style="color: #000000;">:
    jq </span>=<span style="color: #000000;"> JoinableQueue()
    p </span>=Process(target=producer,args=(jq,<span style="color: #800000;">'</span><span style="color: #800000;">wusir</span><span style="color: #800000;">'</span>,<span style="color: #800000;">'</span><span style="color: #800000;">泔水</span><span style="color: #800000;">'</span><span style="color: #000000;">))
    p.start()
    c </span>= Process(target=consumer,args=(jq,<span style="color: #800000;">'</span><span style="color: #800000;">alex</span><span style="color: #800000;">'</span><span style="color: #000000;">))
    c.daemon </span>=<span style="color: #000000;"> True
    c.start()
    p.join()</span></pre>
</div>
<span class="cnblogs_code_collapse">示例</span></div>
</li>
</ul>
<p class="md-end-block md-p"><span class="md-image md-img-loaded" data-src="C:%5CUsers%5CDELL%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1557909398338.png"><img src="file://C:/Users/DELL/AppData/Roaming/Typora/typora-user-images/1557909398338.png?lastModify=1565405432" alt="" data-alt="1557909398338" data-local-refresh="true" /></span></p>
<h3 class="md-end-block md-heading"><span class="md-plain">五、Process类的一些方法</span></h3>
<ul>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">p.start()：开启进程，异步非阻塞</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">p.terminate()：结束进程， 异步非阻塞</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">p.is_alive()：判断子进程是否还活着</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">p.join()：等待子进程的结束，同步阻塞</span></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('e6d8f467-99c6-4d1c-862b-60b1ca74b637')"><img id="code_img_closed_e6d8f467-99c6-4d1c-862b-60b1ca74b637" class="code_img_closed" src="./images/进程相关0.png" alt="" /><img id="code_img_opened_e6d8f467-99c6-4d1c-862b-60b1ca74b637" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('e6d8f467-99c6-4d1c-862b-60b1ca74b637',event)" src="./images/进程相关1.png" alt="" />
<div id="cnblogs_code_open_e6d8f467-99c6-4d1c-862b-60b1ca74b637" class="cnblogs_code_hide">
<pre><code><span style="color: #0000ff;">import</span><span style="color: #000000;"> time
</span><span style="color: #0000ff;">from</span> multiprocessing <span style="color: #0000ff;">import</span><span style="color: #000000;"> Process
​
</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> son1():
    </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> True:
        </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">is alive</span><span style="color: #800000;">'</span><span style="color: #000000;">)
        time.sleep(</span>0.5<span style="color: #000000;">)
​
</span><span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">'</span><span style="color: #800000;">__main__</span><span style="color: #800000;">'</span><span style="color: #000000;">:
    p </span>= Process(target=<span style="color: #000000;">son1)
    p.start()      </span><span style="color: #008000;">#</span><span style="color: #008000;"> 异步 非阻塞</span>
    <span style="color: #0000ff;">print</span><span style="color: #000000;">(p.is_alive())
    time.sleep(</span>1<span style="color: #000000;">)
    p.terminate()   </span><span style="color: #008000;">#</span><span style="color: #008000;"> 异步的 非阻塞</span>
    <span style="color: #0000ff;">print</span>(p.is_alive())   <span style="color: #008000;">#</span><span style="color: #008000;"> 进程还活着 因为操作系统还没来得及关闭进程</span>
    time.sleep(0.01<span style="color: #000000;">)
    </span><span style="color: #0000ff;">print</span>(p.is_alive())   <span style="color: #008000;">#</span><span style="color: #008000;"> 操作系统已经响应了我们要关闭进程的需求，再去检测的时候，得到的结果是进程已经结束了</span></pre>
</div>
<span class="cnblogs_code_collapse">示例</span></div>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">总结：</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">开启进程的方式</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">#</span><span style="color: #008000;"> 面向函数</span>
<span style="color: #0000ff;">def</span><span style="color: #000000;"> 函数名:要在子进程中执行的代码
p </span>= Process(target= 函数名,args=<span style="color: #000000;">(参数1，))
​
</span><span style="color: #008000;">#</span><span style="color: #008000;"> 面向对象</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> 类名(Process):
    </span><span style="color: #0000ff;">def</span> <span style="color: #800080;">__init__</span>(self,参数1，参数2):   <span style="color: #008000;">#</span><span style="color: #008000;"> 如果子进程不需要参数可以不写</span>
        self.a =<span style="color: #000000;"> 参数1
        self.b </span>=<span style="color: #000000;"> 参数2
        super().</span><span style="color: #800080;">__init__</span><span style="color: #000000;">()
    </span><span style="color: #0000ff;">def</span><span style="color: #000000;"> run(self):
        </span><span style="color: #008000;">#</span><span style="color: #008000;"> 要在子进程中执行的代码</span>
p = 类名(参数1，参数2)</pre>
</div>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">Process提供的操作进程的方法</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">p.start()：开启进程，异步非阻塞</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">p.terminate()：结束进程，异步非阻塞</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">p.join()：同步阻塞</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">p.isalive()：获取当前进程的状态</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">p.daemon = True：设置为守护进程，守护进程永远在主进程的代码结束之后自动结束</span></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 class="md-end-block md-heading"><span class="md-plain">六、锁Lock</span></h3>
<ul>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">如果在一个并发的场景下，涉及到某部分内容是需要修改一些所有进程共享数据资源，需要加锁来维护数据的安全</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">在数据安全的基础上，才考虑效率问题</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">同步存在的意义：数据的安全性</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">方式：</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">在主进程中实例化 lock = Lock()</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">把这把锁传递给子进程</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">在子进程中 对需要加锁的代码 进行 with lock：</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">with lock相当于lock.acquire()和lock.release()</span></p>
</li>
</ul>
</li>
</ul>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">应用场景：（在进程中需要加锁的场景）</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">共享的数据资源（文件、数据库）</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">对资源进行修改、删除操作</span></p>
</li>
</ul>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">加锁之后能够保证数据的安全性 但是也降低了程序的执行效率</span></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('5d09b42a-e220-49c6-b0ac-5ffa2f60f03c')"><img id="code_img_closed_5d09b42a-e220-49c6-b0ac-5ffa2f60f03c" class="code_img_closed" src="./images/进程相关0.png" alt="" /><img id="code_img_opened_5d09b42a-e220-49c6-b0ac-5ffa2f60f03c" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('5d09b42a-e220-49c6-b0ac-5ffa2f60f03c',event)" src="./images/进程相关1.png" alt="" />
<div id="cnblogs_code_open_5d09b42a-e220-49c6-b0ac-5ffa2f60f03c" class="cnblogs_code_hide">
<pre><code><span style="color: #0000ff;">import</span><span style="color: #000000;"> time
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> json
</span><span style="color: #0000ff;">from</span> multiprocessing <span style="color: #0000ff;">import</span><span style="color: #000000;"> Process,Lock
​
</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> search_ticket(user):
    with open(</span><span style="color: #800000;">'</span><span style="color: #800000;">ticket_count</span><span style="color: #800000;">'</span><span style="color: #000000;">) as f:
        dic </span>=<span style="color: #000000;"> json.load(f)
        </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">%s查询结果  : %s张余票</span><span style="color: #800000;">'</span>%(user,dic[<span style="color: #800000;">'</span><span style="color: #800000;">count</span><span style="color: #800000;">'</span><span style="color: #000000;">]))
​
</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> buy_ticket(user,lock):
    </span><span style="color: #008000;">#</span><span style="color: #008000;"> with lock:</span>
    <span style="color: #008000;">#</span><span style="color: #008000;"> lock.acquire()   # 给这段代码加上一把锁</span>
        time.sleep(0.02<span style="color: #000000;">)
        with open(</span><span style="color: #800000;">'</span><span style="color: #800000;">ticket_count</span><span style="color: #800000;">'</span><span style="color: #000000;">) as f:
            dic </span>=<span style="color: #000000;"> json.load(f)
        </span><span style="color: #0000ff;">if</span> dic[<span style="color: #800000;">'</span><span style="color: #800000;">count</span><span style="color: #800000;">'</span>] &gt;<span style="color: #000000;"> 0:
            </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">%s买到票了</span><span style="color: #800000;">'</span>%<span style="color: #000000;">(user))
            dic[</span><span style="color: #800000;">'</span><span style="color: #800000;">count</span><span style="color: #800000;">'</span>] -= 1
        <span style="color: #0000ff;">else</span><span style="color: #000000;">:
            </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">%s没买到票</span><span style="color: #800000;">'</span> %<span style="color: #000000;"> (user))
        time.sleep(</span>0.02<span style="color: #000000;">)
        with open(</span><span style="color: #800000;">'</span><span style="color: #800000;">ticket_count</span><span style="color: #800000;">'</span>,<span style="color: #800000;">'</span><span style="color: #800000;">w</span><span style="color: #800000;">'</span><span style="color: #000000;">) as f:
            json.dump(dic,f)
    </span><span style="color: #008000;">#</span><span style="color: #008000;"> lock.release()   # 给这段代码解锁</span>
<span style="color: #000000;">​
</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> task(user, lock):
    search_ticket(user)
    with lock:
        buy_ticket(user, lock)
​
</span><span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">'</span><span style="color: #800000;">__main__</span><span style="color: #800000;">'</span><span style="color: #000000;">:
    lock </span>=<span style="color: #000000;"> Lock()
    </span><span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span> range(10<span style="color: #000000;">):
        p </span>= Process(target=task,args=(<span style="color: #800000;">'</span><span style="color: #800000;">user%s</span><span style="color: #800000;">'</span>%<span style="color: #000000;">i,lock))
        p.start()</span></pre>
</div>
<span class="cnblogs_code_collapse">示例：抢票系统</span></div>
</li>
</ul>
<h3 class="md-end-block md-heading"><span class="md-plain">七、进程之间通信</span></h3>
<ul>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">进程之间的数据隔离</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">from</span> multiprocessing <span style="color: #0000ff;">import</span><span style="color: #000000;"> Process
n </span>= 100
<span style="color: #0000ff;">def</span><span style="color: #000000;"> func():
    </span><span style="color: #0000ff;">global</span><span style="color: #000000;"> n
    n </span>-= 1<span style="color: #000000;">
​
</span><span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">'</span><span style="color: #800000;">__main__</span><span style="color: #800000;">'</span><span style="color: #000000;">:
    p_l </span>=<span style="color: #000000;"> []
    </span><span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span> range(10<span style="color: #000000;">):
        p </span>= Process(target=<span style="color: #000000;">func)
        p.start()
        p_l.append(p)
    </span><span style="color: #0000ff;">for</span> p <span style="color: #0000ff;">in</span><span style="color: #000000;"> p_l:p.join()
    </span><span style="color: #0000ff;">print</span>(n)</pre>
</div>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">进程之间的通信 - IPC（inter process communication）</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">from</span> multiprocessing <span style="color: #0000ff;">import</span><span style="color: #000000;"> Queue,Process
</span><span style="color: #008000;">#</span><span style="color: #008000;"> 先进先出</span>
<span style="color: #0000ff;">def</span><span style="color: #000000;"> func(exp,q):
    ret </span>=<span style="color: #000000;"> eval(exp)
    q.put({ret,</span>2,3<span style="color: #000000;">})
    q.put(ret</span>*2<span style="color: #000000;">)
    q.put(ret</span>*4<span style="color: #000000;">)
​
</span><span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">'</span><span style="color: #800000;">__main__</span><span style="color: #800000;">'</span><span style="color: #000000;">:
    q </span>=<span style="color: #000000;"> Queue()
    Process(target</span>=func,args=(<span style="color: #800000;">'</span><span style="color: #800000;">1+2+3</span><span style="color: #800000;">'</span><span style="color: #000000;">,q)).start()
    </span><span style="color: #0000ff;">print</span><span style="color: #000000;">(q.get())
    </span><span style="color: #0000ff;">print</span><span style="color: #000000;">(q.get())
    </span><span style="color: #0000ff;">print</span><span style="color: #000000;">(q.get())
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> queue
</span><span style="color: #0000ff;">from</span> multiprocessing <span style="color: #0000ff;">import</span><span style="color: #000000;"> Queue
q </span>= Queue(5<span style="color: #000000;">)
q.put(</span>1<span style="color: #000000;">)
q.put(</span>2<span style="color: #000000;">)
q.put(</span>3<span style="color: #000000;">)
q.put(</span>4<span style="color: #000000;">)
q.put(</span>5)             <span style="color: #008000;">#</span><span style="color: #008000;"> 当队列为满的时候再向队列中放数据 队列会阻塞</span>
<span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">5555555</span><span style="color: #800000;">'</span><span style="color: #000000;">)
</span><span style="color: #0000ff;">try</span><span style="color: #000000;">:
    q.put_nowait(</span>6)  <span style="color: #008000;">#</span><span style="color: #008000;"> 当队列为满的时候再向队列中放数据 会报错并且会丢失数据</span>
<span style="color: #0000ff;">except</span><span style="color: #000000;"> queue.Full:
    </span><span style="color: #0000ff;">pass</span>
<span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">6666666</span><span style="color: #800000;">'</span><span style="color: #000000;">)
​
</span><span style="color: #0000ff;">print</span><span style="color: #000000;">(q.get())
</span><span style="color: #0000ff;">print</span><span style="color: #000000;">(q.get())
</span><span style="color: #0000ff;">print</span><span style="color: #000000;">(q.get())   
</span><span style="color: #0000ff;">print</span><span style="color: #000000;">(q.get())   
</span><span style="color: #0000ff;">print</span>(q.get())              <span style="color: #008000;">#</span><span style="color: #008000;"> 在队列为空的时候会发生阻塞</span>
<span style="color: #0000ff;">try</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">print</span>(q.get_nowait())   <span style="color: #008000;">#</span><span style="color: #008000;"> 在队列为空的时候 直接报错</span>
<span style="color: #0000ff;">except</span> queue.Empty:<span style="color: #0000ff;">pass</span></pre>
</div>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">内置IPC机制：</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">Queue(队列)：进程之间数据安全</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">天生就是数据安全的</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">基于文件家族的socket pickle lock</span></p>
</li>
</ul>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">pipe(管道)：进程之间数据不安全</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">不安全的</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">基于文件家族的socket pickle</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">队列 = 管道 + 锁</span></p>
</li>
</ul>
</li>
</ul>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">第三方工具（软件）提供的IPC机制：</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">redis / memcache / kafka / rabbitmq</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">优点：</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">并发需求</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">高可用，多个消息中间件</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">断电保存数据</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">解耦</span></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 class="md-end-block md-heading"><span class="md-plain">八、进程之间的数据共享</span></h3>
<ul>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">mulprocessing中有一个manager类，封装了所有和进程（数据共享、数据传递）相关的数据类型</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">但是对于字典、列表这一类的数据操作的时候会产生数据不安全</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">需要加锁解决问题，并且需要尽量少的使用这种方式</span></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('3788598d-c944-436b-92eb-c82a87b8d32f')"><img id="code_img_closed_3788598d-c944-436b-92eb-c82a87b8d32f" class="code_img_closed" src="./images/进程相关0.png" alt="" /><img id="code_img_opened_3788598d-c944-436b-92eb-c82a87b8d32f" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('3788598d-c944-436b-92eb-c82a87b8d32f',event)" src="./images/进程相关1.png" alt="" />
<div id="cnblogs_code_open_3788598d-c944-436b-92eb-c82a87b8d32f" class="cnblogs_code_hide">
<pre><code><span style="color: #0000ff;">from</span> multiprocessing <span style="color: #0000ff;">import</span><span style="color: #000000;"> Manager,Process,Lock
​
</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> func(dic,lock):
    with lock:
        dic[</span><span style="color: #800000;">'</span><span style="color: #800000;">count</span><span style="color: #800000;">'</span>] -= 1<span style="color: #000000;">
​
</span><span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">'</span><span style="color: #800000;">__main__</span><span style="color: #800000;">'</span><span style="color: #000000;">:
    </span><span style="color: #008000;">#</span><span style="color: #008000;"> m = Manager()</span>
<span style="color: #000000;">    with Manager() as m:
        l </span>=<span style="color: #000000;"> Lock()
        dic </span>= m.dict({<span style="color: #800000;">'</span><span style="color: #800000;">count</span><span style="color: #800000;">'</span>:100<span style="color: #000000;">})
        p_l </span>=<span style="color: #000000;"> []
        </span><span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span> range(100<span style="color: #000000;">):
            p </span>= Process(target=func,args=<span style="color: #000000;">(dic,l))
            p.start()
            p_l.append(p)
        </span><span style="color: #0000ff;">for</span> p <span style="color: #0000ff;">in</span><span style="color: #000000;"> p_l:p.join()
        </span><span style="color: #0000ff;">print</span>(dic)</pre>
</div>
<span class="cnblogs_code_collapse">示例</span></div>
</li>
</ul>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>